[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class VAST::Base {\n    method emit_m0ld {\n        use Mildew::AST::Helpers;\n        if ($self->{infix}) {\n            my $name = $self->{infix}{SYM};\n            return fcall('&infix:'.$name,[map {$_->emit_m0ld} @{$self->{args}}]);\n        }\n        my @keys = grep {/^[a-z]\\w*$/} keys %{$self};\n        if (@keys == 1) {\n            $self->{$keys[0]}->emit_m0ld;\n        } else {\n            die (ref $self,\" is not a simple node, possible choices are: \",join(' ',@keys));\n        }\n    }\n}\n1",
      "file" : "/var/tmp/arv_1uWiFw/Mildew-0.05/lib/VAST.pm",
      "package" : "VAST"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class Mildew::Frontend::STD {\n    use Getopt::Long qw(GetOptionsFromArray);\n    use Digest::MD4 qw(md4_hex);\n    has options=>(is=>'ro',default=>sub {{}});\n    has debug=>(is=>'rw',default=>0);\n    has setting=>(is=>'rw',default=>'MildewCORE');\n    has tmp=>(is=>'rw',default=>'/tmp/mildew/');\n    has syml_search_path=>(lazy_build=>1,is=>'rw');\n    has PERL6LIB=>(lazy_build=>1,is=>'rw');\n    method BUILD {\n        my ($debug,$setting,$tmp,$syml_search_path,$PERL6LIB);\n        GetOptionsFromArray(\n            ($self->options->{FRONTEND} // []),\n            'debug' => \\$debug,\n            'setting=s' => \\$setting,\n            'tmp=s' => \\$tmp,\n            'syml-search-path=s' => \\$syml_search_path,\n            'PERL6LIB=s' => \\$PERL6LIB,\n        );\n        $self->debug($debug);\n        $self->setting($setting) if $setting;\n        $self->tmp($tmp.'/') if $tmp;\n        $self->syml_search_path([map {$_.'/'} split(':',$syml_search_path)]) if $syml_search_path;\n        $self->PERL6LIB($PERL6LIB) if $PERL6LIB;\n    }\n    use Scalar::Util qw(reftype);\n    sub prune {\n        my $what = shift;\n    \n        state %pruned;\n        return unless defined $what;\n        return if $pruned{$what}++;\n    \n        if (reftype $what and reftype $what eq 'HASH') {\n            delete $what->{'.'};\n            delete $what->{BEG};\n            delete $what->{END};\n            delete $what->{WS};\n            for my $key (keys %{$what}) {\n                prune($what->{$key});\n            }\n        } elsif (reftype $what and reftype $what eq 'ARRAY') {\n            for (@{$what}) {\n                prune($_);\n            }\n        } else {\n        }\n    }\n    method _build_syml_search_path {\n        require Mildew::Setting::SMOP;\n        [$self->tmp,Mildew::Setting::SMOP::std_tmp_files_path().'/']\n    }\n    method _build_PERL6LIB {\n        require Mildew::Setting::SMOP;\n        Mildew::Setting::SMOP::standard_libs();\n    }\n    method parse($source) {\n        $::ORIG = $source;\n        local $ENV{'PERL6LIB'} = $self->PERL6LIB; \n        mkdir($self->tmp);\n        my $m = STD->parse($source, actions=>'STD::Actions',tmp_prefix=>$self->tmp,syml_search_path=>$self->syml_search_path,setting=>$self->setting,filename=>md4_hex($source));\n        local $ENV{'DEFAULT_SETTING_FOR_MODULES'} = 'MildewCORE';\n\n\n        if ($self->debug) {\n            require YAML::XS;\n            prune($m);\n            die YAML::XS::Dump($m->{'_ast'}); \n        }\n        $m->{'_ast'}->emit_m0ld;\n    }\n}",
      "file" : "/var/tmp/arv_1uWiFw/Mildew-0.05/lib/Mildew/Frontend/STD.pm",
      "package" : "main"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class VAST::Base {\n    method emit_m0ld {\n        use Mildew::AST::Helpers;\n        if ($self->{infix}) {\n            my $name = $self->{infix}{SYM};\n            return fcall('&infix:'.$name,[map {$_->emit_m0ld} @{$self->{args}}]);\n        }\n        my @keys = grep {/^[a-z]\\w*$/} keys %{$self};\n        if (@keys == 1) {\n            $self->{$keys[0]}->emit_m0ld;\n        } else {\n            die (ref $self,\" is not a simple node, possible choices are: \",join(' ',@keys));\n        }\n    }\n}\n1",
      "file" : "/var/tmp/arv_1uWiFw/Mildew-0.05/WIP/lib/VAST.pm",
      "package" : "VAST"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class Mildew::Frontend::STD {\n    use Getopt::Long qw(GetOptionsFromArray);\n    use Digest::MD4 qw(md4_hex);\n    has options=>(is=>'ro',default=>sub {{}});\n    has debug=>(is=>'rw',default=>0);\n    has setting=>(is=>'rw',default=>'MildewCORE');\n    has tmp=>(is=>'rw',default=>'/tmp/mildew/');\n    has syml_search_path=>(lazy_build=>1,is=>'rw');\n    has PERL6LIB=>(lazy_build=>1,is=>'rw');\n    method BUILD {\n        my ($debug,$setting,$tmp,$syml_search_path,$PERL6LIB);\n        GetOptionsFromArray(\n            ($self->options->{FRONTEND} // []),\n            'debug' => \\$debug,\n            'setting=s' => \\$setting,\n            'tmp=s' => \\$tmp,\n            'syml-search-path=s' => \\$syml_search_path,\n            'PERL6LIB=s' => \\$PERL6LIB,\n        );\n        $self->debug($debug);\n        $self->setting($setting) if $setting;\n        $self->tmp($tmp.'/') if $tmp;\n        $self->syml_search_path([map {$_.'/'} split(':',$syml_search_path)]) if $syml_search_path;\n        $self->PERL6LIB($PERL6LIB) if $PERL6LIB;\n    }\n    use Scalar::Util qw(reftype);\n    sub prune {\n        my $what = shift;\n    \n        state %pruned;\n        return unless defined $what;\n        return if $pruned{$what}++;\n    \n        if (reftype $what and reftype $what eq 'HASH') {\n            delete $what->{'.'};\n            delete $what->{BEG};\n            delete $what->{END};\n            delete $what->{WS};\n            for my $key (keys %{$what}) {\n                prune($what->{$key});\n            }\n        } elsif (reftype $what and reftype $what eq 'ARRAY') {\n            for (@{$what}) {\n                prune($_);\n            }\n        } else {\n        }\n    }\n    method _build_syml_search_path {\n        require Mildew::Setting::SMOP;\n        [$self->tmp,Mildew::Setting::SMOP::std_tmp_files_path().'/']\n    }\n    method _build_PERL6LIB {\n        require Mildew::Setting::SMOP;\n        Mildew::Setting::SMOP::standard_libs();\n    }\n    method parse($source) {\n        $::ORIG = $source;\n        local $ENV{'PERL6LIB'} = $self->PERL6LIB; \n        mkdir($self->tmp);\n        my $m = STD->parse($source, actions=>'STD::Actions',tmp_prefix=>$self->tmp,syml_search_path=>$self->syml_search_path,setting=>$self->setting,filename=>md4_hex($source));\n        local $ENV{'DEFAULT_SETTING_FOR_MODULES'} = 'MildewCORE';\n\n\n        if ($self->debug) {\n            require YAML::XS;\n            prune($m);\n            die YAML::XS::Dump($m->{'_ast'}); \n        }\n        $m->{'_ast'}->emit_m0ld;\n    }\n}",
      "file" : "/var/tmp/arv_1uWiFw/Mildew-0.05/WIP/lib/Mildew/Frontend/STD.pm",
      "package" : "main"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class VAST::Base {\n    method emit_m0ld {\n        use Mildew::AST::Helpers;\n        if ($self->{infix}) {\n            my $name = $self->{infix}{SYM};\n            return fcall('&infix:'.$name,[map {$_->emit_m0ld} @{$self->{args}}]);\n        }\n        my @keys = grep {/^[a-z]\\w*$/} keys %{$self};\n        if (@keys == 1) {\n            $self->{$keys[0]}->emit_m0ld;\n        } else {\n            die (ref $self,\" is not a simple node, possible choices are: \",join(' ',@keys));\n        }\n    }\n}\n1",
      "file" : "/var/tmp/arv_1uWiFw/Mildew-0.05/WIP/blib/lib/VAST.pm",
      "package" : "VAST"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class Mildew::Frontend::STD {\n    use Getopt::Long qw(GetOptionsFromArray);\n    use Digest::MD4 qw(md4_hex);\n    has options=>(is=>'ro',default=>sub {{}});\n    has debug=>(is=>'rw',default=>0);\n    has setting=>(is=>'rw',default=>'MildewCORE');\n    has tmp=>(is=>'rw',default=>'/tmp/mildew/');\n    has syml_search_path=>(lazy_build=>1,is=>'rw');\n    has PERL6LIB=>(lazy_build=>1,is=>'rw');\n    method BUILD {\n        my ($debug,$setting,$tmp,$syml_search_path,$PERL6LIB);\n        GetOptionsFromArray(\n            ($self->options->{FRONTEND} // []),\n            'debug' => \\$debug,\n            'setting=s' => \\$setting,\n            'tmp=s' => \\$tmp,\n            'syml-search-path=s' => \\$syml_search_path,\n            'PERL6LIB=s' => \\$PERL6LIB,\n        );\n        $self->debug($debug);\n        $self->setting($setting) if $setting;\n        $self->tmp($tmp.'/') if $tmp;\n        $self->syml_search_path([map {$_.'/'} split(':',$syml_search_path)]) if $syml_search_path;\n        $self->PERL6LIB($PERL6LIB) if $PERL6LIB;\n    }\n    use Scalar::Util qw(reftype);\n    sub prune {\n        my $what = shift;\n    \n        state %pruned;\n        return unless defined $what;\n        return if $pruned{$what}++;\n    \n        if (reftype $what and reftype $what eq 'HASH') {\n            delete $what->{'.'};\n            delete $what->{BEG};\n            delete $what->{END};\n            delete $what->{WS};\n            for my $key (keys %{$what}) {\n                prune($what->{$key});\n            }\n        } elsif (reftype $what and reftype $what eq 'ARRAY') {\n            for (@{$what}) {\n                prune($_);\n            }\n        } else {\n        }\n    }\n    method _build_syml_search_path {\n        require Mildew::Setting::SMOP;\n        [$self->tmp,Mildew::Setting::SMOP::std_tmp_files_path().'/']\n    }\n    method _build_PERL6LIB {\n        require Mildew::Setting::SMOP;\n        Mildew::Setting::SMOP::standard_libs();\n    }\n    method parse($source) {\n        $::ORIG = $source;\n        local $ENV{'PERL6LIB'} = $self->PERL6LIB; \n        mkdir($self->tmp);\n        my $m = STD->parse($source, actions=>'STD::Actions',tmp_prefix=>$self->tmp,syml_search_path=>$self->syml_search_path,setting=>$self->setting,filename=>md4_hex($source));\n        local $ENV{'DEFAULT_SETTING_FOR_MODULES'} = 'MildewCORE';\n\n\n        if ($self->debug) {\n            require YAML::XS;\n            prune($m);\n            die YAML::XS::Dump($m->{'_ast'}); \n        }\n        $m->{'_ast'}->emit_m0ld;\n    }\n}",
      "file" : "/var/tmp/arv_1uWiFw/Mildew-0.05/WIP/blib/lib/Mildew/Frontend/STD.pm",
      "package" : "main"
   }
]
