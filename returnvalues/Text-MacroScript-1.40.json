[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "DESTROY { \n    ; \n}\n\n\n\nsub new { \n    my $self  = shift ;\n    my $class = ref( $self ) || $self ;\n\n    $self = { \n        -comment    => 0,     \n        -file       => [],    \n        -macro      => [],    \n        -script     => [],    \n        -variable   => [],    \n        -embedded   => 0,     \n        -opendelim  => undef, \n        -closedelim => undef, \n        @_ \n        } ;\n\n    @{$self->{MACRO}}    = () ; \n    @{$self->{SCRIPT}}   = () ; \n    %{$self->{VARIABLE}} = () ; \n\n    $self->{REMOVE}      = 1 ;  \n\n    $self->{IN_MACRO}    = 0 ;  \n    $self->{IN_SCRIPT}   = 0 ;  \n    $self->{IN_CASE}     = 0 ;  \n    $self->{IN_EMBEDDED} = 0 ;  \n    $self->{DEFINE}      = '' ; \n    $self->{NAME}        = '' ; \n    $self->{LINO}        = 1 ;  \n    $self->{OPEN_LEN}    = 0 ; \n    $self->{CLOSE_LEN}   = 0 ; \n\n    if( $self->{-embedded} or defined $self->{-opendelim} ) {\n        $self->{-opendelim}  = \"<:\" unless $self->{-opendelim} ;\n        $self->{-closedelim} = $self->{-opendelim} \n        if not $self->{-closedelim} and $self->{-opendelim} ne \"<:\" ;\n\n        $self->{-closedelim} = \":>\" unless $self->{-closedelim} ; \n        $self->{-embedded}   = 1 ;\n        $self->{OPEN_LEN}    = length $self->{-opendelim} ; \n        $self->{CLOSE_LEN}   = length $self->{-closedelim} ; \n    }\n    \n    bless $self, $class ;   \n    \n    eval {\n        local $_ ;\n\n        $self->define( -macro, '%%', '' ) if $self->{-comment} ;\n\n        foreach( @{$self->{-file}} ) {\n            $self->load_file( $_ ) ;\n        }\n\n        foreach( @{$self->{-variable}} ) {\n            my( $name, $body ) = @{$_} ;\n            $self->define( -variable, $name, $body ) ;\n        }\n\n        foreach( @{$self->{-macro}} ) {\n            my( $name, $body ) = @{$_} ;\n            $self->define( -macro, $name, $body ) ;\n        }\n\n        foreach( @{$self->{-script}} ) {\n            my( $name, $body ) = @{$_} ;\n            $self->define( -script, $name, $body ) ;\n        }\n    } ;\n    croak $@ if $@ ;\n\n    $self ;\n}\n\n\nsub get { \n    my $self  = shift ;\n    my $class = ref( $self ) || $self ;\n\n    $self->{shift()} ;\n}\n\n\n\nsub define { \n    my( $self, $which, $name, $body ) = @_ ;\n    my $class = ref( $self ) || $self ;\n\n    $self->_insert_element( uc substr( $which, 1 ), $name, $body ) ;\n}\n\n\nsub undefine { \n    my( $self, $which, $name ) = @_ ;\n    my $class = ref( $self ) || $self ;\n\n    $which = uc substr( $which, 1 ) ;\n\n    carp \"No $which called $name exists\" unless \n    $self->_remove_element( $which, $name ) ; \n}\n\n\nsub list { \n    my( $self, $which, $namesonly ) = @_ ;\n    my $class = ref( $self ) || $self ;\n\n    my @lines ;\n    local $_ ;\n\n    $which     = uc substr( $which, 1 ) ;\n    my $script = '' ;\n    $script    = \"_$which\" unless $which eq 'MACRO' ;\n\n    my $array ;\n\n    if( $which eq 'VARIABLE' ) {\n        $array = [ map { [ $_, $self->{VARIABLE}{$_} ] } \n                    keys %{$self->{VARIABLE}} ] ;\n    }\n    else {\n        $array = $self->{$which} ;\n    }\n\n    foreach( @{$array} ) {\n        my( $name, $body ) = @{$_} ;\n        my $line = \"%DEFINE$script $name\" ;\n\n        if( $body =~ /\\n/o ) {\n            $line .= \"\\n$body%END_DEFINE\\n\" unless $namesonly ;\n        }\n        else {\n            $line .= \" [$body]\\n\" unless $namesonly ;\n        }\n\n        if( wantarray ) {\n            push @lines, $line ;\n        }\n        else {\n            print \"$line\\n\" ;\n        }\n    }\n\n    @lines if wantarray ;\n}\n\n\nsub undefine_all { \n    my( $self, $which ) = @_ ;\n    my $class = ref( $self ) || $self ;\n\n    $which = uc substr( $which, 1 ) ;\n\n    if( $which eq 'VARIABLE' ) {\n        %{$self->{$which}} = () ;\n    }\n    else {\n        @{$self->{$which}} = () ;\n    }\n}\n\n\nsub load_file { \n    my( $self, $file ) = @_ ;\n    my $class = ref( $self ) || $self ;\n\n    my $in_embedded = $self->{IN_EMBEDDED} ; \n    $self->{IN_EMBEDDED} = 1 ; \n\n    $self->expand_file( $file, -noprint ) ;\n\n    $self->{IN_EMBEDDED} = $in_embedded ; \n}\n\n\nsub expand_file { \n    my( $self, $file, $noprint ) = @_ ;\n    my $class = ref( $self ) || $self ;\n\n    my $wantarray = wantarray ;\n\n    my @lines ;\n\n    eval {\n        croak \"missing filename\"            unless     $file ; \n        croak \"file `$file' does not exist\" unless  -e $file ;\n\n        substr( $file, 0, 1 ) = ( $ENV{HOME} or $ENV{LOGDIR} or (getpwuid( $> ))[7] ) \n        if substr( $file, 0, 1 ) eq '~' ;\n\n        local $_ ;\n\n        my $fh = Symbol::gensym ;\n\n        open $fh, $file or croak \"failed to open $file: $!\" ;\n\n        while( <$fh> ) {\n            my $line = $self->{-embedded} ? \n                            $self->expand_embedded( $_, $file ) :\n                            $self->expand( $_, $file ) ;\n\n            next unless defined $line and $line ; \n\n            if( $wantarray ) {\n                push @lines, $line ;\n            }\n            else {\n                print $line unless $noprint ;\n            }\n        }\n\n        close $fh or croak \"failed to close $file: $!\" ;\n\n\tif( $self->{IN_MACRO} or $self->{IN_SCRIPT} ) {\n\t    my $which = $self->{IN_MACRO} ? 'DEFINE' : 'DEFINE_SCRIPT' ;\n\t    croak \"runaway \\%$which to end of file\"\n\t}\n\n    } ;\n    croak $@ if $@ ;\n\n    @lines if $wantarray and not $noprint ;\n}\n\n\nsub expand_embedded { \n    my $self  = shift ;\n    my $class = ref( $self ) || $self ;\n    local $_  = shift ;\n    my $file  = (shift || '-') ;\n\n    my $line = '' ;\n\n    if( not $self->{IN_EMBEDDED} and /^$self->{-opendelim}$/o ) {\n        $self->{IN_EMBEDDED} = 1 ;\n    } \n    elsif( $self->{IN_EMBEDDED} and /^$self->{-closedelim}$/o ) {\n        $self->{IN_EMBEDDED} = 0 ;\n    }\n    elsif( not $self->{IN_EMBEDDED} ) {\n        my $pos = index( $_, $self->{-opendelim} ) ;\n        if( $pos > -1 ) {\n            $line = substr( $_, 0, $pos ) if $pos > 0 ;\n            my $start = $pos + $self->{OPEN_LEN} ;\n            my $end   = index( $_, $self->{-closedelim}, $start ) ;\n            if( $end > -1 ) {\n                $line .= $self->expand( \n                    substr( $_, $start, $end - $start ), $file ) ;\n                $line .= $self->expand_embedded( \n                            substr( $_, $end + $self->{CLOSE_LEN} ), $file ) ;\n            }\n            else {\n                $line .= $self->expand( substr( $_, $start ), $file ) ;\n                $self->{IN_EMBEDDED} = 1 ;\n            }\n        }\n        else {\n            $line = $_ ;\n        }\n    }\n    else {\n        my $end = index( $_, $self->{-closedelim} ) ;\n        if( $end > -1 ) {\n            $line = $self->expand( substr( $_, 0, $end ), $file ) ;\n            $self->{IN_EMBEDDED} = 0 ;\n            $line .= $self->expand_embedded( \n                        substr( $_, $end + $self->{CLOSE_LEN} ), $file ) ;\n        }\n        else {\n            $line = $self->expand( $_, $file ) ;\n        }\n    }\n\n    $line ;\n}\n\n\nsub expand { \n    my $self  = shift ;\n    my $class = ref( $self ) || $self ;\n    local $_  = shift ;\n    my $file  = (shift || '-') ;\n\n    $self->{LINO} = $. || 1 unless $self->{IN_MACRO} or $self->{IN_SCRIPT} ;\n    my $where     = \"at $file line $self->{LINO}\" ;\n\n    eval {\n        if( /^\\%((?:END_)?CASE)(?:\\s*\\[(.*?)\\])?/mso or \n            ( $self->{IN_CASE} eq 'SKIP' ) ) {\n\n            croak \"runaway \\%DEFINE $where to line $.\"\n            if $self->{IN_MACRO} ;\n            croak \"runaway \\%DEFINE_SCRIPT $where to line $.\"\n            if $self->{IN_SCRIPT} ;\n\n            if( defined $1 and $1 eq 'CASE' ) {\n                croak \"no condition for CASE $where\" unless defined $2 ;\n\n                my $eval    = $self->_expand_variable( $2 ) ;\n                my $result ;\n                eval {\n                    my %Var = %{$self->{VARIABLE}} ;\n                    local $_ ;\n                    $result = eval $eval ;\n                    %{$self->{VARIABLE}} = %Var ;\n                } ;\n                croak \"evaluation of CASE $eval failed $where: $@\" if $@ ;\n\n                $self->{IN_CASE} = $result ? 1 : 'SKIP' ;\n            }\n            elsif( defined $1 and $1 eq 'END_CASE' ) {\n                $self->{IN_CASE} = 0 ;\n            }\n\n            $_ = '' if $self->{REMOVE} ;\n        }\n        elsif( ( $self->{IN_MACRO} or $self->{IN_SCRIPT} ) and /^\\%END_DEFINE/mso ) {\n            $self->{DEFINE} = $self->_expand_variable( $self->{DEFINE} ) ;\n\n            my $which = $self->{IN_MACRO} ? 'MACRO' : 'SCRIPT' ;\n\n            $self->{\"IN_$which\"} = 0 ;\n            $self->_insert_element( $which, $self->{NAME}, $self->{DEFINE} ) ;\n            $self->{NAME} = $self->{DEFINE} = '' ;\n\n            $_ = '' if $self->{REMOVE} ;\n        }\n        elsif( $self->{IN_MACRO} or $self->{IN_SCRIPT} ) {\n            my $which = $self->{IN_MACRO} ? 'DEFINE' : 'DEFINE_SCRIPT' ;\n            croak \"runaway \\%$which $where to line $.\"\n            if /^\\%\n                (?:(?:UNDEFINE(?:_ALL)|DEFINE)(?:_SCRIPT|_VARIABLE)?) |\n                LOAD | INCLUDE | (?:END_)CASE\n               /msox ;\n\n            $self->{DEFINE} .= $_ ;\n\n            $_ = '' if $self->{REMOVE} ;\n        }\n        elsif( /^\\%UNDEFINE(?:_(SCRIPT|VARIABLE))?\\s+([^][\\s]+)/mso ) {\n            my $which = $1 || 'MACRO' ;\n\n            carp \"Cannot undefine non-existent $which $2 $where\" \n            unless $self->_remove_element( $which, $2 ) ; \n     \n            $_ = '' if $self->{REMOVE} ;\n        }\n        elsif( /^\\%UNDEFINE_ALL(?:_(SCRIPT|VARIABLE))?/mso ) {\n            my $which = $1 || 'MACRO' ;\n\n            @{$self->{$which}} = () ;\n\n            $_ = '' if $self->{REMOVE} ;\n        }\n        elsif( /^\\%DEFINE(?:_(SCRIPT|VARIABLE))?\\s+([^][\\s]+)\\s*\\[(.*?)\\]/mso ) {\n            my $which = $1 || 'MACRO' ;\n\n            $self->_insert_element( $which, $2, $self->_expand_variable( $3 || '' ) ) ;\n\n            $_ = '' if $self->{REMOVE} ;\n        }\n        elsif( /^\\%DEFINE(?:_(SCRIPT))?\\s+([^][\\s]+)/mso ) {\n            my $which = defined $1 ? 'SCRIPT' : 'MACRO' ;\n            $self->{NAME}        = $2 ;\n            $self->{DEFINE}      = '' ;\n            $self->{\"IN_$which\"} = 1 ;\n\n            $_ = '' if $self->{REMOVE} ;\n        }\n        elsif( /^\\%(LOAD|INCLUDE)\\s*\\[(.+?)\\]/mso ) {\n            my $in_macro    = $self->{IN_MACRO} ;   \n            my $in_script   = $self->{IN_SCRIPT} ;  \n            my $in_case     = $self->{IN_CASE} ;    \n            my $define      = $self->{DEFINE} ;\n            my $name        = $self->{NAME} ;\n            my $lino        = $self->{LINO} ;\n            my $in_embedded = $self->{IN_EMBEDDED} ;\n\n            my @lines = () ;\n            \n            if( $1 eq 'LOAD' ) {\n                carp \"Should be embedded when LOADing $2\" \n                if $self->{-embedded} and not $self->{IN_EMBEDDED} ;\n\n\n                $self->load_file( $2 ) ;\n            }\n            else {\n                carp \"Should be embedded when INCLUDINGing $2\" \n                if $self->{-embedded} and not $self->{IN_EMBEDDED} ;\n\n                $self->{IN_EMBEDDED} = 0 ; \n\n                @lines = $self->expand_file( $2 ) ;\n            }\n        \n            $self->{IN_MACRO}    = $in_macro ;\n            $self->{IN_SCRIPT}   = $in_script ;\n            $self->{IN_CASE}     = $in_case ;\n            $self->{DEFINE}      = $define ;\n            $self->{NAME}        = $name ;\n            $self->{LINO}        = $lino ;\n            $self->{IN_EMBEDDED} = $in_embedded ;\n\n            $_ = join '', @lines ;\n        }\n        elsif( /^\\%REQUIRE\\s*\\[(.+?)\\]/mso ) {\n            my $file = $1 ;\n            eval {\n                require $file ;\n            } ;\n            carp \"Failed to require `$file': $@\" if $@ ;\n\n            $_ = '' if $self->{REMOVE} ;\n        }\n        else {\n            foreach my $script ( @{$self->{SCRIPT}} ) {\n                my( $name, $orig_body ) = @{$script} ;\n                s{\n                    \\Q$name\\E\n                    (?:\\[(.+?)\\])?  \n                 }{\n                    # Get any parameters\n                    my @param = split /\\|/, $1 if defined $1 ;\n                    # We get $body fresh every time since we could have the same\n                    # macro or script occur more than once in a line but of course\n                    # with different parameters.\n                    my $body  = $orig_body ;\n                    # Substitute any parameters in the script's body; we go from\n                    # largest index to smallest to ensure that we substitute #13\n                    # before #1!\n                    if( $body =~ /#\\d/mso ) {\n\n                        $body =~ s/\\\\#/\\x0/msgo ; # Hide escaped #s\n\n                        # Warnings don't seem to work correctly here so we switch\n                        # them off and do them manually.\n                        local $^W = 0 ;\n\n                        for( my $i = $#param ; $i >= 0 ; $i-- ) {\n                            $body =~ s/#$i/$param[$i]/msg ;\n                        }\n                        carp \"missing parameter or unescaped # in SCRIPT \" .\n                             \"$name $body $where\"\n                        if ( $#param > 9 and $body =~ /#\\d\\d\\D/mso ) or \n                                           ( $body =~ /#\\d\\D/mso ) ;\n\n                        $body =~ s/\\x0/#/msgo ; # Unhide escaped #s\n                        # Extra parameters, i.e. those given in the text but not\n                        # used by the macro or script are ignored and do not\n                        # appear in the output.\n                    }\n                    # Evaluate the script \n                    my $result = '' ;\n                    eval {\n                        my @Param = @param ; # Give (local)  access to params\n                        my %Var   = %{$self->{VARIABLE}} ;\n                        local $_ ;\n                        $result   = eval $body ;\n                        %{$self->{VARIABLE}} = %Var ;\n                    } ;\n                    croak \"evaluation of SCRIPT $name failed $where: $@\" \n                    if $@ ;\n                    # This carp does't work - its supposed to catch a failed eval\n                    # and give an error message - instead perl doesn't set $@ but\n                    # outputs its own error message immediately instead. Although\n                    # we can switch off perl's message using local $^W = 0, doing\n                    # so means that the error goes by silently, so I've left the\n                    # default behaviour so at least we know we've got an error.\n                    # Please let me know how to fix this!\n\n                    # Return the result of the evaluation as the replacement string\n                    $result ;\n                 }gmsex ; \n            }\n\n            foreach my $macro ( @{$self->{MACRO}} ) {\n                my( $name, $body ) = @{$macro} ;\n\n                s{\n                    \\Q$name\\E\n                    (?:\\[(.+?)\\])?  \n                 }{\n                    my @param = split /\\|/, $1 if defined $1 ;\n                    {\n                        $body =~ s/\\\\#/\\x0/msgo ; # Hide escaped #s\n\n                        local $^W = 0 ;\n\n                        for( my $i = $#param ; $i >= 0 ; $i-- ) {\n                            $body =~ s/#$i/$param[$i]/msg ;\n                        }\n\n                        carp \"missing parameter or unescaped # in MACRO \" .\n                             \"$name $body $where\"\n                        if ( $#param > 9 and $body =~ /#\\d\\d\\D/mso ) or \n                                           ( $body =~ /#\\d\\D/mso ) ;\n\n                        $body =~ s/\\x0/#/msgo ; # Unhide escaped #s\n                    }\n                    $body ;\n                 }gmsex ; \n            }\n        }\n    } ;\n    croak $@ if $@ ;\n\n    $_ ;\n}\n\n\n1",
      "file" : "/var/tmp/arv_YvGUEP/Text-MacroScript-1.40/MacroScript.pm",
      "package" : "Text::MacroScript"
   }
]
