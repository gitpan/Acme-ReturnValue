[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub parse {\n\tmy ($expr) = @_;\n\tif ( $expr =~ $path_grammar ) {\n\t\tmy $ref = \\%/;\n\t\tnormalize_compounds($ref);\n\t\tcomplement_to_boolean($ref);\n\t\tif ( contains_condition($ref) ) {\n\t\t\tnormalize_parens($ref);\n\t\t\toperator_precedence($ref);\n\t\t\tmerge_conditions($ref);\n\t\t\tfix_predicates($ref);\n\t\t}\n\t\toptimize($ref);\n\t\tconfirm_separators( $ref, 0 );\n\t\treturn $ref;\n\t}\n\telse {\n\t\tconfess \"could not parse '$expr' as a TPath expression:\\n\" . join \"\\n\",\n\t\t  @!;\n\t}\n}\n\n# require a separator before all non-initial steps\nsub confirm_separators {\n\tmy ( $ref, $non_initial ) = @_;\n\tfor ( ref $ref ) {\n\t\twhen ('ARRAY') { confirm_separators( $_, $non_initial ) for @$ref }\n\t\twhen ('HASH') {\n\t\t\tmy ($path) = $ref->{path};\n\t\t\tif ($path) {\n\t\t\t\tfor my $i ( 0 .. $#$path ) {\n\t\t\t\t\tmy @steps = @{ $path->[$i]{segment} };\n\t\t\t\t\tfor my $j ( 0 .. $#steps ) {\n\t\t\t\t\t\tmy $step = $steps[$j];\n\t\t\t\t\t\tif (   ( $j || $non_initial )\n\t\t\t\t\t\t\t&& $step->{step}\n\t\t\t\t\t\t\t&& !$step->{separator} )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconfess\n'every non-initial step must be preceded by one of the separators \"/\", \"//\", or \"/>\"';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconfirm_separators( $step, $i ? 1 : $non_initial );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmy $attribute = $ref->{attribute};\n\t\t\t\tif ($attribute) { confirm_separators( $attribute, 0 ) }\n\t\t\t\telse {\n\t\t\t\t\tmy $predicate = $ref->{predicate};\n\t\t\t\t\tif ($predicate) {\n\t\t\t\t\t\tconfirm_separators( $predicate, 0 );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconfirm_separators( $_, $non_initial ) for values %$ref;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n# convert (/foo) to /foo and (/foo)? to /foo?\nsub normalize_compounds {\n\tmy $ref = shift;\n\tfor ( ref $ref ) {\n\t\twhen ('HASH') {\n\n\t\t\t# depth first\n\t\t\tnormalize_compounds($_) for values %$ref;\n\n\t\t\tmy $cs = $ref->{cs};\n\t\t\tif ($cs) {\n\t\t\t\tmy $gs = $cs->{grouped_step};\n\t\t\t\tif (   $gs\n\t\t\t\t\t&& @{ $gs->{treepath}{path} } == 1\n\t\t\t\t\t&& @{ $gs->{treepath}{path}[0]{segment} } == 1 )\n\t\t\t\t{\n\t\t\t\t\tmy $quantifier = $gs->{quantifier};\n\t\t\t\t\tmy $step       = $gs->{treepath}{path}[0]{segment}[0];\n\t\t\t\t\t$step->{quantifier} = $quantifier if $quantifier;\n\t\t\t\t\t$ref->{cs} = $step;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhen ('ARRAY') {\n\n\t\t\t# depth first\n\t\t\tnormalize_compounds($_) for @$ref;\n\n\t\t\tmy $among_steps;\n\t\t\tfor my $i ( 0 .. $#$ref ) {\n\t\t\t\tmy $v = $ref->[$i];\n\t\t\t\tlast unless $among_steps // ref $v;\n\t\t\t\tmy $cs = $v->{cs};\n\t\t\t\t$among_steps //= $cs // 0 || $v->{step} // 0;\n\t\t\t\tlast unless $among_steps;\n\t\t\t\tif ( $cs && $cs->{step} && !$cs->{quantifier} ) {\n\t\t\t\t\tsplice @$ref, $i, 1, $cs;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n# converts complement => '^' to complement => 1 simply to make AST function clearer\nsub complement_to_boolean {\n\tmy $ref = shift;\n\tfor ( ref $ref ) {\n\t\twhen ('HASH') {\n\t\t\tfor my $k ( keys %$ref ) {\n\t\t\t\tif ( $k eq 'complement' ) { $ref->{$k} &&= 1 }\n\t\t\t\telse { complement_to_boolean( $ref->{$k} ) }\n\t\t\t}\n\t\t}\n\t\twhen ('ARRAY') { complement_to_boolean($_) for @$ref }\n\t}\n}\n\n# remove no-op steps etc.\nsub optimize {\n\tmy $ref = shift;\n\tclean_no_op($ref);\n}\n\n# remove . and /. steps\nsub clean_no_op {\n\tmy $ref = shift;\n\tfor ( ref $ref ) {\n\t\twhen ('HASH') {\n\t\t\tmy $paths = $ref->{path};\n\t\t\tfor my $path ( @{ $paths // [] } ) {\n\t\t\t\tmy @segments = @{ $path->{segment} };\n\t\t\t\tmy @cleaned;\n\t\t\t\tfor my $i ( 1 .. $#segments ) {\n\t\t\t\t\tmy $step = $segments[$i];\n\t\t\t\t\tpush @cleaned, $step unless find_dot($step);\n\t\t\t\t}\n\t\t\t\tif (@cleaned) {\n\t\t\t\t\tmy $step = $segments[0];\n\t\t\t\t\tif ( find_dot($step) ) {\n\t\t\t\t\t\tmy $sep  = $step->{separator};\n\t\t\t\t\t\tmy $next = $cleaned[0];\n\t\t\t\t\t\tmy $nsep = $next->{separator};\n\t\t\t\t\t\tif ($sep) {\n\t\t\t\t\t\t\tunshift @cleaned, $step\n\t\t\t\t\t\t\t  unless $nsep eq '/' && find_axis($next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif ( $nsep eq '/' ) {\n\t\t\t\t\t\t\t\tdelete $next->{separator};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tunshift @cleaned, $step;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tunshift @cleaned, $step;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t@cleaned = @segments;\n\t\t\t\t}\n\t\t\t\t$path->{segment} = \\@cleaned;\n\t\t\t}\n\t\t\tclean_no_op($_) for values %$ref;\n\t\t}\n\t\twhen ('ARRAY') {\n\t\t\tclean_no_op($_) for @$ref;\n\t\t}\n\t}\n}\n\n# returns the axis if any; prevents reification of hash keys\nsub find_axis {\n\tmy $next = shift;\n\tmy $step = $next->{step};\n\treturn unless $step;\n\tmy $full = $step->{step};\n\treturn unless $full;\n\treturn $full->{axis};\n}\n\n# finds dot, if any; prevents reification of hash keys\nsub find_dot {\n\tmy $step = shift;\n\texists $step->{step}\n\t  && ( $step->{step}{abbreviated} // '' ) eq '.';\n}\n\n# remove unnecessary levels in predicate trees\nsub fix_predicates {\n\tmy $ref  = shift;\n\tmy $type = ref $ref;\n\tfor ($type) {\n\t\twhen ('HASH') {\n\t\t\twhile ( my ( $k, $v ) = each %$ref ) {\n\t\t\t\tif ( $k eq 'predicate' ) {\n\t\t\t\t\tfor my $i ( 0 .. $#$v ) {\n\t\t\t\t\t\tmy $item = $v->[$i];\n\t\t\t\t\t\tnext if exists $item->{idx};\n\t\t\t\t\t\tif ( ref $item->{condition} eq 'ARRAY' ) {\n\t\t\t\t\t\t\t$item = $item->{condition}[0];\n\t\t\t\t\t\t\tsplice @$v, $i, 1, $item;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfix_predicates($item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfix_predicates($v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhen ('ARRAY') { fix_predicates($_) for @$ref }\n\t}\n}\n\n# merge nested conditions with the same operator into containing conditions\nsub merge_conditions {\n\tmy $ref  = shift;\n\tmy $type = ref $ref;\n\treturn $ref unless $type;\n\tfor ($type) {\n\t\twhen ('HASH') {\n\t\t\twhile ( my ( $k, $v ) = each %$ref ) {\n\t\t\t\tif ( $k eq 'condition' ) {\n\t\t\t\t\tif ( !exists $v->{args} ) {\n\t\t\t\t\t\tmerge_conditions($_) for values %$v;\n\t\t\t\t\t\tnext;\n\t\t\t\t\t}\n\n\t\t\t\t\t# depth first\n\t\t\t\t\tmerge_conditions($_) for @{ $v->{args} };\n\t\t\t\t\tmy $op = $v->{operator};\n\t\t\t\t\tmy @args;\n\t\t\t\t\tfor my $a ( @{ $v->{args} } ) {\n\t\t\t\t\t\tmy $condition = $a->{condition};\n\t\t\t\t\t\tif ( defined $condition ) {\n\t\t\t\t\t\t\tmy $o = $condition->{operator};\n\t\t\t\t\t\t\tif ( defined $o ) {\n\t\t\t\t\t\t\t\tif ( $o eq $op ) {\n\t\t\t\t\t\t\t\t\tpush @args, @{ $condition->{args} };\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tpush @args, $a;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tpush @args, $condition;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpush @args, $a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$v->{args} = \\@args;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmerge_conditions($v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhen ('ARRAY') { merge_conditions($_) for @$ref }\n\t\tdefault { confess \"unexpected type $type\" }\n\t}\n}\n\n# group operators and arguments according to operator precedence ! > & > ` > ||\nsub operator_precedence {\n\tmy $ref  = shift;\n\tmy $type = ref $ref;\n\treturn $ref unless $type;\n\tfor ($type) {\n\t\twhen ('HASH') {\n\t\t\twhile ( my ( $k, $v ) = each %$ref ) {\n\t\t\t\tif ( $k eq 'condition' && ref $v eq 'ARRAY' ) {\n\t\t\t\t\tmy @ar = @$v;\n\n\t\t\t\t\t# normalize ! strings\n\t\t\t\t\t@ar = grep { $_ } map {\n\t\t\t\t\t\tif ( !ref $_ && /^!++$/ ) {\n\t\t\t\t\t\t\t( my $s = $_ ) =~ s/..//g;\n\t\t\t\t\t\t\t$s;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { $_ }\n\t\t\t\t\t} @ar;\n\t\t\t\t\t$ref->{$k} = \\@ar if @$v != @ar;\n\n\t\t\t\t\t# depth first\n\t\t\t\t\toperator_precedence($_) for @ar;\n\t\t\t\t\treturn $ref if @ar == 1;\n\n\t\t\t\t\t# build binary logical operation tree\n\t\t\t\t  OUTER: while ( @ar > 1 ) {\n\t\t\t\t\t\tfor my $op (qw(! & ` ||)) {\n\t\t\t\t\t\t\tfor my $i ( 0 .. $#ar ) {\n\t\t\t\t\t\t\t\tmy $item = $ar[$i];\n\t\t\t\t\t\t\t\tnext if ref $item;\n\t\t\t\t\t\t\t\tif ( $item eq $op ) {\n\t\t\t\t\t\t\t\t\tif ( $op eq '!' ) {\n\t\t\t\t\t\t\t\t\t\tsplice @ar, $i, 2,\n\t\t\t\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\t\t\t\tcondition => {\n\t\t\t\t\t\t\t\t\t\t\t\toperator => '!',\n\t\t\t\t\t\t\t\t\t\t\t\targs     => [ $ar[ $i + 1 ] ]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t  };\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tsplice @ar, $i - 1, 3,\n\t\t\t\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\t\t\t\tcondition => {\n\t\t\t\t\t\t\t\t\t\t\t\toperator => $op eq '`'\n\t\t\t\t\t\t\t\t\t\t\t\t? '^'\n\t\t\t\t\t\t\t\t\t\t\t\t: $op,\n\t\t\t\t\t\t\t\t\t\t\t\targs => [\n\t\t\t\t\t\t\t\t\t\t\t\t\t$ar[ $i - 1 ],\n\t\t\t\t\t\t\t\t\t\t\t\t\t$ar[ $i + 1 ]\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t  };\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tnext OUTER;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t# replace condition with logical operation tree\n\t\t\t\t\t$ref->{condition} = $ar[0]{condition};\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toperator_precedence($v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhen ('ARRAY') { operator_precedence($_) for @$ref }\n\t\tdefault { confess \"unexpected type $type\" }\n\t}\n\treturn $ref;\n}\n\n# looks for structures requiring normalization\nsub contains_condition {\n\tmy $ref  = shift;\n\tmy $type = ref $ref;\n\treturn 0 unless $type;\n\tif ( $type eq 'HASH' ) {\n\t\twhile ( my ( $k, $v ) = each %$ref ) {\n\t\t\treturn 1 if $k eq 'condition' || contains_condition($v);\n\t\t}\n\t\treturn 0;\n\t}\n\tfor my $v (@$ref) {\n\t\treturn 1 if contains_condition($v);\n\t}\n\treturn 0;\n}\n\n# removes redundant parentheses and simplifies condition elements somewhat\nsub normalize_parens {\n\tmy $ref  = shift;\n\tmy $type = ref $ref;\n\treturn $ref unless $type;\n\tfor ($type) {\n\t\twhen ('ARRAY') {\n\t\t\tnormalize_parens($_) for @$ref;\n\t\t}\n\t\twhen ('HASH') {\n\t\t\tfor my $name ( keys %$ref ) {\n\t\t\t\tmy $value = $ref->{$name};\n\t\t\t\tif ( $name eq 'condition' ) {\n\t\t\t\t\tmy @ar = @{ $value->{item} };\n\t\t\t\t\tfor my $i ( 0 .. $#ar ) {\n\t\t\t\t\t\t$ar[$i] = normalize_item( $ar[$i] );\n\t\t\t\t\t}\n\t\t\t\t\t$ref->{condition} = \\@ar;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnormalize_parens($value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdefault {\n\t\t\tconfess \"unexpected type: $type\";\n\t\t}\n\t}\n\treturn $ref;\n}\n\n# normalizes parentheses in a condition item\nsub normalize_item {\n\tmy $item = shift;\n\treturn $item unless ref $item;\n\tif ( exists $item->{term} ) {\n\t\treturn normalize_parens( $item->{term} );\n\t}\n\telsif ( exists $item->{group} ) {\n\n\t\t# remove redundant parentheses\n\t\twhile ( exists $item->{group}\n\t\t\t&& @{ $item->{group}{condition}{item} } == 1 )\n\t\t{\n\t\t\t$item = $item->{group}{condition}{item}[0];\n\t\t}\n\t\treturn normalize_parens( $item->{group} // $item->{term} );\n\t}\n\telse {\n\t\tconfess\n\t\t  'items in a condition are expected to be either <term> or <group>';\n\t}\n}\n\n# some functions to undo escaping and normalize strings\n\nsub clean_literal {\n\tmy $m = shift;\n\t$m = substr $m, 1, -1;\n\treturn clean_escapes($m);\n}\n\nsub clean_pattern {\n\tmy $m = shift;\n\t$m = substr $m, 1, -1;\n\tmy $r = '';\n\tmy $i = 0;\n\t{\n\t\tmy $j = index $m, '~~', $i;\n\t\tif ( $j > -1 ) {\n\t\t\t$r .= substr $m, $i, $j - $i + 1;\n\t\t\t$i = $j + 2;\n\t\t\tredo;\n\t\t}\n\t\telse {\n\t\t\t$r .= substr $m, $i;\n\t\t}\n\t}\n\treturn $r;\n}\n\nsub clean_not {\n\tmy $m = shift;\n\treturn '!' if $m eq 'not';\n\treturn $m;\n}\n\nsub clean_operator {\n\tmy $m = shift;\n\tfor ($m) {\n\t\twhen ('and') { return '&' }\n\t\twhen ('or')  { return '||' }\n\t\twhen ('one') { return '`' }\n\t}\n\treturn $m;\n}\n\nsub clean_escapes {\n\tmy $m = shift;\n\treturn '' unless $m;\n\tmy $r = '';\n\t{\n\t\tmy $i = index $m, '\\\\';\n\t\tif ( $i > -1 ) {\n\t\t\tmy $prefix = substr $m, 0, $i;\n\t\t\t$prefix .= substr $m, $i + 1, 1;\n\t\t\t$m = substr $m, $i + 2;\n\t\t\t$r .= $prefix;\n\t\t\tredo;\n\t\t}\n\t\telse {\n\t\t\t$r .= $m;\n\t\t}\n\t}\n\treturn $r;\n}\n\n1;\n\n__END__\n\n__END__\n\n=pod\n\n=head1 NAME\n\nTPath::Grammar - parses TPath expressions into ASTs\n\n=head1 VERSION\n\nversion 0.009\n\n=head1 SYNOPSIS\n\n    use TPath::Grammar qw(parse);\n\n    my $ast = parse('/>a[child::b || @foo(\"bar\")][-1]');\n\n=head1 DESCRIPTION\n\nC<TPath::Grammar> exposes a single function: C<parse>. Parsing is a preliminary step to\ncompiling the expression into an object that will select the tree nodes matching\nthe expression.\n\nC<TPath::Grammar> is really intended for use by C<TPath> modules, but if you want \na parse tree, here's how to get it.\n\nAlso exportable from C<TPath::Grammar> is C<%AXES>, the set of axes understood by TPath\nexpressions. See L<TPath> for the list and explanation.\n\n=head1 FUNCTIONS\n\n=head2 parse\n\nConverts a TPath expression to a parse tree, normalizing boolean expressions\nand parentheses and unescaping escaped strings. C<parse> throws an error with\na stack trace if the expression is unparsable. Otherwise it returns a hashref.\n\n=head1 AUTHOR\n\nDavid F. Houghton <dfhoughton@gmail.com>\n\n=head1 COPYRIGHT AND LICENSE\n\nThis software is copyright (c) 2013 by David F. Houghton.\n\nThis is free software; you can redistribute it and/or modify it under\nthe same terms as the Perl 5 programming language system itself.\n\n=cut\n",
      "file" : "/var/tmp/arv_2yQGmP/TPath-0.009/lib/TPath/Grammar.pm",
      "package" : "TPath::Grammar"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "enum 'Axis' => keys %AXES",
      "file" : "/var/tmp/arv_2yQGmP/TPath-0.009/lib/TPath/TypeConstraints.pm",
      "package" : "TPath::TypeConstraints"
   }
]
