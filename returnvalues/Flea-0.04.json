[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "default_export get    Flea::Parser::Route  { route(['get'],  @_) }\ndefault_export put    Flea::Parser::Route  { route(['put'],  @_) }\ndefault_export del    Flea::Parser::Route  { route(['del'],  @_) }\ndefault_export any    Flea::Parser::Route  { route(['any'],  @_) }\ndefault_export post   Flea::Parser::Route  { route(['post'], @_) }\ndefault_export method Flea::Parser::Method { \n    my $code    = pop;\n    my $re      = pop;\n    my $methods = [@_];\n    route($methods, $re, $code);\n}\n\ndefault_export uri {\n    my ($req, $path) = @_;\n    my $base  = $req->base->as_string;\n    $base =~ s|/$||;\n    $path =~ s|^/||;\n    URI->new(\"$base/$path\")->canonical;\n}\n\ndefault_export json {\n    return [\n        200,\n        ['Content-Type' => 'application/json; charset=UTF-8'],\n        [ JSON::encode_json(shift) ]\n    ];\n}\n\ndefault_export html {\n    return [\n        200,\n        ['Content-Type' => 'text/html; charset=UTF-8'],\n        [ shift ]\n    ];\n}\n\ndefault_export text {\n    return [\n        200,\n        ['Content-Type' => 'text/plain; charset=UTF-8'],\n        [ shift ]\n    ];\n}\n\nsub http {\n    HTTP::Exception->throw(@_);\n}\n\nsub handle {\n    my ($fh, $type) = @_;\n    return [\n        200,\n        ['Content-Type' => $type || 'text/html; charset=UTF-8'],\n        $fh\n    ];\n}\n\ndefault_export file {\n    open my $fh, '<', shift;\n    handle($fh, @_);\n}\n\ndefault_export request  { Plack::Request->new(shift) }\ndefault_export response { shift->new_response(200) }\n\nsub _rethrow {\n    my $e = shift;\n    $e->rethrow if ref $e && $e->can('rethrow');\n    die $e || 'unknown error';\n}\n\nsub _find_and_run {\n    my ($handlers, $env) = @_;\n    my $method = lc $env->{REQUEST_METHOD};\n    my $found  = 0;\n    for my $h (@$handlers) {\n        my @matches = $env->{PATH_INFO} =~ $h->{pattern};\n        if (@matches) {\n            $found = 1;\n            next unless first { $_ eq $method || $_ eq 'any' }\n                        @{ $h->{methods} };\n\n            my $result = try {\n                $h->{handler}->($env, @matches);\n            }\n            catch {\n                my $e = $_;\n                _rethrow($e) unless Flea::Pass->caught;\n                undef;\n            };\n            next unless $result;\n            return try { $result->finalize } || $result;\n        }\n    }\n    http ($found ? 405 : 404);\n}\n\ndefault_export bite codeblock {\n    my $block = shift;\n    my @handlers;\n    local $_add = sub {\n        my ($m, $r, $c) = @_;\n        push(@handlers, { methods => $m, pattern => $r, handler => $c });\n    };\n    $block->();\n\n    return sub { _find_and_run(\\@handlers, shift) };\n}\n\n1",
      "file" : "/var/tmp/arv_0jvJxb/Flea-0.04/lib/Flea.pm",
      "package" : "Flea"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub rewrite {\n    my $self  = shift;\n    my $parts = $self->parts;\n    $self->bail('Not enough arguments') unless @$parts > 1;\n\n    my $re = do {\n        my $r = pop @$parts;\n        $r = eval { qr{$r->[0]} } or $self->bail('Could not parse route');\n        [ $r, undef ]\n    };\n    push(@$parts, $re);\n    $self->new_parts($parts);\n}",
      "file" : "/var/tmp/arv_0jvJxb/Flea-0.04/lib/Flea/Parser/Method.pm",
      "package" : "Flea::Parser::Method"
   }
]
