[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "sub _ {gettext(@_)}\n\nsub gettext {\n    defined $I18N->{$RUN_LANG}{$_[0]} ? $I18N->{$RUN_LANG}{$_[0]} : $_[0];\n}\n\n{   \n    local $^W = 0;\n    eval \"sub x_ {_check_gettext('__', \\@_);}\";\n}\n\nsub S_ { _check_gettext($SOURCE_LANG, @_)}\n\nsub D_ { _check_gettext($DIAG_LANG, @_)}\n\nsub _check_gettext {\n    my ($key, $text, $depth) = @_;\n\n    $depth ||= 1;\n    if (defined $I18N->{$key}{$text}) {\n        return $I18N->{$key}{$text};\n    } else {\n        if ($I18N->{$key}{$SAVE_MISSING}) {\n            my $called_at = \n                basename((caller $depth)[1]). \":\".(caller $depth)[2];\n            unless ($I18N->{$key}{$MISSING_STRINGS}{$text} && \n                $I18N->{$key}{$MISSING_STRINGS}{$text} =~ / $called_at /) {\n                $I18N->{$key}{$MISSING_STRINGS}{$text} .= \" $called_at \";\n            }\n        }\n        return $text;\n    }\n}\n\nsub start_checking_gettext_strings {\n    my ($class, $key, $file) = @_;\n\n    $I18N->{($key || $RUN_LANG)}{$SAVE_MISSING} = ($file || \"&STDOUT\");\n}\n\nsub stop_checking_gettext_strings {\n    my ($class, $key) = @_;\n\n    undef $I18N->{($key || $RUN_LANG)}{$SAVE_MISSING};\n}\n\nsub write_missing_gettext_strings {\n    my ($class, $key, $file, $no_header, $copy_to) = @_;\n\n    my ($string, $called_at);\n    my $me = __PACKAGE__.\"->write_translatable_strings\";\n    my $saved = $I18N->{$key}{$MISSING_STRINGS};\n    $key  ||= $RUN_LANG;\n    $file ||= $I18N->{$key}{$SAVE_MISSING};\n    return unless keys %$saved;\n    open POT, \">$file\" or \n        die sprintf((\"error %s - can't open file '%s' for output\"),\n                $me, $file);\n    my $date = `date +\"%Y-%m-%d %H:%M%z\"`; chomp $date;\n    my $year = `date +\"%Y\"`; chomp $year;\n    print POT \"# \".sprintf(S_(\"These are strings that had no gettext translation in '%s'\"), $key).\"\\n\";\n    print POT \"# \".sprintf(S_(\"Automatically generated by %s\"),__PACKAGE__).\"\\n\";\n    print POT \"# \".S_(\"Date\").\" \".`date`;\n    print POT \"# \".sprintf(S_(\"Run from class %s in file %s\"), $class->PACKAGE, (caller 0)[1]).\"\\n\";\n    unless ($no_header && $no_header eq \"NO_HEADER\") {\n        print POT \"\n# SOME DESCRIPTIVE TITLE.\n# Copyright (C) $year ORGANISATION\n# \".$class->AUTHOR.\",\n#\n# , fuzzy\nmsgid \\\"\\\"\nmsgstr \\\"\\\"\n\\\"Project-Id-Version:  \".$class->PACKAGE.\" \".$class->VERSION.\"\\\\n\\\"\n\\\"POT-Creation-Date: $date\\\\n\\\"\n\\\"PO-Revision-Date:  YEAR-MO-DA HO:MI+ZONE\\\\n\\\"\n\\\"Last-Translator:  \".$class->AUTHOR.\"\\\\n\\\"\n\\\"Language-Team:  LANGUAGE \\<LL\".'@li.org'.\"\\>\\\\n\\\"\n\\\"MIME-Version:  1.0\\\\n\\\"\n\\\"Content-Type: text/plain; charset=CHARSET\\\\n\\\"\n\\\"Content-Transfer-Encoding:  ENCODING\\\\n\\\"\n\n#: Generic replacement\nmsgid \\\"\\%s\\\"\nmsgstr \\\"\\%s\\\"\n\n\";  }\n\n    foreach $string (%$saved) {\n        next unless $string and $saved->{$string};\n        print POT wrap(\"#\", \"#\",$saved->{$string}), \"\\n\";\n        if ($string =~ s/\\n/\\\\n\\\"\\n\\\"/g) {$string = \"\\\"\\n\\\"\".$string}\n        print POT \"msgid \\\"$string\\\"\\n\";\n        if ($copy_to && $copy_to eq 'COPY_TO') {\n            print POT \"msgstr \\\"$string\\\"\\n\\n\";\n        } else {\n            print POT \"msgstr \\\"\\\"\\n\\n\";\n        }\n    }\n    close POT;\n}\n\nsub load_translations {\n    my ($class, $domain, $language, $locale_dir, $file, $key, $merge) = @_;\n\n    my $catalog_filename = $file;\n    $key ||= $RUN_LANG;\n    $I18N->{$key} = {} unless $merge and $merge eq \"MERGE\";;\n\n    $language ||= $ENV{\"LANG\"};\n    return unless $language;\n    $locale_dir ||= \"/usr/local/share/locale\";\n    $domain     ||= \"Glade-Perl\";\n\n    for $catalog_filename ( $file || \n        (\"/usr/local/share/locale/$language/LC_MESSAGES/$domain.mo\",\n        \"/usr/share/locale/$language/LC_MESSAGES/$domain.mo\")) {\n        if ($catalog_filename and (-f $catalog_filename)) {\n            $class->load_mo($catalog_filename, $key);\n            last;\n        }\n    }\n}\n\nsub load_mo {\n    my ($class, $catalog, $key) = @_;\n\n    my ($reverse, $buffer);\n    my ($magic, $revision, $nstrings);\n    my ($orig_tab_offset, $orig_length, $orig_pointer);\n    my ($trans_length, $trans_pointer, $trans_tab_offset);\n\n    my $save = $/;\n    open CATALOG, $catalog or return;\n    undef $/; \n    $buffer = <CATALOG>; \n    close CATALOG;\n    $/ = $save;\n    \n    $magic = unpack (\"I\", $buffer);\n    if (sprintf (\"%x\", $magic) eq \"de120495\") {\n    \t$reverse = 1;\n\n    } elsif (sprintf (\"%x\", $magic) ne \"950412de\") {\n    \tprint STDERR \"'$catalog' \"._(\"is not a catalog file\").\"\\n\";\n        return;\n    }\n\n    $revision = &mo_format_value (4, $reverse, $buffer);\n    $nstrings = &mo_format_value (8, $reverse, $buffer);\n    $orig_tab_offset = &mo_format_value (12, $reverse, $buffer);\n    $trans_tab_offset = &mo_format_value (16, $reverse, $buffer);\n\n    while ($nstrings-- > 0) {\n\t    $orig_length = &mo_format_value ($orig_tab_offset, $reverse, $buffer);\n\t    $orig_pointer = &mo_format_value ($orig_tab_offset + 4, $reverse, $buffer);\n\t    $orig_tab_offset += 8;\n\n\t    $trans_length = &mo_format_value ($trans_tab_offset, $reverse, $buffer);\n\t    $trans_pointer = &mo_format_value ($trans_tab_offset + 4,$reverse, $buffer);\n\t    $trans_tab_offset += 8;\n\n    \t$I18N->{$key}{substr ($buffer, $orig_pointer, $orig_length)}\n\t        = substr ($buffer, $trans_pointer, $trans_length);\n    }\n\n    $I18N->{$key}{$MO_HEADER_INFO} = $I18N->{$key}{''};\n    $I18N->{$key}{''} = '';\n}\n\nsub mo_format_value {\n    my ($string, $reverse, $buffer) = @_;\n\n    unpack (\"i\",\n\t    $reverse\n\t    ? pack (\"c4\", reverse unpack (\"c4\", substr ($buffer, $string, 4)))\n\t    : substr ($buffer, $string, 4));\n}\n\nsub WH {\n    my ($class, $new) = @_; \n    if ($new) {\n        return $class->FORM->{$WH} = $new;\n    } else {\n      return $class->FORM->{$WH};\n    }\n}\n\nsub CH {\n    my ($class, $new) = @_;\n    if ($new) {\n      return $class->FORM->{$CH} = $new;\n    } else {\n      return $class->FORM->{$CH};\n    }\n}\n\nsub W {\n    my ($class, $proto, $new) = @_;\n    if ($new) {\n      return $proto->{$W} = $new;\n    } else {\n      return $proto->{$W};\n    }\n}\n\nsub C {\n    my ($class, $proto, @new) = @_;\n    if ($#new) {\n      return push @{$proto->{$C}}, @new;\n    } else {\n      return $proto->{$C};\n    }\n}\n\n\n\nsub create_pixmap {\n    my ($class, $widget, $filename, $pixmap_dirs) = @_;\n    my $me = \"$class->create_pixmap\";\n\n\n    if (ref $filename eq 'CODE') {\n        return new Gtk2::Pixmap(\n            Gtk2::Gdk::Pixmap->create_from_xpm_d(\n                $work->{'window'}, $work->{'style'}, &filename ));\n    } else {\n        my $found_filename = $class->find_file_in_dirs(\n            $filename, \n            @{$pixmap_dirs}, $Glade::Two::Run::pixmaps_directory, getcwd);\n\n        return Gtk::Pixmap->create_from_xpm($found_filename);\n    }\n}\n\nsub create_image {\n    my ($class, $filename, $pixmap_dirs) = @_;\n    my $me = \"$class->create_image\";\n\n    my $found_filename = $class->find_file_in_dirs(\n        $filename, \n        @{$pixmap_dirs}, $Glade::Two::Run::pixmaps_directory, getcwd);\n    return Gtk2::Image->new_from_file($found_filename);\n}\n\nsub create_pixbuf {\n    my ($class, $filename, $pixmap_dirs) = @_;\n    my $me = \"$class->create_pixbuf\";\n\n    my $found_filename = $class->find_file_in_dirs(\n        $filename, \n        @{$pixmap_dirs}, $Glade::Two::Run::pixmaps_directory, getcwd);\n    return Gtk2::Gdk::Pixbuf->new_from_file($found_filename);\n}\n\nsub find_file_in_dirs {\n    my ($class, $filename, @dirs) = @_;\n    my $me = \"$class->find_file_in_dirs\";\n    my ($work, $testfile, $found_filename, $dir);\n    if (-f $filename) {\n        $found_filename = $filename;\n\n    } else {\n        foreach $dir (@dirs) {\n            $testfile = $class->full_Path($filename, $dir);\n        \tif (-f $testfile) {\n                $found_filename = $testfile;\n                last;\n        \t}\n        }\n    }\n    if ($found_filename) {\n        return $found_filename;\n    } else {\n        print STDERR sprintf(_(\n            \"error file '%s' does not exist in %s\\n\"),\n            $filename, $me);\n        return undef;\n    }\n}\n\nsub missing_handler {\n    my ($class, $dataref, $eventref) = @_;\n    my ($widgetname, $signal, $handler, $pixmap) = @$dataref;\n    my $me = __PACKAGE__.\"->missing_handler\";\n\n    print STDOUT sprintf(_(\"%s- %s - called with args ('%s')\"),\n        $indent, $me, join(\"', '\", @_)), \"\\n\";\n    my $message = sprintf(\"\\n\"._(\"%s has been called because\\n\".\n                    \"a signal (%s) was caused by widget (%s).\\n\".\n                    \"When Glade::Two::Generate writes the Perl source to a file \\n\".\n                    \"a skeleton signal handler sub called '%s'\\n\".\n                    \"will be generated in the ProjectSIGS class file. You can write a sub with\\n\".\n                    \"the same name in another module and it will automatically be called instead.\\n\"),\n                    $me, $signal, $widgetname, $handler) ;\n    my $widget = __PACKAGE__->message_box($message, \n        _(\"Missing handler\").\" '$handler' \"._(\"called\"), \n        [_(\"Dismiss\"), _(\"Quit\").\" Glade::Two::Generate\"], 1, $pixmap);\n    \n    return $widget;\n}\n\nsub show_skeleton_message {\n    my ($class, $caller, $data, $package, $pixmap) = @_;\n    $pixmap  ||= \"$Glade::Two::Run::pixmaps_directory/Logo.xpm\";\n    $package ||= (caller);\n    $data    ||= ['unknown args'];\n\n    my $args = (ref $data->[0]);\n    if (ref $data->[1] and ref $data->[1] eq 'ARRAY') {\n        $args .= \", ['\".join(\"', '\", @{$data->[1]}).\"']\".\n        (ref $data->[2] && ', '.(ref $data->[2]).')');\n    }\n    $class->message_box(sprintf(_(\"\nA signal handler has just been triggered.\n\n%s \nwas called with parameters (%s)\n\nUntil the sub is written, I will show you \nthis box to prove that I have been called\n\"), \n    $caller, \n    $args),\n    $caller, \n    [_('Dismiss'), _(\"Quit\").\" Program\"], \n    1, \n    $pixmap);\n}\n\nsub message_box {\n    my ($class, $text, $title, $buttons, $default, \n        $pixmapfile, $just, $handlers, $entry) = @_;\n\n    my ($i, $ilimit);\n    my $justify = $just || 'center';\n    my $mbno = 1;\n    while (defined $widgets->{\"MessageBox-$mbno\"}) {$mbno++;}\n    $widgets->{\"MessageBox-$mbno\"}{$WIDGET_INSTANCE} = new Gtk2::Window('toplevel');\n    $widgets->{\"MessageBox-$mbno\"}{$WIDGET_INSTANCE}->set_title($title);\n    $widgets->{\"MessageBox-$mbno\"}{$WIDGET_INSTANCE}->set_position('mouse');\n    $widgets->{\"MessageBox-$mbno\"}{$WIDGET_INSTANCE}->set_border_width('6');\n    $widgets->{\"MessageBox-$mbno\"}{$WIDGET_INSTANCE}->modal('1');\n    $widgets->{\"MessageBox-$mbno\"}{$WIDGET_INSTANCE}->realize;\n        $widgets->{\"MessageBox-$mbno\"}{'vbox1'} = new Gtk2::VBox(0, 0);\n        $widgets->{\"MessageBox-$mbno\"}{'vbox1'}->set_border_width(0);\n        $widgets->{\"MessageBox-$mbno\"}{$WIDGET_INSTANCE}->add($widgets->{\"MessageBox-$mbno\"}{'vbox1'});\n        $widgets->{\"MessageBox-$mbno\"}{$WIDGET_INSTANCE}->show();\n            $widgets->{\"MessageBox-$mbno\"}{'hbox1'} = new Gtk2::HBox('0', '0');\n            $widgets->{\"MessageBox-$mbno\"}{'hbox1'}->set_border_width('0');\n            $widgets->{\"MessageBox-$mbno\"}{'vbox1'}->add($widgets->{\"MessageBox-$mbno\"}{'hbox1'});\n            $widgets->{\"MessageBox-$mbno\"}{'hbox1'}->show();\n\n    \t\tif ($pixmapfile) { \n    \t\t\t$widgets->{\"MessageBox-$mbno\"}{'pixmap1'} = $class->create_image($pixmapfile);\n    \t\t\tif ($widgets->{\"MessageBox-$mbno\"}{'pixmap1'}) {\n                    $widgets->{\"MessageBox-$mbno\"}{'pixmap1'}->set_alignment('0.5', '0.5');\n        \t        $widgets->{\"MessageBox-$mbno\"}{'hbox1'}->add($widgets->{\"MessageBox-$mbno\"}{'pixmap1'});\n            \t    $widgets->{\"MessageBox-$mbno\"}{'pixmap1'}->show();\n    \t\t\t}\n    \t\t}\n\n                $widgets->{\"MessageBox-$mbno\"}{'label1'} = new Gtk2::Label($text);\n                $widgets->{\"MessageBox-$mbno\"}{'label1'}->set_justify($justify);\n                $widgets->{\"MessageBox-$mbno\"}{'label1'}->set_alignment('0.5', '0.5');\n                $widgets->{\"MessageBox-$mbno\"}{'hbox1'}->add($widgets->{\"MessageBox-$mbno\"}{'label1'});\n                $widgets->{\"MessageBox-$mbno\"}{'label1'}->show();\n            $widgets->{\"MessageBox-$mbno\"}{'action_area1'} = new Gtk2::HBox('1', '5');\n            $widgets->{\"MessageBox-$mbno\"}{'action_area1'}->set_border_width('10');\n            $widgets->{\"MessageBox-$mbno\"}{'vbox1'}->add($widgets->{\"MessageBox-$mbno\"}{'action_area1'});\n            $widgets->{\"MessageBox-$mbno\"}{'action_area1'}->show();\n                if ($entry) {\n                    $widgets->{\"MessageBox-$mbno\"}{'entry'} = new Gtk2::Entry;\n                    $widgets->{\"MessageBox-$mbno\"}{'vbox1'}->add($widgets->{\"MessageBox-$mbno\"}{'entry'});\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->show( );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->set_usize('160', '0' );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->can_focus('1' );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->set_text('' );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->set_max_length('0' );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->set_visibility('1' );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->set_editable('1' );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->grab_focus();\n                }\n                $widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'} = new Gtk2::HButtonBox;\n                $widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'}->set_layout('default_style');\n                $widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'}->set_spacing('10');\n                $widgets->{\"MessageBox-$mbno\"}{'action_area1'}->add($widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'});\n                $widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'}->show();\n    \t\t\t$ilimit = scalar(@$buttons);\n    \t\t\tfor ($i = 0; $i < $ilimit; $i++) {\n                    $widgets->{\"MessageBox-$mbno\"}{'button'.$i} = new_with_label Gtk2::Button($buttons->[$i]);\n    \t\t\t\tif ($handlers->[$i]) {\n    \t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'button'.$i}->signal_connect('clicked', $handlers->[$i], [$mbno, $buttons->[$i]]);\n    \t\t\t\t} else {\n    \t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'button'.$i}->signal_connect('clicked', __PACKAGE__.\"::message_box_close\", [$mbno, $buttons->[$i]]);\n    \t\t\t\t}\n                    $widgets->{\"MessageBox-$mbno\"}{'button'.$i}->set_border_width('0');\n                    $widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'}->add($widgets->{\"MessageBox-$mbno\"}{'button'.$i});\n    \t\t\t\tif ($i == ($default-1)) {\n                        $widgets->{\"MessageBox-$mbno\"}{'button'.$i}->SET_FLAGS('can-default');\n    \t                $widgets->{\"MessageBox-$mbno\"}{'button'.$i}->grab_default();\n    \t\t\t\t}\n                    $widgets->{\"MessageBox-$mbno\"}{'button'.$i}->show();\n                }\n    $widgets->{\"MessageBox-$mbno\"}{$WIDGET_INSTANCE}->show_all();\n    return $widgets->{\"MessageBox-$mbno\"}{$WIDGET_INSTANCE};\n}\n\nsub message_box_close {\n    my ($class, $dataref) = @_;\n    my ($mbno, $button_label) = @$dataref;\n    $widgets->{\"MessageBox-$mbno\"}{$WIDGET_INSTANCE}->destroy;\n    undef $widgets->{\"MessageBox-$mbno\"};\n    my $quit_string = _(\"Quit\").\" Program*\"._(\"Quit\").\" Glade::Two::Generate*\";\n    if (_(\"*$quit_string*Quit Generate*Quit UI Build*Close Form*\") =~ m/\\*$button_label\\*/) {\n        Gtk2->quit;\n    }\n    return $dataref;\n}\n\nsub destroy_all_forms {\n    my $class = shift;\n    my $hashref = shift || $__PACKAGE__::all_forms;\n    my $myform;\n    foreach $myform (keys %$hashref) {\n        $hashref->{$myform}->get_toplevel->destroy;\n        undef $hashref->{$myform};\n    }\n}\n\n\n\nsub get_time {\n    my $time = `date`;\n    chomp $time;\n    return $time\n}\n\nsub full_Path {\n    my ($class, $rel_path, $directory, $default) = @_;\n    my $me = \"$class->full_Path\";\n    my $basename;\n    my $slash = '/';\n    my $updir = '/\\.\\./';\n    my $fullname = $rel_path || $default || '';\n    if ($fullname !~ /^$slash/ && defined $directory) {\n        my $save_dir = getcwd;\n        chdir($directory);\n        my $fulldir = getcwd;\n        $fullname = \"$fulldir$slash$fullname\"; \n        chdir($save_dir);\n    } else {\n        my $dirname = dirname($fullname);\n        my $basename = basename($fullname);\n        my $save_dir = getcwd;\n        chdir($dirname);\n        my $fulldir = getcwd;\n        $fullname = \"$fulldir$slash$basename\"; \n        chdir($save_dir);\n    }    \n    $fullname =~ s/$slash\\.?$slash/$slash/g;\n    while ($fullname =~ /$updir/) {\n        $fullname =~ s/(.+)(?!$updir)$slash.+?$updir/$1$slash/;\n    }\n    $fullname =~ s/$slash$//;\n    return $fullname;\n}\n\nsub relative_path {\n    my ($class, $basepath, $path, $root) = @_;\n    my $me = __PACKAGE__.\"::relative_path\";\n\n    return $path if $path =~ /:/;\n    my $rel;\n    my $li = 1;\n    while (1) {\n        my $i = index($path, '/', $li);\n        last if $i < 0 ||\n                $i != index($basepath, '/', $li) ||\n                substr($path,$li,$i-$li) ne substr($basepath,$li,$i-$li);\n        $li=$i+1;\n    }\n    substr($path, 0,$li) = '';\n    substr($basepath,0,$li) = '';\n\n    $rel = \"\";\n\n    $path = ('../' x $basepath =~ tr|/|/|) . $path;\n    $path = \"./\" if $path eq \"\";\n    $rel = $path;\n\n    return $rel;\n}\n\nsub string_from_file {&string_from_File(@_);}\nsub string_from_File {\n    my ($class, $filename) = @_;\n    my $me = __PACKAGE__.\"->string_from_File\";\n\n    my $save = $/;\n    undef $/;\n    open INFILE, $filename or \n        die sprintf((\n            \"error %s - can't open file '%s' for input\"),\n            $me, $filename);    \n    undef $/;\n    my $string = <INFILE>;\n    close INFILE;\n    $/ = $save;\n\n    return $string;\n}\n\nsub typeKey     { return ' type'; }\nsub keyFormat   { return '%04u' } \n\nsub QuoteXMLChars {\n    my $text = shift;\n    my %ents=('&'=>'amp','<'=>'lt','>'=>'gt',\"'\"=>'apos','\"'=>'quot');\n    $text =~ s/([&<>'\"])/&$ents{$1};/g;\n    return $text;\n}\n\nsub UnQuoteXMLChars {\n    my $text = shift;\n    my %ents=('&lt;'=>'<','&gt;'=>'>','&apos;'=>\"'\",'&quot;'=>'\"', '&amp;'=>'&');\n    $text =~ s/(&lt;|&gt;|&apos;|&quot;|&amp;)/$ents{$1}/g;\n    return $text;\n}\n\nsub XmlUtf8Encode {\n    my $n = shift;\n    my $me = \"XmlUtf8Encode\";\n    if ($n < 0x80)    { \n        return chr ($n);\n\n    } elsif ($n < 0x800) {\n        return pack (\"CC\", (($n >> 6) | 0xc0), \n                    (($n & 0x3f) | 0x80));\n\n    } elsif ($n < 0x10000) {\n        return pack (\"CCC\", (($n >> 12) | 0xe0), \n                    ((($n >> 6) & 0x3f) | 0x80),\n                     (($n & 0x3f) | 0x80));\n\n    } elsif ($n < 0x110000) {\n        return pack (\"CCCC\", (($n >> 18) | 0xf0), \n                    ((($n >> 12) & 0x3f) | 0x80),\n                     ((($n >> 6) & 0x3f) | 0x80), \n                      (($n & 0x3f) | 0x80));\n    }\n    __PACKAGE__->diag_print(1, \n        \"error Number is too large for Unicode [%s] in %s \", $n, $me);\n    return \"#\";\n}\n\nsub reload_any_altered_modules {\n    my ($class) = @_;\n    my $me = __PACKAGE__.\"->reload_any_altered_modules\";\n\n    my $stat = \\%stat;\n    my $reloaded = 0;\n    my ($prefix, $msg);\n    if (ref $class) {\n        $prefix = ($class->{diag}{indent} || $indent);\n    } else {\n        $prefix = $indent;\n    }\n    $prefix .= \"- $me\";\n    while(my($key,$file) = each %INC) {\n        local $^W = 0;\n        my $mtime = (stat $file)[9];\n        unless (defined $mtime and $mtime) {\n            print \"$prefix - Can't locate $file\\n\",next \n        }\n        unless(defined $stat->{$file}) {\n            $stat->{$file} = $^T;\n        }\n\n        if($mtime > $stat->{$file}) {\n            delete $INC{$key};\n            require $key;\n            $reloaded++;\n            print \"$prefix - Reloading $key in process $$\\n\";\n        }\n        $stat->{$file} = $mtime;\n    }\n    return \"Reloaded $reloaded module(s) in process $$\";\n}\n\n\n1",
      "file" : "/var/tmp/arv_j93OFJ/Glade-Perl-Two-0.01/Glade/Two/Run.pm",
      "package" : "Glade::Two::Run"
   }
]
