[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub shell_options { \n    my $c = shift;\n\n    if (@_==0) {\n        $c->register( _shell_command() => \\&shell, _shell_help() );\n        return;\n    }\n\n    my ($opts, $name, $help);\n    my $no_register;\n\n    if ('HASH' eq ref $_[0]) {\n        ($opts, $name, $help) = @_;\n        $GreetWithCommand = $opts->{GreetWithCommand}\n                             if exists $opts->{GreetWithCommand};\n        $GreetWithSub = $opts->{GreetWithSub}\n                             if exists $opts->{GreetWithSub};\n        $DefaultCommand = $opts->{DefaultCommand}\n                             if exists $opts->{DefaultCommand};\n        $ShellPrompt = $opts->{ShellPrompt}\n                             if exists $opts->{ShellPrompt};\n\n        $c->debug(sprintf'shell_options '\n                    . '$GreetWithCommand   = %s, '\n                    . '$GreetWithSub       = %s, '\n                    . '$ShellPrompt        = %s, '\n                    . '$DefaultCommand     = %s. also '\n                    . '$name = %s, $help = %s',\n                    map defined $_ ? $_ : '(not defined)',\n                        $GreetWithCommand,\n                        $GreetWithSub,\n                        $ShellPrompt,\n                        $DefaultCommand,\n                        $name, $help\n        );\n\n        $no_register = 1\n            if @_ >= 2 and not defined $name;\n    }\n    else {\n        ($name, $help) = @_;\n        $no_register = 1\n            if @_ >= 1 and not defined $name;\n    }\n\n    if ($no_register) { \n        $c->debug(\"not registering shell as a command since \\$name was passed as undef\");\n    }\n    else {\n        $name = _shell_command() if not defined $name;\n        $help = _shell_help()    if not defined $help;\n        \n\n        $c->debug(\"registering shell as '$name' => '$help'\");\n        $c->register( $name => \\&shell, $help );\n    }\n}\n\n\n# this is printed when your shell first starts, it will optionally run a command,\n# then optionally run a sub\n# again, you can do both, but that's likely to be unhelpful\nsub _welcome {\n    my $c = shift;\n    $c->stash->{shelllvl} ++;\n\n    do {\n        local $c->{'cmd'} = $GreetWithCommand; \n        $c->execute();\n    } if defined $GreetWithCommand; \n\n    $c->$GreetWithSub() if defined $GreetWithSub;\n\n} \n\nsub shell {\n    my $c = shift;\n    $c->stash->{shelllvl} ++;\n    {no warnings qw[ redefine ];\n    *App::Rad::Help::usage = sub { \n        \"Your app as a shell. Type commands with arguments\"\n    };}\n\n    \n    local $GreetWithCommand  = $GreetWithCommand ;\n    local $GreetWithSub      = $GreetWithSub     ;\n    local $DefaultCommand    = $DefaultCommand   ;\n\n    local $ShellPrompt       = $ShellPrompt      ;\n    local $still_going       = $still_going      ;\n\n    $c->shell_options(@_) if @_;\n\n    $c->register( 'exit', sub { \n        $App::Rad::Plugin::ReadLine::still_going = 0;\n    }, \"exit the $0 shell\" );\n\n    $c->unregister_command('shell');\n\n    my $welcome = \\&_welcome;\n    $c->$welcome();\n\n    while($still_going) {\n        (my $cmd, local @ARGV) = split  ' ',\n        _terminal->get_reply(\n              prompt => _shell_prompt(),\n              default => $DefaultCommand,\n        );\n        if (defined $cmd and $cmd ne '') { \n            @{$c->argv} = @ARGV;\n            $c->{'cmd'} = $cmd;\n\n            $c->debug('received command: ' . $c->{'cmd'});\n            $c->debug('received parameters: ' . join (' ', @{$c->argv} ));\n        }\n        $c->_tinygetopt();\n        $c->execute();\n    }\n}\n\n\n\"Say my name\"\n\n__END__\n\n",
      "file" : "/var/tmp/arv_YxV1DJ/App-Rad-Plugin-ReadLine-0.002/lib/App/Rad/Plugin/ReadLine.pm",
      "package" : "App::Rad::Plugin::ReadLine"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub getopt \n{\n    my $c = shift;\n    use Data::Dumper;\n    Data::Dumper->Dump(\n        [ $c->options, $c->argv, \\@ARGV ],\n        [qw( $c->options $c->argv @ARGV)]\n    );\n}",
      "file" : "/var/tmp/arv_YxV1DJ/App-Rad-Plugin-ReadLine-0.002/lib/App/Rad/Plugin/ReadLine/Demo.pm",
      "package" : "App::Rad::Plugin::ReadLine::Demo"
   }
]
