[
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n    use strict;\n    use warnings;\n    use Scalar::Util qw[blessed weaken refaddr];\n    use List::Util qw[max];\n    use Time::HiRes;\n    use Socket qw[/inet_/ SOCK_STREAM SOCK_DGRAM SOL_SOCKET PF_INET SOMAXCONN\n        /pack_sockaddr_in/ SO_REUSEADDR];\n    use Carp qw[carp];\n    use Digest::SHA qw[sha1_hex];\n    use POSIX qw[];\n    sub _EWOULDBLOCK { $^O eq q[MSWin32] ? 10035 : POSIX::EWOULDBLOCK() }\n    sub _EINPROGRESS { $^O eq q[MSWin32] ? 10036 : POSIX::EINPROGRESS() }\n    use lib q[../../lib];\n    use Net::BitTorrent::Util qw[:bencode :compact];\n    use Net::BitTorrent::Torrent;\n    use Net::BitTorrent::Peer;\n    use Net::BitTorrent::DHT;\n    use Net::BitTorrent::Version;\n    use version qw[qv];\n    our $VERSION_BASE = 50; our $UNSTABLE_RELEASE = 0; our $VERSION = sprintf(($UNSTABLE_RELEASE ? q[%.3f_%03d] : q[%.3f]), (version->new(($VERSION_BASE))->numify / 1000), $UNSTABLE_RELEASE);\n    my (@CONTENTS) = \\my (\n        %_tcp,                  %_udp,\n        %_schedule,             %_tid,\n        %_event,                %torrents,\n        %_connections,          %peerid,\n        %_max_ul_rate,          %_k_ul,\n        %_max_dl_rate,          %_k_dl,\n        %_dht,                  %_use_dht,\n        %__UDP_OBJECT_CACHE,    %_peers_per_torrent,\n        %_connections_per_host, %_half_open,\n        %_encryption_mode\n    );\n    my %REGISTRY;\n    sub _MSE_DISABLED {0}\n    sub _MSE_ENABLED  {1}\n    sub _MSE_FORCED   {2}\n\n    sub new {\n        my ($class, $args) = @_;\n        my $self = bless \\$class, $class;\n        my ($host, @ports) = (q[0.0.0.0], (0));\n\n        $_max_ul_rate{refaddr $self}          = 0;\n        $_k_ul{refaddr $self}                 = 0;\n        $_max_dl_rate{refaddr $self}          = 0;\n        $_k_dl{refaddr $self}                 = 0;\n        $_peers_per_torrent{refaddr $self}    = 100;\n        $_half_open{refaddr $self}            = 8;\n        $_connections_per_host{refaddr $self} = 1;\n        $torrents{refaddr $self}              = {};\n        $_tid{refaddr $self}                  = qq[\\0] x 5;\n        $_use_dht{refaddr $self}              = 1;\n        $_encryption_mode{refaddr $self}      = _MSE_ENABLED;\n\n        $_connections{refaddr $self} = {};\n        $_schedule{refaddr $self}    = {};\n        $_dht{refaddr $self}   = Net::BitTorrent::DHT->new({Client => $self});\n        $peerid{refaddr $self} = Net::BitTorrent::Version::gen_peerid();\n        if (defined $args) {\n            if (ref($args) ne q[HASH]) {\n                carp q[Net::BitTorrent->new({}) requires ]\n                    . q[parameters to be passed as a hashref];\n                return;\n            }\n            $host = $args->{q[LocalHost]}\n                if defined $args->{q[LocalHost]};\n            @ports\n                = defined $args->{q[LocalPort]}\n                ? (ref($args->{q[LocalPort]}) eq q[ARRAY]\n                   ? @{$args->{q[LocalPort]}}\n                   : $args->{q[LocalPort]}\n                )\n                : @ports;\n        }\n\n        for my $port (@ports) {\n            last\n                if $self->_socket_open_tcp($host, $port)\n                    && $self->_socket_open_udp($host, $port);\n        }\n\n        $self->_reset_bandwidth;\n        weaken($REGISTRY{refaddr $self} = $self);\n        $$self = $peerid{refaddr $self};\n        return $self;\n    }\n\n    sub _tcp               { return $_tcp{refaddr +shift} }\n    sub _udp               { return $_udp{refaddr +shift} }\n    sub _connections       { return $_connections{refaddr +shift} }\n    sub _max_ul_rate       { return $_max_ul_rate{refaddr +shift} }\n    sub _max_dl_rate       { return $_max_dl_rate{refaddr +shift} }\n    sub _peers_per_torrent { return $_peers_per_torrent{refaddr +shift} }\n    sub _half_open         { return $_half_open{refaddr +shift} }\n\n    sub _connections_per_host {\n        return $_connections_per_host{refaddr +shift};\n    }\n    sub _dht { return $_dht{refaddr +shift} }\n\n    sub _use_dht {\n        my ($s) = @_;\n        return $_udp{refaddr $s} && $_use_dht{refaddr $s};\n    }\n\n    sub _tcp_port {\n        my ($self) = @_;\n        return if not defined $_tcp{refaddr $self};\n        my ($port, undef)\n            = unpack_sockaddr_in(getsockname($_tcp{refaddr $self}));\n        return $port;\n    }\n\n    sub _tcp_host {\n        my ($self) = @_;\n        return if not defined $_tcp{refaddr $self};\n        my (undef, $packed_ip)\n            = unpack_sockaddr_in(getsockname($_tcp{refaddr $self}));\n        return inet_ntoa($packed_ip);\n    }\n\n    sub _udp_port {\n        my ($self) = @_;\n        return if not defined $_udp{refaddr $self};\n        my ($port, undef)\n            = unpack_sockaddr_in(getsockname($_udp{refaddr $self}));\n        return $port;\n    }\n\n    sub _udp_host {\n        my ($self) = @_;\n        return if not defined $_udp{refaddr $self};\n        my (undef, $packed_ip)\n            = unpack_sockaddr_in(getsockname($_udp{refaddr $self}));\n        return inet_ntoa($packed_ip);\n    }\n\n    sub _encryption_mode {\n        my ($self) = @_;\n        return $_encryption_mode{refaddr $self};\n    }\n\n    sub _set_encryption_mode {\n        my ($self, $value) = @_;\n        if (not defined $value\n            or (    ($value != _MSE_DISABLED)\n                and ($value != _MSE_ENABLED)\n                and ($value != _MSE_FORCED))\n            )\n        {   carp\n                q[Net::BitTorrent->_set_encryption_mode( VALUE ) requires an integer value];\n            return;\n        }\n        return $_encryption_mode{refaddr $self} = $value;\n    }\n\n    sub _set_max_ul_rate {    \n        my ($self, $value) = @_;\n        if (not defined $value or $value !~ m[^\\d+$] or !$value) {\n            carp\n                q[Net::BitTorrent->_set_max_ul_rate( VALUE ) requires an integer value];\n            return;\n        }\n        return $_max_ul_rate{refaddr $self} = $value;\n    }\n\n    sub _set_max_dl_rate {    \n        my ($self, $value) = @_;\n        if (not defined $value or $value !~ m[^\\d+$]) {\n            carp\n                q[Net::BitTorrent->_set_max_dl_rate( VALUE ) requires an integer value];\n            return;\n        }\n        return $_max_dl_rate{refaddr $self} = $value;\n    }\n\n    sub _set_peers_per_torrent {\n        my ($self, $value) = @_;\n        if (not defined $value or $value !~ m[^\\d+$] or $value < 1) {\n            carp\n                q[Net::BitTorrent->_set_peers_per_torrent( VALUE ) requires an integer value];\n            return;\n        }\n        return $_peers_per_torrent{refaddr $self} = $value;\n    }\n\n    sub _set_half_open {\n        my ($self, $value) = @_;\n        if (not defined $value or $value !~ m[^\\d+$] or $value < 1) {\n            carp\n                q[Net::BitTorrent->_set_half_open( VALUE ) requires an integer value];\n            return;\n        }\n        return $_half_open{refaddr $self} = $value;\n    }\n\n    sub _set_connections_per_host {\n        my ($self, $value) = @_;\n        if (not defined $value or $value !~ m[^\\d+$] or $value < 1) {\n            carp\n                q[Net::BitTorrent->_set_connections_per_host( VALUE ) requires an integer value];\n            return;\n        }\n        return $_connections_per_host{refaddr $self} = $value;\n    }\n\n    sub _set_use_dht {\n        my ($self, $value) = @_;\n        if (not defined $value or $value !~ m[^[10]$]) {\n            carp\n                q[Net::BitTorrent->_set_use_dht( VALUE ) requires a bool value];\n            return;\n        }\n        return $_use_dht{refaddr $self} = $value;\n    }\n\n    sub peerid   { my ($self) = @_; return $peerid{refaddr $self} }\n    sub torrents { my ($self) = @_; return $torrents{refaddr $self} }\n\n    sub do_one_loop {\n        my ($self, $timeout) = @_;\n        $self->_process_schedule;\n        $timeout\n            = defined $timeout && $timeout =~ m[^(\\-1|\\d+)\\.?\\d*$]\n            ? $timeout < 0\n                ? undef\n                : $timeout\n            : 1;\n        my ($rin, $win, $ein) = (q[], q[], q[]);\n    PUSHSOCK: for my $fileno (keys %{$_connections{refaddr $self}}) {\n            vec($rin, $fileno, 1) = 1\n                if $_connections{refaddr $self}{$fileno}{q[Mode]} =~ m[r];\n            vec($win, $fileno, 1) = 1\n                if $_connections{refaddr $self}{$fileno}{q[Mode]} =~ m[w];\n            vec($ein, $fileno, 1) = 1;\n        }\n        my ($nfound, $timeleft) = select($rin, $win, $ein, $timeout);\n        $self->_process_connections(\\$rin, \\$win, \\$ein)\n            if $nfound and $nfound != -1;\n        return 1;\n    }\n\n    sub _reset_bandwidth {\n        my ($self) = @_;\n        $self->_schedule({Time   => time + 1,\n                          Code   => \\&_reset_bandwidth,\n                          Object => $self\n                         }\n        );\n\n        return $_k_dl{refaddr $_[0]} = $_k_ul{refaddr $_[0]} = 0;\n    }\n\n    sub _add_connection {\n        my ($self, $connection, $mode) = @_;\n        if (not defined $connection) {\n            carp q[Net::BitTorrent->_add_connection() requires an object];\n            return;\n        }\n        if (not blessed $connection) {\n            carp\n                q[Net::BitTorrent->_add_connection() requires a blessed object];\n            return;\n        }\n        my $_sock = $connection->_socket;\n        if ((not $_sock) or (ref($_sock) ne q[GLOB])) { return; }\n        if ((!$mode) || ($mode !~ m[^(?:ro|rw|wo)$])) {\n            carp\n                q[Net::BitTorrent->_add_connection(SOCKET, MODE) requires a mode parameter];\n            return;\n        }\n        return $_connections{refaddr $self}{fileno $_sock} = {\n                                                        Object => $connection,\n                                                        Mode   => $mode\n        };\n    }\n\n    sub _remove_connection {\n        my ($self, $connection) = @_;\n        if (not defined $connection) {\n            carp q[Net::BitTorrent->_remove_connection() requires an object];\n            return;\n        }\n        if (not blessed $connection) {\n            carp\n                q[Net::BitTorrent->_remove_connection() requires a blessed object];\n            return;\n        }\n        my $socket = $connection->_socket;\n        return if not defined $socket;\n        return delete $_connections{refaddr $self}{fileno $socket};\n    }\n\n    sub _socket_open_tcp {\n        my ($self, $host, $port) = @_;\n        if (   not $self\n            || not blessed $self\n            || not $self->isa(q[Net::BitTorrent]))\n        {   carp\n                q[Net::BitTorrent->_socket_open_tcp(HOST, PORT) requires a blessed object];\n            return;\n        }\n        if ((!$_tcp{refaddr $self}) && (!$host)) {\n            carp q[Net::BitTorrent::_socket_open_tcp( ) ]\n                . q[requires a hostname];\n            return;\n        }\n        if (defined $port and $port !~ m[^\\d+$]) {\n            carp q[Net::BitTorrent::_socket_open_tcp( ) ]\n                . q[requires an integer port number];\n            return;\n        }\n        my $_packed_host = undef;\n        $host ||= q[0.0.0.0];\n        $port ||= 0;\n        $port =~ m[^(\\d+)$];\n        $port = $1;\n        if (    $host\n            and $host\n            !~ m[^(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.]?){4})$])\n        {   my ($name, $aliases, $addrtype, $length, @addrs)\n                = gethostbyname($host)\n                or return;\n            $_packed_host = $addrs[0];\n        }\n        else { $_packed_host = inet_aton($host) }\n        socket(my ($_tcp), PF_INET, SOCK_STREAM, getprotobyname(q[tcp]))\n            or return;\n\n        bind($_tcp, pack_sockaddr_in($port, $_packed_host))\n            or return;\n        listen($_tcp, 1) or return;\n        $_connections{refaddr $self}{fileno $_tcp} = {Object => $self,\n                                                      Mode   => q[ro],\n            }\n            or return;\n        if (   defined $_tcp{refaddr $self}\n            && fileno $_tcp{refaddr $self}\n            && defined $_connections{refaddr $self}\n            {fileno $_tcp{refaddr $self}})\n        {   delete $_connections{refaddr $self}{fileno $_tcp{refaddr $self}};\n            close $_tcp{refaddr $self};\n        }\n        return $_tcp{refaddr $self} = $_tcp;\n    }\n\n    sub _socket_open_udp {\n        my ($self, $host, $port) = @_;\n        if (   not $self\n            || not blessed $self\n            || not $self->isa(q[Net::BitTorrent]))\n        {   carp\n                q[Net::BitTorrent->_socket_open_udp(HOST, PORT) requires a blessed object];\n            return;\n        }\n        if ((!$_tcp{refaddr $self}) && (!$host)) {\n            carp q[Net::BitTorrent::_socket_open_udp( ) ]\n                . q[requires a hostname];\n            return;\n        }\n        if (defined $port and $port !~ m[^\\d+$]) {\n            carp q[Net::BitTorrent::_socket_open_udp( ) ]\n                . q[requires an integer port number];\n            return;\n        }\n        my $_packed_host = undef;\n        $host ||= q[0.0.0.0];\n\n        $port ||= 0;\n        $port =~ m[^(\\d+)$];\n        $port = $1;\n        if (    $host\n            and $host\n            !~ m[^(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.]?){4})$])\n        {   my ($name, $aliases, $addrtype, $length, @addrs)\n                = gethostbyname($host)\n                or return;\n            $_packed_host = $addrs[0];\n        }\n        else { $_packed_host = inet_aton($host) }\n        socket(my ($_udp), PF_INET, SOCK_DGRAM, getprotobyname(q[udp]))\n            or return;\n\n        bind($_udp, pack_sockaddr_in($port, $_packed_host))\n            or return;\n        $_connections{refaddr $self}{fileno $_udp} = {Object => $self,\n                                                      Mode   => q[ro],\n            }\n            or return;\n        if (   $_udp{refaddr $self}\n            && fileno $_udp{refaddr $self}\n            && defined $_connections{refaddr $self}\n            {fileno $_udp{refaddr $self}})\n        {   delete $_connections{refaddr $self}{fileno $_udp{refaddr $self}};\n            close $_udp{refaddr $self};\n        }\n        return $_udp{refaddr $self} = $_udp;\n    }\n\n    sub _process_connections {\n        my ($self, $rin, $win, $ein) = @_;\n        if (!(     ($rin and ref $rin and ref $rin eq q[SCALAR])\n               and ($win and ref $win and ref $win eq q[SCALAR])\n               and ($ein and ref $ein and ref $ein eq q[SCALAR])\n            )\n            )\n        {   carp\n                q[Malformed parameters to Net::BitTorrent::_process_connections(RIN, WIN, EIN)];\n            return;\n        }\n    POPSOCK: foreach my $fileno (keys %{$_connections{refaddr $self}}) {\n            next POPSOCK unless defined $_connections{refaddr $self}{$fileno};\n            if (   $_tcp{refaddr $self}\n                && $fileno == fileno $_tcp{refaddr $self})\n            {   if (vec($$rin, $fileno, 1) == 1) {\n                    vec($$rin, $fileno, 1) = 0;\n                    if (scalar(\n                            grep {\n                                $_->{q[Object]}->isa(q[Net::BitTorrent::Peer])\n                                    && !$_->{q[Object]}->torrent\n                                } values %{$_connections{refaddr $self}}\n                        ) < $_half_open{refaddr $self}\n                        )\n                    {   accept(my ($new_socket), $_tcp{refaddr $self})\n                            or next POPSOCK;\n                        Net::BitTorrent::Peer->new({Socket => $new_socket,\n                                                    Client => $self\n                                                   }\n                        );\n                    }\n                }\n            }\n            elsif (   $_udp{refaddr $self}\n                   && $fileno == fileno $_udp{refaddr $self})\n            {   if (vec($$rin, $fileno, 1) == 1) {\n                    vec($$rin, $fileno, 1) = 0;\n                    my $paddr\n                        = recv($_udp{refaddr $self}, my ($data), 1024, 0)\n                        or next POPSOCK;\n                    if ($__UDP_OBJECT_CACHE{refaddr $self}{$paddr}{q[Object]})\n                    {   $__UDP_OBJECT_CACHE{refaddr $self}{$paddr}{q[Object]}\n                            ->_on_data($paddr, $data)\n                            or\n                            delete $__UDP_OBJECT_CACHE{refaddr $self}{$paddr}\n                            {q[Object]};\n                        next POPSOCK;\n                    }\n                    else {\n                        for my $_tor (values %{$torrents{refaddr $self}}) {\n                            for my $_tier (@{$_tor->trackers}) {\n                                my ($tracker) = grep {\n                                    $_->isa(\n                                        q[Net::BitTorrent::Torrent::Tracker::UDP]\n                                        )\n                                        and $_->_packed_host eq $paddr\n                                } @{$_tier->urls};\n                                if (   $tracker\n                                    && $tracker->_on_data($paddr, $data))\n                                {   $__UDP_OBJECT_CACHE{refaddr $self}{$paddr}\n                                        = {Object => $tracker};\n                                    weaken($__UDP_OBJECT_CACHE{refaddr $self}\n                                           {$paddr}{q[Object]});\n                                    next POPSOCK;\n                                }\n                            }\n                        }\n                    }\n                    if (   $_use_dht{refaddr $self}\n                        && $_dht{refaddr $self}->_on_data($paddr, $data))\n                    {   $__UDP_OBJECT_CACHE{refaddr $self}{$paddr}\n                            = {Object => $_dht{refaddr $self}};\n                        weaken($__UDP_OBJECT_CACHE{refaddr $self}{$paddr}\n                               {q[Object]});\n                    }\n                    next POPSOCK;\n                }\n            }\n            else {\n                my $read = (($_max_dl_rate{refaddr $self}\n                             ? max(0,\n                                   (      $_max_dl_rate{refaddr $self}\n                                        - $_k_dl{refaddr $self}\n                                   )\n                                 )\n                             : (2**15)\n                            ) * vec($$rin, $fileno, 1)\n                );\n                my $write = (($_max_ul_rate{refaddr $self}\n                              ? max(0,\n                                    (      $_max_ul_rate{refaddr $self}\n                                         - $_k_ul{refaddr $self}\n                                    )\n                                  )\n                              : (2**15)\n                             ) * vec($$win, $fileno, 1)\n                );\n                my $error = vec($$ein, $fileno, 1)\n                    && (   $^E\n                        && ($^E != _EINPROGRESS)\n                        && ($^E != _EWOULDBLOCK));\n                if ($read || $write || $error) {\n                    my ($this_r, $this_w)\n                        = $_connections{refaddr $self}{$fileno}{q[Object]}\n                        ->_rw($read, $write, $error);\n                    $_k_dl{refaddr $self} += defined $this_r ? $this_r : 0;\n                    $_k_ul{refaddr $self} += defined $this_w ? $this_w : 0;\n                    vec($$rin, $fileno, 1) = 0;\n                    vec($$win, $fileno, 1) = 0;\n                    vec($$ein, $fileno, 1) = 0;\n                }\n            }\n        }\n        return 1;\n    }\n\n    sub _locate_torrent {\n        my ($self, $infohash) = @_;\n        carp q[Bad infohash for Net::BitTorrent->_locate_torrent(INFOHASH)]\n            && return\n            if $infohash !~ m[^[\\d|a-f]{40}$]i;\n        return $torrents{refaddr $self}{lc $infohash}\n            ? $torrents{refaddr $self}{lc $infohash}\n            : undef;\n    }\n\n    sub add_torrent {\n        my ($self, $args) = @_;\n        if (ref($args) ne q[HASH]) {\n            carp\n                q[Net::BitTorrent->add_torrent() requires params passed as a hash ref];\n            return;\n        }\n        $args->{q[Client]} = $self;\n        my $torrent = Net::BitTorrent::Torrent->new($args);\n        return if not defined $torrent;\n        return if $self->_locate_torrent($torrent->infohash);\n        return $torrents{refaddr $self}{$torrent->infohash} = $torrent;\n    }\n\n    sub remove_torrent {\n        my ($self, $torrent) = @_;\n        if (   not blessed($torrent)\n            or not $torrent->isa(q[Net::BitTorrent::Torrent]))\n        {   carp\n                q[Net::BitTorrent->remove_torrent(TORRENT) requires a blessed Net::BitTorrent::Torrent object];\n            return;\n        }\n        for my $_peer ($torrent->peers) {\n            $_peer->_disconnect(\n                              q[Removing .torrent torrent from local client]);\n        }\n        $torrent->stop;    \n        return delete $torrents{refaddr $self}{$torrent->infohash};\n    }\n\n    sub on_event {\n        my ($self, $type, $method) = @_;\n        carp sprintf q[Unknown callback: %s], $type\n            unless ___check_event($type);\n        $_event{refaddr $self}{$type} = $method;\n    }\n\n    sub _event {\n        my ($self, $type, $args) = @_;\n        carp sprintf\n            q[Unknown event: %s. This is a bug in Net::BitTorrent; Report it.],\n            $type\n            unless ___check_event($type);\n        return $_event{refaddr $self}{$type}\n            ? $_event{refaddr $self}{$type}($self, $args)\n            : ();\n    }\n\n    sub ___check_event {\n        my $type = shift;\n        return scalar grep { $_ eq $type } qw[\n            ip_filter\n            incoming_packet outgoing_packet\n            peer_connect    peer_disconnect\n            peer_read       peer_write\n            tracker_connect tracker_disconnect\n            tracker_read    tracker_write\n            tracker_success tracker_failure\n            piece_hash_pass piece_hash_fail\n            file_open       file_close\n            file_read       file_write\n            file_error\n        ];\n    }\n\n    sub _schedule {\n        my ($self, $args) = @_;\n        if ((!$args) || (ref $args ne q[HASH])) {\n            carp\n                q[Net::BitTorrent->_schedule() requires params to be passed as a HashRef];\n            return;\n        }\n        if ((!$args->{q[Object]}) || (!blessed $args->{q[Object]})) {\n            carp\n                q[Net::BitTorrent->_schedule() requires a blessed 'Object' parameter];\n            return;\n        }\n        if ((!$args->{q[Time]}) || ($args->{q[Time]} !~ m[^\\d+(?:\\.\\d+)?$])) {\n            carp\n                q[Net::BitTorrent->_schedule() requires an integer or float 'Time' parameter];\n            return;\n        }\n        if ((!$args->{q[Code]}) || (ref $args->{q[Code]} ne q[CODE])) {\n            carp q[Net::BitTorrent->_schedule() requires a 'Code' parameter];\n            return;\n        }\n        my $tid = $self->_generate_token_id();\n        $_schedule{refaddr $self}{$tid} = {Timestamp => $args->{q[Time]},\n                                           Code      => $args->{q[Code]},\n                                           Object    => $args->{q[Object]}\n        };\n        weaken $_schedule{refaddr $self}{$tid}{q[Object]};\n        return $tid;\n    }\n\n    sub _cancel {\n        my ($self, $tid) = @_;\n        if (!$tid) {\n            carp q[Net::BitTorrent->_cancel( TID ) requires an ID];\n            return;\n        }\n        if (!$_schedule{refaddr $self}{$tid}) {\n            carp sprintf\n                q[Net::BitTorrent->_cancel( TID ) cannot find an event with TID == %s],\n                $tid;\n            return;\n        }\n        return delete $_schedule{refaddr $self}{$tid};\n    }\n\n    sub _process_schedule {\n        my ($self) = @_;\n        for my $job (keys %{$_schedule{refaddr $self}}) {\n            if ($_schedule{refaddr $self}{$job}->{q[Timestamp]} <= time) {\n                &{$_schedule{refaddr $self}{$job}->{q[Code]}}(\n                                 $_schedule{refaddr $self}{$job}->{q[Object]})\n                    if defined $_schedule{refaddr $self}{$job}->{q[Object]};\n                delete $_schedule{refaddr $self}{$job};\n            }\n        }\n        return 1;\n    }\n\n    sub _generate_token_id {\n        return if defined $_[1];\n        my ($self) = @_;\n        $_tid{refaddr $self} ||= qq[\\0] x 4;\n        my ($len) = ($_tid{refaddr $self} =~ m[^([a-z]+)]);\n        $_tid{refaddr $self} = (\n                   ($_tid{refaddr $self} =~ m[^z*(\\0*)$])\n                   ? ($_tid{refaddr $self} =~ m[\\0]\n                      ? pack(q[a] . (length $_tid{refaddr $self}),\n                             (q[a] x (length($len || q[]) + 1))\n                          )\n                      : (q[a] . (qq[\\0] x (length($_tid{refaddr $self}) - 1)))\n                       )\n                   : ++$_tid{refaddr $self}\n        );\n        return $_tid{refaddr $self};\n    }\n\n    sub _build_reserved {\n        my ($self) = @_;\n        my @reserved = qw[0 0 0 0 0 0 0 0];\n        $reserved[5] |= 0x10;    \n        $reserved[7] |= 0x04;    \n        return join q[], map {chr} @reserved;\n    }\n\n    sub as_string {\n        my ($self, $advanced) = @_;\n        my $dump\n            = !$advanced ? $peerid{refaddr $self} : sprintf <<'END',\n            $peerid{refaddr $self},\n            $_use_dht{refaddr $self} ? q[En] : q[Dis],\n            unpack(q[H*], $_dht{refaddr $self}->node_id),\n            $self->_tcp_host, $self->_tcp_port, $self->_udp_host,\n            $self->_udp_port, (scalar keys %{$torrents{refaddr $self}}), join(\n            qq[\\r\\n],\n            map {\n                sprintf q[%40s (%d: %s)], $_->infohash, $_->status,\n                    $_->_status_as_string()\n                } values %{$torrents{refaddr $self}}\n            );\n        return defined wantarray ? $dump : print STDERR qq[$dump\\n];\n    }\n\n    sub CLONE {\n        for my $_oID (keys %REGISTRY) {\n            my $_obj = $REGISTRY{$_oID};\n            my $_nID = refaddr $_obj;\n            for (@CONTENTS) {\n                $_->{$_nID} = $_->{$_oID};\n                delete $_->{$_oID};\n            }\n            delete $_schedule{$_nID};\n            weaken($REGISTRY{$_nID} = $_obj);\n            delete $REGISTRY{$_oID};\n        }\n        return 1;\n    }\n    DESTROY {\n        my ($self) = @_;\n        close($_tcp{refaddr $self}) if $_tcp{refaddr $self};\n        close($_udp{refaddr $self}) if $_udp{refaddr $self};\n        foreach my $conn (values %{$_connections{refaddr $self}}) {\n            close($conn->{q[Object]}->_socket) if $conn->{q[Object]};\n        }\n        for (@CONTENTS) { delete $_->{refaddr $self}; }\n        return delete $REGISTRY{refaddr $self};\n    }\n    1;\n}",
      "file" : "/var/tmp/arv_xkFB3e/Net-BitTorrent-0.052/lib/Net/BitTorrent.pm",
      "package" : "Net::BitTorrent"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n    use strict;\n    use warnings;\n    use Carp qw[carp];\n    use List::Util qw[min max shuffle sum];\n    use version qw[qv];\n    our $VERSION_BASE = 50; our $UNSTABLE_RELEASE = 0; our $VERSION = sprintf(($UNSTABLE_RELEASE ? q[%.3f_%03d] : q[%.3f]), (version->new(($VERSION_BASE))->numify / 1000), $UNSTABLE_RELEASE);\n    use vars qw[@EXPORT_OK %EXPORT_TAGS];\n    use Exporter qw[];\n    *import = *import = *Exporter::import;\n    @EXPORT_OK = qw[bencode bdecode compact uncompact];\n    %EXPORT_TAGS = (all     => [@EXPORT_OK],\n                    bencode => [qw[bencode bdecode]],\n                    compact => [qw[compact uncompact]],\n    );\n\n    sub bencode {\n        my ($ref) = @_;\n        $ref = defined $ref ? $ref : q[];\n        if (not ref $ref) {\n            return (  (defined $ref and $ref =~ m[^[-+]?\\d+$])\n                    ? (q[i] . $ref . q[e])\n                    : (length($ref) . q[:] . $ref)\n            );\n        }\n        elsif (ref $ref eq q[ARRAY]) {\n            return join(q[], q[l], (map { bencode($_) } @{$ref}), q[e]);\n        }\n        elsif (ref $ref eq q[HASH]) {\n            return\n                join(q[], q[d],\n                     (map { bencode($_) . bencode($ref->{$_}) }\n                      sort keys %{$ref}\n                     ),\n                     q[e]\n                );\n        }\n        return q[];\n    }\n\n    sub bdecode {\n        my ($string) = @_;\n        return if not defined $string;\n        my ($return, $leftover);\n        if (   $string =~ m[^([1-9]\\d*):]s\n            or $string =~ m[^(0+):]s)\n        {   my $size = $1;\n            $return = q[] if $1 =~ m[^0+$];\n            $string =~ s|^$size:||s;\n            while ($size) {\n                my $this_time = min($size, 32766);\n                $string =~ s|^(.{$this_time})||s;\n                return if not $1;\n                $return .= $1;\n                $size = max(0, ($size - $this_time));\n            }\n            return wantarray ? ($return, $string) : $return;    \n        }\n        elsif ($string =~ s|^i([-+]?\\d+)e||s) {                 \n            return wantarray ? (int($1), $string) : int($1);\n        }\n        elsif ($string =~ s|^l(.*)||s) {                        \n            $leftover = $1;\n            while ($leftover and $leftover !~ s|^e||s) {\n                (my ($piece), $leftover) = bdecode($leftover);\n                push @$return, $piece;\n            }\n            return wantarray ? (\\@$return, $leftover) : \\@$return;\n        }\n        elsif ($string =~ s|^d(.*)||s) {                        \n            $leftover = $1;\n            while ($leftover and $leftover !~ s|^e||s) {\n                my ($key, $value);\n                ($key, $leftover) = bdecode($leftover);\n                ($value, $leftover) = bdecode($leftover) if $leftover;\n                $return->{$key} = $value if defined $key;\n            }\n            return wantarray ? (\\%$return, $leftover) : \\%$return;\n        }\n        return;\n    }\n\n    sub compact {\n        my (@peers) = @_;\n        if (not @peers) {return}\n        my $return;\n        my %seen;\n    PEER: for my $peer (grep(defined && !$seen{$_}++, @peers)) {\n            next if not $peer;\n            my ($ip, $port) = split(q[:], $peer, 2);\n            if ($peer\n                !~ m[^(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.]?){4}):\\d+$]\n                )\n            {   carp q[Invalid IP address: ] . $peer;\n            }\n            elsif ($port > 2**16) {\n                carp q[Port number beyond ephemeral range: ] . $peer;\n            }\n            else {\n                $return .= pack q[C4n],\n                    ($ip =~ m[^([\\d]+)\\.([\\d]+)\\.([\\d]+)\\.([\\d]+)$]),\n                    int $port;\n            }\n        }\n        return $return;\n    }\n\n    sub uncompact {\n        my $string = shift;\n        if (not defined $string) { return; }\n        my %peers;\n        while ($string =~ m|(....)(..)|g) {\n            $peers{\n                sprintf(q[%d.%d.%d.%d:%d],\n                        unpack(q[C4], $1),\n                        unpack(q[n],  $2))\n                }++;\n        }\n        return (shuffle(%peers ? keys %peers : ()));\n    }\n    1;\n}",
      "file" : "/var/tmp/arv_xkFB3e/Net-BitTorrent-0.052/lib/Net/BitTorrent/Util.pm",
      "package" : "Net::BitTorrent::Util"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n    use strict;\n    use warnings;\n    use version qw[qv];\n    our $VERSION_BASE = 52; our $UNSTABLE_RELEASE = 0; our $VERSION = sprintf(($UNSTABLE_RELEASE ? q[%.3f_%03d] : q[%.3f]), (version->new(($VERSION_BASE))->numify / 1000), $UNSTABLE_RELEASE);\n    our $PRODUCT_TOKEN = qq[Net::BitTorrent $VERSION];\n\n    sub gen_peerid {\n        return pack(\n            q[a20],\n            (sprintf(\n                 q[NB%03d%1s-%8s%5s],\n                 $VERSION_BASE,\n                 ($UNSTABLE_RELEASE ? q[U] : q[S]),\n                 (join q[],\n                  map {\n                      [q[A] .. q[Z], q[a] .. q[z], 0 .. 9, qw[- . _ ~]]\n                      ->[rand(66)]\n                      } 1 .. 8\n                 ),\n                 q[Riana]\n             )\n            )\n        );\n    }\n\n    sub gen_node_id {\n        return pack(q[H40], join(q[], map { rand(12) } 1 .. 40));\n    }\n    1;\n}",
      "file" : "/var/tmp/arv_xkFB3e/Net-BitTorrent-0.052/lib/Net/BitTorrent/Version.pm",
      "package" : "Net::BitTorrent::Version"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n    use strict;\n    use warnings;\n    use Carp qw[carp];\n    use lib q[../../../lib];\n    use Net::BitTorrent::Util qw[:bencode];\n    use version qw[qv];\n    our $VERSION_BASE = 50; our $UNSTABLE_RELEASE = 0; our $VERSION = sprintf(($UNSTABLE_RELEASE ? q[%.3f_%03d] : q[%.3f]), (version->new(($VERSION_BASE))->numify / 1000), $UNSTABLE_RELEASE);\n    use vars qw[@EXPORT_OK %EXPORT_TAGS];\n    use Exporter qw[];\n    *import = *import = *Exporter::import;\n    @EXPORT_OK = qw[build_handshake build_keepalive build_choke build_unchoke\n        build_interested  build_not_interested build_have build_bitfield\n        build_request build_piece build_cancel build_port build_suggest\n        build_allowed_fast build_reject build_have_all build_have_none\n        build_extended parse_packet _parse_handshake _parse_keepalive\n        _parse_choke _parse_unchoke _parse_interested _parse_not_interested\n        _parse_have _parse_bitfield _parse_request _parse_piece _parse_cancel\n        _parse_port _parse_suggest _parse_have_all _parse_have_none\n        _parse_reject _parse_allowed_fast _parse_extended HANDSHAKE KEEPALIVE\n        CHOKE UNCHOKE INTERESTED NOT_INTERESTED HAVE BITFIELD REQUEST PIECE\n        CANCEL PORT SUGGEST HAVE_ALL HAVE_NONE REJECT ALLOWED_FAST EXTPROTOCOL\n        _build_dht_reply_get_peers _build_dht_query_get_peers\n        _build_dht_reply_values    _build_dht_query_announce\n        _build_dht_reply_ping      _build_dht_query_ping\n        _build_dht_reply_find_node _build_dht_query_find_node];\n    %EXPORT_TAGS = (\n        all   => [@EXPORT_OK],\n        build => [\n            qw[build_handshake build_keepalive build_choke build_unchoke\n                build_interested  build_not_interested build_have\n                build_bitfield build_request build_piece build_cancel\n                build_port build_suggest build_allowed_fast build_reject\n                build_have_all build_have_none build_extended]\n        ],\n        parse => [\n            qw[parse_packet _parse_handshake _parse_keepalive\n                _parse_choke _parse_unchoke _parse_interested\n                _parse_not_interested _parse_have _parse_bitfield\n                _parse_request _parse_piece _parse_cancel _parse_port\n                _parse_suggest _parse_have_all _parse_have_none\n                _parse_reject _parse_allowed_fast _parse_extended]\n        ],\n        types => [\n            qw[HANDSHAKE KEEPALIVE CHOKE UNCHOKE INTERESTED NOT_INTERESTED\n                HAVE BITFIELD REQUEST PIECE CANCEL PORT SUGGEST HAVE_ALL\n                HAVE_NONE REJECT ALLOWED_FAST EXTPROTOCOL]\n        ],\n        dht => [\n            qw[_build_dht_reply_get_peers _build_dht_query_get_peers\n                _build_dht_reply_values    _build_dht_query_announce\n                _build_dht_reply_ping      _build_dht_query_ping\n                _build_dht_reply_find_node _build_dht_query_find_node]\n        ],\n\n    );\n    sub HANDSHAKE      {-1}\n    sub KEEPALIVE      {q[]}\n    sub CHOKE          {0}\n    sub UNCHOKE        {1}\n    sub INTERESTED     {2}\n    sub NOT_INTERESTED {3}\n    sub HAVE           {4}\n    sub BITFIELD       {5}\n    sub REQUEST        {6}\n    sub PIECE          {7}\n    sub CANCEL         {8}\n    sub PORT           {9}\n    sub SUGGEST        {13}\n    sub HAVE_ALL       {14}\n    sub HAVE_NONE      {15}\n    sub REJECT         {16}\n    sub ALLOWED_FAST   {17}\n    sub EXTPROTOCOL    {20}\n\n    sub build_handshake {\n        my ($reserved, $infohash, $peerid) = @_;\n        if (   (grep { not defined } @_[0 .. 2])\n            || (length($reserved) != 8)\n            || (length($infohash) != 20)\n            || (length($peerid) != 20))\n        {   carp\n                q[Malformed parameters for Net::BitTorrent::Protocol::build_handshake()];\n            return;\n        }\n        return\n            pack(q[c/a* a8 a20 a20],\n                 q[BitTorrent protocol],\n                 $reserved, $infohash, $peerid);\n    }\n    sub build_keepalive      { return pack(q[N],  0); }\n    sub build_choke          { return pack(q[Nc], 1, 0); }\n    sub build_unchoke        { return pack(q[Nc], 1, 1); }\n    sub build_interested     { return pack(q[Nc], 1, 2); }\n    sub build_not_interested { return pack(q[Nc], 1, 3); }\n\n    sub build_have {\n        my ($index) = @_;\n        if ((!defined $index) || ($index !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_have() requires an integer index parameter];\n            return;\n        }\n        return pack(q[NcN], 5, 4, $index);\n    }\n\n    sub build_bitfield {\n        my ($bitfield) = @_;\n        if ((!$bitfield) || (unpack(q[b*], $bitfield) !~ m[^[01]+$])) {\n            carp\n                q[Malformed bitfield passed to Net::BitTorrent::Protocol::build_bitfield()];\n            return;\n        }\n        return pack(q[Nca*], (length($bitfield) + 1), 5, $bitfield);\n    }\n\n    sub build_request {\n        my ($index, $offset, $length) = @_;\n        if ((!defined $index) || ($index !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_request() requires an integer index parameter];\n            return;\n        }\n        if ((!defined $offset) || ($offset !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_request() requires an offset parameter];\n            return;\n        }\n        if ((!defined $length) || ($length !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_request() requires an length parameter];\n            return;\n        }\n        my $packed = pack(q[NNN], $index, $offset, $length);\n        return pack(q[Nca*], length($packed) + 1, 6, $packed);\n    }\n\n    sub build_piece {\n        my ($index, $offset, $data) = @_;\n        if ((!defined $index) || ($index !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_piece() requires an index parameter];\n            return;\n        }\n        if ((!defined $offset) || ($offset !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_piece() requires an offset parameter];\n            return;\n        }\n        if (!$data or !$$data) {\n            carp\n                q[Net::BitTorrent::Protocol::build_piece() requires data to work with];\n            return;\n        }\n        my $packed = pack(q[N2a*], $index, $offset, $$data);\n        return pack(q[Nca*], length($packed) + 1, 7, $packed);\n    }\n\n    sub build_cancel {\n        my ($index, $offset, $length) = @_;\n        if ((!defined $index) || ($index !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_cancel() requires an integer index parameter];\n            return;\n        }\n        if ((!defined $offset) || ($offset !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_cancel() requires an offset parameter];\n            return;\n        }\n        if ((!defined $length) || ($length !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_cancel() requires an length parameter];\n            return;\n        }\n        my $packed = pack(q[N3], $index, $offset, $length);\n        return pack(q[Nca*], length($packed) + 1, 8, $packed);\n    }\n\n    sub build_port {\n        my ($port) = @_;\n        if ((!defined $port) || ($port !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_port() requires an index parameter];\n            return;\n        }\n        return pack(q[NcN], length($port) + 1, 9, $port);\n    }\n\n    sub build_suggest {\n        my ($index) = @_;\n        if ((!defined $index) || ($index !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_suggest() requires an index parameter];\n            return;\n        }\n        return pack(q[NcN], 5, 13, $index);\n    }\n    sub build_have_all  { return pack(q[Nc], 1, 14); }\n    sub build_have_none { return pack(q[Nc], 1, 15); }\n\n    sub build_reject {\n        my ($index, $offset, $length) = @_;\n        if ((!defined $index) || ($index !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_reject() requires an index parameter];\n            return;\n        }\n        if ((!defined $offset) || ($offset !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_reject() requires an offset parameter];\n            return;\n        }\n        if ((!defined $length) || ($length !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_reject() requires an length parameter];\n            return;\n        }\n        my $packed = pack(q[N3], $index, $offset, $length);\n        return pack(q[Nca*], length($packed) + 1, 16, $packed);\n    }\n\n    sub build_allowed_fast {\n        my ($index) = @_;\n        if ((!defined $index) || ($index !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_allowed_fast() requires an index parameter];\n            return;\n        }\n        return pack(q[NcN], 5, 17, $index);\n    }\n\n    sub build_extended {\n        my ($msgID, $data) = @_;\n        if ((!defined $msgID) || ($msgID !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_extended() requires a message id parameter];\n            return;\n        }\n        if ((!$data) || (ref($data) ne q[HASH])) {\n            carp\n                q[Net::BitTorrent::Protocol::build_extended() requires a payload];\n            return;\n        }\n        my $packet = pack(q[ca*], $msgID, bencode($data));\n        return pack(q[Nca*], length($packet) + 1, 20, $packet);\n    }\n    my %parse_packet_dispatch = (&KEEPALIVE      => \\&_parse_keepalive,\n                                 &CHOKE          => \\&_parse_choke,\n                                 &UNCHOKE        => \\&_parse_unchoke,\n                                 &INTERESTED     => \\&_parse_interested,\n                                 &NOT_INTERESTED => \\&_parse_not_interested,\n                                 &HAVE           => \\&_parse_have,\n                                 &BITFIELD       => \\&_parse_bitfield,\n                                 &REQUEST        => \\&_parse_request,\n                                 &PIECE          => \\&_parse_piece,\n                                 &CANCEL         => \\&_parse_cancel,\n                                 &PORT           => \\&_parse_port,\n                                 &SUGGEST        => \\&_parse_suggest,\n                                 &HAVE_ALL       => \\&_parse_have_all,\n                                 &HAVE_NONE      => \\&_parse_have_none,\n                                 &REJECT         => \\&_parse_reject,\n                                 &ALLOWED_FAST   => \\&_parse_allowed_fast,\n                                 &EXTPROTOCOL    => \\&_parse_extended\n    );\n\n    sub parse_packet {\n        my ($data) = @_;\n        if ((!$data) || (ref($data) ne q[SCALAR]) || (!$$data)) {\n            carp\n                q[Net::BitTorrent::Protocol::parse_packet() needs data to parse];\n            return;\n        }\n        my ($packet);\n        if (unpack(q[c], $$data) == 0x13) {\n            my @payload = _parse_handshake(substr($$data, 0, 68, q[]));\n            $packet = {Type    => HANDSHAKE,\n                       Payload => @payload\n                }\n                if @payload;\n        }\n        elsif (    (defined unpack(q[N], $$data))\n               and (unpack(q[N], $$data) =~ m[\\d]))\n        {   if ((unpack(q[N], $$data) <= length($$data))) {\n                (my ($packet_data), $$data) = unpack(q[N/aa*], $$data);\n                (my ($type), $packet_data) = unpack(q[ca*], $packet_data);\n                if (defined $parse_packet_dispatch{$type}) {\n                    my $payload = $parse_packet_dispatch{$type}($packet_data);\n                    $packet = {Type => $type,\n                               (defined $payload\n                                ? (Payload => $payload)\n                                : ()\n                               )\n                    };\n                }\n                elsif (eval q[require Data::Dump]) {\n                    carp\n                        sprintf\n                        <<'END', Data::Dump::pp($type), Data::Dump::pp($packet);\n                }\n            }\n        }\n        return $packet;\n    }\n\n    sub _parse_handshake {\n        my ($packet) = @_;\n        if (!$packet || (length($packet) < 68)) {\n\n            return;\n        }\n        my ($protocol_name, $reserved, $infohash, $peerid)\n            = unpack(q[c/a a8 a20 a20], $packet);\n        if ($protocol_name ne q[BitTorrent protocol]) {\n\n            return;\n        }\n        return [$reserved, $infohash, $peerid];\n    }\n    sub _parse_keepalive      { return; }\n    sub _parse_choke          { return; }\n    sub _parse_unchoke        { return; }\n    sub _parse_interested     { return; }\n    sub _parse_not_interested { return; }\n\n    sub _parse_have {\n        my ($packet) = @_;\n        if ((!$packet) || (length($packet) < 1)) {\n\n            return;\n        }\n        return unpack(q[N], $packet);\n    }\n\n    sub _parse_bitfield {\n        my ($packet) = @_;\n        if ((!$packet) || (length($packet) < 1)) {\n\n            return;\n        }\n        return (pack q[b*], unpack q[B*], $packet);\n    }\n\n    sub _parse_request {\n        my ($packet) = @_;\n        if ((!$packet) || (length($packet) < 9)) {\n\n            return;\n        }\n        return ([unpack(q[N3], $packet)]);\n    }\n\n    sub _parse_piece {\n        my ($packet) = @_;\n        if ((!$packet) || (length($packet) < 9)) {\n\n            return;\n        }\n        return ([unpack(q[N2a*], $packet)]);\n    }\n\n    sub _parse_cancel {\n        my ($packet) = @_;\n        if ((!$packet) || (length($packet) < 9)) {\n\n            return;\n        }\n        return ([unpack(q[N3], $packet)]);\n    }\n\n    sub _parse_port {\n        my ($packet) = @_;\n        if ((!$packet) || (length($packet) < 1)) {\n\n            return;\n        }\n        return (unpack q[N], $packet);\n    }\n\n    sub _parse_suggest {\n        my ($packet) = @_;\n        if ((!$packet) || (length($packet) < 1)) {\n\n            return;\n        }\n        return unpack(q[N], $packet);\n    }\n    sub _parse_have_all  { return; }\n    sub _parse_have_none { return; }\n\n    sub _parse_reject {\n        my ($packet) = @_;\n        if ((!$packet) || (length($packet) < 9)) {\n\n            return;\n        }\n        return ([unpack(q[N3], $packet)]);\n    }\n\n    sub _parse_allowed_fast {\n        my ($packet) = @_;\n        if ((!$packet) || (length($packet) < 1)) {\n\n            return;\n        }\n        return unpack(q[N], $packet);\n    }\n\n    sub _parse_extended {\n        my ($packet) = @_;\n        if ((!$packet) || (!length($packet))) { return; }\n        my ($id, $payload) = unpack(q[ca*], $packet);\n        return ([$id, scalar bdecode($payload)]);\n    }\n\n    sub _build_dht_query_ping {\n        my ($tid, $id) = @_;\n        if (!defined $tid) {\n            carp\n                q[Net::BitTorrent::Protocol::_build_dht_query_ping() requires a 'token id' parameter];\n            return;\n        }\n        if (!defined $id) {\n            carp\n                q[Net::BitTorrent::Protocol::_build_dht_query_ping() requires an 'client id' parameter];\n            return;\n        }\n        return\n            bencode({t => $tid,\n                     y => q[q],\n                     q => q[ping],\n                     a => {id => $id},\n                     v => q[NB00]\n                    }\n            );\n    }\n\n    sub _build_dht_query_announce {\n        my ($tid, $id, $infohash, $token, $port) = @_;\n        if (!defined $tid) {\n            carp\n                q[Net::BitTorrent::Protocol::_build_dht_query_announce() requires a 'token id' parameter];\n            return;\n        }\n        if (!defined $id) {\n            carp\n                q[Net::BitTorrent::Protocol::_build_dht_query_announce() requires an 'client id' parameter];\n            return;\n        }\n        if (!defined $token) {\n            carp\n                q[Net::BitTorrent::Protocol::_build_dht_query_announce() requires an 'token' parameter];\n            return;\n        }\n        if ((!defined $infohash) || (length($infohash) != 20)) {\n            carp\n                q[Net::BitTorrent::Protocol::_build_dht_query_announce() requires an 'infohash' parameter];\n            return;\n        }\n        if ((!defined $tid) || ($port !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Protocol::_build_dht_query_ping() requires a 'port' parameter];\n            return;\n        }\n        return\n            bencode({t => $tid,\n                     y => q[q],\n                     q => q[announce_peer],\n                     a => {id        => $id,\n                           port      => $port,\n                           info_hash => $infohash,\n                           token     => $token\n                     },\n                     v => q[NB00]\n                    }\n            );\n    }\n\n    sub _build_dht_query_find_node {\n        my ($tid, $id, $target) = @_;\n        if (!defined $tid) {\n            carp\n                q[Net::BitTorrent::Protocol::_build_dht_query_find_node() requires a 'token id' parameter];\n            return;\n        }\n        if (!defined $id) {\n            carp\n                q[Net::BitTorrent::Protocol::_build_dht_query_find_node() requires an 'client id' parameter];\n            return;\n        }\n        if ((!defined $target) || (length($target) != 20)) {\n            carp\n                q[Net::BitTorrent::Protocol::_build_dht_query_find_node() requires an 'target' parameter];\n            return;\n        }\n        return\n            bencode({t => $tid,\n                     y => q[q],\n                     q => q[find_node],\n                     a => {id     => $id,\n                           target => $target\n                     },\n                     v => q[NB00]\n                    }\n            );\n    }\n\n    sub _build_dht_query_get_peers {\n        my ($tid, $id, $info_hash) = @_;\n        if (!defined $tid) {\n            carp\n                q[Net::BitTorrent::Protocol::_build_dht_query_get_peers() requires a 'token id' parameter];\n            return;\n        }\n        if (!defined $id) {\n            carp\n                q[Net::BitTorrent::Protocol::_build_dht_query_get_peers() requires an 'client id' parameter];\n            return;\n        }\n        if ((!defined $info_hash) || (length($info_hash) != 20)) {\n            Carp::confess\n                q[Net::BitTorrent::Protocol::_build_dht_query_get_peers() requires an 'info_hash' parameter];\n            return;\n        }\n        return\n            bencode({t => $tid,\n                     y => q[q],\n                     q => q[get_peers],\n                     a => {id => $id, info_hash => $info_hash},\n                     v => q[NB00]\n                    }\n            );\n    }\n\n    sub _build_dht_reply_ping {\n        my ($tid, $id) = @_;\n        return bencode(\n                      {t => $tid, y => q[r], r => {id => $id}, v => q[NB00]});\n    }\n\n    sub _build_dht_reply_find_node {\n        my ($tid, $id, $nodes) = @_;\n        return\n            bencode({t => $tid,\n                     y => q[r],\n                     r => {id => $id, nodes => $nodes},\n                     v => q[NB00]\n                    }\n            );\n    }\n\n    sub _build_dht_reply_get_peers {\n        my ($tid, $id, $nodes, $token) = @_;\n        return\n            bencode({t => $tid,\n                     y => q[r],\n                     r => {id => $id, token => $token, nodes => $nodes},\n                     v => q[NB00]\n                    }\n            );\n    }\n\n    sub _build_dht_reply_values {\n        my ($tid, $id, $values, $token) = @_;\n        return\n            bencode({t => $tid,\n                     y => q[r],\n                     r => {id     => $id,\n                           token  => $token,\n                           values => $values\n                     },\n                     v => q[NB00]\n                    }\n            );\n    }\n    1;\n}",
      "file" : "/var/tmp/arv_xkFB3e/Net-BitTorrent-0.052/lib/Net/BitTorrent/Protocol.pm",
      "package" : "Net::BitTorrent::Protocol"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n    use strict;\n    use warnings;\n    use Digest::SHA qw[sha1_hex];\n    use Carp qw[carp carp];\n    use Cwd qw[cwd];\n    use File::Spec::Functions qw[rel2abs catfile];\n    use Scalar::Util qw[blessed weaken refaddr];\n    use List::Util qw[sum shuffle max min];\n    use Fcntl qw[/O_/ /SEEK/ :flock];\n    use vars qw[@EXPORT_OK %EXPORT_TAGS];\n    use Exporter qw[];\n    *import = *import = *Exporter::import;\n    @EXPORT_OK = qw[\n        STARTED CHECKING START_AFTER_CHECK CHECKED\n        ERROR   PAUSED   LOADED            QUEUED\n    ];\n    %EXPORT_TAGS = (status => [@EXPORT_OK], all => [@EXPORT_OK]);\n    use lib q[../../../lib];\n    use Net::BitTorrent::Util qw[:bencode :compact];\n    use Net::BitTorrent::Peer qw[];\n    use Net::BitTorrent::Torrent::File;\n    use Net::BitTorrent::Torrent::Tracker;\n    use version qw[qv];\n    our $VERSION_BASE = 51; our $UNSTABLE_RELEASE = 0; our $VERSION = sprintf(($UNSTABLE_RELEASE ? q[%.3f_%03d] : q[%.3f]), (version->new(($VERSION_BASE))->numify / 1000), $UNSTABLE_RELEASE);\n    my %REGISTRY = ();\n    my @CONTENTS = \\my (%_client,  %path,            %_basedir,\n                        %size,     %files,           %trackers,\n                        %infohash, %uploaded,        %downloaded,\n                        %bitfield, %_working_pieces, %_block_length,\n                        %raw_data, %status,          %error,\n                        %_event,   %resume_path,     %_nodes\n    );\n    sub STARTED           {1}\n    sub CHECKING          {2}\n    sub START_AFTER_CHECK {4}\n    sub CHECKED           {8}\n    sub ERROR             {16}\n    sub PAUSED            {32}\n    sub LOADED            {64}\n    sub QUEUED            {128}\n\n    sub new {\n        my ($class, $args) = @_;\n        my $self = bless \\$class, $class;\n        if ((!$args) || (ref($args) ne q[HASH])) {\n            carp q[Net::BitTorrent::Torrent->new({ }) requires ]\n                . q[parameters to be passed as a hashref];\n            return;\n        }\n        if (!$args->{q[Path]}) {\n            carp\n                sprintf(\n                q[Net::BitTorrent::Torrent->new({ }) requires a 'Path' parameter]\n                );\n            return;\n        }\n        if (not -f $args->{q[Path]}) {\n            carp\n                sprintf(\n                       q[Net::BitTorrent::Torrent->new({ }) cannot find '%s'],\n                       $args->{q[Path]});\n            return;\n        }\n        if (($args->{q[Client]})\n            && (   (!blessed $args->{q[Client]})\n                || (!$args->{q[Client]}->isa(q[Net::BitTorrent])))\n            )\n        {   carp q[Net::BitTorrent::Torrent->new({ }) requires a ]\n                . q[blessed Net::BitTorrent object in the 'Client' parameter];\n            return;\n        }\n        if (    $args->{q[BlockLength]}\n            and $args->{q[BlockLength]} !~ m[^\\d+$])\n        {   carp q[Net::BitTorrent::Torrent->new({ }) requires an ]\n                . q[integer 'BlockLength' parameter];\n            delete $args->{q[BlockLength]};\n        }\n        if ($args->{q[Status]} and $args->{q[Status]} !~ m[^\\d+$]) {\n            carp q[Net::BitTorrent::Torrent->new({ }) requires an ]\n                . q[integer 'Status' parameter.  Falling back to defaults.];\n            delete $args->{q[Status]};\n        }\n        $args->{q[Path]} = rel2abs($args->{q[Path]});\n        $args->{q[BaseDir]} = rel2abs(\n                  defined($args->{q[BaseDir]}) ? $args->{q[BaseDir]} : cwd());\n        my ($TORRENT_FH, $TORRENT_RAW);\n        if (not sysopen($TORRENT_FH, $args->{q[Path]}, O_RDONLY)) {\n            carp\n                sprintf(\n                q[Net::BitTorrent::Torrent->new({ }) could not open '%s': %s],\n                $args->{q[Path]}, $!);\n            return;\n        }\n        flock($TORRENT_FH, LOCK_SH);\n        if (sysread($TORRENT_FH, $TORRENT_RAW, -s $args->{q[Path]})\n            != -s $args->{q[Path]})\n        {   carp sprintf(\n                q[Net::BitTorrent::Torrent->new({ }) could not read all %d bytes of '%s' (Read %d instead)],\n                -s $args->{q[Path]},\n                $args->{q[Path]}, length($TORRENT_RAW)\n            );\n            return;\n        }\n        flock($TORRENT_FH, LOCK_UN);\n        $raw_data{refaddr $self} = bdecode($TORRENT_RAW);\n        close($TORRENT_FH);\n        undef $TORRENT_FH;\n        undef $TORRENT_RAW;\n        if (!$raw_data{refaddr $self}) {\n            carp q[Malformed .torrent];\n            return;\n        }\n        if (length(unpack(q[H*], $raw_data{refaddr $self}{q[info]}{q[pieces]})\n            ) < 40\n            )\n        {   return;\n        }\n        if (length(unpack(q[H*], $raw_data{refaddr $self}{q[info]}{q[pieces]})\n            ) % 40\n            )\n        {   return;\n        }\n        $infohash{refaddr $self}\n            = sha1_hex(bencode($raw_data{refaddr $self}{q[info]}));\n        $path{refaddr $self}            = $args->{q[Path]};\n        $_basedir{refaddr $self}        = $args->{q[BaseDir]};\n        $_working_pieces{refaddr $self} = {};\n        $_block_length{refaddr $self} = (defined $args->{q[BlockLength]}\n                                         ? $args->{q[BlockLength]}\n                                         : (2**14)\n        );\n        $downloaded{refaddr $self} = 0;\n        $uploaded{refaddr $self}   = 0;\n        $_nodes{refaddr $self}     = q[];\n        ${$bitfield{refaddr $self}}\n            = pack(q[b*], qq[\\0] x $self->piece_count);\n        my @_files;\n\n        if (defined $raw_data{refaddr $self}{q[info]}{q[files]}) {\n            for my $file (@{$raw_data{refaddr $self}{q[info]}{q[files]}}) {\n                push @_files,\n                    [catfile($_basedir{refaddr $self},\n                             $raw_data{refaddr $self}{q[info]}{q[name]},\n                             @{$file->{q[path]}}\n                     ),\n                     $file->{q[length]}\n                    ];\n            }\n        }\n        else {\n            push @_files,\n                [catfile($_basedir{refaddr $self},\n                         $raw_data{refaddr $self}{q[info]}{q[name]}\n                 ),\n                 $raw_data{refaddr $self}{q[info]}{q[length]}\n                ];\n        }\n        $size{refaddr $self} = 0;\n        for my $_file (@_files) {\n            my ($path, $size) = @$_file;\n            $path =~ s[\\.\\.][]g;\n            $path =~ m[(.+)];\n            $path = $1;\n            if (    defined $raw_data{refaddr $self}{q[encoding]}\n                and $raw_data{refaddr $self}{q[encoding]} !~ m[^utf-?8$]i\n                and not utf8::is_utf8($path)\n                and require Encode)\n            {   $path =\n                    Encode::decode(Encode::find_encoding(\n                                         $raw_data{refaddr $self}{q[encoding]}\n                                       )->name,\n                                   $path\n                    );\n            }\n            push(@{$files{refaddr $self}},\n                 Net::BitTorrent::Torrent::File->new(\n                                 {Size    => $size,\n                                  Path    => $path,\n                                  Torrent => $self,\n                                  Index   => scalar(@{$files{refaddr $self}})\n                                 }\n                 )\n            );\n            $size{refaddr $self} += $size;\n        }\n        $trackers{refaddr $self} = [];\n        foreach my $_tier ($raw_data{refaddr $self}{q[announce-list]}\n                           ? @{$raw_data{refaddr $self}{q[announce-list]}}\n                           : $raw_data{refaddr $self}{q[announce]}\n                           ? [$raw_data{refaddr $self}{q[announce]}]\n                           : ()\n            )\n        {   push(@{$trackers{refaddr $self}},\n                 Net::BitTorrent::Torrent::Tracker->new(\n                                            {Torrent => $self, URLs => $_tier}\n                 )\n            );\n        }\n        if (   ($args->{q[Client]})\n            && (blessed $args->{q[Client]})\n            && ($args->{q[Client]}->isa(q[Net::BitTorrent])))\n        {   foreach my $_node ($raw_data{refaddr $self}{q[nodes]}\n                               ? @{$raw_data{refaddr $self}{q[nodes]}}\n                               : ()\n                )\n            {   $args->{q[Client]}->_dht->add_node(\n                                    {ip => $_node->[0], port => $_node->[1]});\n            }\n        }\n        $args->{q[Status]} ||= 0;\n        $args->{q[Status]} ^= CHECKING if $args->{q[Status]} & CHECKING;\n        $args->{q[Status]} ^= CHECKED  if $args->{q[Status]} & CHECKED;\n        $args->{q[Status]} ^= ERROR    if $args->{q[Status]} & ERROR;\n        $args->{q[Status]} ^= LOADED   if $args->{q[Status]} & LOADED;\n        ${$status{refaddr $self}} = $args->{q[Status]};\n        ${$status{refaddr $self}} |= LOADED;\n        ${$error{refaddr $self}} = undef;\n\n        my $_start = 1;\n        $resume_path{refaddr $self} = undef;\n        if ($args->{q[Resume]}) {\n            $resume_path{refaddr $self} = $args->{q[Resume]};\n            my $_resume_data;\n            if (-f $args->{q[Resume]}) {\n                open(my ($_RD), q[<], $resume_path{refaddr $self});\n                sysread($_RD, $_resume_data, -s $_RD);\n                close $_RD;\n            }\n            if ($_resume_data) {\n                $_start       = 0;\n                $_resume_data = bdecode($_resume_data);\n\n                if (   $_resume_data->{q[.format]}\n                    && $_resume_data->{q[.format]} eq\n                    q[Net::BitTorrent resume]\n                    && $_resume_data->{q[.version]}\n                    && $_resume_data->{q[.version]} <= 2    \n                    )\n                {   $_nodes{refaddr $self}\n                        = $_resume_data->{q[peers]}\n                        ? $_resume_data->{q[peers]}\n                        : q[];\n                    my $_okay = 1;\n                    for my $_index (0 .. $#{$files{refaddr $self}}) {\n                        if ((!-f $files{refaddr $self}->[$_index]->path\n                             && $_resume_data->{q[files]}[$_index]{q[mtime]}\n                            )\n                            || ((stat($files{refaddr $self}->[$_index]->path))\n                                [9]\n                                || 0 != $_resume_data->{q[files]}[$_index]\n                                {q[mtime]})\n                            )\n                        {   ${$status{refaddr $self}} |= START_AFTER_CHECK;\n                            $_okay = 0;\n                        }\n                        $files{refaddr $self}->[$_index]->set_priority(\n                             $_resume_data->{q[files]}[$_index]{q[priority]});\n                    }\n                    if (!$_okay) {\n                        $self->_set_error(\n                                       q[Bad resume data. Please hashcheck.]);\n                    }\n                    else {\n                        ${$bitfield{refaddr $self}}\n                            = $_resume_data->{q[bitfield]};\n\n                        my $start_after_check\n                            = ${$status{refaddr $self}} & START_AFTER_CHECK;\n                        ${$status{refaddr $self}} ^= START_AFTER_CHECK\n                            if ${$status{refaddr $self}} & START_AFTER_CHECK;\n                        ${$status{refaddr $self}} ^= CHECKED\n                            if !(${$status{refaddr $self}} & CHECKED);\n                        if ($start_after_check) { $_start = 1; }\n\n                        for my $_piece (@{$_resume_data->{q[working]}}) {\n                            $_working_pieces{refaddr $self}\n                                {$_piece->{q[Index]}} = {\n                                Index            => $_piece->{q[Index]},\n                                Priority         => $_piece->{q[Priority]},\n                                Blocks_Requested => [\n                                     map { {} } 1 .. $_piece->{q[Block_Count]}\n                                ],\n                                Blocks_Received => [\n                                    map {\n                                        vec($_piece->{q[Blocks_Received]},\n                                            $_, 1)\n                                        } 1 .. $_piece->{q[Block_Count]}\n                                ],\n                                Block_Length => $_piece->{q[Block_Length]},\n                                Block_Length_Last =>\n                                    $_piece->{q[Block_Length_Last]},\n                                Block_Count => $_piece->{q[Block_Count]},\n                                Length      => $_piece->{q[Length]},\n                                Endgame     => $_piece->{q[Endgame]},\n                                Slow  => 1,     \n                                mtime => time\n                                };\n                        }\n                    }\n                }\n            }\n        }\n\n        weaken($REGISTRY{refaddr $self} = $self);\n        if ($threads::shared::threads_shared) {\n            threads::shared::share($bitfield{refaddr $self});\n            threads::shared::share($status{refaddr $self});\n            threads::shared::share($error{refaddr $self});\n        }\n        $$self = $infohash{refaddr $self};\n        if ($args->{q[Client]}) {\n            $self->queue($args->{q[Client]});\n            $_client{refaddr $self}->_schedule(\n                                     {Time   => time + 25,\n                                      Code   => sub { shift->_dht_announce },\n                                      Object => $self\n                                     }\n            );\n            $_client{refaddr $self}->_schedule(\n                                       {Time   => time,\n                                        Code   => sub { shift->_dht_scrape },\n                                        Object => $self\n                                       }\n            );\n        }\n        $self->start if $_start && (${$status{refaddr $self}} & QUEUED);\n        $self->_new_peer();    \n        return $self;\n    }\n\n    sub infohash    { return $infohash{refaddr +shift}; }\n    sub trackers    { return $trackers{refaddr +shift}; }\n    sub bitfield    { return ${$bitfield{refaddr +shift}}; }\n    sub path        { return $path{refaddr +shift}; }\n    sub resume_path { return $resume_path{refaddr +shift}; }\n    sub files       { return $files{refaddr +shift}; }\n    sub size        { return $size{refaddr +shift}; }\n    sub status      { return ${$status{refaddr +shift}}; }\n    sub downloaded  { return $downloaded{refaddr +shift}; }\n    sub uploaded    { return $uploaded{refaddr +shift}; }\n    sub error       { return ${$error{refaddr +shift}}; }\n    sub comment     { return $raw_data{refaddr +shift}{q[comment]}; }\n    sub created_by  { return $raw_data{refaddr +shift}{q[created by]}; }\n\n    sub creation_date {\n        return $raw_data{refaddr +shift}{q[creation date]};\n    }\n    sub name { return $raw_data{refaddr +shift}{q[info]}{q[name]}; }\n\n    sub private {\n        return $raw_data{refaddr +shift}{q[info]}{q[private]} ? 1 : 0;\n    }\n\n    sub raw_data {\n        my ($self, $raw) = @_;\n        return $raw\n            ? $raw_data{refaddr $self}\n            : bencode $raw_data{refaddr $self};\n    }\n\n    sub is_complete {\n        my ($self) = @_;\n        return if (${$status{refaddr $self}} & CHECKING);\n        return unpack(q[b*], $self->_wanted) !~ m[1] ? 1 : 0;\n    }\n\n    sub piece_count {    \n        my ($self) = @_;\n        return\n            int(\n               length(\n                   unpack(q[H*], $raw_data{refaddr $self}{q[info]}{q[pieces]})\n                   ) / 40\n            );\n    }\n\n    sub peers {\n        my ($self) = @_;\n        return if (${$status{refaddr $self}} & CHECKING);\n        return if !(${$status{refaddr $self}} & QUEUED);\n        my $_connections = $_client{refaddr $self}->_connections;\n        return map {\n            (    ($_->{q[Object]}->isa(q[Net::BitTorrent::Peer]))\n             and ($_->{q[Object]}->torrent)\n             and ($_->{q[Object]}->torrent eq $self))\n                ? $_->{q[Object]}\n                : ()\n        } values %$_connections;\n    }\n\n    sub _add_node {\n        my ($self, $node) = @_;\n        return $_nodes{refaddr $self} .= compact($node);\n    }\n\n    sub _set_bitfield {\n        my ($self, $new_value) = @_;\n        return if (${$status{refaddr $self}} & CHECKING);\n        return if length ${$bitfield{refaddr $self}} != length $new_value;\n\n        return ${$bitfield{refaddr $self}} = $new_value;\n    }\n\n    sub _set_status {\n        my ($self, $new_value) = @_;\n        return if (${$status{refaddr $self}} & CHECKING);\n\n        return ${$status{refaddr $self}} = $new_value;\n    }\n\n    sub _set_error {\n        my ($self, $msg) = @_;\n        ${$error{refaddr $self}} = $msg;\n        $self->stop() if ${$status{refaddr $self}} & STARTED;\n        ${$status{refaddr $self}} |= ERROR;\n        return 1;\n    }\n\n    sub _set_block_length {\n        my ($self, $value) = @_;\n        return if $value !~ m[^\\d+$];\n        return $_block_length{refaddr $self} = $value;\n    }\n\n    sub _client         { return $_client{refaddr +shift}; }\n    sub _block_length   { return $_block_length{refaddr +shift} }\n    sub _nodes          { return $_nodes{refaddr +shift}; }\n    sub _working_pieces { return $_working_pieces{refaddr +shift}; }\n    sub _basedir        { return $_basedir{refaddr +shift}; }\n\n    sub _wanted {\n        my ($self) = @_;\n        my $wanted = q[0] x $self->piece_count;\n        my $p_size = $raw_data{refaddr $self}{q[info]}{q[piece length]};\n        my $offset = 0;\n        for my $file (@{$files{refaddr $self}}) {\n            my $start = ($offset / $p_size);\n            my $end   = (($offset + $file->size) / $p_size);\n            if ($file->priority ? 1 : 0) {\n                substr($wanted, $start,\n                       ($end - $start + 1),\n                       (($file->priority ? 1 : 0) x ($end - $start + 1)));\n            }\n            $offset += $file->size;\n        }\n        return (\n             pack(q[b*], $wanted)\n                 | ${$bitfield{refaddr $self}} ^ ${$bitfield{refaddr $self}});\n    }\n\n    sub _weights {\n        my ($self) = @_;\n        my %_weights;\n        my $p_size = $raw_data{refaddr $self}{q[info]}{q[piece length]};\n        my $offset = 0;\n        for my $file (@{$files{refaddr $self}}) {\n            my $priority = $file->priority;\n            my $start    = ($offset / $p_size);\n            my $end      = (($offset + $file->size) / $p_size);\n            $offset += $file->size;\n            next if !$priority;\n            grep {\n                $_weights{$_} = $priority\n                    if !vec(${$bitfield{refaddr $self}}, $_, 1)\n            } $start .. $end;\n        }\n        return %_weights;\n    }\n\n    sub hashcheck {\n        my ($self) = @_;\n        return if (${$status{refaddr $self}} & PAUSED);\n        return if (${$status{refaddr $self}} & CHECKING);\n        ${$bitfield{refaddr $self}}    \n            = pack(q[b*], qq[\\0] x $self->piece_count);\n        my $start_after_check = ${$status{refaddr $self}} & START_AFTER_CHECK;\n        ${$status{refaddr $self}} |= CHECKING\n            if !${$status{refaddr $self}} & CHECKING;\n        for my $index (0 .. ($self->piece_count - 1)) {\n            $self->_check_piece_by_index($index);\n        }\n        (${$status{refaddr $self}} ^= START_AFTER_CHECK)\n            if ${$status{refaddr $self}} & START_AFTER_CHECK;\n        ${$status{refaddr $self}} ^= CHECKED\n            if !(${$status{refaddr $self}} & CHECKED);\n        ${$status{refaddr $self}} ^= CHECKING\n            if ${$status{refaddr $self}} & CHECKING;\n        if ($start_after_check) { $self->start(); }\n        return 1;\n    }\n\n    sub pause {\n        my ($self) = @_;\n        if (!${$status{refaddr $self}} & QUEUED) {\n            carp q[Cannot pause an orphan torrent];\n            return;\n        }\n        if (!${$status{refaddr $self}} & STARTED) {\n            carp q[Cannot pause a stopped torrent];\n            return;\n        }\n        return ${$status{refaddr $self}} |= PAUSED;\n    }\n\n    sub start {\n        my ($self) = @_;\n        return if !(${$status{refaddr $self}} & QUEUED);\n        ${$status{refaddr $self}} ^= ERROR\n            if ${$status{refaddr $self}} & ERROR;\n        ${$status{refaddr $self}} ^= PAUSED\n            if ${$status{refaddr $self}} & PAUSED;\n        if (!(${$status{refaddr $self}} & STARTED)) {\n            ${$status{refaddr $self}} |= STARTED;\n            for my $tracker (@{$trackers{refaddr $self}}) {\n                $tracker->_announce(q[started]);\n            }\n        }\n        return ${$status{refaddr $self}};\n    }\n\n    sub stop {\n        my ($self) = @_;\n        return if !(${$status{refaddr $self}} & QUEUED);\n        for my $_peer ($self->peers) {\n            $_peer->_disconnect(q[Torrent has been stopped]);\n        }\n        for my $_file (@{$files{refaddr $self}}) { $_file->_close(); }\n        if (${$status{refaddr $self}} & STARTED) {\n            ${$status{refaddr $self}} ^= STARTED;\n            for my $tracker (@{$trackers{refaddr $self}}) {\n                $tracker->_announce(q[stopped]);\n            }\n        }\n        return !!${$status{refaddr $self}} & STARTED;\n    }\n\n    sub queue {\n        my ($self, $client) = @_;\n        if (   (!$client)\n            || (!blessed $client)\n            || (!$client->isa(q[Net::BitTorrent])))\n        {   carp q[Net::BitTorrent::Torrent->queue() requires a ]\n                . q[blessed Net::BitTorrent object];\n            return;\n        }\n        if ($_client{refaddr $self} or ${$status{refaddr $self}} & QUEUED) {\n            carp q[Cannot serve the same .torrent more than once];\n            return;\n        }\n        $_client{refaddr $self} = $client;\n        weaken $_client{refaddr $self};\n        ${$status{refaddr $self}} ^= QUEUED;\n\n        return $_client{refaddr $self};\n    }\n\n    sub _add_uploaded {\n        my ($self, $amount) = @_;\n        return if (${$status{refaddr $self}} & CHECKING);\n        return if !(${$status{refaddr $self}} & QUEUED);\n        return if not $amount;\n        $uploaded{refaddr $self} += (($amount =~ m[^\\d+$]) ? $amount : 0);\n    }\n\n    sub _add_downloaded {\n        my ($self, $amount) = @_;\n        return if (${$status{refaddr $self}} & CHECKING);\n        return if !(${$status{refaddr $self}} & QUEUED);\n        $downloaded{refaddr $self} += (($amount =~ m[^\\d+$]) ? $amount : 0);\n    }\n\n    sub _new_peer {\n        my ($self) = @_;\n        return if not defined $_client{refaddr $self};\n        $_client{refaddr $self}->_schedule(\n                             {Time => time + ($self->is_complete ? 60 : 5),\n                              Code => sub { shift->_new_peer if @_; },\n                              Object => $self\n                             }\n        );\n        return if (${$status{refaddr $self}} & CHECKING);\n        return if !(${$status{refaddr $self}} & STARTED);\n        return if !(${$status{refaddr $self}} & QUEUED);\n\n        return\n            if scalar $self->peers\n                >= $_client{refaddr $self}->_peers_per_torrent;\n\n        my $half_open = scalar(\n            grep {\n                $_->{q[Object]}->isa(q[Net::BitTorrent::Peer])\n                    and not defined $_->{q[Object]}->peerid\n                } values %{$_client{refaddr $self}->_connections}\n        );\n\n        my @peers = $self->peers;\n\n        if (!$_nodes{refaddr $self}) {\n            $_nodes{refaddr $self}\n                = $_client{refaddr $self}->_dht->_peers($self->infohash)\n                if !$self->private;\n            for my $tier (@{$trackers{refaddr $self}}) {\n                for my $url (@{$tier->urls}) {\n                    $_nodes{refaddr $self} .= $url->_peers;\n                }\n            }\n        }\n\n        return if !$_nodes{refaddr $self};\n\n        my @nodes = uncompact($_nodes{refaddr $self});\n        for ($half_open .. $_client{refaddr $self}->_half_open - 1) {\n            last if !@nodes;\n            my $node = shift @nodes;\n            next\n                if scalar grep {\n                sprintf(q[%s:%d], ($_->host || q[]), ($_->port || 0)) eq\n                    $node    \n                } @peers;\n            my $ok = $_client{refaddr $self}\n                ->_event(q[ip_filter], {Address => $node});\n            if (defined $ok and $ok == 0) { next; }\n            my $peer =\n                Net::BitTorrent::Peer->new({Address => $node,\n                                            Torrent => $self,\n                                            Source  => q[TODO]\n                                           }\n                );\n        }\n\n        $_nodes{refaddr $self} = compact(@nodes);\n\n        return 1;\n    }\n\n    sub _add_tracker {\n        my ($self, $tier) = @_;\n        carp q[Please, pass new tier in an array ref...]\n            unless ref $tier eq q[ARRAY];\n        my $tracker = Net::BitTorrent::Torrent::Tracker->new(\n                                           {Torrent => $self, URLs => $tier});\n        $tracker->_announce(q[started]);\n        return push(@{$trackers{refaddr $self}}, $tracker);\n    }\n\n    sub _piece_by_index {\n        my ($self, $index) = @_;\n        return if !${$status{refaddr $self}} & STARTED;\n        return if (${$status{refaddr $self}} & CHECKING);\n        return if !(${$status{refaddr $self}} & QUEUED);\n        if ((!defined $index) || ($index !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Torrent->_piece_by_index() requires an index];\n            return;\n        }\n        return $_working_pieces{refaddr $self}{$index}\n            ? $_working_pieces{refaddr $self}{$index}\n            : ();\n    }\n\n    sub _pick_piece {\n        my ($self, $peer) = @_;\n        return if $self->is_complete;\n        return if !${$status{refaddr $self}} & STARTED;\n        return if (${$status{refaddr $self}} & CHECKING);\n        return if !(${$status{refaddr $self}} & QUEUED);\n        if (!$_client{refaddr $self}) {\n            carp\n                q[Net::BitTorrent::Torrent->_pick_piece(PEER) will not on an orphan torrent];\n            return;\n        }\n        if (   (!${$status{refaddr $self}} & STARTED)\n            || (${$status{refaddr $self}} & CHECKING))\n        {   carp\n                q[Net::BitTorrent::Torrent->_pick_piece(PEER) will not work while hashchecking];\n            return;\n        }\n        if (   (!$peer)\n            || (!blessed $peer)\n            || (!$peer->isa(q[Net::BitTorrent::Peer])))\n        {   carp\n                q[Net::BitTorrent::Torrent->_pick_piece(PEER) requires a peer];\n            return;\n        }\n        my $piece;\n        my $_wanted   = $self->_wanted;\n        my $relevence = $peer->bitfield & $_wanted;\n        return if unpack(q[b*], $relevence) !~ m[1];\n        my $endgame = (    \n            (sum(split(q[], unpack(q[b*], $_wanted)))\n                 <= (length(unpack(q[b*], $_wanted)) * .1)\n            ) ? 1 : 0\n        );\n\n        my $unrequested_blocks = 0;\n        for my $index (keys %{$_working_pieces{refaddr $self}}) {\n            $unrequested_blocks += scalar grep {\n                !keys %{$_working_pieces{refaddr $self}{$index}\n                        {q[Blocks_Requested]}[$_]}\n                } 0 .. $_working_pieces{refaddr $self}{$index}{q[Block_Count]}\n                - 1;\n        }\n        if (scalar(grep { $_->{q[Slow]} == 1 }\n                       values %{$_working_pieces{refaddr $self}}\n            ) >= 3\n            )\n        {   my @indexes\n                = grep { $_working_pieces{refaddr $self}{$_}{q[Slow]} == 1 }\n                keys %{$_working_pieces{refaddr $self}};\n            for my $index (@indexes) {\n                if (vec($relevence, $index, 1) == 1) {\n                    if (($endgame\n                         ? index($_working_pieces{refaddr $self}{$index}\n                                     {q[Blocks_Received]},\n                                 0,\n                                 0\n                         )\n                         : scalar grep { scalar keys %$_ }\n                         @{  $_working_pieces{refaddr $self}{$index}\n                                 {q[Blocks_Requested]}\n                         }\n                        ) != -1\n                        )\n                    {   $piece = $_working_pieces{refaddr $self}{$index};\n                        last;\n                    }\n                }\n            }\n        }\n        elsif (\n            scalar(values %{$_working_pieces{refaddr $self}}) >= (\n                (   $unrequested_blocks > (\n                        int($raw_data{refaddr $self}{q[info]}{q[piece length]}\n                                / $_block_length{refaddr $self}\n                            ) / 4\n                        ) ? 0 : 1\n                ) + scalar keys %{$_working_pieces{refaddr $self}}\n            )\n            )\n        {   my @indexes = sort {\n                (scalar grep { scalar keys %$_ }\n                     @{\n                     $_working_pieces{refaddr $self}{$a}{q[Blocks_Requested]}\n                     }\n                    ) <=> (scalar grep { scalar keys %$_ }\n                               @{\n                               $_working_pieces{refaddr $self}{$b}\n                                   {q[Blocks_Requested]}\n                               }\n                    )\n            } keys %{$_working_pieces{refaddr $self}};\n            for my $index (@indexes) {\n                if (vec($relevence, $index, 1) == 1) {\n                    if (($endgame\n                         ? index($_working_pieces{refaddr $self}{$index}\n                                     {q[Blocks_Received]},\n                                 0,\n                                 0\n                         )\n                         : scalar grep { scalar keys %$_ }\n                         @{  $_working_pieces{refaddr $self}{$index}\n                                 {q[Blocks_Requested]}\n                         }\n                        ) != -1\n                        )\n                    {   $piece = $_working_pieces{refaddr $self}{$index};\n                        last;\n                    }\n                }\n            }\n        }\n        else {\n            my %weights = $self->_weights;\n            return if not keys %weights;\n            my $total    = sum values %weights;    \n            my $rand_val = $total * rand;\n            my $index;\n            for my $i (reverse sort keys %weights) {\n                $rand_val -= $weights{$i};\n                if ($rand_val <= 0\n                    && vec($relevence, $i, 1) == 1)\n                {   $index = $i;\n                    last;\n                }\n            }\n            return if not defined $index;\n            my $_piece_length = (    \n                ($index == int(\n                            $size{refaddr $self}\n                          / $raw_data{refaddr $self}{q[info]}{q[piece length]}\n                 )\n                )\n                ? ($size{refaddr $self} % $raw_data{refaddr $self}{q[info]}\n                   {q[piece length]})\n                : ($raw_data{refaddr $self}{q[info]}{q[piece length]})\n            );\n            my $block_length = (\n                        ($raw_data{refaddr $self}{q[info]}{q[piece length]}\n                             < $_block_length{refaddr $self}\n                        )\n                        ? ($raw_data{refaddr $self}{q[info]}{q[piece length]})\n                        : $_block_length{refaddr $self}\n            );\n            my $block_length_last\n                = ($raw_data{refaddr $self}{q[info]}{q[piece length]}\n                   % $_piece_length);\n            my $block_count\n                = (int($_piece_length / $block_length)\n                       + ($block_length_last ? 1 : 0));\n            $piece = {Index             => $index,\n                      Priority          => $weights{$index},\n                      Blocks_Requested  => [map { {} } 1 .. $block_count],\n                      Blocks_Received   => [map {0} 1 .. $block_count],\n                      Block_Length      => $block_length,\n                      Block_Length_Last => $block_length_last,\n                      Block_Count       => $block_count,\n                      Length            => $_piece_length,\n                      Endgame           => $endgame,\n                      Slow              => 1,\n                      mtime             => 0\n            };\n        }\n        if ($piece) {\n            if (not\n                defined $_working_pieces{refaddr $self}{$piece->{q[Index]}})\n            {   $_working_pieces{refaddr $self}{$piece->{q[Index]}} = $piece;\n                $_working_pieces{refaddr $self}{$piece->{q[Index]}}\n                    {q[Endgame]} = $endgame;\n            }\n        }\n        return $piece\n            ? $_working_pieces{refaddr $self}{$piece->{q[Index]}}\n            : ();\n    }\n\n    sub _write_data {\n        my ($self, $index, $offset, $data) = @_;\n        return if !${$status{refaddr $self}} & STARTED;\n        return if (${$status{refaddr $self}} & CHECKING);\n        return if !(${$status{refaddr $self}} & QUEUED);\n        if ((length($$data) + (\n                 ($raw_data{refaddr $self}{q[info]}{q[piece length]} * $index)\n                 + $offset\n             )\n            ) > $size{refaddr $self}\n            )\n        {   carp q[Too much data or bad offset data for this torrent];\n            return;\n        }\n        my $file_index = 0;\n        my $total_offset\n            = int(\n               (($index * $raw_data{refaddr $self}{q[info]}{q[piece length]}))\n               + ($offset || 0));\n    SEARCH:\n        while ($total_offset > $files{refaddr $self}->[$file_index]->size) {\n            $total_offset -= $files{refaddr $self}->[$file_index]->size;\n            $file_index++;\n            last SEARCH    \n                if not defined $files{refaddr $self}->[$file_index]->size;\n        }\n    WRITE: while (length $$data > 0) {\n            my $this_write\n                = ($total_offset + length $$data\n                   > $files{refaddr $self}->[$file_index]->size)\n                ? $files{refaddr $self}->[$file_index]->size - $total_offset\n                : length $$data;\n            $files{refaddr $self}->[$file_index]->_open(q[w]) or return;\n            $files{refaddr $self}->[$file_index]->_sysseek($total_offset);\n            $files{refaddr $self}->[$file_index]\n                ->_write(substr($$data, 0, $this_write, q[]))\n                or return;\n            $file_index++;\n            last WRITE\n                if not defined $files{refaddr $self}->[$file_index];\n            $total_offset = 0;\n        }\n        return 1;\n    }\n\n    sub _read_data {\n        my ($self, $index, $offset, $length) = @_;\n        return if !defined $index  || $index !~ m[^\\d+$];\n        return if !defined $offset || $offset !~ m[^\\d+$];\n        return if !defined $length || $length !~ m[^\\d+$];\n        my $data = q[];\n        if (($length + (\n                 ($raw_data{refaddr $self}{q[info]}{q[piece length]} * $index)\n                 + $offset\n             )\n            ) > $size{refaddr $self}\n            )\n        {   carp q[Too much or bad offset data for this torrent];\n            return;\n        }\n        my $file_index = 0;\n        my $total_offset\n            = int(\n               (($index * $raw_data{refaddr $self}{q[info]}{q[piece length]}))\n               + ($offset || 0));\n    SEARCH:\n        while ($total_offset > $files{refaddr $self}->[$file_index]->size) {\n            $total_offset -= $files{refaddr $self}->[$file_index]->size;\n            $file_index++;\n            last SEARCH    \n                if not defined $files{refaddr $self}->[$file_index]->size;\n        }\n    READ: while ((defined $length) && ($length > 0)) {\n            my $this_read\n                = (($total_offset + $length)\n                   >= $files{refaddr $self}->[$file_index]->size)\n                ? ($files{refaddr $self}->[$file_index]->size - $total_offset)\n                : $length;\n            $files{refaddr $self}->[$file_index]->_open(q[r]) or return;\n            $files{refaddr $self}->[$file_index]->_sysseek($total_offset);\n            my $_data\n                = $files{refaddr $self}->[$file_index]->_read($this_read);\n            $data .= $_data if $_data;\n            $file_index++;\n            $length -= $this_read;\n            last READ if not defined $files{refaddr $self}->[$file_index];\n            $total_offset = 0;\n        }\n        return \\$data;\n    }\n\n    sub _check_piece_by_index {\n        my ($self, $index) = @_;\n        if ((!defined $index) || ($index !~ m[^\\d+$])) {\n            carp q[Net::BitTorrent::Torrent->_check_piece_by_index( INDEX ) ]\n                . q[requires an index.];\n            return;\n        }\n        delete $_working_pieces{refaddr $self}{$index};\n        my $data =\n            $self->_read_data(\n                  $index, 0,\n                  ($index == ($self->piece_count - 1)\n                   ? ($size{refaddr $self} % $raw_data{refaddr $self}{q[info]}\n                      {q[piece length]})\n                   : $raw_data{refaddr $self}{q[info]}{q[piece length]}\n                  )\n            );\n        if ((!$data)\n            or (sha1_hex($$data) ne substr(\n                              unpack(\n                                  q[H*],\n                                  $raw_data{refaddr $self}{q[info]}{q[pieces]}\n                              ),\n                              $index * 40,\n                              40\n                )\n            )\n            )\n        {   vec(${$bitfield{refaddr $self}}, $index, 1) = 0;\n            $self->_event(q[piece_hash_fail],\n                          {Torrent => $self, Index => $index});\n            return 0;\n        }\n        if (vec(${$bitfield{refaddr $self}}, $index, 1) == 0) {\n            vec(${$bitfield{refaddr $self}}, $index, 1) = 1;\n            $self->_event(q[piece_hash_pass],\n                          {Torrent => $self, Index => $index});\n        }\n        return 1;\n    }\n\n    sub _dht_announce {\n        my ($self) = @_;\n        $_client{refaddr $self}->_schedule(\n                                     {Time   => time + 120,\n                                      Code   => sub { shift->_dht_announce },\n                                      Object => $self\n                                     }\n        );\n        return if !${$status{refaddr $self}} & STARTED;\n        return if (${$status{refaddr $self}} & CHECKING);\n        return if !(${$status{refaddr $self}} & QUEUED);\n        return if $self->private;\n        return if !$_client{refaddr $self}->_use_dht;\n        $_client{refaddr $self}->_dht->_announce($self);\n        $_client{refaddr $self}->_schedule(\n            {   Time => time + 15,\n                Code => sub {\n                    my ($s) = @_;\n                    $_client{refaddr $s}->_dht->_scrape($s)\n                        if $_client{refaddr $s}->_use_dht;\n                },\n                Object => $self\n            }\n        );\n    }\n\n    sub _dht_scrape {\n        my ($self) = @_;\n        $_client{refaddr $self}->_schedule(\n                                       {Time   => time + 60,\n                                        Code   => sub { shift->_dht_scrape },\n                                        Object => $self\n                                       }\n        );\n        return if !(${$status{refaddr $self}} & STARTED);\n        return if (${$status{refaddr $self}} & CHECKING);\n        return if !(${$status{refaddr $self}} & QUEUED);\n        return if $self->private;\n        $_client{refaddr $self}->_dht->_scrape($self)\n            if $_client{refaddr $self}->_use_dht;\n    }\n\n    sub on_event {\n        my ($self, $type, $method) = @_;\n        carp sprintf q[Unknown callback: %s], $type\n            unless ___check_event($type);\n        $_event{refaddr $self}{$type} = $method;\n    }\n\n    sub _event {\n        my ($self, $type, $args) = @_;\n        carp sprintf\n            q[Unknown event: %s. This is a bug in Net::BitTorrent::Torrent; Report it.],\n            $type\n            unless ___check_event($type);\n        $_client{refaddr $self}->_event($type, $args)\n            if ${$status{refaddr $self}} & QUEUED;\n        return $_event{refaddr $self}{$type}\n            ? $_event{refaddr $self}{$type}($self, $args)\n            : ();\n    }\n\n    sub ___check_event {\n        my $type = shift;\n        return scalar grep { $_ eq $type } qw[\n            tracker_connect tracker_disconnect\n            tracker_read    tracker_write\n            tracker_success tracker_failure\n            piece_hash_pass piece_hash_fail\n            file_open       file_close\n            file_read       file_write\n            file_error\n        ];\n    }\n\n    sub save_resume_data {\n        my ($self, $file) = @_;\n        $file ||= $resume_path{refaddr $self};\n        return if !$file;    \n\n        for my $_file (@{$files{refaddr $self}}) { $_file->_close }\n\n        my $_nodes = $_nodes{refaddr $self};\n\n        $_nodes .= (((${$status{refaddr $self}} & QUEUED) && !$self->private)\n                    ? $_client{refaddr $self}->_dht->_peers($self->infohash)\n                    : q[]\n        );\n\n        for my $tier (@{$trackers{refaddr $self}}) {\n            for my $url (@{$tier->urls}) { $_nodes .= $url->_peers; }\n        }\n\n        my %resume_data = (\n            q[.format]  => q[Net::BitTorrent resume],\n            q[.t]       => time,\n            q[.version] => 2,\n            bitfield    => ${$bitfield{refaddr $self}},\n            files       => [\n                map {\n                    {priority => $_->priority,\n                     mtime    => (-f $_->path ? (stat($_->path))[9] : 0)\n                    }\n                    } @{$files{refaddr $self}}\n            ],\n            peers => ($_nodes ? $_nodes : q[]),\n            working => [\n                map {\n                    {Block_Count => $_->{q[Block_Count]},\n                     Endgame     => $_->{q[Endgame]},\n                     Blocks_Received =>\n                         pack(q[b*], join q[], @{$_->{q[Blocks_Received]}}),\n                     Index             => $_->{q[Index]},\n                     Slow              => $_->{q[Slow]},\n                     Block_Length      => $_->{q[Block_Length]},\n                     Block_Length_Last => $_->{q[Block_Length_Last]},\n                     Length            => $_->{q[Length]},\n                     Priority          => $_->{q[Priority]}\n                    }\n                    } values %{$_working_pieces{refaddr $self}}\n            ]\n        );\n\n        open(my ($_RD), q[>], $file) || return;\n        syswrite($_RD, bencode(\\%resume_data)) || return;\n        return close $_RD;\n    }\n\n    sub as_string {\n        my ($self, $advanced) = @_;\n        my $wanted = $self->_wanted;\n        my $dump\n            = !$advanced ? $self->infohash : sprintf <<'END',\n            $self->path, $raw_data{refaddr $self}{q[info]}{q[name]},\n            $self->infohash(), $_basedir{refaddr $self}, $size{refaddr $self},\n            ${$status{refaddr $self}}, $self->_status_as_string(),\n            ($self->private ? q[Disabled [Private]] : q[Enabled.]),\n            100 - (grep {$_} split //,\n                   unpack(q[b*], $wanted) / $self->piece_count * 100\n            ),\n            $uploaded{refaddr $self}, $downloaded{refaddr $self}, (\n            sprintf q[%s],\n            join q[],\n            map {\n                vec(${$bitfield{refaddr $self}}, $_, 1) ? q[|]    \n                    : $_working_pieces{refaddr $self}{$_} ? q[*]  \n                    : vec($wanted, $_, 1) ? q[ ]                  \n                    : q[x]                                        \n                } 0 .. $self->piece_count - 1\n            ),\n            $self->piece_count(),\n            $raw_data{refaddr $self}{q[info]}{q[piece length]},\n            (scalar keys %{$_working_pieces{refaddr $self}} || q[N/A]), (\n            join qq[\\n],\n            map {\n                my $index = $_;\n                sprintf q[%4d [%s] % 3.2f%%], $index, join(\n                    q[],\n                    map {\n                        $_working_pieces{refaddr $self}{$index}\n                            {q[Blocks_Received]}[$_] ? q[|]\n                            : scalar\n                            keys %{$_working_pieces{refaddr $self}{$index}\n                                {q[Blocks_Requested]}[$_]} == 1 ? q[*]\n                            : scalar\n                            keys %{$_working_pieces{refaddr $self}{$index}\n                                {q[Blocks_Requested]}[$_]} ? q[!]\n                            : q[ ]\n                        } 0 .. $_working_pieces{refaddr $self}{$index}\n                        {q[Block_Count]} - 1\n                    ),\n                    (scalar(grep {$_}\n                                @{\n                                $_working_pieces{refaddr $self}{$index}\n                                    {q[Blocks_Received]}\n                                }\n                         )\n                         / $_working_pieces{refaddr $self}{$index}\n                         {q[Block_Count]}\n                    ) * 100;\n                } sort { $a <=> $b }\n                keys %{$_working_pieces{refaddr $self}}\n            ),\n            scalar @{$files{refaddr $self}},\n            @{$files{refaddr $self}} != 1 ? q[s] : q[],\n            join(qq[\\n  ], map { $_->path } @{$files{refaddr $self}}),\n            scalar @{$trackers{refaddr $self}},\n            @{$trackers{refaddr $self}} != 1 ? q[s] : q[],\n            join(qq[\\n  ],\n                 map     { $_->url }\n                     map { @{$_->urls} } @{$trackers{refaddr $self}}\n            );\n        return defined wantarray ? $dump : print STDERR qq[$dump\\n];\n    }\n\n    sub _status_as_string {\n        my ($self) = @_;\n        return ucfirst join q[, ],\n            grep {$_}\n            (${$status{refaddr $self}} & LOADED) ? q[was loaded okay] : q[],\n            (${$status{refaddr $self}} & STARTED) ? q[is started]\n            : q[is stopped],\n            (${$status{refaddr $self}} & CHECKING)\n            ? q[is currently hashchecking]\n            : q[],\n            (${$status{refaddr $self}} & START_AFTER_CHECK)\n            ? q[needs hashchecking]\n            : q[], (${$status{refaddr $self}} & CHECKED) ? q[has been checked]\n            : q[has not been checked],\n            (${$status{refaddr $self}} & PAUSED) ? q[has been paused] : q[],\n            (${$status{refaddr $self}} & QUEUED) ? q[is queued]\n            : q[is good for informational use only],\n            (${$status{refaddr $self}} & ERROR) ? q[but has an error] : q[];\n    }\n\n    sub CLONE {\n        for my $_oID (keys %REGISTRY) {\n            my $_obj = $REGISTRY{$_oID};\n            my $_nID = refaddr $_obj;\n            for (@CONTENTS) {\n                $_->{$_nID} = $_->{$_oID};\n                delete $_->{$_oID};\n            }\n            weaken $_client{$_nID};\n            weaken($REGISTRY{$_nID} = $_obj);\n            delete $REGISTRY{$_oID};\n        }\n        return 1;\n    }\n    DESTROY {\n        my ($self) = @_;\n        for (@CONTENTS) { delete $_->{refaddr $self}; }\n        return delete $REGISTRY{refaddr $self};\n    }\n    1;\n}",
      "file" : "/var/tmp/arv_xkFB3e/Net-BitTorrent-0.052/lib/Net/BitTorrent/Torrent.pm",
      "package" : "Net::BitTorrent::Torrent"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n    use strict;\n    use warnings;\n    use Carp qw[carp];\n    use Scalar::Util qw[blessed weaken refaddr];\n    use List::Util qw[sum max];\n    use Socket qw[/F_INET/ SOMAXCONN SOCK_STREAM /inet_/ /pack_sockaddr_in/];\n    use Fcntl qw[F_SETFL O_NONBLOCK];\n    use Math::BigInt;\n    use Digest::SHA qw[sha1];\n    use version qw[qv];\n    our $VERSION_BASE = 52; our $UNSTABLE_RELEASE = 0; our $VERSION = sprintf(($UNSTABLE_RELEASE ? q[%.3f_%03d] : q[%.3f]), (version->new(($VERSION_BASE))->numify / 1000), $UNSTABLE_RELEASE);\n    use vars qw[@EXPORT_OK %EXPORT_TAGS];\n    use Exporter qw[];\n    *import = *import = *Exporter::import;\n    @EXPORT_OK = qw[\n        DISCONNECT_BY_REMOTE           DISCONNECT_LOOPBACK\n        DISCONNECT_NO_SUCH_TORRENT     DISCONNECT_HANDSHAKE_INFOHASH\n        DISCONNECT_MALFORMED_HANDSHAKE DISCONNECT_MALFORMED_PACKET\n        DISCONNECT_PREXISTING          DISCONNECT_TOO_MANY\n        DISCONNECT_HASHCHECKING        DISCONNECT_SEED\n        DISCONNECT_TIMEOUT_HANDSHAKE   DISCONNECT_USELESS_PEER\n        DISCONNECT_HANDSHAKE_SYNC_DH5  ];\n    %EXPORT_TAGS = (\n        all        => [@EXPORT_OK],\n        disconnect => [\n            qw[ DISCONNECT_BY_REMOTE           DISCONNECT_LOOPBACK\n                DISCONNECT_NO_SUCH_TORRENT     DISCONNECT_HANDSHAKE_INFOHASH\n                DISCONNECT_MALFORMED_HANDSHAKE DISCONNECT_MALFORMED_PACKET\n                DISCONNECT_PREXISTING          DISCONNECT_TOO_MANY\n                DISCONNECT_HASHCHECKING        DISCONNECT_SEED\n                DISCONNECT_TIMEOUT_HANDSHAKE   DISCONNECT_USELESS_PEER\n                DISCONNECT_HANDSHAKE_SYNC_DH5  ]\n        ],\n    );\n    use lib q[../../../lib];\n    use Net::BitTorrent::Protocol qw[:build parse_packet :types];\n    use Net::BitTorrent::Util qw[:bencode];\n    use Net::BitTorrent::Version;\n    my (@CONTENTS) = \\my (\n        %_client,           %_socket,         %torrent,\n        %_data_out,         %_data_in,        %peerid,\n        %bitfield,          %am_choking,      %am_interested,\n        %peer_choking,      %peer_interested, %incoming,\n        %requests_out,      %requests_in,     %_last_contact,\n        %_incoming_fastset, %reserved_bytes,  %source,\n        %host,              %port,\n        %_RC4_S, %_crypto_select, %_S,  %_i, %_j, %_state,\n        %_Xa,    %_Ya,            %_Yb, %_Xb,\n        %_KeyA,  %_KeyB,          %_parse_packets_schedule\n    );\n    my %REGISTRY;\n    my %_Disconnect_Strings = (\n        DISCONNECT_BY_REMOTE() =>\n            q[Connection closed by remote peer],    \n        DISCONNECT_LOOPBACK()        => q[...we've connected to ourself.],\n        DISCONNECT_NO_SUCH_TORRENT() => q[We aren't serving this torrent]\n        ,                                   \n        DISCONNECT_HANDSHAKE_INFOHASH() =>\n            q[Bad plaintext handshake (Incorrect Infohash)],\n        DISCONNECT_MALFORMED_HANDSHAKE() => q[Bad plaintext handshake],\n        DISCONNECT_MALFORMED_PACKET()    => q[...bad packet.],\n        DISCONNECT_PREXISTING()          => q[Already connected to this peer]\n        ,                                   \n        DISCONNECT_TOO_MANY()     => q[Enough peers already!],\n        DISCONNECT_HASHCHECKING() => q[Hash checking],\n        DISCONNECT_SEED()         => q[Disconnect seed],\n        -26                       => q[Handed a piece we never asked for]\n        ,    \n        -28 => q[Sent a reject to a non-existant piece],\n        -29 => q[Rejected a request we never made.],\n        DISCONNECT_TIMEOUT_HANDSHAKE() =>\n            q[Failed to complete handshake within 30s],\n        -40 => q[Peer is idle],\n        DISCONNECT_USELESS_PEER() =>\n            q[Useless peer (Not interested and not interesting.)],\n        -101                            => q[Bad VC in encrypted handshake],\n        DISCONNECT_HANDSHAKE_SYNC_DH5() => q[Failed to sync DH-5],\n        -103                            => q[Bad encrypted header at stage 4],\n        -104 => q[Bad encrypted handshake (Bad SKEY)],\n        -105 => q[Unsupported encryption scheme]\n    );\n    sub DISCONNECT_BY_REMOTE           {0}\n    sub DISCONNECT_LOOPBACK            {-10}\n    sub DISCONNECT_NO_SUCH_TORRENT     {-11}\n    sub DISCONNECT_HANDSHAKE_INFOHASH  {-12}\n    sub DISCONNECT_MALFORMED_HANDSHAKE {-13}\n    sub DISCONNECT_MALFORMED_PACKET    {-22}\n    sub DISCONNECT_PREXISTING          {-16}\n    sub DISCONNECT_TOO_MANY            {-17}\n    sub DISCONNECT_HASHCHECKING        {-18}\n    sub DISCONNECT_SEED                {-25}\n    sub DISCONNECT_TIMEOUT_HANDSHAKE   {-30}\n    sub DISCONNECT_USELESS_PEER        {-41}\n    sub DISCONNECT_HANDSHAKE_SYNC_DH5  {-102}\n\n    sub MSE_ONE   {1}\n    sub MSE_TWO   {2}\n    sub MSE_THREE {3}\n    sub MSE_FOUR  {4}\n    sub MSE_FIVE  {5}\n    sub REG_ONE   {11}\n    sub REG_TWO   {12}\n    sub REG_THREE {13}\n    sub REG_OKAY  {100}\n\n    sub CRYPTO_PLAIN {0x01}\n    sub CRYPTO_RC4   {0x02}\n    sub CRYPTO_XOR   {0x04}    \n    sub CRYPTO_AES   {0x08}    \n\n    sub DH_P {\n        return Math::BigInt->new(\n            q[0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A63A36210000000000090563]\n        );\n    }\n    sub DH_G {2}\n    sub VC   { qq[\\0] x 8 }\n\n    sub crypto_provide {\n        return pack q[N],\n            CRYPTO_PLAIN       \n    }\n    sub len { pack(q[n], length(shift)) }\n\n    sub new {\n\n        my ($class, $args) = @_;\n        my $self = undef;\n        if (not defined $args) {\n            carp q[Net::BitTorrent::Peer->new({ }) requires ]\n                . q[parameters a hashref];\n            return;\n        }\n        if (    !$args->{q[Socket]}\n            and !$args->{q[Address]})\n        {   carp <<'END'; return; }\n        if ($args->{q[Socket]}) {\n            if (ref($args->{q[Socket]}) ne q[GLOB]) {\n                carp\n                    q[Net::BitTorrent::Peer->new({ }) requires a GLOB-type socket];\n                return;\n            }\n            if (   (!$args->{q[Client]})\n                || (!blessed $args->{q[Client]})\n                || (!$args->{q[Client]}->isa(q[Net::BitTorrent])))\n            {   carp\n                    q[Net::BitTorrent::Peer->new({ }) requires a blessed Net::BitTorrent object in the 'Client' parameter];\n                return;\n            }\n            my ($port, $packed_ip)\n                = unpack_sockaddr_in(getpeername($args->{q[Socket]}));\n            my $ok = $args->{q[Client]}->_event(q[ip_filter],\n                {Address => sprintf(q[%s:%d], inet_ntoa($packed_ip), $port)});\n            if (defined $ok and $ok == 0) { return; }\n            my $ip = inet_ntoa($packed_ip);\n            if (scalar(\n                    grep {\n                               $_->{q[Object]}->isa(q[Net::BitTorrent::Peer])\n                            && $_->{q[Object]}->host\n                            && $_->{q[Object]}->host eq $ip\n                            && $_->{q[Object]}->port\n                            && $_->{q[Object]}->port eq $port\n                        } values %{$args->{q[Client]}->_connections}\n                ) > $args->{q[Client]}->_connections_per_host\n                )\n            {   shutdown($args->{q[Socket]}, 2);\n                close($args->{q[Socket]});\n                return;\n            }\n            $self\n                = bless \\sprintf(q[%s:%d], $ip, $port),\n                $class;\n            $_socket{refaddr $self} = $args->{q[Socket]};\n            $_client{refaddr $self} = $args->{q[Client]};\n            weaken $_client{refaddr $self};\n            $_client{refaddr $self}->_add_connection($self, q[ro]) or return;\n            $_data_out{refaddr $self} = q[];\n            $_data_in{refaddr $self}  = q[];\n            $incoming{refaddr $self}  = 1;\n            $source{refaddr $self}    = q[Incoming];\n            $_state{refaddr $self} = (\n                                     $_client{refaddr $self}->_encryption_mode\n                                     ? MSE_TWO\n                                     : REG_TWO\n            );\n        }\n        else {\n            if ($args->{q[Address]}\n                !~ m[^(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.]?){4}):\\d+$]\n                )\n            {   carp\n                    q[Net::BitTorrent::Peer->new({ }) requires an IPv4:port 'Address'];\n                return;\n            }\n            if (   (!$args->{q[Torrent]})\n                || (!blessed $args->{q[Torrent]})\n                || (!$args->{q[Torrent]}->isa(q[Net::BitTorrent::Torrent])))\n            {   carp\n                    q[Net::BitTorrent::Peer->new({ }) requires a blessed 'Torrent'];\n                return;\n            }\n            if (!$args->{q[Source]}) {\n                carp\n                    q[Net::BitTorrent::Peer->new({ }) would like to know where this peer info is from];\n                return;\n            }\n            my $half_open = grep {\n                $_->{q[Object]}->isa(q[Net::BitTorrent::Peer])\n                    && !$_->{q[Object]}->torrent\n            } values %{$args->{q[Torrent]}->_client->_connections};\n            if ($half_open >= $args->{q[Torrent]}->_client->_half_open) {\n\n                return;\n            }\n            if (scalar($args->{q[Torrent]}->peers)\n                >= $args->{q[Torrent]}->_client->_peers_per_torrent)\n            {   return;\n            }\n            my ($_host, $_port) = split q[:], $args->{q[Address]}, 2;\n            if (scalar(\n                    grep {\n                               $_->{q[Object]}->isa(q[Net::BitTorrent::Peer])\n                            && $_->{q[Object]}->host\n                            && $_->{q[Object]}->host eq $_host\n                            && $_->{q[Object]}->port\n                            && $_->{q[Object]}->port == $_port\n                        } values %{$args->{q[Torrent]}->_client->_connections}\n                ) > $args->{q[Torrent]}->_client->_connections_per_host\n                )\n            {   return;\n            }\n            socket(my ($socket), PF_INET, SOCK_STREAM, getprotobyname(q[tcp]))\n                or return;\n            $self = bless \\$args->{q[Address]}, $class;\n            ($host{refaddr $self}, $port{refaddr $self}) = ($_host, $_port);\n            $_socket{refaddr $self} = $socket;\n            if (not($^O eq q[MSWin32]    \n                    ? ioctl($_socket{refaddr $self}, 0x8004667e,\n                            pack(q[I], 1))\n                    : fcntl($_socket{refaddr $self}, F_SETFL, O_NONBLOCK)\n                )\n                )\n            {   return;\n            }\n            connect($_socket{refaddr $self},\n                    pack_sockaddr_in($port{refaddr $self},\n                                     inet_aton($host{refaddr $self})\n                    )\n            );\n            $_client{refaddr $self} = $args->{q[Torrent]}->_client;\n            weaken $_client{refaddr $self};\n            $torrent{refaddr $self} = $args->{q[Torrent]};\n            weaken $torrent{refaddr $self};\n            ${$bitfield{refaddr $self}}\n                = pack(q[b*], qq[\\0] x $torrent{refaddr $self}->piece_count);\n            my %_payload = (\n                  Reserved => $_client{refaddr $self}->_build_reserved,\n                  Infohash => pack(q[H40], $torrent{refaddr $self}->infohash),\n                  PeerID   => $_client{refaddr $self}->peerid\n            );\n\n            if (   ($_client{refaddr $self}->_encryption_mode != 0x00)\n                && (!$args->{q[_plaintext]})    \n                )\n            {   $_state{refaddr $self} = MSE_ONE;\n            }\n            else {\n                $_state{refaddr $self} = REG_ONE;\n            }\n            $_data_in{refaddr $self} = q[];\n            $_client{refaddr $self}->_add_connection($self, q[wo]) or return;\n            $incoming{refaddr $self} = 0;\n            $source{refaddr $self}   = $args->{q[Source]};\n        }\n        if ($self) {\n            ${$am_choking{refaddr $self}}      = 1;\n            ${$am_interested{refaddr $self}}   = 0;\n            ${$peer_choking{refaddr $self}}    = 1;\n            ${$peer_interested{refaddr $self}} = 0;\n            ${$bitfield{refaddr $self}} ||= ();\n            $_last_contact{refaddr $self}  = time;            \n            $_crypto_select{refaddr $self} = CRYPTO_PLAIN;    \n            $requests_out{refaddr $self}   = [];\n            $requests_in{refaddr $self}    = [];\n            $_client{refaddr $self}->_schedule({Time   => time + 120,\n                                                Code   => \\&_send_keepalive,\n                                                Object => $self\n                                               }\n            );\n            $_client{refaddr $self}->_schedule(\n                                           {Time   => time + 30,\n                                            Code   => \\&_cancel_old_requests,\n                                            Object => $self\n                                           }\n            );\n            $_client{refaddr $self}->_schedule(\n                                       {Time   => time + 90,\n                                        Code   => \\&_disconnect_useless_peer,\n                                        Object => $self\n                                       }\n            );\n            $_client{refaddr $self}->_schedule(\n                {   Time => time + 30,\n                    Code => sub {\n                        my $s = shift;\n                        if (!$peerid{refaddr $s}) {\n                            weaken $s;\n                            $s->_disconnect(DISCONNECT_TIMEOUT_HANDSHAKE);\n                            if ((!$incoming{refaddr $self}\n                                )    \n                                && ($torrent{refaddr $self})\n                                && ($_state{refaddr $self} < REG_ONE)\n                                )\n                            {\n\n                                my $peer =    \n                                    Net::BitTorrent::Peer->new(\n                                    {   Address => (\n                                                sprintf q[%s:%d], $self->host,\n                                                $self->port\n                                        ),\n                                        Torrent => $torrent{refaddr $self},\n                                        Source  => q[TODO],\n                                        _plaintext => 1    \n                                    }\n                                    );\n                            }\n                        }\n                        return 1;\n                    },\n                    Object => $self\n                }\n            );\n            $_client{refaddr $self}->_schedule(\n                {   Time => time + 1,\n                    Code => sub {\n                        my $s = shift;\n                        return $s->_parse_packets;\n                    },\n                    Object => $self\n                }\n            );\n            if ($threads::shared::threads_shared) {\n                threads::shared::share($bitfield{refaddr $self})\n                    if defined $bitfield{refaddr $self};\n                threads::shared::share($am_choking{refaddr $self});\n                threads::shared::share($am_interested{refaddr $self});\n                threads::shared::share($peer_choking{refaddr $self});\n                threads::shared::share($peer_interested{refaddr $self});\n            }\n            weaken($REGISTRY{refaddr $self} = $self);\n        }\n        return $self;\n    }\n\n    sub peerid { return $peerid{refaddr +shift}; }\n\n    sub _socket        { return $_socket{refaddr +shift}; }\n    sub torrent        { return $torrent{refaddr +shift}; }\n    sub reserved_bytes { return $reserved_bytes{refaddr +shift}; }\n    sub bitfield       { return ${$bitfield{refaddr +shift}}; }\n\n    sub port {\n        return if defined $_[1];\n        my ($self) = @_;\n        if (!$port{refaddr $self}) {\n            return if not defined $_socket{refaddr $self};\n            my $peername = getpeername($_socket{refaddr $self});\n            return if not defined $peername;\n            ($port{refaddr $self}, undef) = unpack_sockaddr_in($peername);\n        }\n        return $port{refaddr $self};\n    }\n\n    sub host {\n        return if defined $_[1];\n        my ($self) = @_;\n        if (!$host{refaddr $self}) {\n            return if not defined $_socket{refaddr $self};\n            my $peername = getpeername($_socket{refaddr $self});\n            return if not defined $peername;\n            my (undef, $packed_ip) = unpack_sockaddr_in($peername);\n            $host{refaddr $self} = inet_ntoa($packed_ip);\n        }\n        return $host{refaddr $self};\n    }\n\n    sub peer_choking    { return ${$peer_choking{refaddr +shift}}; }\n    sub am_choking      { return ${$am_choking{refaddr +shift}}; }\n    sub peer_interested { return ${$peer_interested{refaddr +shift}}; }\n    sub am_interested   { return ${$am_interested{refaddr +shift}}; }\n    sub incoming        { return $incoming{refaddr +shift}; }\n    sub source          { return $source{refaddr +shift}; }\n\n    sub _rw {\n\n        my ($self, $read, $write, $error) = @_;\n\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT);\n            return;\n        }\n        if ($error) {\n            weaken $self;\n            $self->_disconnect($^E);\n            return;\n        }\n        if (defined $torrent{refaddr $self}\n            and $torrent{refaddr $self}->status & 2)\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_HASHCHECKING);\n            return;\n        }\n        my ($actual_read, $actual_write) = (0, 0);\n        if ($read) {\n            if (   ($_crypto_select{refaddr $self} == CRYPTO_RC4)\n                && ($_state{refaddr $self} >= REG_ONE))\n            {   $actual_read\n                    = sysread($_socket{refaddr $self}, my ($data_in), $read);\n                $_data_in{refaddr $self} .=\n                    $self->_RC4((   $incoming{refaddr $self}\n                                  ? $_KeyA{refaddr $self}\n                                  : $_KeyB{refaddr $self}\n                                ),\n                                $data_in\n                    );\n\n            }\n            else {\n\n                $actual_read = sysread($_socket{refaddr $self},\n                                       $_data_in{refaddr $self},\n                                       $read,\n                                       length($_data_in{refaddr $self})\n                );\n            }\n            if (!$actual_read) {\n                weaken $self;\n                $self->_disconnect($^E);\n                return;\n            }\n\n            $_last_contact{refaddr $self} = time;\n            if (!$peerid{refaddr $self}) {\n                $_client{refaddr $self}\n                    ->_event(q[peer_connect], {Peer => $self});\n            }\n            $_client{refaddr $self}->_event(q[peer_read],\n                                     {Peer => $self, Length => $actual_read});\n        }\n        if ($write && $_data_out{refaddr $self}) {\n            $actual_write =\n                syswrite($_socket{refaddr $self},\n                         $_data_out{refaddr $self},\n                         $write, 0);\n\n            if (not $actual_write) {\n                weaken $self;\n                $self->_disconnect($^E);\n                return;\n            }\n            else {\n                $_client{refaddr $self}->_event(q[peer_write],\n                                    {Peer => $self, Length => $actual_write});\n                substr($_data_out{refaddr $self}, 0, $actual_write, q[]);\n            }\n        }\n\n        return ($actual_read, $actual_write);\n    }\n\n    sub _syswrite {    \n        my ($self, $data) = @_;\n        return if !$data;\n\n        if (   ($_crypto_select{refaddr $self} == CRYPTO_RC4)\n            && ($_state{refaddr $self} >= REG_ONE))\n        {   $data = $self->_RC4((  $incoming{refaddr $self}\n                                 ? $_KeyB{refaddr $self}\n                                 : $_KeyA{refaddr $self}\n                                ),\n                                $data\n            );\n        }\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return length($_data_out{refaddr $self} .= $data);\n    }\n    my %_parse_packets_handshake_dispatch = (\n                          &MSE_ONE   => \\&___handle_encrypted_handshake_one,\n                          &MSE_TWO   => \\&___handle_encrypted_handshake_two,\n                          &MSE_THREE => \\&___handle_encrypted_handshake_three,\n                          &MSE_FOUR  => \\&___handle_encrypted_handshake_four,\n                          &MSE_FIVE  => \\&___handle_encrypted_handshake_five,\n                          &REG_ONE   => \\&___handle_plaintext_handshake_one,\n                          &REG_TWO   => \\&___handle_plaintext_handshake_two,\n                          &REG_THREE => \\&___handle_plaintext_handshake_three\n    );\n    my %_parse_packets_dispatch = (\n                                 &KEEPALIVE      => \\&__handle_keepalive,\n                                 &CHOKE          => \\&__handle_choke,\n                                 &UNCHOKE        => \\&__handle_unchoke,\n                                 &INTERESTED     => \\&__handle_interested,\n                                 &NOT_INTERESTED => \\&__handle_not_interested,\n                                 &HAVE           => \\&__handle_have,\n                                 &BITFIELD       => \\&__handle_bitfield,\n                                 &REQUEST        => \\&__handle_request,\n                                 &PIECE          => \\&__handle_piece,\n                                 &CANCEL         => \\&__handle_cancel,\n                                 &HAVE_ALL       => \\&__handle_have_all,\n                                 &HAVE_NONE      => \\&__handle_have_none,\n                                 &ALLOWED_FAST   => \\&__handle_allowed_fast,\n                                 &REJECT         => \\&__handle_reject,\n                                 &EXTPROTOCOL    => \\&__handle_ext_protocol\n    );\n\n    sub _parse_packets {\n        my ($self, $time) = @_;\n\n        if ($_state{refaddr $self} != REG_OKAY) {\n            if (defined\n                $_parse_packets_handshake_dispatch{$_state{refaddr $self}})\n            {   $_parse_packets_handshake_dispatch{$_state{refaddr $self}}(\n                                                                       $self);\n            }\n            else {\n                Carp::cluck q[Unknown state: ] . $_state{refaddr $self};\n            }\n        }\n        elsif (length $_data_in{refaddr $self}) {\n        PACKET: while ($_data_in{refaddr $self}) {\n                my $data_len = length $_data_in{refaddr $self};\n                my $packet   = parse_packet(\\$_data_in{refaddr $self});\n\n                if (!$packet) {\n                    if (length($_data_in{refaddr $self}) != $data_len) {\n\n                        weaken $self;\n                        $self->_disconnect(DISCONNECT_MALFORMED_PACKET);\n                        return;\n                    }\n                    last PACKET;\n                }\n                if (defined $_parse_packets_dispatch{$packet->{q[Type]}}) {\n                    $_parse_packets_dispatch{$packet->{q[Type]}}($self,\n                                                       $packet->{q[Payload]});\n                }\n                else {\n                    my $packet_dump = q[];\n                    if (eval require Data::Dump) {    \n                        $packet_dump = Data::Dump::pp($packet);\n                    }\n                    else {    \n                        require Data::Dumper;\n                        $packet_dump = Data::Dumper::Dumper($packet);\n                    }\n                    Carp::carp\n                        sprintf <<'END', $self->as_string(1), $packet_dump;\n                }\n            }\n        }\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        $_parse_packets_schedule{refaddr $self}\n            = $_client{refaddr $self}->_schedule({Time   => time + 3,\n                                                  Code   => \\&_parse_packets,\n                                                  Object => $self\n                                                 }\n            ) if !$time;\n        return 1;\n    }\n\n    sub ___handle_encrypted_handshake_one {\n\n        my ($self) = @_;\n\n        $_Xa{refaddr $self} = int rand(9999999999999999);\n        $_Ya{refaddr $self}\n            = Math::BigInt->new(DH_G)->bmodpow($_Xa{refaddr $self}, DH_P);\n        my @bits\n            = map { chr hex $_ } ($_Ya{refaddr $self}->as_hex =~ m[(..)]g);\n        shift @bits;\n\n        $self->_syswrite(join q[], @bits,\n                         (map { chr rand(255) } 1 .. int(rand 512)));\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        $_state{refaddr $self} = MSE_THREE;\n        return 1;\n    }\n\n    sub ___handle_encrypted_handshake_two {\n\n        my ($self) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        if ($_data_in{refaddr $self} =~ m[^\\x13BitTorrent protocol.{48}$]s) {\n\n            $_state{refaddr $self} = REG_TWO;\n            return;\n        }\n\n        if (length($_data_in{refaddr $self}) < 96) {\n\n            $_client{refaddr $self}->_add_connection($self, q[rw]);\n            return 1;\n        }\n        $_Ya{refaddr $self} = Math::BigInt->new(\n            join q[],    \n            q[0x],\n            map { sprintf q[%02x], ord $_ } split //,\n            substr($_data_in{refaddr $self}, 0, 96, q[])\n        );\n        $_Xb{refaddr $self} = int rand(9999999999999999);    \n        $_Yb{refaddr $self}\n            = Math::BigInt->new(DH_G)->bmodpow($_Xb{refaddr $self}, DH_P);\n        my @bits\n            = map { chr hex $_ }\n            ($_Ya{refaddr $self}->bmodpow($_Xb{refaddr $self}, DH_P)->as_hex\n             =~ m[(..)]g);\n        shift @bits;\n        $_S{refaddr $self} = join q[], @bits;\n        my @_bits\n            = map { chr hex $_ } ($_Yb{refaddr $self}->as_hex =~ m[(..)]g);\n        shift @_bits;\n        $self->_syswrite(\n                  join(q[], @_bits)\n                . join(q[], map { chr int rand(255) } 1 .. (rand(1024) % 512))\n        );\n\n        $self->_syswrite(\n                  join(q[], @_bits)\n                . join(q[], map { chr int rand(255) } 1 .. (rand(1024) % 512))\n        );\n        $_state{refaddr $self} = MSE_FOUR;\n        return 1;\n    }\n\n    sub ___handle_encrypted_handshake_three {\n\n        my ($self) = @_;\n\n        if (length($_data_in{refaddr $self}) < 96) {\n\n            $_client{refaddr $self}->_add_connection($self, q[rw]);\n            return 1;\n        }\n        $_Yb{refaddr $self} =\n            Math::BigInt->new(join q[],\n                              q[0x],\n                              map { sprintf q[%02x], ord $_ }\n                                  split //,\n                              substr($_data_in{refaddr $self}, 0, 96, q[])\n            );\n        my @bits\n            = map { chr hex $_ }\n            ($_Yb{refaddr $self}->bmodpow($_Xa{refaddr $self}, DH_P)->as_hex\n             =~ m[(..)]g);\n        shift @bits;\n        $_S{refaddr $self} = join q[], @bits;\n        $torrent{refaddr $self} || return 0;  \n        $_KeyA{refaddr $self}\n            = sha1(  q[keyA]\n                   . $_S{refaddr $self}\n                   . pack(q[H*], $torrent{refaddr $self}->infohash));\n\n        $self->_syswrite(sha1(q[req1] . $_S{refaddr $self}));\n\n        $self->_syswrite(\n                sha1(q[req2] . pack(q[H*], $torrent{refaddr $self}->infohash))\n                    ^ sha1(q[req3] . $_S{refaddr $self}));\n\n        my $PadC = q[];\n        my $IA   = q[];\n        $self->_RC4($_KeyA{refaddr $self}, q[ ] x 1024, 1);\n        $self->_syswrite(\n            $self->_RC4(\n                $_KeyA{refaddr $self},\n                VC                       \n                    . crypto_provide     \n                    . len($PadC)         \n                    . $PadC              \n                    . len($IA)           \n            )\n        );\n\n        $self->_syswrite($self->_RC4($_KeyA{refaddr $self}, $IA));\n\n        $_state{refaddr $self} = MSE_FIVE;\n        return 1;\n    }\n\n    sub ___handle_encrypted_handshake_four {\n\n        my ($self) = @_;\n        if (length($_data_in{refaddr $self}) < 40) {\n\n            $_client{refaddr $self}->_add_connection($self, q[rw]);\n            return 1;\n        }\n\n        if (index($_data_in{refaddr $self}, sha1(q[req1], $_S{refaddr $self})\n            ) == -1\n            )\n        {   $_client{refaddr $self}->_add_connection($self, q[rw]);\n            return;\n        }\n        substr(    \n            $_data_in{refaddr $self},\n            0,\n            index($_data_in{refaddr $self}, sha1(q[req1], $_S{refaddr $self})\n            ),\n            q[]\n        );\n        my $req1      = substr($_data_in{refaddr $self}, 0, 20, q[]);\n        my $req2_req3 = substr($_data_in{refaddr $self}, 0, 20, q[]);\n    INFOHASH:\n        for my $torrent (values %{$_client{refaddr $self}->torrents}) {\n            if ((sha1(q[req2], pack q[H*], $torrent->infohash)\n                 ^ sha1(q[req3], $_S{refaddr $self})\n                ) eq $req2_req3\n                )\n            {   $torrent{refaddr $self} = $torrent;\n                weaken $torrent{refaddr $self};\n                ${$bitfield{refaddr $self}} = pack(q[b*],\n                               qq[\\0] x $torrent{refaddr $self}->piece_count);\n                last INFOHASH;\n            }\n        }\n        if (!$torrent{refaddr $self}) {\n            $self->_disconnect(-103);\n            return;\n        }\n        if (!$torrent{refaddr $self}) {\n            $self->_disconnect(-104);\n            return;\n        }\n        $_KeyB{refaddr $self}\n            = sha1(  q[keyB]\n                   . $_S{refaddr $self}\n                   . pack(q[H*], $torrent{refaddr $self}->infohash));\n        $_KeyA{refaddr $self}\n            = sha1(  q[keyA]\n                   . $_S{refaddr $self}\n                   . pack(q[H*], $torrent{refaddr $self}->infohash));\n        $self->_RC4($_KeyA{refaddr $self}, q[ ] x 1024, 1);\n        my ($VC, $crypto_provide, $len_padC, $PadC, $len_IA)\n            = ($self->_RC4($_KeyA{refaddr $self},\n                           substr($_data_in{refaddr $self}, 0, 16, q[]))\n                   =~ m[^(.{8})(....)(..)()(..)$]\n            );\n        if (!($VC && $crypto_provide)) {    \n            return;\n        }\n\n        if (unpack(q[N], $crypto_provide) & CRYPTO_RC4) {\n            $_crypto_select{refaddr $self} = CRYPTO_RC4;\n        }\n        elsif (unpack(q[N], $crypto_provide) & CRYPTO_PLAIN) {\n            $_crypto_select{refaddr $self} = CRYPTO_PLAIN;\n        }\n\n        else {\n            weaken $self;\n            $self->_disconnect(-105);\n            return;\n        }\n        my $IA\n            = substr($_data_in{refaddr $self}, 0, unpack(q[n], $len_IA), q[]);\n        if ($IA) {\n            if ($_crypto_select{refaddr $self} = CRYPTO_RC4) {\n                $IA = $self->_RC4($_KeyA{refaddr $self}, $IA);\n            }\n            $_data_in{refaddr $self} = $IA;\n        }\n\n        $self->_RC4($_KeyB{refaddr $self}, q[ ] x 1024, 1);\n\n        my $PadD = q[];\n        $self->_syswrite(\n                  $self->_RC4($_KeyB{refaddr $self},\n                              VC\n                                  . pack(q[N], $_crypto_select{refaddr $self})\n                                  . len($PadD)\n                                  . $PadD\n                  )\n        );\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        $_state{refaddr $self} = REG_TWO;\n        return 1;\n    }\n\n    sub ___handle_encrypted_handshake_five {\n\n        my ($self) = @_;\n        if (length($_data_in{refaddr $self}) < 34) {\n\n            $_client{refaddr $self}->_add_connection($self, q[rw]);\n            return;\n        }\n\n        $_KeyB{refaddr $self}\n            = sha1(  q[keyB]\n                   . $_S{refaddr $self}\n                   . pack(q[H40], $torrent{refaddr $self}->infohash));\n        $self->_RC4($_KeyB{refaddr $self}, q[ ] x 1024, 1);\n        my $index = index($_data_in{refaddr $self},\n                          $self->_RC4($_KeyB{refaddr $self}, VC));\n        if ($index == -1) {\n            if (length($_data_in{refaddr $self}) >= 628) {\n                $self->_disconnect(DISCONNECT_HANDSHAKE_SYNC_DH5);\n                my $peer =    \n                    Net::BitTorrent::Peer->new(\n                    {   Address =>\n                            (sprintf q[%s:%d], $self->host, $self->port),\n                        Torrent    => $torrent{refaddr $self},\n                        Source     => q[TODO],\n                        _plaintext => 1                          \n                    }\n                    ) if !$incoming{refaddr $self};\n            }\n            else {\n                $_client{refaddr $self}->_add_connection($self, q[rw]);\n            }\n            return;\n        }\n        substr($_data_in{refaddr $self}, 0, $index, q[]);\n        $self->_RC4($_KeyB{refaddr $self}, q[ ] x 1024, 1);\n        my ($VC, $crypto_select, $len_PadD) = (\n            $self->_RC4(    \n                $_KeyB{refaddr $self},\n                substr($_data_in{refaddr $self}, 0, 14, q[])\n                ) =~ m[^(.{8})(....)(..)$]\n        );\n        if (!$VC || $VC ne VC) {\n            weaken $self;\n            $self->_disconnect(-101);\n            my $peer =      \n                Net::BitTorrent::Peer->new(\n                {   Address => (sprintf q[%s:%d], $self->host, $self->port),\n                    Torrent    => $torrent{refaddr $self},\n                    Source     => q[TODO],\n                    _plaintext => 1                          \n                }\n                ) if !$incoming{refaddr $self};\n            return;\n        }\n        $_crypto_select{refaddr $self} = unpack(q[N], $crypto_select);\n\n        substr($_data_in{refaddr $self}, 0, unpack(q[n], $len_PadD), q[]);\n        if ($_crypto_select{refaddr $self} == CRYPTO_RC4) {\n\n            $self->_RC4($_KeyA{refaddr $self}, q[ ] x (1024 + 16), 1);\n\n        }\n        if ($_data_in{refaddr $self}) {\n\n        }\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n\n        $_state{refaddr $self} = REG_ONE;\n        return 1;\n    }\n\n    sub ___handle_plaintext_handshake_one {\n\n        my ($self) = @_;\n\n        my %_payload = (\n                  Reserved => $_client{refaddr $self}->_build_reserved,\n                  Infohash => pack(q[H40], $torrent{refaddr $self}->infohash),\n                  PeerID   => $_client{refaddr $self}->peerid\n        );\n        $self->_syswrite(build_handshake(\n                               $_payload{q[Reserved]}, $_payload{q[Infohash]},\n                               $_payload{q[PeerID]}\n                         )\n        );\n        $_client{refaddr $self}->_event(q[outgoing_packet],\n                                        {Peer    => $self,\n                                         Payload => \\%_payload,\n                                         Type    => HANDSHAKE\n                                        }\n        );\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        $_state{refaddr $self} = REG_THREE;\n        return 1;\n    }\n\n    sub ___handle_plaintext_handshake_two {\n\n        my ($self) = @_;\n        return if !defined $_socket{refaddr $self};\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !$_data_in{refaddr $self};\n        my $packet = parse_packet(\\$_data_in{refaddr $self});\n        return if !defined $packet;\n        if ($packet->{q[Type]} != HANDSHAKE) {\n            weaken $self;\n            $self->_disconnect(DISCONNECT_MALFORMED_HANDSHAKE);\n            return;\n        }\n        my $payload = $packet->{q[Payload]};\n        return if !defined $payload;\n\n        ($reserved_bytes{refaddr $self}, undef, $peerid{refaddr $self})\n            = @{$payload};\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Peer    => $self,\n                                         Payload => {\n                                                    Reserved => $payload->[0],\n                                                    Infohash => $payload->[1],\n                                                    PeerID   => $payload->[2]\n                                         },\n                                         Type => HANDSHAKE\n                                        }\n        );\n        if ($payload->[2] eq $_client{refaddr $self}->peerid) {\n            weaken $self;\n            $self->_disconnect(DISCONNECT_LOOPBACK);\n            return;\n        }\n        $torrent{refaddr $self} = $_client{refaddr $self}\n            ->_locate_torrent(unpack(q[H40], $payload->[1]));\n        if (!defined $torrent{refaddr $self}) {\n            weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT,\n                               {Infohash => unpack(q[H40], $payload->[1])});\n            return;\n        }\n        weaken $torrent{refaddr $self};\n        ${$bitfield{refaddr $self}}\n            = pack(q[b*], qq[\\0] x $torrent{refaddr $self}->piece_count);\n        if (scalar(\n                grep {\n                           $_->{q[Object]}->isa(q[Net::BitTorrent::Peer])\n                        && $_->{q[Object]}->peerid\n                        && $_->{q[Object]}->peerid eq $peerid{refaddr $self}\n                    } values %{$_client{refaddr $self}->_connections}\n            ) > $_client{refaddr $self}->_connections_per_host\n            )\n        {   $self->_disconnect(DISCONNECT_PREXISTING,\n                               {PeerID => $peerid{refaddr $self}});\n            return;\n        }\n        if (scalar($torrent{refaddr $self}->peers)\n            >= $_client{refaddr $self}->_peers_per_torrent)\n        {   $self->_disconnect(DISCONNECT_TOO_MANY);\n            return;\n        }\n        if ($threads::shared::threads_shared) {\n            threads::shared::share($bitfield{refaddr $self});\n        }\n        $_state{refaddr $self} = REG_OKAY;\n        my %_payload = (\n                  Reserved => $_client{refaddr $self}->_build_reserved,\n                  Infohash => pack(q[H40], $torrent{refaddr $self}->infohash),\n                  PeerID   => $_client{refaddr $self}->peerid\n        );\n        $self->_syswrite(build_handshake(\n                               $_payload{q[Reserved]}, $_payload{q[Infohash]},\n                               $_payload{q[PeerID]}\n                         )\n        );\n        $_client{refaddr $self}->_event(q[outgoing_packet],\n                                        {Peer    => $self,\n                                         Payload => \\%_payload,\n                                         Type    => HANDSHAKE\n                                        }\n        );\n        $self->_send_bitfield;\n        $self->_send_extended_handshake;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        $_state{refaddr $self} = REG_OKAY;\n        return 1;\n    }\n\n    sub ___handle_plaintext_handshake_three {\n\n        my ($self) = @_;\n        return if !defined $_socket{refaddr $self};\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !$_data_in{refaddr $self};\n        my $packet = parse_packet(\\$_data_in{refaddr $self});\n        return if !defined $packet;\n        if ($packet->{q[Type]} != HANDSHAKE) {\n            weaken $self;\n            $self->_disconnect(DISCONNECT_MALFORMED_HANDSHAKE);\n            return;\n        }\n        my $payload = $packet->{q[Payload]};\n        return if !defined $payload;\n\n        ($reserved_bytes{refaddr $self}, undef, $peerid{refaddr $self})\n            = @{$payload};\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Peer    => $self,\n                                         Payload => {\n                                                    Reserved => $payload->[0],\n                                                    Infohash => $payload->[1],\n                                                    PeerID   => $payload->[2]\n                                         },\n                                         Type => HANDSHAKE\n                                        }\n        );\n\n        if ($payload->[2] eq $_client{refaddr $self}->peerid) {\n            weaken $self;\n            $self->_disconnect(DISCONNECT_LOOPBACK);\n            return;\n        }\n\n        if ($payload->[1] ne pack q[H*], $torrent{refaddr $self}->infohash) {\n            weaken $self;\n            $self->_disconnect(DISCONNECT_HANDSHAKE_INFOHASH);\n            return;\n        }\n\n        $self->_send_bitfield;\n        $self->_send_extended_handshake;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        $_state{refaddr $self} = REG_OKAY;\n        return 1;\n    }\n\n    sub __handle_keepalive {\n\n        my ($self) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Peer    => $self,\n                                         Payload => {},\n                                         Type    => KEEPALIVE\n                                        }\n        );\n        return 1;\n    }\n\n    sub __handle_choke {\n\n        my ($self) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Peer    => $self,\n                                         Payload => {},\n                                         Type    => CHOKE\n                                        }\n        );\n        ${$peer_choking{refaddr $self}}  = 1;\n        ${$am_interested{refaddr $self}} = 0;\n        for my $request (@{$requests_out{refaddr $self}}) {\n            my $piece = $torrent{refaddr $self}\n                ->_piece_by_index($request->{q[Index]});\n            delete $piece->{q[Blocks_Requested]}->[$request->{q[_vec_offset]}]\n                ->{refaddr $self};\n        }\n        return $requests_out{refaddr $self} = [];\n    }\n\n    sub __handle_unchoke {\n\n        my ($self) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        ${$peer_choking{refaddr $self}} = 0;\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Peer    => $self,\n                                         Payload => {},\n                                         Type    => UNCHOKE\n                                        }\n        );\n        $self->_request_block(2);\n        return 1;\n    }\n\n    sub __handle_interested {\n\n        my ($self) = @_;\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        ${$peer_interested{refaddr $self}} = 1;\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Peer    => $self,\n                                         Payload => {},\n                                         Type    => INTERESTED\n                                        }\n        );\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        $self->_send_unchoke();\n        return 1;\n    }\n\n    sub __handle_not_interested {\n\n        my ($self) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Peer    => $self,\n                                         Payload => {},\n                                         Type    => NOT_INTERESTED\n                                        }\n        );\n        ${$peer_interested{refaddr $self}} = 1;\n        ${$am_choking{refaddr $self}}      = 1;\n        return 1;\n    }\n\n    sub __handle_have {\n\n        my ($self, $index) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        return if !defined $index;\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Peer    => $self,\n                                         Payload => {Index => $index},\n                                         Type    => HAVE\n                                        }\n        );\n        vec(${$bitfield{refaddr $self}}, $index, 1) = 1;\n        if ((unpack(q[b*], ${$bitfield{refaddr $self}}) !~ m[1])\n            && $torrent{refaddr $self}->is_complete)\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_SEED);\n            return;\n        }\n        $self->_check_interest;\n        if (${$am_interested{refaddr $self}}\n            and not ${$peer_choking{refaddr $self}})\n        {   $self->_request_block;\n        }\n    }\n\n    sub __handle_bitfield {\n\n        my ($self, $payload) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        return if !defined $payload;\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        ${$bitfield{refaddr $self}} = $payload;\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Peer    => $self,\n                                         Payload => {Bitfield => $payload},\n                                         Type    => BITFIELD\n                                        }\n        );\n        if ((unpack(q[b*], ${$bitfield{refaddr $self}}) !~ m[1])\n            && $torrent{refaddr $self}->is_complete)\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_SEED);\n            return;\n        }\n        return $self->_check_interest;\n    }\n\n    sub __handle_request {\n\n        my ($self, $payload) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        return if !defined $payload;\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Peer    => $self,\n                                         Payload => {Index  => $payload->[0],\n                                                     Offset => $payload->[1],\n                                                     Length => $payload->[2]\n                                         },\n                                         Type => REQUEST\n                                        }\n        );\n        if (not @{$requests_in{refaddr $self}}) {\n            $_client{refaddr $self}->_schedule({Time   => time + 3,\n                                                Code   => \\&_fill_requests,\n                                                Object => $self\n                                               }\n            );\n        }\n        return push @{$requests_in{refaddr $self}},\n            {Index  => $payload->[0],\n             Offset => $payload->[1],\n             Length => $payload->[2]\n            };\n    }\n\n    sub __handle_piece {\n\n        my ($self, $payload) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !defined $payload;\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        my ($index, $offset, $data) = @{$payload};\n        my $length = length($data);\n        my ($request) = grep {\n                    ($_->{q[Index]} == $index)\n                and ($_->{q[Offset]} == $offset)\n                and ($_->{q[Length]} == $length)\n        } @{$requests_out{refaddr $self}};\n        if (not defined $request) {\n            weaken $self;\n            $self->_disconnect(-26);\n            return;\n        }\n        $torrent{refaddr $self}->_add_downloaded($request->{q[Length]});\n        @{$requests_out{refaddr $self}} = grep {\n                   ($_->{q[Index]} != $index)\n                or ($_->{q[Offset]} != $offset)\n                or ($_->{q[Length]} != $length)\n        } @{$requests_out{refaddr $self}};\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Payload => {Index  => $index,\n                                                     Offset => $offset,\n                                                     Length => $length\n                                         },\n                                         Peer => $self,\n                                         Type => PIECE\n                                        }\n        );\n        my $piece = $torrent{refaddr $self}->_piece_by_index($index);\n        my $okay  = 0;\n        for my $_retry (1 .. 3) {\n\n            if ($torrent{refaddr $self}->_write_data($index, $offset, \\$data))\n            {   $okay++;\n                last;\n            }\n        }\n        return if !$okay;\n        $piece->{q[Blocks_Received]}->[$request->{q[_vec_offset]}] = 1;\n        $piece->{q[Slow]}                                          = 0;\n        $piece->{q[Touch]}                                         = time;\n        for my $peer ($torrent{refaddr $self}->peers) {\n            for my $x (reverse 0 .. $#{$requests_out{refaddr $peer}}) {\n                if (    (defined $requests_out{refaddr $peer}->[$x])\n                    and\n                    ($requests_out{refaddr $peer}->[$x]->{q[Index]} == $index)\n                    and ($requests_out{refaddr $peer}->[$x]->{q[Offset]}\n                         == $offset)\n                    and ($requests_out{refaddr $peer}->[$x]->{q[Length]}\n                         == $length)\n                    )\n                {   $_data_out{refaddr $peer } .=\n                        build_cancel($request->{q[Index]},\n                                     $request->{q[Offset]},\n                                     $request->{q[Length]}\n                        );\n                    $_client{refaddr $self}->_event(q[outgoing_packet],\n                                                    {Payload => {\n                                                            Index  => $index,\n                                                            Offset => $offset,\n                                                            Length => $length\n                                                     },\n                                                     Peer => $peer,\n                                                     Type => CANCEL\n                                                    }\n                    );\n                    $_client{refaddr $self}->_add_connection($peer, q[rw]);\n                    splice(@{$requests_out{refaddr $peer }}, $x, 1);\n                    last;\n                }\n            }\n        }\n        if (not grep { !$_ } @{$piece->{q[Blocks_Received]}}) {\n            if ($torrent{refaddr $self}->_check_piece_by_index($index)\n                and defined $torrent{refaddr $self})\n            {   for my $p ($torrent{refaddr $self}->peers) {\n                    $_data_out{refaddr $p} .= build_have($index);\n                    $_client{refaddr $self}->_add_connection($p, q[rw]);\n                }\n            }\n        }\n        $self->_request_block if $self->_check_interest;\n        return 1;\n    }\n\n    sub __handle_cancel {\n\n        my ($self, $payload) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        return if !defined $payload;\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        my ($index, $offset, $length) = @$payload;\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Payload => {Index  => $index,\n                                                     Offset => $offset,\n                                                     Length => $length\n                                         },\n                                         Peer => $self,\n                                         Type => CANCEL\n                                        }\n        );\n        for my $x (reverse 0 .. $#{$requests_in{refaddr $self}}) {\n            if (    ($requests_in{refaddr $self}->[$x]->{q[Index]} == $index)\n                and\n                ($requests_in{refaddr $self}->[$x]->{q[Offset]} == $offset)\n                and\n                ($requests_in{refaddr $self}->[$x]->{q[Length]} == $length))\n            {   splice(@{$requests_in{refaddr $self}}, $x, 1);\n            }\n        }\n        return 1;\n    }\n\n    sub __handle_have_all {\n\n        my ($self) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        if (!$torrent{refaddr $self}->status & 1) {\n            weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        ${$bitfield{refaddr $self}}\n            = pack(q[b*], qq[\\1] x $torrent{refaddr $self}->piece_count);\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Peer    => $self,\n                                         Payload => {},\n                                         Type    => HAVE_ALL\n                                        }\n        );\n        if ($torrent{refaddr $self}->is_complete) {\n            weaken $self;\n            $self->_disconnect(DISCONNECT_SEED);\n            return;\n        }\n        $self->_check_interest;\n        if (${$am_interested{refaddr $self}}\n            and not ${$peer_choking{refaddr $self}})\n        {   $self->_request_block;\n        }\n        return 1;\n    }\n\n    sub __handle_have_none {\n\n        my ($self) = @_;\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        if (!($torrent{refaddr $self}->status & 1)) {\n            weaken $self;    \n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT);\n            return;\n        }\n        ${$bitfield{refaddr $self}}\n            = pack(q[b*], qq[\\0] x $torrent{refaddr $self}->piece_count);\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Peer    => $self,\n                                         Payload => {},\n                                         Type    => HAVE_NONE\n                                        }\n        );\n        return $self->_check_interest;\n    }\n\n    sub __handle_allowed_fast {\n\n        my ($self, $payload) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        return if !defined $payload;\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Payload => {Index => $payload},\n                                         Peer    => $self,\n                                         Type    => ALLOWED_FAST\n                                        }\n        );\n        push(@{$_incoming_fastset{refaddr $self}}, $payload);\n        return 1;\n    }\n\n    sub __handle_reject {\n\n        my ($self, $payload) = @_;\n        $_client{refaddr $self}->_add_connection($self, q[rw]);\n        return if !defined $payload;\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        my ($index, $offset, $length) = @{$payload};\n        my ($request) = grep {\n                    ($_->{q[Index]} == $index)\n                and ($_->{q[Offset]} == $offset)\n                and ($_->{q[Length]} == $length)\n        } @{$requests_out{refaddr $self}};\n\n        if (not defined $request) {\n            weaken $self;\n            $self->_disconnect(-29);\n            return;\n        }\n        @{$requests_out{refaddr $self}} = grep {\n                   ($_->{q[Index]} != $index)\n                or ($_->{q[Offset]} != $offset)\n                or ($_->{q[Length]} != $length)\n        } @{$requests_out{refaddr $self}};\n        my $piece = $torrent{refaddr $self}->_piece_by_index($index);\n        if (not defined $piece) {\n            weaken $self;\n            $self->_disconnect(-28);\n            return;\n        }\n        delete $piece->{q[Blocks_Requested]}->[$request->{q[_vec_offset]}]\n            ->{refaddr $self};\n        $_client{refaddr $self}->_event(q[incoming_packet],\n                                        {Payload => {Index  => $index,\n                                                     Offset => $offset,\n                                                     Length => $length\n                                         },\n                                         Peer => $self,\n                                         Type => REJECT\n                                        }\n        );\n        return 1;\n    }\n\n    sub __handle_ext_protocol {\n\n        my ($self, $payload) = @_;\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        return if !defined $payload;\n        if (defined $torrent{refaddr $self}    \n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT);\n            return;\n        }\n        return if $torrent{refaddr $self}->status & 32;\n        my ($id, $packet) = @{$payload};\n        if ($packet) {\n            if ($id == 0) {\n                if (    defined $_client{refaddr $self}->_dht\n                    and defined $packet->{q[p]})\n                {   my (undef, $packed_ip)\n                        = unpack_sockaddr_in(\n                                        getpeername($_socket{refaddr $self}));\n                    $_client{refaddr $self}->_dht->add_node(\n                                              {ip   => inet_ntoa($packed_ip),\n                                               port => $packet->{q[p]}\n                                              }\n                    );\n                }\n            }\n            $packet->{q[ID]} = $id;\n            $_client{refaddr $self}->_event(q[incoming_packet],\n                                            {Payload => $packet,\n                                             Peer    => $self,\n                                             Type    => EXTPROTOCOL\n                                            }\n            );\n        }\n        return 1;\n    }\n\n    sub _check_interest {\n\n        my ($self) = @_;\n        if (!$torrent{refaddr $self}) { return; }\n        if (!($torrent{refaddr $self}->status & 1)) {\n            weaken $self;    \n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT);\n            return;\n        }\n        return if $torrent{refaddr $self}->status & 32;\n        my $interesting  = ${$am_interested{refaddr $self}};\n        my $torrent_have = $torrent{refaddr $self}->bitfield();\n        my $torrent_want = $torrent{refaddr $self}->_wanted();\n        my $relevence    = ${$bitfield{refaddr $self}} & $torrent_want;\n        $interesting = (index(unpack(q[b*], $relevence), 1, 0) != -1) ? 1 : 0;\n        if ($interesting and not ${$am_interested{refaddr $self}}) {\n            ${$am_interested{refaddr $self}} = 1;\n            $self->_syswrite(build_interested);\n            $_client{refaddr $self}->_event(q[outgoing_packet],\n                          {Peer => $self, Payload => {}, Type => INTERESTED});\n            $_client{refaddr $self}->_add_connection($self, q[rw]);\n        }\n        elsif (not $interesting and ${$am_interested{refaddr $self}}) {\n            ${$am_interested{refaddr $self}} = 0;\n            $self->_syswrite(build_not_interested);\n            $_client{refaddr $self}->_event(q[outgoing_packet],\n                      {Peer => $self, Payload => {}, Type => NOT_INTERESTED});\n            $_client{refaddr $self}->_add_connection($self, q[rw]);\n        }\n        return ${$am_interested{refaddr $self}};\n    }\n\n    sub _disconnect_useless_peer {\n\n        my ($self) = @_;\n        return if not defined $self;\n        if ($_last_contact{refaddr $self} < (time - 180)) {\n            weaken $self;\n            $self->_disconnect(-40);\n            return;\n        }\n        if (    ${$peer_choking{refaddr $self}}\n            and ${$am_interested{refaddr $self}})\n        {    \n            $self->_check_interest;\n        }\n        if (    (${$peer_choking{refaddr $self}})\n            and (!${$am_interested{refaddr $self}})\n            and (!${$peer_interested{refaddr $self}}))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_USELESS_PEER);\n            return;\n        }\n        $_client{refaddr $self}->_schedule(\n                            {Time   => (180 + $_last_contact{refaddr $self}),\n                             Code   => \\&_disconnect_useless_peer,\n                             Object => $self\n                            }\n        );\n        return 1;\n    }\n\n    sub _cancel_old_requests {\n\n        my ($self) = @_;\n        return if not defined $self;\n        return if not defined $_socket{refaddr $self};\n        $_client{refaddr $self}->_schedule({Time   => time + 15,\n                                            Code   => \\&_cancel_old_requests,\n                                            Object => $self\n                                           }\n        );\n        my $canceled = 0;\n        if (@{$requests_out{refaddr $self}} == []) {\n            return;\n        }\n        for my $i (reverse(0 .. $#{$requests_out{refaddr $self}})) {\n            my $request = $requests_out{refaddr $self}->[$i];\n            if (time <= ($request->{q[Timestamp]} + 60)) {\n                next;\n            }\n            my $piece = $torrent{refaddr $self}\n                ->_piece_by_index($request->{q[Index]});\n            delete $piece->{q[Blocks_Requested]}->[$request->{q[_vec_offset]}]\n                ->{refaddr $self};\n            if (!$piece->{q[Touch]} || $piece->{q[Touch]} <= time - 180) {\n                $piece->{q[Slow]} = 1;\n            }\n            $self->_syswrite(build_cancel(\n                                  $request->{q[Index]}, $request->{q[Offset]},\n                                  $request->{q[Length]}\n                             )\n            );\n            $_client{refaddr $self}->_event(\n                                         q[outgoing_packet],\n                                         {Payload => {\n                                              Index  => $request->{q[Index]},\n                                              Offset => $request->{q[Offset]},\n                                              Length => $request->{q[Length]}\n                                          },\n                                          Peer => $self,\n                                          Type => CANCEL\n                                         }\n            );\n            splice(@{$requests_out{refaddr $self}}, $i, 1);\n            $canceled++;\n        }\n        $_client{refaddr $self}->_add_connection($self, q[rw])\n            if $canceled;\n        return $canceled;\n    }\n\n    sub _request_block {\n\n        my ($self, $_range) = @_;\n        return if not defined $_socket{refaddr $self};\n        return if ${$peer_choking{refaddr $self}};\n        if (!($torrent{refaddr $self}->status & 1)) {\n            weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        return if $torrent{refaddr $self}->status & 32;\n        my $return = 0;\n        my $range\n            = defined $_range\n            ? [1 .. $_range]\n            : [max(1, scalar(@{$requests_out{refaddr $self}})) .. max(\n                                    25,\n                                    int((2**21)\n                                        / $torrent{refaddr $self}->raw_data(1)\n                                            ->{q[info]}{q[piece length]}\n                                    )\n               )\n            ];\n    REQUEST:\n        for (@$range) {\n            my $piece = $torrent{refaddr $self}->_pick_piece($self);\n            if ($piece) {\n                my $vec_offset;\n                if ($piece->{q[Endgame]}) {\n\n                    my $tmp_index = -1;\n                    my %temp      = map {\n                        $tmp_index++;\n                        (        ($_ < 5)\n                             and\n                             ($piece->{q[Blocks_Received]}->[$tmp_index] == 0)\n                            )\n                            ? ($tmp_index => $_)\n                            : ()\n                    } @{$piece->{q[Blocks_Received]}};\n                INDEX:\n                    for my $index (sort { $temp{$a} <=> $temp{$b} }\n                                   sort { $a <=> $b } keys %temp)\n                    {\n                        if (not grep {\n                                (defined $piece->{q[Blocks_Requested]}\n                                     ->[$index]->{refaddr $self})\n                                    and (\n                                    ($piece->{q[Blocks_Received]}->[$index])\n                                    or (($piece->{q[Index]} == $_->{q[Index]})\n                                        and ($index == $_->{q[_vec_offset]}))\n                                    )\n                            } @{$requests_out{refaddr $self}}\n                            )\n                        {   $vec_offset = $index;\n                            last INDEX;\n                        }\n                    }\n                }\n                else {\n                BLOCK:\n                    for my $i (0 .. $#{$piece->{q[Blocks_Requested]}}) {\n                        if (not(keys %{$piece->{q[Blocks_Requested]}->[$i]}))\n                        {   $vec_offset = $i;\n                            last BLOCK;\n                        }\n                    }\n                }\n                if (not defined $vec_offset or $vec_offset == -1) {\n\n                    last REQUEST;\n                }\n                $piece->{q[Blocks_Requested]}->[$vec_offset]->{refaddr $self}\n                    = $self;\n                weaken $piece->{q[Blocks_Requested]}->[$vec_offset]\n                    ->{refaddr $self};\n                my $offset = $vec_offset * $piece->{q[Block_Length]};\n                my $length = (\n                          (($vec_offset + 1) == $piece->{q[Block_Count]})\n                          ? (($piece->{q[Length]} % $piece->{q[Block_Length]})\n                             || $piece->{q[Block_Length]})\n                          : ($piece->{q[Block_Length]})\n                );\n                my $request = {Index       => $piece->{q[Index]},\n                               Offset      => $offset,\n                               Length      => $length,\n                               Timestamp   => time,\n                               _vec_offset => $vec_offset,\n                };\n                push @{$requests_out{refaddr $self}}, $request;\n                $_client{refaddr $self}->_event(\n                                             q[outgoing_packet],\n                                             {Payload => {\n                                                  Index => $piece->{q[Index]},\n                                                  Offset => $offset,\n                                                  Length => $length\n                                              },\n                                              Peer => $self,\n                                              Type => REQUEST\n                                             }\n                );\n                $_client{refaddr $self}->_add_connection($self, q[rw]);\n                $self->_syswrite(\n                         build_request($piece->{q[Index]}, $offset, $length));\n                $return++;\n            }\n            else {\n                last REQUEST;\n            }\n        }\n        return $return;\n    }\n\n    sub _send_bitfield {\n\n        my ($self) = @_;\n        return if !defined $torrent{refaddr $self};\n        return $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n            if !$torrent{refaddr $self}->status & 1;\n        return if !defined $_socket{refaddr $self};\n        return if !defined $reserved_bytes{refaddr $self};\n        my ($_i, @have) = (0);\n        for my $x (split q[], unpack q[b*], $torrent{refaddr $self}->bitfield)\n        {   push @have, $_i if $x;\n            $_i++;\n        }\n        if (   (scalar(@have) == 0)\n            && (ord(substr($reserved_bytes{refaddr $self}, 7, 1)) & 0x04))\n        {   $self->_syswrite(build_have_none);\n            $_client{refaddr $self}->_event(q[outgoing_packet],\n                           {Peer => $self, Payload => {}, Type => HAVE_NONE});\n        }\n        elsif (   (scalar(@have) == $self->torrent->piece_count)\n               && (ord(substr($reserved_bytes{refaddr $self}, 7, 1)) & 0x04))\n        {   $self->_syswrite(build_have_all);\n            $_client{refaddr $self}->_event(q[outgoing_packet],\n                            {Peer => $self, Payload => {}, Type => HAVE_ALL});\n        }\n        elsif (scalar(@have) > 12) {\n            $self->_syswrite(build_bitfield(pack q[B*], unpack q[b*],\n                                            $torrent{refaddr $self}->bitfield\n                             )\n            );\n            $_client{refaddr $self}->_event(q[outgoing_packet],\n                            {Peer => $self, Payload => {}, Type => BITFIELD});\n        }\n        else {\n            for my $index (@have) {\n                $self->_syswrite(build_have($index));\n                $_client{refaddr $self}->_event(q[outgoing_packet],\n                                                {Peer    => $self,\n                                                 Payload => {Index => $index},\n                                                 Type    => HAVE\n                                                }\n                );\n            }\n        }\n        return 1;\n    }\n\n    sub _send_extended_handshake {\n\n        my ($self) = @_;\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        return if not defined $reserved_bytes{refaddr $self};\n        return\n            if not ord(substr($reserved_bytes{refaddr $self}, 5, 1)) & 0x10;\n        my ($_peerport, $_packed_ip)\n            = unpack_sockaddr_in(getpeername($_socket{refaddr $self}));\n        my $_id      = 0;\n        my $_payload = {\n\n            ($_client{refaddr $self}->_use_dht\n             ? (p => $_client{refaddr $self}->_udp_port)\n             : ()\n            ),\n            v => $Net::BitTorrent::Version::PRODUCT_TOKEN,\n            ($_packed_ip ? (yourip => $_packed_ip) : ()),\n            reqq => 30    \n        };\n        $_client{refaddr $self}->_event(q[outgoing_packet],\n                                        {Payload => $_payload,\n                                         ID      => $_id,\n                                         Peer    => $self,\n                                         Type    => EXTPROTOCOL\n                                        }\n        );\n        return $self->_syswrite(build_extended($_id, $_payload));\n    }\n\n    sub _send_keepalive {\n\n        my ($self) = @_;\n        return if not defined $self;\n        return if not defined $_socket{refaddr $self};\n        return if not defined $torrent{refaddr $self};\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        $_client{refaddr $self}->_schedule({Time   => time + 120,\n                                            Code   => \\&_send_keepalive,\n                                            Object => $self\n                                           }\n        );\n        return if $torrent{refaddr $self}->status & 32;\n        $_client{refaddr $self}->_event(q[outgoing_packet],\n                                        {Peer    => $self,\n                                         Payload => {},\n                                         Type    => KEEPALIVE\n                                        }\n        );\n        $self->_syswrite(build_keepalive);\n        $self->_check_interest;\n        return 1;\n    }\n\n    sub _fill_requests {\n\n        my ($self) = @_;\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        return if $torrent{refaddr $self}->status & 32;\n        return if not @{$requests_in{refaddr $self}};\n        return if ${$am_choking{refaddr $self}};\n        if (defined $torrent{refaddr $self}\n            and !($torrent{refaddr $self}->status & 1))\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_NO_SUCH_TORRENT)\n                ;    \n            return;\n        }\n        if (defined $torrent{refaddr $self}\n            and ($torrent{refaddr $self}->status & 32))\n        {   return;\n        }\n        while ((length($_data_out{refaddr $self}) < 2**18)\n               and @{$requests_in{refaddr $self}})\n        {   my $request = shift @{$requests_in{refaddr $self}};\n            next\n                unless $torrent{refaddr $self}\n                    ->_check_piece_by_index($request->{q[Index]});\n            next unless $request->{q[Length]};\n            $torrent{refaddr $self}->_add_uploaded($request->{q[Length]});\n            $_client{refaddr $self}->_event(\n                                         q[outgoing_packet],\n                                         {Payload => {\n                                              Index  => $request->{q[Index]},\n                                              Offset => $request->{q[Offset]},\n                                              Length => $request->{q[Length]}\n                                          },\n                                          Peer => $self,\n                                          Type => PIECE\n                                         }\n            );\n            $self->_syswrite(\n                          build_piece(\n                              $request->{q[Index]},\n                              $request->{q[Offset]},\n                              $torrent{refaddr $self}->_read_data(\n                                  $request->{q[Index]}, $request->{q[Offset]},\n                                  $request->{q[Length]}\n                              )\n                          )\n            );\n\n        }\n        $_client{refaddr $self}->_schedule({Time   => time + 3,\n                                            Code   => \\&_fill_requests,\n                                            Object => $self\n                                           }\n        ) if @{$requests_in{refaddr $self}};\n        $_client{refaddr $self}->_add_connection($self, q[rw]) or return;\n        return 1;\n    }\n\n    sub _send_choke {\n\n        my ($self) = @_;\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        if (defined $torrent{refaddr $self}\n            and $torrent{refaddr $self}->status & 2)\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_HASHCHECKING);\n            return;\n        }\n        return if ${$am_choking{refaddr $self}} == 1;\n        $requests_in{refaddr $self} = [];\n        ${$am_choking{refaddr $self}}      = 1;\n        ${$peer_interested{refaddr $self}} = 0;\n        $self->_syswrite(build_choke);\n        $_client{refaddr $self}->_event(q[outgoing_packet],\n                                        {Peer    => $self,\n                                         Payload => {},\n                                         Type    => CHOKE\n                                        }\n        );\n        $_client{refaddr $self}->_add_connection($self, q[rw]) or return;\n        return 1;\n    }\n\n    sub _send_unchoke {\n\n        my ($self) = @_;\n        return if !defined $torrent{refaddr $self};\n        return if !defined $_socket{refaddr $self};\n        if (defined $torrent{refaddr $self}\n            and $torrent{refaddr $self}->status & 2)\n        {   weaken $self;\n            $self->_disconnect(DISCONNECT_HASHCHECKING);\n            return;\n        }\n        return if $torrent{refaddr $self}->status & 32;\n        return if ${$am_choking{refaddr $self}} == 0;\n        if (scalar(grep { $_->am_choking == 0 } $torrent{refaddr $self}->peers\n            ) <= 16    \n            )\n        {   ${$am_choking{refaddr $self}} = 0;\n            $self->_syswrite(build_unchoke);\n            $_client{refaddr $self}->_event(q[outgoing_packet],\n                             {Peer => $self, Payload => {}, Type => UNCHOKE});\n            $_client{refaddr $self}->_add_connection($self, q[rw])\n                or return;\n        }\n        else {\n            $_client{refaddr $self}->_schedule({Time   => time + 15,\n                                                Code   => \\&_send_unchoke,\n                                                Object => $self\n                                               }\n            );\n        }\n        return 1;\n    }\n\n    sub _disconnect {\n\n        my ($self, $reason, $extra) = @_;\n        $_client{refaddr $self}->_remove_connection($self);\n        if (defined $_socket{refaddr $self}) {\n            shutdown($_socket{refaddr $self}, 2);\n            close($_socket{refaddr $self});\n        }\n        delete $_socket{refaddr $self};\n        $_client{refaddr $self}->_event(q[peer_disconnect],\n                                        {Peer   => $self,\n                                         Reason => ($reason + 0),\n                                         ($extra ? (Advanced => $extra) : ())\n                                        }\n        );\n        return 1;\n    }\n\n    sub as_string {\n\n        my ($self, $advanced) = @_;\n        my $dump = sprintf(\n            (!$advanced ? q[%s:%s (%s)] : <<'ADVANCED'),\n            ($self->host || q[]),\n            ($self->port || q[]),\n            ($peerid{refaddr $self} ? $peerid{refaddr $self} : q[Unknown]),\n            (  $torrent{refaddr $self}\n             ? $torrent{refaddr $self}->infohash\n             : q[Unknown]\n            ),\n            ($incoming{refaddr $self} ? q[Incoming] : q[Outgoing]),\n            (map { $_ ? q[Yes] : q[No] } (${$peer_interested{refaddr $self}},\n                                          ${$am_interested{refaddr $self}},\n                                          ${$am_choking{refaddr $self}},\n                                          ${$peer_choking{refaddr $self}}\n             )\n            ),\n            (($_state{refaddr $self} == REG_OKAY)\n             ? (sprintf q[%s],\n                join q[],\n                map { vec(${$bitfield{refaddr $self}}, $_, 1) ? q[|] : q[ ] }\n                    0 .. $torrent{refaddr $self}->piece_count - 1\n                 )\n             : q[NA]\n            )\n        );\n        return defined wantarray ? $dump : print STDERR qq[$dump\\n];\n    }\n\n    sub CLONE {\n        for my $_oID (keys %REGISTRY) {\n            my $_obj = $REGISTRY{$_oID};\n            my $_nID = refaddr $_obj;\n            for (@CONTENTS) {\n                $_->{$_nID} = $_->{$_oID};\n                delete $_->{$_oID};\n            }\n            weaken $_client{$_nID};\n            weaken $torrent{$_nID};\n            weaken($REGISTRY{$_nID} = $_obj);\n            delete $REGISTRY{$_oID};\n        }\n        return 1;\n    }\n    DESTROY {\n        my ($self) = @_;\n        if ($torrent{refaddr $self}) {\n            for my $request (@{$requests_out{refaddr $self}}) {\n                my $piece = $torrent{refaddr $self}\n                    ->_piece_by_index($request->{q[Index]});\n                delete $piece->{q[Blocks_Requested]}\n                    ->[$request->{q[_vec_offset]}]->{refaddr $self};\n            }\n        }\n        for (@CONTENTS) { delete $_->{refaddr $self}; }\n        return delete $REGISTRY{refaddr $self};\n    }\n\n    sub _RC4 {\n        my ($self, $pass, $text, $reset) = @_;\n        my $rc4_output = sub {    \n            $_i{refaddr $self}{$pass} = ($_i{refaddr $self}{$pass} + 1) & 255;\n            $_j{refaddr $self}{$pass}\n                = (  $_j{refaddr $self}{$pass}\n                   + $_RC4_S{refaddr $self}{$pass}[$_i{refaddr $self}{$pass}]\n                ) & 255;\n            @{$_RC4_S{refaddr $self}{$pass}}[$_i{refaddr $self}{$pass},\n                $_j{refaddr $self}{$pass}]\n                = @{$_RC4_S{refaddr $self}{$pass}}[$_j{refaddr $self}{$pass},\n                $_i{refaddr $self}{$pass}];\n            return\n                $_RC4_S{refaddr $self}{$pass}[\n                (     $_RC4_S{refaddr $self}{$pass}[$_i{refaddr $self}{$pass}]\n                    + $_RC4_S{refaddr $self}{$pass}\n                    [$_j{refaddr $self}{$pass}]) & 255\n                ];\n        };\n        my $_j = 0;\n        if ($reset || !$_RC4_S{refaddr $self}{$pass}) {\n            my @key = unpack q[C*], $pass;\n            @{$_RC4_S{refaddr $self}{$pass}} = 0 .. 255;    \n            ($_i{refaddr $self}{$pass}, $_j{refaddr $self}{$pass}) = (0, 0);\n            for my $_i (0 .. 255) {\n                $_j\n                    = (  $_j \n                       + $key[$_i % @key]\n                       + $_RC4_S{refaddr $self}{$pass}[$_i]) & 255;\n                @{$_RC4_S{refaddr $self}{$pass}}[$_i, $_j]\n                    = @{$_RC4_S{refaddr $self}{$pass}}[$_j, $_i];\n            }\n        }\n        return pack q[C*],\n            map { ord(substr($text, $_, 1)) ^ $rc4_output->() }\n            0 .. length($text) - 1;\n    }\n    1;\n}",
      "file" : "/var/tmp/arv_xkFB3e/Net-BitTorrent-0.052/lib/Net/BitTorrent/Peer.pm",
      "package" : "Net::BitTorrent::Peer"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n    use strict;\n    use warnings;\n    use Carp qw[carp];\n    use Scalar::Util qw[blessed weaken refaddr];\n    use Fcntl qw[/O_/ /SEEK/ :flock];\n    use version qw[qv];\n    our $VERSION_BASE = 50; our $UNSTABLE_RELEASE = 0; our $VERSION = sprintf(($UNSTABLE_RELEASE ? q[%.3f_%03d] : q[%.3f]), (version->new(($VERSION_BASE))->numify / 1000), $UNSTABLE_RELEASE);\n    my (@CONTENTS)\n        = \\\n        my (%path, %torrent, %size, %index, %priority, %mode, %handle,\n            %win32_handle);\n    my %REGISTRY = ();\n\n    sub new {\n        my ($class, $args) = @_;\n        my $self;\n        if ((!$args) || (ref($args) ne q[HASH])) {\n            carp\n                q[Net::BitTorrentS::Torrent::File->new({}) requires parameters to be passed as a hashref];\n            return;\n        }\n        if (!$args->{q[Path]}) {\n            carp\n                q[Net::BitTorrent::Torrent::File->new({}) requires a 'Path' parameter];\n            return;\n        }\n        if (   (!$args->{q[Torrent]})\n            || (!blessed $args->{q[Torrent]})\n            || (!$args->{q[Torrent]}->isa(q[Net::BitTorrent::Torrent])))\n        {   carp\n                q[Net::BitTorrent::Torrent::File->new({}) requires a 'Torrent' parameter];\n            return;\n        }\n        if ((!defined $args->{q[Size]}) || ($args->{q[Size]} !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Torrent::File->new({}) requires an integer value for 'Size'];\n            return;\n        }\n        if ((!defined $args->{q[Index]}) || ($args->{q[Index]} !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Torrent::File->new({}) requires an 'Index' parameter];\n            return;\n        }\n        $self = bless \\$args->{q[Path]}, $class;\n        $path{refaddr $self}    = $args->{q[Path]};\n        $torrent{refaddr $self} = $args->{q[Torrent]};\n        weaken $torrent{refaddr $self};\n        $size{refaddr $self}     = $args->{q[Size]};\n        $index{refaddr $self}    = $args->{q[Index]};\n        $priority{refaddr $self} = 2;\n        weaken($REGISTRY{refaddr $self} = $self);\n        return $self;\n    }\n\n    sub priority { return $priority{refaddr +shift} }\n\n    sub set_priority {\n        my ($self, $newval) = @_;\n        if (not defined $newval) {\n            carp\n                q[Net::BitTorrent::Torrent::File->set_priority() requires an priority parameter];\n            return;\n        }\n        if ($newval !~ m[^\\d+$]) {\n            carp\n                q[Net::BitTorrent::Torrent::File->set_priority() requires an integer];\n            return;\n        }\n        return $priority{refaddr $self} = $newval;\n    }\n    sub mode    { return $mode{refaddr +shift} }\n    sub size    { return $size{refaddr +shift} }\n    sub torrent { return $torrent{refaddr +shift} }\n    sub index   { return $index{refaddr +shift} }\n    sub path    { return $path{refaddr +shift} }\n\n    sub _percent_complete {\n        my ($self) = @_;\n        my $start = 0;\n        for my $index (0 .. $index{refaddr $self} - 1) {\n            $start += $torrent{refaddr $self}->files->[$index]->size;\n        }\n        my $end          = $start + $size{refaddr $self};\n        my $piece_length = $torrent{refaddr $self}->raw_data(1)\n            ->{q[info]}{q[piece length]};\n        my $have      = 0;\n        my $_bitfield = $torrent{refaddr +shift}->bitfield;\n        $start = int($start / $piece_length);\n        $end   = int(($end / $piece_length) + 1);\n        for my $index ($start .. $end) {\n            $have += vec($_bitfield, $index, 1);\n        }\n        my $return = ($have / ($end - $start) * 100);\n        return $return > 100 ? 100 : $return;\n    }\n\n    sub _open {\n        my ($self, $mode) = @_;\n        if ((!$mode) || ($mode !~ m[^[rw]$])) {\n            carp\n                q[Net::BitTorrent::Torrent::File->_open() requires a valid mode];\n            return;\n        }\n        if (defined $handle{refaddr $self} and defined $mode{refaddr $self}) {\n            if ($mode{refaddr $self} eq $mode) {\n                return sysseek($handle{refaddr $self}, 0, SEEK_SET);\n            }\n            if ($mode{refaddr $self} eq q[w]) {\n                flock($handle{refaddr $self}, LOCK_UN) or return;\n            }\n            $self->_close;\n        }\n        $self->_mkpath;\n        my $mode_Fcntl = $mode eq q[r] ? O_RDONLY : O_WRONLY;\n        if (not $self->_sysopen(($mode eq q[r] ? (O_RDONLY) : (O_WRONLY)))) {\n            $torrent{refaddr $self}->_event(\n                 q[file_error],\n                 {File    => $self,\n                  Message => sprintf(q[Cannot open file for %s: %s],\n                                     ($mode eq q[r] ? q[read] : q[write]), $^E\n                  )\n                 }\n            ) if $mode eq q[w];\n            return;\n        }\n        $mode{refaddr $self} = $mode;\n        if (not flock($handle{refaddr $self},\n                      (($mode{refaddr $self} eq q[r]) ? LOCK_SH : LOCK_EX)\n            )\n            )\n        {   $torrent{refaddr $self}->_event(\n                 q[file_error],\n                 {File    => $self,\n                  Message => sprintf(q[Cannot lock file for %s: %s],\n                                     ($mode eq q[r] ? q[read] : q[write]), $^E\n                  )\n                 }\n            );\n            $torrent{refaddr $self}->_set_error(\n                             sprintf(q[Cannot lock '%s' for %s: %s],\n                                     $path{refaddr $self},\n                                     ($mode eq q[r] ? q[read] : q[write]), $^E\n                             )\n            );\n            return;\n        }\n        $torrent{refaddr $self}->_event(q[file_open],\n                               {File => $self, Mode => $mode{refaddr $self}});\n        return defined $handle{refaddr $self};\n    }\n\n    sub _write {\n        my ($self, $data) = @_;\n        if (not defined $data) {return}\n        if (not $handle{refaddr $self}) {\n            $torrent{refaddr $self}->_event(\n                            q[file_error],\n                            {File    => $self,\n                             Message => q[Cannot write to file: File not open]\n                            }\n            );\n            $torrent{refaddr $self}->_set_error(\n                               sprintf(q[Cannot write to '%s': File not open],\n                                       $path{refaddr $self})\n            );\n            return;\n        }\n        elsif ($mode{refaddr $self} ne q[w]) {\n            $torrent{refaddr $self}->_event(\n                  q[file_error],\n                  {File    => $self,\n                   Message => q[Cannot write to file: File not open for write]\n                  }\n            );\n            $torrent{refaddr $self}->_set_error(\n                     sprintf(q[Cannot write to '%s': File not open for write],\n                             $path{refaddr $self})\n            );\n            return;\n        }\n        elsif (($self->_systell + length($data)) > $size{refaddr $self}) {\n            $torrent{refaddr $self}->_event(\n                q[file_error],\n                {File    => $self,\n                 Message => sprintf(\n                     q[Cannot write beyond end of file (tell: %d | data:%d bytes | size: %d) (%d > %d)],\n                     $self->_systell,\n                     length($data),\n                     $size{refaddr $self},\n                     ($self->_systell + length($data)),\n                     $size{refaddr $self}\n                 )\n                }\n            );\n            $torrent{refaddr $self}->_set_error(\n                sprintf(\n                    <<'END', $path{refaddr $self},\n                    $self->_systell,\n                    length($data),\n                    $size{refaddr $self},\n                    ($self->_systell + length($data)),\n                    $size{refaddr $self}\n                )\n            );\n            return;\n        }\n        truncate($handle{refaddr $self}, $size{refaddr $self})\n            if -s $handle{refaddr $self} != $size{refaddr $self};\n        my $expected_length = length $data;\n        my $actual_length\n            = syswrite($handle{refaddr $self}, $data, $expected_length);\n        if (defined $actual_length) {\n            if ($actual_length != $expected_length) {\n                $torrent{refaddr $self}->_event(\n                    q[file_error],\n                    {File    => $self,\n                     Message => sprintf(\n                         q[Cannot write %d bytes of data to file; Wrote %d bytes instead (%s)],\n                         length($data), $actual_length, $^E\n                     )\n                    }\n                );\n                $torrent{refaddr $self}->_set_error(\n                    sprintf(\n                        q[Cannot write %d bytes to '%s': Wrote %d bytes instead (%s)],\n                        length($data),  $path{refaddr $self},\n                        $actual_length, $^E\n                    )\n                );\n                return;\n            }\n        }\n        else {\n            $torrent{refaddr $self}->_event(\n                   q[file_error],\n                   {File    => $self,\n                    Message => sprintf(\n                                q[Cannot write %d bytes of data to file (%s)],\n                                length($data), $^E\n                    )\n                   }\n            );\n            $torrent{refaddr $self}->_set_error(\n                              sprintf(q[Cannot write %d bytes to '%s' (%s)],\n                                      length($data), $path{refaddr $self}, $^E\n                              )\n            );\n            return;\n        }\n        $torrent{refaddr $self}->_event(q[file_write],\n                                   {File => $self, Length => $actual_length});\n        return $actual_length;\n    }\n\n    sub _read {\n        my ($self, $length) = @_;\n        if ((!defined $length) || ($length !~ m[^\\d+$])) {\n            carp\n                q[Net::BitTorrent::Torrent::File->_read( LENGTH ) requires a length];\n            return;\n        }\n        my $data = q[];\n        if (not $handle{refaddr $self}) {\n            $torrent{refaddr $self}->_event(\n                           q[file_error],\n                           {File    => $self,\n                            Message => q[Cannot read from file: File not open]\n                           }\n            );\n            $torrent{refaddr $self}->_set_error(\n                              sprintf(q[Cannot read from '%s': File not open],\n                                      $path{refaddr $self})\n            );\n            return;\n        }\n        elsif ($mode{refaddr $self} ne q[r]) {\n            $torrent{refaddr $self}->_event(\n                  q[file_error],\n                  {File    => $self,\n                   Message => q[Cannot read from file: File not open for read]\n                  }\n            );\n            $torrent{refaddr $self}->_set_error(\n                     sprintf(q[Cannot read from '%s': File not open for read],\n                             $path{refaddr $self})\n            );\n            return;\n        }\n        elsif ($self->_systell + $length > $size{refaddr $self}) {\n            $torrent{refaddr $self}->_event(\n                                 q[file_error],\n                                 {File    => $self,\n                                  Message => q[Cannot read beyond end of file]\n                                 }\n            );\n            $torrent{refaddr $self}->_set_error(\n                 sprintf(\n                     q[Cannot read from '%s': Cannot read beyond end of file],\n                     $path{refaddr $self})\n            );\n            return;\n        }\n        else {\n            truncate($handle{refaddr $self}, $size{refaddr $self})\n                if -s $handle{refaddr $self} != $size{refaddr $self};\n            my $real_length = sysread($handle{refaddr $self}, $data, $length);\n            if ($real_length != $length) {\n                $torrent{refaddr $self}->_event(\n                     q[file_error],\n                     {File    => $self,\n                      Message => sprintf(q[Failed to read %d bytes from file],\n                                         $length)\n                     }\n                );\n                $torrent{refaddr $self}->_set_error(\n                                    sprintf(q[Cannot read %d bytes from '%s'],\n                                            $length, $path{refaddr $self}\n                                    )\n                );\n                return;\n            }\n        }\n        $torrent{refaddr $self}->_event(q[file_read],\n                                        {File   => $self,\n                                         Length => length($data)\n                                        }\n        );\n        return $data;\n    }\n\n    sub _systell {\n        my ($self) = @_;\n        if (not $handle{refaddr $self}) {\n            $torrent{refaddr $self}->_event(\n                 q[file_error],\n                 {File    => $self,\n                  Message => q[Cannot get filehandle position: File not open],\n                 }\n            );\n            $torrent{refaddr $self}->_set_error(\n                sprintf(\n                    q[Cannot get filehandle position for '%s': File not open],\n                    $path{refaddr $self})\n            );\n            return;\n        }\n        return sysseek($handle{refaddr $self}, 0, SEEK_CUR);\n    }\n\n    sub _sysseek {\n        my ($self, $position, $wence) = @_;\n        $wence = defined $wence ? $wence : SEEK_SET;\n        if (not defined $handle{refaddr $self}) {\n            $torrent{refaddr $self}->_event(\n                  q[file_error],\n                  {File    => $self,\n                   Message => q[Cannot set filehandle position: File not open]\n                  }\n            );\n            $torrent{refaddr $self}->_set_error(\n                sprintf(\n                    q[Cannot set filehandle position for '%s': File not open],\n                    $path{refaddr $self})\n            );\n            return;\n        }\n        elsif (not defined $position) {\n            $torrent{refaddr $self}->_event(\n                                q[file_error],\n                                {File    => $self,\n                                 Message => q[Cannot seek: Undefined position]\n                                }\n            );\n            $torrent{refaddr $self}->_set_error(\n                sprintf(\n                    q[Cannot get filehandle position for '%s': Undefined position],\n                    $path{refaddr $self})\n            );\n            return;\n        }\n        elsif (\n             (   (($position < 0) and ($wence == SEEK_SET))\n              or\n              ((($position + $self->_systell()) < 0) and ($wence == SEEK_CUR))\n             )\n             or (($position > 0) and ($wence == SEEK_END))\n            )\n        {   $torrent{refaddr $self}->_event(\n                q[file_error],\n                {File => $self,\n                 Message =>\n                     sprintf(q[Cannot seek beyond the start of file (0 > %d)],\n                             $position)\n                }\n            );\n            $torrent{refaddr $self}->_set_error(\n                sprintf(\n                    q[Cannot set filehandle position for '%s': Beyond start of file (0 > %d)],\n                    $path{refaddr $self}, $position\n                )\n            );\n            return;\n        }\n        elsif ((abs($position) > $size{refaddr $self})) {\n            $torrent{refaddr $self}->_event(\n                   q[file_error],\n                   {File    => $self,\n                    Message => sprintf(\n                                   q[Cannot seek beyond %s of file (%d > %d)],\n                                   ($position > 0 ? q[start] : q[end]),\n                                   $position,\n                                   $size{refaddr $self}\n                    )\n                   }\n            );\n            $torrent{refaddr $self}->_set_error(\n                sprintf(\n                    q[Cannot set filehandle position for '%s': Beyond %s of file (%d > %d)],\n                    $path{refaddr $self},\n                    ($position > 0 ? q[start] : q[end]),\n                    $position,\n                    $size{refaddr $self}\n                )\n            );\n            return;\n        }\n        return sysseek($handle{refaddr $self}, $position, $wence);\n    }\n\n    sub _sysopen {\n        my ($self, $mode) = @_;\n        $self->_mkpath() if $mode &= O_WRONLY;\n        if ((    $^O eq q[MSWin32]\n             and utf8::is_utf8($path{refaddr $self})\n             and require Win32API::File\n             and require Encode\n            )\n            )\n        {   Win32API::File->import(qw[:ALL]);\n            Encode->import(qw[find_encoding encode]);\n            for my $null (qq[\\0], q[]) {\n                $win32_handle{refaddr $self}\n                    = CreateFileW(\n                                 encode(\n                                     q[UTF-16LE], $path{refaddr $self} . $null\n                                 ),\n                                 (($mode &= O_WRONLY) ? GENERIC_WRITE()\n                                  : GENERIC_READ()\n                                 ),\n                                 FILE_SHARE_READ(),\n                                 [],\n                                 (($mode &= O_WRONLY) ? OPEN_ALWAYS()\n                                  : OPEN_EXISTING()\n                                 ),\n                                 FILE_ATTRIBUTE_NORMAL(),\n                                 0\n                    ) and last;\n            }\n            return if not $win32_handle{refaddr $self};\n            my $fd = OsFHandleOpenFd($win32_handle{refaddr $self}, $mode);\n            return if $fd < 0;\n            return\n                open($handle{refaddr $self},\n                     (($mode &= O_WRONLY)\n                      ? q[>&]\n                      : q[<&]\n                     ),\n                     $fd\n                );\n        }\n        return\n            sysopen($handle{refaddr $self},\n                    $path{refaddr $self},\n                    $mode | (($mode &= O_WRONLY)\n                             ? O_CREAT\n                             : 0\n                    )\n            );\n    }\n\n    sub _close {\n        my ($self) = @_;\n        return if not defined $mode{refaddr $self};\n        if (defined $win32_handle{refaddr $self} and require Win32API::File) {\n            Win32API::File::CloseHandle($win32_handle{refaddr $self});\n            delete $win32_handle{refaddr $self};\n        }\n        my $return = CORE::close($handle{refaddr $self});\n        if ($return) {\n            delete $mode{refaddr $self};\n            delete $handle{refaddr $self};\n            $torrent{refaddr $self}->_event(q[file_close], {File => $self});\n            return $return;\n        }\n        $torrent{refaddr $self}->_event(\n                            q[file_error],\n                            {File    => $self,\n                             Message => sprintf(q[Cannot close file: %s], $^E)\n                            }\n        );\n        return;\n    }\n\n    sub _mkpath {\n        my ($self) = @_;\n        my ($vol, $dir, $file) = File::Spec->splitpath($path{refaddr $self});\n        if (not -d File::Spec->catpath($vol, $dir, q[])) {\n            if (    $^O eq q[MSWin32]\n                and utf8::is_utf8($path{refaddr $self})\n                and require Win32\n                and require Win32API::File\n                and require Encode)\n            {   Win32API::File->import(qw[:ALL]);\n                Encode->import(qw[encode]);\n                my $path = $vol;\n                foreach my $this_dir (\n                               File::Spec->splitdir(File::Spec->catdir($dir)))\n                {   next unless length($this_dir);\n                    $path = File::Spec->catdir($path, $this_dir);\n                    utf8::decode($path);\n                    next if -d $path;\n                    Win32::CreateDirectory($path);\n                }\n            }\n            elsif (require File::Path) {\n                File::Path::mkpath(File::Spec->catpath($vol, $dir, q[]),\n                                   {verbose => 0});\n            }\n        }\n        return 1;\n    }\n\n    sub as_string {\n        my ($self, $advanced) = @_;\n        my $dump = !$advanced ? $path{refaddr $self} : sprintf <<'END',\n            $path{refaddr $self}, $size{refaddr $self},\n            $priority{refaddr $self},\n            ( !$mode{refaddr $self} ? q[Closed]\n             : $mode{refaddr $self} eq q[ro] ? q[Read only]\n             : $mode{refaddr $self} eq q[wo] ? q[Write only]\n             : $mode{refaddr $self} eq q[rw] ? q[Read/Write]\n             : q[Closed]\n            ),\n            $self->_percent_complete,\n            $torrent{refaddr $self}->infohash, $index{refaddr $self},\n            scalar(@{$torrent{refaddr $self}->files});\n        return defined wantarray ? $dump : print STDERR qq[$dump\\n];\n    }\n\n    sub CLONE {\n        for my $_oID (keys %REGISTRY) {\n            my $_obj = $REGISTRY{$_oID};\n            my $_nID = refaddr $_obj;\n            for (@CONTENTS) {\n                $_->{$_nID} = $_->{$_oID};\n                delete $_->{$_oID};\n            }\n            weaken $torrent{$_nID};\n            weaken($REGISTRY{$_nID} = $_obj);\n            delete $REGISTRY{$_oID};\n        }\n        return 1;\n    }\n    DESTROY {\n        my ($self) = @_;\n        for (@CONTENTS) { delete $_->{refaddr $self}; }\n        return delete $REGISTRY{refaddr $self};\n    }\n    1;\n}",
      "file" : "/var/tmp/arv_xkFB3e/Net-BitTorrent-0.052/lib/Net/BitTorrent/Torrent/File.pm",
      "package" : "Net::BitTorrent::Torrent::File"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n    use strict;\n    use warnings;\n    use Carp qw[carp];\n    use Scalar::Util qw[blessed weaken refaddr];\n    use List::Util qw[shuffle];\n    use lib q[./../../../];\n    use Net::BitTorrent::Torrent::Tracker::HTTP;\n    use Net::BitTorrent::Torrent::Tracker::UDP;\n    use version qw[qv];\n    our $VERSION_BASE = 50; our $UNSTABLE_RELEASE = 0; our $VERSION = sprintf(($UNSTABLE_RELEASE ? q[%.3f_%03d] : q[%.3f]), (version->new(($VERSION_BASE))->numify / 1000), $UNSTABLE_RELEASE);\n    my (@CONTENTS) = \\my (%torrent, %urls);\n    my %REGISTRY;\n\n    sub new {\n        my ($class, $args) = @_;\n        my $self;\n        if ((!$args) || (ref($args) ne q[HASH])) {\n            carp\n                q[Net::BitTorrent::Torrent::Tracker->new({}) requires parameters to be passed as a hashref];\n            return;\n        }\n        if (   (!$args->{q[URLs]})\n            || (ref $args->{q[URLs]} ne q[ARRAY])\n            || (!scalar(@{$args->{q[URLs]}})))\n        {   carp\n                q[Net::BitTorrent::Torrent::Tracker->new({}) requires a list of URLs];\n            return;\n        }\n        if (   (!$args->{q[Torrent]})\n            || (!blessed $args->{q[Torrent]})\n            || (!$args->{q[Torrent]}->isa(q[Net::BitTorrent::Torrent])))\n        {   carp\n                q[Net::BitTorrent::Torrent::Tracker->new({}) requires a Torrent];\n            return;\n        }\n        $self = bless(\\$args->{q[URLs]}->[0], $class);\n        $torrent{refaddr $self} = $args->{q[Torrent]};\n        weaken $torrent{refaddr $self};\n        $urls{refaddr $self} = [];\n        for my $_url (@{$args->{q[URLs]}}) {\n            push @{$urls{refaddr $self}},\n                ($_url =~ m[^http://]i\n                 ? q[Net::BitTorrent::Torrent::Tracker::HTTP]\n                 : q[Net::BitTorrent::Torrent::Tracker::UDP]\n                )->new({URL => $_url, Tier => $self});\n        }\n        weaken($REGISTRY{refaddr $self} = $self);\n        @{$urls{refaddr $self}} = shuffle(@{$urls{refaddr $self}});\n        return $self;\n    }\n\n    sub urls { return $urls{refaddr +shift}; }\n\n    sub _client  { return $torrent{refaddr +shift}->_client; }\n    sub _torrent { return $torrent{refaddr +shift}; }\n\n    sub _nodes {\n        my ($self) = @_;\n        return compact(map { $_->_nodes } @{$urls{refaddr $self}});\n    }\n\n    sub _shuffle {\n        my ($self) = @_;\n        return (\n               push(@{$urls{refaddr $self}}, shift(@{$urls{refaddr $self}})));\n    }\n\n    sub _announce {\n        my ($self, $event) = @_;\n        return if not defined $self;\n        return if not defined $urls{refaddr $self};\n        return if not scalar @{$urls{refaddr $self}};\n        return $urls{refaddr $self}->[0]->_announce($event ? $event : ());\n    }\n\n    sub as_string {\n        my ($self, $advanced) = @_;\n        my $dump = !$advanced ? $$self : sprintf <<'END',\n            scalar(@{$urls{refaddr $self}}),\n            join qq[\\r\\n    ], map { $_->url() } @{$urls{refaddr $self}};\n        return defined wantarray ? $dump : print STDERR qq[$dump\\n];\n    }\n\n    sub CLONE {\n        for my $_oID (keys %REGISTRY) {\n            my $_obj = $REGISTRY{$_oID};\n            my $_nID = refaddr $_obj;\n            for (@CONTENTS) {\n                $_->{$_nID} = $_->{$_oID};\n                delete $_->{$_oID};\n            }\n            weaken $torrent{$_nID};\n            weaken($REGISTRY{$_nID} = $_obj);\n            delete $REGISTRY{$_oID};\n        }\n        return 1;\n    }\n    DESTROY {\n        my ($self) = @_;\n        for (@CONTENTS) { delete $_->{refaddr $self}; }\n        return delete $REGISTRY{refaddr $self};\n    }\n    1;\n}",
      "file" : "/var/tmp/arv_xkFB3e/Net-BitTorrent-0.052/lib/Net/BitTorrent/Torrent/Tracker.pm",
      "package" : "Net::BitTorrent::Torrent::Tracker"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n    use strict;\n    use warnings;\n    use Carp qw[carp];\n    use Scalar::Util qw[blessed weaken refaddr];\n    use List::Util qw[sum];\n    use Socket qw[inet_aton pack_sockaddr_in];\n    use lib q[../../../../../lib];\n    use Net::BitTorrent::Util qw[:compact];\n    use version qw[qv];\n    our $VERSION_BASE = 50; our $UNSTABLE_RELEASE = 0; our $VERSION = sprintf(($UNSTABLE_RELEASE ? q[%.3f_%03d] : q[%.3f]), (version->new(($VERSION_BASE))->numify / 1000), $UNSTABLE_RELEASE);\n    my %REGISTRY = ();\n    my @CONTENTS = \\my (%_url,                  %_tier,\n                        %_tid,                  %_cid,\n                        %_outstanding_requests, %_packed_host,\n                        %_event,                %_peers,\n                        %_complete,             %_incomplete\n    );\n\n    sub new {\n        my ($class, $args) = @_;\n        if (!$args) {\n            carp q[Net::[...]Tracker::UDP->new({}) requires params];\n            return;\n        }\n        if ((!$args->{q[URL]}) || ($args->{q[URL]} !~ m[^udp://]i)) {\n            carp q[Net::[...]Tracker::UDP->new({}) requires a valid URL];\n            return;\n        }\n        if (   (!$args->{q[Tier]})\n            || (!$args->{q[Tier]}->isa(q[Net::BitTorrent::Torrent::Tracker])))\n        {   carp q[Net::[...]Tracker::UDP->new({}) requires a parent Tracker];\n            return;\n        }\n        my $self = bless \\$args->{q[URL]}, $class;\n        my ($host, $port, $path)\n            = $args->{q[URL]} =~ m{^udp://([^/:]*)(?::(\\d+))?(/.*)$};\n        $port = $port ? $port : 80;\n        my $packed_host = undef;\n        if ($host\n            !~ m[^(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.]?){4})$])\n        {   my ($name, $aliases, $addrtype, $length, @addrs)\n                = gethostbyname($host)\n                or return;\n            $packed_host = $addrs[0];\n        }\n        else { $packed_host = inet_aton($host) }\n        $_packed_host{refaddr $self}\n            = pack_sockaddr_in($port, inet_aton($host));\n        $_url{refaddr $self}        = $args->{q[URL]};\n        $_event{refaddr $self}      = q[];\n        $_tier{refaddr $self}       = $args->{q[Tier]};\n        $_peers{refaddr $self}      = q[];\n        $_complete{refaddr $self}   = 0;\n        $_incomplete{refaddr $self} = 0;\n        $_tid{refaddr $self}        = int(rand() * 26**5);\n        weaken $_tier{refaddr $self};\n        weaken($REGISTRY{refaddr $self} = $self);\n        return $self;\n    }\n\n    sub url { my ($self) = @_; return $_url{refaddr $self}; }\n\n    sub _packed_host { return $_packed_host{refaddr +shift} }\n    sub _tier        { return $_tier{refaddr +shift}; }\n    sub _peers       { return $_peers{refaddr +shift}; }\n    sub _client      { return $_tier{refaddr +shift}->_client }\n\n    sub _announce {\n        my ($self, $event) = @_;\n        if (!$_tier{refaddr $self}->_client->_udp) {\n            carp sprintf q[UDP port is not open];\n            $_tier{refaddr $self}->_shuffle();\n            return;\n        }\n        if (defined $event) {\n            if ($event !~ m[^(?:st(?:art|opp)|complet)ed$]) {\n                carp sprintf q[Invalid event for announce: %s], $event;\n                return;\n            }\n            $_event{refaddr $self} = $event;\n        }\n        my $tid = $self->_generate_token_id();\n        if (not $_cid{refaddr $self}) {\n            my $packet = pack q[a8NN], ___pack64(4497486125440), 0, $tid;\n            $_outstanding_requests{refaddr $self}{$tid} = {Timestamp => time,\n                                                           Attempt   => 1,\n                                                           Packet => $packet\n            };\n        }\n        else {\n            my $packet = pack q[a8NN]\n                . q[a20 a20 a8 a8 a8 N N N N n],\n                $_cid{refaddr $self}, 1, $tid,\n                pack(q[H*], $_tier{refaddr $self}->_torrent->infohash),\n                $self->_client->peerid(),\n                ___pack64($_tier{refaddr $self}->_torrent->downloaded()),\n                ___pack64(\n                     $_tier{refaddr $self}->_torrent->raw_data(1)\n                         ->{q[info]}{q[piece length]} * sum(\n                         split(q[],\n                               unpack(\n                                   q[b*],\n                                   ($_tier{refaddr $self}->_torrent->_wanted()\n                                        || q[]\n                                   )\n                               )\n                         )\n                         )\n                ),\n                ___pack64($_tier{refaddr $self}->_torrent->uploaded()),\n                (  $_event{refaddr $self} eq q[completed] ? 1\n                 : $_event{refaddr $self} eq q[started]   ? 2\n                 : $_event{refaddr $self} eq q[stopped]   ? 3\n                 : 0\n                ),\n                0, $^T, 200, $self->_client->_tcp_port\n                || 0;\n            $_outstanding_requests{refaddr $self}{$tid} = {Timestamp => time,\n                                                           Attempt   => 1,\n                                                           Packet => $packet,\n                                                           Retry_ID => q[]\n            };\n        }\n        $self->_send($tid);\n    }\n\n    sub _send {\n        my ($self, $tid) = @_;\n        if (!$_tier{refaddr $self}->_client->_udp) {\n            $self->_client->_socket_open();\n        }\n        return if not $self->_client->_udp;\n        if ($_outstanding_requests{refaddr $self}{$tid}{q[Attempt]} > 8) {\n            delete $_outstanding_requests{refaddr $self}{$tid};\n            return;\n        }\n        if (not send($_tier{refaddr $self}->_client->_udp,\n                     $_outstanding_requests{refaddr $self}{$tid}{q[Packet]},\n                     0,\n                     $_packed_host{refaddr $self}\n            )\n            )\n        {   carp sprintf(\n                    q[Cannot send %d bytes to %s: [%d] %s],\n                    length(\n                        $_outstanding_requests{refaddr $self}{$tid}{q[Packet]}\n                    ),\n                    q[TODO], $^E, $^E\n            );\n            return;\n        }\n        $_tier{refaddr $self}->_torrent->_event(\n                                         q[tracker_connect],\n                                         {Tracker => $self,\n                                          ($_event{refaddr $self}\n                                           ? (Event => $_event{refaddr $self})\n                                           : ()\n                                          )\n                                         }\n        );\n        $_tier{refaddr $self}->_torrent->_event(\n                   q[tracker_write],\n                   {Tracker => $self,\n                    Length  => length(\n                        $_outstanding_requests{refaddr $self}{$tid}{q[Packet]}\n                    )\n                   }\n        );\n        $_outstanding_requests{refaddr $self}{$tid}{q[Retry_ID]}\n            = $self->_client->_schedule(\n            {Time =>\n                 time + (15 * (2**$_outstanding_requests{refaddr $self}{$tid}\n                                   {q[Attempt]}\n                         )\n                 ),\n             Code => sub {\n                 $_outstanding_requests{refaddr $self}{$tid}{q[Attempt]}++;\n                 shift->_send($tid);\n             },\n             Object => $self\n            }\n            );\n        return 1;\n    }\n\n    sub _on_data {\n        my ($self, $paddr, $data) = @_;\n        my ($action, $tid, $packet) = unpack q[NNa*], $data;\n        $_tier{refaddr $self}->_torrent->_event(q[tracker_read],\n                                 {Tracker => $self, Length => length($data)});\n        return if not $_outstanding_requests{refaddr $self}{$tid};\n        my $_request = $_outstanding_requests{refaddr $self}{$tid};\n        $self->_client->_cancel(\n                    $_outstanding_requests{refaddr $self}{$tid}{q[Retry_ID]});\n        delete $_outstanding_requests{refaddr $self}{$tid};\n        if ($action == 0) {\n\n            if (length($data) == 16) {\n                my ($cid) = unpack(q[a8], $packet);\n                $_cid{refaddr $self} = $cid;\n                $self->_announce();\n                return $self;\n            }\n            return;\n        }\n        elsif ($action == 1) {\n            if (length($data) >= 20) {\n                my ($min_interval, $leeches, $seeds, $peers)\n                    = unpack(q[N N N a*], $packet);\n                $_peers{refaddr $self}      = $peers;\n                $_complete{refaddr $self}   = $seeds;\n                $_incomplete{refaddr $self} = $leeches;\n                $_tier{refaddr $self}->_torrent->_event(\n                                            q[tracker_success],\n                                            {Tracker => $self,\n                                             Payload => {\n                                                 complete     => $seeds,\n                                                 incomplete   => $leeches,\n                                                 peers        => $peers,\n                                                 min_interval => $min_interval\n                                             }\n                                            }\n                );\n                $self->_client->_schedule(\n                    {   Time => (time + (  $min_interval\n                                         ? $min_interval\n                                         : 1800\n                                 )\n                        ),\n                        Code =>\n                            sub { return $_tier{refaddr +shift}->_announce() }\n                        ,\n                        Object => $self\n                    }\n                );\n            }\n            $_event{refaddr $self} = q[];\n            return $self;\n        }\n        elsif ($action == 2) {\n        }\n        elsif ($action == 3) {\n            $_tier{refaddr $self}->_torrent->_event(q[tracker_failure],\n                                                    {Tracker => $self,\n                                                     Reason  => $packet\n                                                    }\n            );\n            $self->_client->_schedule(\n                {Time => time + 30,\n                 Code => sub {\n                     my ($s) = @_;\n                     $s->_tier->_shuffle;\n                     return $s->_tier->_announce();\n                 },\n                 Object => $self\n                }\n            );\n            return;\n        }\n        else { }\n        return;\n    }\n\n    sub _generate_token_id {\n        return if defined $_[1];\n        my ($self) = @_;\n        my ($len) = ($_tid{refaddr $self} =~ m[^(\\d+)]);\n        $_tid{refaddr $self}\n            = ($_tid{refaddr $self} >= (26**5) ? 0 : ++$_tid{refaddr $self});\n        return $_tid{refaddr $self};\n    }\n\n    sub as_string {\n        my ($self, $advanced) = @_;\n        my $dump = !$advanced ? $$self : sprintf <<'END',\n            $_url{refaddr $self};\n        return defined wantarray ? $dump : print STDERR qq[$dump\\n];\n    }\n\n    sub ___pack64 {    \n        my ($value) = @_;\n        my $return;\n        if (!eval { $return = pack(q[Q], $value); 1; }) {\n            require Math::BigInt;\n            my $i = new Math::BigInt $value;\n            my ($int1, $int2) = do {\n                if ($i < 0) {\n                    $i = -1 - $i;\n                    (~(int($i / 2**32) % 2**32), ~int($i % 2**32));\n                }\n                else {\n                    (int($i / 2**32) % 2**32, int($i % 2**32));\n                }\n            };\n            $return = pack(q[NN], $int1, $int2);\n        }\n        return $return;\n    }\n\n    sub CLONE {\n        for my $_oID (keys %REGISTRY) {\n            my $_obj = $REGISTRY{$_oID};\n            my $_nID = refaddr $_obj;\n            for (@CONTENTS) {\n                $_->{$_nID} = $_->{$_oID};\n                delete $_->{$_oID};\n            }\n            weaken $_tier{$_nID};\n            weaken($REGISTRY{$_nID} = $_obj);\n            delete $REGISTRY{$_oID};\n        }\n        return 1;\n    }\n    DESTROY {\n        my ($self) = @_;\n        for (@CONTENTS) { delete $_->{refaddr $self}; }\n        delete $REGISTRY{refaddr $self};\n        return 1;\n    }\n    1;\n}",
      "file" : "/var/tmp/arv_xkFB3e/Net-BitTorrent-0.052/lib/Net/BitTorrent/Torrent/Tracker/UDP.pm",
      "package" : "Net::BitTorrent::Torrent::Tracker::UDP"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n    use strict;\n    use warnings;\n    use Carp qw[carp];\n    use Scalar::Util qw[blessed weaken refaddr];\n    use List::Util qw[sum];\n    use Socket qw[PF_INET SOMAXCONN SOCK_STREAM inet_aton pack_sockaddr_in];\n    use Fcntl qw[F_SETFL O_NONBLOCK];\n    use lib q[../../../../../lib];\n    use Net::BitTorrent::Util qw[:bencode :compact];\n    use version qw[qv];\n    our $VERSION_BASE = 50; our $UNSTABLE_RELEASE = 0; our $VERSION = sprintf(($UNSTABLE_RELEASE ? q[%.3f_%03d] : q[%.3f]), (version->new(($VERSION_BASE))->numify / 1000), $UNSTABLE_RELEASE);\n    my (@CONTENTS)\n        = \\my (%_url,   %_tier,     %resolve,\n               %_event, %_socket,   %_data_out,\n               %_peers, %_complete, %_incomplete\n        );\n    my %REGISTRY;\n\n    sub new {\n        my ($class, $args) = @_;\n        if (!$args) {\n            carp q[Net::[...]Tracker::HTTP->new({}) requires params];\n            return;\n        }\n        if ((!$args->{q[URL]}) || ($args->{q[URL]} !~ m[^http://]i)) {\n            carp q[Net::[...]Tracker::HTTP->new({}) requires a valid URL];\n            return;\n        }\n        if (   (!$args->{q[Tier]})\n            || (!$args->{q[Tier]}->isa(q[Net::BitTorrent::Torrent::Tracker])))\n        {   carp\n                q[Net::[...]Tracker::HTTP->new({}) requires a parent Tracker];\n            return;\n        }\n        my $self = bless \\$args->{q[URL]}, $class;\n        $_url{refaddr $self}        = $args->{q[URL]};\n        $_tier{refaddr $self}       = $args->{q[Tier]};\n        $_peers{refaddr $self}      = q[];\n        $_complete{refaddr $self}   = 0;\n        $_incomplete{refaddr $self} = 0;\n        weaken $_tier{refaddr $self};\n        weaken($REGISTRY{refaddr $self} = $self);\n        return $self;\n    }\n\n    sub url { my ($self) = @_; return $_url{refaddr $self}; }\n\n    sub _socket { return $_socket{refaddr +shift}; }\n    sub _tier   { return $_tier{refaddr +shift}; }\n    sub _peers  { return $_peers{refaddr +shift}; }\n    sub _client { return $_tier{refaddr +shift}->_client }\n\n    sub _announce {\n        my ($self, $event) = @_;\n\n        if (defined $event) {\n            if ($event !~ m[^(?:st(?:art|opp)|complet)ed$]) {\n                carp sprintf q[Invalid event for announce: %s], $event;\n                return;\n            }\n            $_event{refaddr $self} = $event;\n        }\n        my ($host, $port, $path)\n            = $_url{refaddr $self} =~ m{^http://([^/:]*)(?::(\\d+))?(/.*)$};\n        $port = $port ? $port : 80;\n        my $packed_host = undef;\n        if ($host\n            !~ m[^(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.]?){4})$])\n        {   my ($name, $aliases, $addrtype, $length, @addrs)\n                = gethostbyname($host)\n                or return;\n            $packed_host = $addrs[0];\n        }\n        else { $packed_host = inet_aton($host) }\n        socket($_socket{refaddr $self},\n               PF_INET, SOCK_STREAM, getprotobyname(q[tcp]))\n            or return;\n        if (not($^O eq q[MSWin32]\n                ? ioctl($_socket{refaddr $self}, 0x8004667e, pack(q[I], 1))\n                : fcntl($_socket{refaddr $self}, F_SETFL, O_NONBLOCK)\n            )\n            )\n        {   $_tier{refaddr $self}->_torrent->_event(\n                q[tracker_failure],\n                {Tracker => $self,\n                 Reason  => sprintf(\n                     q[There was a problem making an outgoing socket non-blocking: [%d] %s],\n                     $^E, $^E\n                 )\n                }\n            );\n            return;\n        }\n        my $_inet_aton = inet_aton($host);\n        if (!$_inet_aton) {\n            $_tier{refaddr $self}->_torrent->_event(\n                         q[tracker_failure],\n                         {Tracker => $self,\n                          Reason => sprintf(q[Cannot resolve host: %s], $host)\n                         }\n            );\n            return;\n        }\n        my $pack_sockaddr_in = pack_sockaddr_in($port, $_inet_aton);\n        if (!$pack_sockaddr_in) {\n            $_tier{refaddr $self}->_torrent->_event(\n                         q[tracker_failure],\n                         {Tracker => $self,\n                          Reason => sprintf(q[Cannot resolve host: %s], $host)\n                         }\n            );\n            return;\n        }\n        connect($_socket{refaddr $self}, $pack_sockaddr_in);\n        $_tier{refaddr $self}->_torrent->_event(q[tracker_connect],\n                                                {Tracker => $self,\n                                                 (defined $event\n                                                  ? (Event => $event)\n                                                  : ()\n                                                 )\n                                                }\n        );\n        my $infohash = $_tier{refaddr $self}->_torrent->infohash;\n        $infohash =~ s|(..)|\\%$1|g;\n        my %query_hash = (\n            q[info_hash] => $infohash,\n            q[peer_id]   => $_tier{refaddr $self}->_client->peerid(),\n            q[port]     => ($_tier{refaddr $self}->_client->_tcp_port() || 0),\n            q[uploaded] => $_tier{refaddr $self}->_torrent->uploaded(),\n            q[downloaded] => $_tier{refaddr $self}->_torrent->downloaded(),\n            q[left]       => (\n                $_tier{refaddr $self}->_torrent->raw_data(1)\n                    ->{q[info]}{q[piece length]} * sum(\n                    split(\n                        q[],\n                        unpack(\n                            q[b*],\n                            ($_tier{refaddr $self}->_torrent->_wanted() || q[]\n                            )\n                        )\n                    )\n                    )\n            ),\n            q[key]        => $^T,\n            q[numwant]    => 200,\n            q[compact]    => 1,\n            q[no_peer_id] => 1,\n            ($_event{refaddr $self}\n             ? (q[event] => $_event{refaddr $self})\n             : ()\n            )\n        );\n        my $url \n            = $path \n            . ($path =~ m[\\?] ? q[&] : q[?])\n            . (join q[&],\n               map { sprintf q[%s=%s], $_, $query_hash{$_} }\n                   sort keys %query_hash\n            );\n        $_data_out{refaddr $self} =\n            join(qq[\\015\\012],\n                 qq[GET $url HTTP/1.0],\n                 q[Connection: close],\n                 qq[Host: $host:$port],\n                 q[Accept: text/plain],\n                 q[Accept-Encoding:],\n                 qq[User-Agent: Net::BitTorrent/] . $Net::BitTorrent::VERSION,\n                 q[],\n                 q[]);\n        $_tier{refaddr $self}->_client->_remove_connection($self);\n        return $_tier{refaddr $self}->_client->_add_connection($self, q[wo]);\n    }\n\n    sub _rw {\n        my ($self, $read, $write, $error) = @_;\n\n        my ($actual_read, $actual_write) = (0, 0);\n        return if not defined $_tier{refaddr $self}->_client;\n        if ($error) {\n            $_tier{refaddr $self}->_client->_remove_connection($self);\n            shutdown($_socket{refaddr $self}, 2);\n            close $_socket{refaddr $self};\n            $_tier{refaddr $self}->_client->_schedule(\n                {   Time => time + 30,\n                    Code => sub {\n                        my ($s) = @_;\n                        $_tier{refaddr $s}->_shuffle;\n                        return $_tier{refaddr $s}->_announce();\n                    },\n                    Object => $self\n                }\n            );\n            return;\n        }\n        elsif ($write) {\n            $actual_write = syswrite($_socket{refaddr $self},\n                                     $_data_out{refaddr $self}, $write);\n            if (!$actual_write) {\n                $_tier{refaddr $self}->_torrent->_event(\n                       q[tracker_failure],\n                       {Tracker => $self,\n                        Reason => sprintf(q[Cannot write to tracker: %s], $^E)\n                       }\n                );\n                $_tier{refaddr $self}->_client->_remove_connection($self);\n                shutdown($_socket{refaddr $self}, 2);\n                close $_socket{refaddr $self};\n                $_tier{refaddr $self}->_client->_schedule(\n                    {   Time => time + 300,\n                        Code => sub {\n                            my ($s) = @_;\n                            $s->_tier->_shuffle;\n                            return $s->_tier->_announce();\n                        },\n                        Object => $self\n                    }\n                );\n                return;\n            }\n            $_tier{refaddr $self}->_torrent->_event(q[tracker_write],\n                                 {Tracker => $self, Length => $actual_write});\n            substr($_data_out{refaddr $self}, 0, $actual_write, q[]);\n            if (!length $_data_out{refaddr $self}) {\n                shutdown($_socket{refaddr $self}, 1);\n                $_tier{refaddr $self}->_client->_remove_connection($self);\n                $_tier{refaddr $self}->_client->_add_connection($self, q[ro]);\n            }\n        }\n        elsif ($read) {\n            $actual_read\n                = sysread($_socket{refaddr $self}, my ($data), $read, 0);\n            if (not $actual_read) {\n                $_tier{refaddr $self}->_torrent->_event(\n                      q[tracker_failure],\n                      {Tracker => $self,\n                       Reason => sprintf(q[Cannot read from tracker: %s], $^E)\n                      }\n                );\n                $_tier{refaddr $self}->_client->_remove_connection($self);\n                shutdown($_socket{refaddr $self}, 2);\n                close $_socket{refaddr $self};\n                $_tier{refaddr $self}->_client->_schedule(\n                    {   Time => time + 300,\n                        Code => sub {\n                            my ($s) = @_;\n                            $_tier{refaddr $s}->_shuffle;\n                            return $_tier{refaddr $s}->_announce();\n                        },\n                        Object => $self\n                    }\n                );\n                return;\n            }\n            else {\n                $_tier{refaddr $self}->_torrent->_event(q[tracker_read],\n                                  {Tracker => $self, Length => $actual_read});\n                $data =~ s[^.+(?:\\015?\\012){2}][]s;\n                $data = bdecode($data);\n                if ($data) {\n                    if (defined $data->{q[failure reason]}) {\n                        $_tier{refaddr $self}->_torrent->_event(\n                                         q[tracker_failure],\n                                         {Tracker => $self,\n                                          Reason => $data->{q[failure reason]}\n                                         }\n                        );\n                    }\n                    else {\n                        $_peers{refaddr $self}      = $data->{q[peers]};\n                        $_complete{refaddr $self}   = $data->{q[complete]};\n                        $_incomplete{refaddr $self} = $data->{q[incomplete]};\n                        $_tier{refaddr $self}\n                            ->_torrent->_event(q[tracker_success],\n                                        {Tracker => $self, Payload => $data});\n                        delete $_event{refaddr $self};\n                    }\n                }\n                $_tier{refaddr $self}->_client->_schedule(\n                    {   Time => (time + (defined $data->{q[interval]}\n                                         ? $data->{q[interval]}\n                                         : 1800\n                                 )\n                        ),\n                        Code =>\n                            sub { return $_tier{refaddr +shift}->_announce() }\n                        ,\n                        Object => $self\n                    }\n                );\n            }\n            $_tier{refaddr $self}->_client->_remove_connection($self);\n            shutdown($_socket{refaddr $self}, 2);\n            close $_socket{refaddr $self};\n            $_tier{refaddr $self}\n                ->_torrent->_event(q[tracker_disconnect], {Tracker => $self});\n        }\n        else {\n            $_tier{refaddr $self}->_torrent->_event(\n                                     q[tracker_failure],\n                                     {Tracker => $self,\n                                      Reason => q[Failed to read from tracker]\n                                     }\n            );\n            $_tier{refaddr $self}->_client->_schedule(\n                  { Time => time + 300,\n                    Code =>\n                        sub { return $_tier{refaddr +shift}->_announce(); },\n                    Object => $self\n                  }\n            );\n            return;\n        }\n        return ($actual_read, $actual_write);\n    }\n\n    sub as_string {\n        my ($self, $advanced) = @_;\n        my $dump = !$advanced ? $$self : sprintf <<'END',\n            $_url{refaddr $self};\n        return defined wantarray ? $dump : print STDERR qq[$dump\\n];\n    }\n\n    sub CLONE {\n        for my $_oID (keys %REGISTRY) {\n            my $_obj = $REGISTRY{$_oID};\n            my $_nID = refaddr $_obj;\n            for (@CONTENTS) {\n                $_->{$_nID} = $_->{$_oID};\n                delete $_->{$_oID};\n            }\n            weaken $_tier{$_nID};\n            weaken($REGISTRY{$_nID} = $_obj);\n            delete $REGISTRY{$_oID};\n        }\n        return 1;\n    }\n    DESTROY {\n        my ($self) = @_;\n        for (@CONTENTS) { delete $_->{refaddr $self}; }\n        return delete $REGISTRY{refaddr $self};\n    }\n    1;\n}",
      "file" : "/var/tmp/arv_xkFB3e/Net-BitTorrent-0.052/lib/Net/BitTorrent/Torrent/Tracker/HTTP.pm",
      "package" : "Net::BitTorrent::Torrent::Tracker::HTTP"
   }
]
