[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub next_block {\n    my ($self) = @_;\n    my $block = bless {}, 'Git::FastExport::Block';\n    my $fh = $self->{export_fh};\n\n    if ( eof $fh ) {\n        $self->{git}->command_close_pipe( $fh, $self->{ctx} )\n            if $self->{git} && $self->{ctx};\n        delete @{$self}{qw( export_fh ctx )};\n        return;\n    }\n\n    $block->{header} = $self->{header} ||= <$fh>;\n    chomp $block->{header};\n    ( $block->{type} ) = $block->{header} =~ /^(\\w+)/g;\n\n    local $_;\n    while (<$fh>) {\n\n        if (/^(commit|tag|reset|blob|checkpoint|progress|feature|option)\\b/) {\n            s/^progress /progress [$self->{source}] /;\n            $self->{header} = $_;\n            last;\n        }\n\n        chomp;\n\n        if (/^data (\\d+)/) {\n            my $bytes= 0 + $1;\n            if ($bytes) {\n                local $/ = \\$bytes;\n                $block->{data} = <$fh>;\n            } else {\n                $block->{data} = \"\";\n            }\n        }\n        elsif (/^(?:[MDRC] |deleteall)/) {\n            push @{ $block->{files} }, $_;\n        }\n        elsif (/^(\\w+)/) {\n            push @{ $block->{$1} }, $_;\n        }\n        else {\n\n            die \"Unexpected line:\\n$_\\n\" if !/^$/;\n            $block->{footer} .= \"\\012\";\n        }\n    }\n\n    if ( $block->{type} eq 'commit' ) {\n        ( $block->{date} )\n            = $block->{committer}[0] =~ /^committer [^>]*> (\\d+) [-+]\\d+$/g;\n    }\n\n    return $block;\n}",
      "file" : "/var/tmp/arv_bzSTBJ/Git-FastExport-0.08/lib/Git/FastExport.pm",
      "package" : "Git::FastExport"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub as_string {\n    my ($self) = @_;\n    my $string = $self->{header} . $LF;\n\n    for my $key ( @{ $fields{ $self->{type} } } ) {\n        next if !exists $self->{$key};\n        if ( $key eq 'data' ) {\n            $string\n                .= 'data ' . length( $self->{data} ) . $LF . $self->{data};\n        }\n        else {\n            $string .= \"$_$LF\" for @{ $self->{$key} };\n        }\n    }\n    return $string .= $self->{footer} || '';\n}",
      "file" : "/var/tmp/arv_bzSTBJ/Git-FastExport-0.08/lib/Git/FastExport/Block.pm",
      "package" : "Git::FastExport::Block"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub _last_alien_child {\n    my ( $self, $node, $branch, $parents ) = @_;\n    my $commits = $self->{commits};\n\n    my $from = $node->{name};\n    my $repo = $node->{repo};\n    my $old  = '';\n\n    while ( $node ne $old ) {\n        $old = $node;\n\n        return $node if ( !@{ $node->{children} } );\n\n        return $node\n            if grep { $commits->{$_}{repo} eq $repo } @{ $node->{children} };\n\n        my @valid;\n        for my $id ( @{ $node->{children} } ) {\n\n            my $peer = $commits->{$id};\n\n            next\n                if grep { !exists $peer->{parents}{ $peer->{repo} }{$_} }\n                    keys %{ $parents->{ $peer->{repo} } };\n\n            push @valid, $id;\n        }\n\n        if (@valid) {\n            my $node_id = $self->{cache}{\"$from $node->{name}\"} ||=\n                  $self->{select} eq 'last'  ? $valid[-1]\n                : $self->{select} eq 'first' ? $valid[0]\n                :                              $valid[ rand @valid ];\n            $node = $commits->{$node_id};\n        }\n    }\n\n    return $node;\n}",
      "file" : "/var/tmp/arv_bzSTBJ/Git-FastExport-0.08/lib/Git/FastExport/Stitch.pm",
      "package" : "Git::FastExport::Stitch"
   }
]
