[
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::cdf::Message::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::cdf::Message::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::cdf::Message::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'cdf');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/cdf/Message/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::cdf::Message::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap metadataIdRef id   );\n\nperfSONAR_PS::Datatypes::v2_0::cdf::Message::Metadata::Subject->mk_accessors(perfSONAR_PS::Datatypes::v2_0::cdf::Message::Metadata::Subject->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::cdf::Message::Metadata::Subject';\nuse constant  LOCALNAME => 'subject';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'cdf');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $subject = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['metadataIdRef' =>  $self->metadataIdRef],\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    return $subject;\n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_subject = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_subject && blessed $new_subject && $new_subject->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of subject  \");\n        return undef;\n    } \n    foreach my $member ($new_subject->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_subject->{$member}); \n                 } else {\n                     $mem = $new_subject->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->metadataIdRef($dom->getAttribute('metadataIdRef')) if($dom->getAttribute('metadataIdRef'));\n    $logger->debug(\" Attribute metadataIdRef= \". $self->metadataIdRef) if $self->metadataIdRef; \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n\n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/cdf/Message/Metadata/Subject.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::cdf::Message::Metadata::Subject"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::cdf::Message::Metadata::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::cdf::Message::Metadata::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::cdf::Message::Metadata::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'cdf');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/cdf/Message/Metadata/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::cdf::Message::Metadata::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::max::Message::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::max::Message::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::max::Message::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'max');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/max/Message/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::max::Message::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap metadataIdRef id   );\n\nperfSONAR_PS::Datatypes::v2_0::max::Message::Metadata::Subject->mk_accessors(perfSONAR_PS::Datatypes::v2_0::max::Message::Metadata::Subject->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::max::Message::Metadata::Subject';\nuse constant  LOCALNAME => 'subject';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'max');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $subject = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['metadataIdRef' =>  $self->metadataIdRef],\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    return $subject;\n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_subject = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_subject && blessed $new_subject && $new_subject->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of subject  \");\n        return undef;\n    } \n    foreach my $member ($new_subject->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_subject->{$member}); \n                 } else {\n                     $mem = $new_subject->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->metadataIdRef($dom->getAttribute('metadataIdRef')) if($dom->getAttribute('metadataIdRef'));\n    $logger->debug(\" Attribute metadataIdRef= \". $self->metadataIdRef) if $self->metadataIdRef; \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n\n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/max/Message/Metadata/Subject.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::max::Message::Metadata::Subject"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::max::Message::Metadata::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::max::Message::Metadata::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::max::Message::Metadata::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'max');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/max/Message/Metadata/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::max::Message::Metadata::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::mean::Message::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::mean::Message::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::mean::Message::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'mean');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/mean/Message/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::mean::Message::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap metadataIdRef id   );\n\nperfSONAR_PS::Datatypes::v2_0::mean::Message::Metadata::Subject->mk_accessors(perfSONAR_PS::Datatypes::v2_0::mean::Message::Metadata::Subject->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::mean::Message::Metadata::Subject';\nuse constant  LOCALNAME => 'subject';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'mean');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $subject = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['metadataIdRef' =>  $self->metadataIdRef],\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    return $subject;\n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_subject = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_subject && blessed $new_subject && $new_subject->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of subject  \");\n        return undef;\n    } \n    foreach my $member ($new_subject->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_subject->{$member}); \n                 } else {\n                     $mem = $new_subject->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->metadataIdRef($dom->getAttribute('metadataIdRef')) if($dom->getAttribute('metadataIdRef'));\n    $logger->debug(\" Attribute metadataIdRef= \". $self->metadataIdRef) if $self->metadataIdRef; \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n\n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/mean/Message/Metadata/Subject.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::mean::Message::Metadata::Subject"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::mean::Message::Metadata::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::mean::Message::Metadata::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::mean::Message::Metadata::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'mean');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/mean/Message/Metadata/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::mean::Message::Metadata::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap value name    text );\n\nperfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters';\nuse constant  LOCALNAME => 'parameter';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'nmwg');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameter = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['value' =>  $self->value],\n                                     ['name' =>  (($self->name    =~ m/(count|packetInterval|packetSize|ttl|valueUnits|startTime|endTime|deadline|transport|setLimit)$/)?$self->name:undef)],\n                                           ],\n                                      'text' => (!($self->value)?$self->text:undef),\n        \t             }); \n    return $parameter;\n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n    my %defined_table = (  'time' => [  'end',   'start',  ],   'metaData' => [  'transport',   'count',   'packetSize',   'ttl',   'deadline',   'packetInterval',  ],   'limit' => [  'setLimit',  ],  );\n    $query->{metaData}{count}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{metaData}{count}) || ref($query->{metaData}{count});\n    $query->{metaData}{transport}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{metaData}{transport}) || ref($query->{metaData}{transport});\n    $query->{metaData}{packetSize}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{metaData}{packetSize}) || ref($query->{metaData}{packetSize});\n    $query->{metaData}{ttl}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{metaData}{ttl}) || ref($query->{metaData}{ttl});\n    $query->{metaData}{deadline}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{metaData}{deadline}) || ref($query->{metaData}{deadline});\n    $query->{metaData}{packetInterval}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{metaData}{packetInterval}) || ref($query->{metaData}{packetInterval});\n    $query->{time}{start}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{time}{start}) || ref($query->{time}{start});\n    $query->{time}{end}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{time}{end}) || ref($query->{time}{end});\n    $query->{limit}{setLimit}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{limit}{setLimit}) || ref($query->{limit}{setLimit});\n    $query->{metaData}{count}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{metaData}{count}) || ref($query->{metaData}{count});\n    $query->{metaData}{transport}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{metaData}{transport}) || ref($query->{metaData}{transport});\n    $query->{metaData}{packetSize}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{metaData}{packetSize}) || ref($query->{metaData}{packetSize});\n    $query->{metaData}{ttl}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{metaData}{ttl}) || ref($query->{metaData}{ttl});\n    $query->{metaData}{deadline}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{metaData}{deadline}) || ref($query->{metaData}{deadline});\n    $query->{metaData}{packetInterval}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{metaData}{packetInterval}) || ref($query->{metaData}{packetInterval});\n    $query->{time}{start}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{time}{start}) || ref($query->{time}{start});\n    $query->{time}{end}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{time}{end}) || ref($query->{time}{end});\n    $query->{limit}{setLimit}= [ 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ] if!(defined $query->{limit}{setLimit}) || ref($query->{limit}{setLimit});\n    eval { \n        foreach my $table  ( keys %defined_table) {  \n            foreach my $entry (@{$defined_table{$table}}) {  \n                if(ref($query->{$table}{$entry}) eq 'ARRAY') {\n                    foreach my $classes (@{$query->{$table}{$entry}}) {  \n                        if($classes && $classes eq 'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters' ) { \n                            if    ($self->value && ( (  ( ($self->name eq 'count')  && $entry eq 'count') or  ( ($self->name eq 'transport')  && $entry eq 'transport') or  ( ($self->name eq 'packetSize')  && $entry eq 'packetSize') or  ( ($self->name eq 'ttl')  && $entry eq 'ttl') or  ( ($self->name eq 'deadline')  && $entry eq 'deadline') or  ( ($self->name eq 'packetInterval')  && $entry eq 'packetInterval')) || (  ( ($self->name eq 'startTime')  && $entry eq 'start') or  ( ($self->name eq 'endTime')  && $entry eq 'end')) || (  ( ($self->name eq 'setLimit')  && $entry eq 'setLimit')) )) {\n                                $query->{$table}{$entry} =  $self->value;\n                                $logger->debug(\" Got value for SQL query $table.$entry: \" . $self->value);\n                                last;  \n                            }\n                            elsif ($self->text && ( (  ( ($self->name eq 'count')  && $entry eq 'count') or  ( ($self->name eq 'transport')  && $entry eq 'transport') or  ( ($self->name eq 'packetSize')  && $entry eq 'packetSize') or  ( ($self->name eq 'ttl')  && $entry eq 'ttl') or  ( ($self->name eq 'deadline')  && $entry eq 'deadline') or  ( ($self->name eq 'packetInterval')  && $entry eq 'packetInterval')) || (  ( ($self->name eq 'startTime')  && $entry eq 'start') or  ( ($self->name eq 'endTime')  && $entry eq 'end')) || (  ( ($self->name eq 'setLimit')  && $entry eq 'setLimit')) )) {\n                                $query->{$table}{$entry} =  $self->text;\n                                $logger->debug(\" Got value for SQL query $table.$entry: \" . $self->text);\n                                last;  \n                            }\n                         }\n                     }\n                 }\n             }\n         }\n    }; \n    if ($@) { $logger->logcroak(\" SQL query building is failed  here \" . $@)};\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameter = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameter && blessed $new_parameter && $new_parameter->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameter  \");\n        return undef;\n    } \n    foreach my $member ($new_parameter->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameter->{$member}); \n                 } else {\n                     $mem = $new_parameter->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->value($dom->getAttribute('value')) if($dom->getAttribute('value'));\n    $logger->debug(\" Attribute value= \". $self->value) if $self->value; \n    $self->name($dom->getAttribute('name')) if($dom->getAttribute('name') && ($dom->getAttribute('name')   =~ m/(count|packetInterval|packetSize|ttl|valueUnits|startTime|endTime|deadline|transport|setLimit)$/));\n    $logger->debug(\" Attribute name= \". $self->name) if $self->name; \n    $self->text($dom->textContent) if(!($self->value) && $dom->textContent);\n\n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/nmwg/Message/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap metadataIdRef id   );\n\nperfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Subject->mk_accessors(perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Subject->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Subject';\nuse constant  LOCALNAME => 'subject';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'nmwg');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $subject = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['metadataIdRef' =>  $self->metadataIdRef],\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    return $subject;\n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_subject = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_subject && blessed $new_subject && $new_subject->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of subject  \");\n        return undef;\n    } \n    foreach my $member ($new_subject->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_subject->{$member}); \n                 } else {\n                     $mem = $new_subject->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->metadataIdRef($dom->getAttribute('metadataIdRef')) if($dom->getAttribute('metadataIdRef'));\n    $logger->debug(\" Attribute metadataIdRef= \". $self->metadataIdRef) if $self->metadataIdRef; \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n\n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/nmwg/Message/Metadata/Subject.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Subject"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::median::Message::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::median::Message::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::median::Message::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'median');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/median/Message/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::median::Message::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap metadataIdRef id   );\n\nperfSONAR_PS::Datatypes::v2_0::median::Message::Metadata::Subject->mk_accessors(perfSONAR_PS::Datatypes::v2_0::median::Message::Metadata::Subject->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::median::Message::Metadata::Subject';\nuse constant  LOCALNAME => 'subject';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'median');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $subject = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['metadataIdRef' =>  $self->metadataIdRef],\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    return $subject;\n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_subject = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_subject && blessed $new_subject && $new_subject->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of subject  \");\n        return undef;\n    } \n    foreach my $member ($new_subject->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_subject->{$member}); \n                 } else {\n                     $mem = $new_subject->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->metadataIdRef($dom->getAttribute('metadataIdRef')) if($dom->getAttribute('metadataIdRef'));\n    $logger->debug(\" Attribute metadataIdRef= \". $self->metadataIdRef) if $self->metadataIdRef; \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n\n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/median/Message/Metadata/Subject.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::median::Message::Metadata::Subject"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::median::Message::Metadata::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::median::Message::Metadata::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::median::Message::Metadata::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'median');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/median/Message/Metadata/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::median::Message::Metadata::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::min::Message::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::min::Message::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::min::Message::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'min');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/min/Message/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::min::Message::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap metadataIdRef id   );\n\nperfSONAR_PS::Datatypes::v2_0::min::Message::Metadata::Subject->mk_accessors(perfSONAR_PS::Datatypes::v2_0::min::Message::Metadata::Subject->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::min::Message::Metadata::Subject';\nuse constant  LOCALNAME => 'subject';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'min');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $subject = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['metadataIdRef' =>  $self->metadataIdRef],\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    return $subject;\n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_subject = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_subject && blessed $new_subject && $new_subject->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of subject  \");\n        return undef;\n    } \n    foreach my $member ($new_subject->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_subject->{$member}); \n                 } else {\n                     $mem = $new_subject->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->metadataIdRef($dom->getAttribute('metadataIdRef')) if($dom->getAttribute('metadataIdRef'));\n    $logger->debug(\" Attribute metadataIdRef= \". $self->metadataIdRef) if $self->metadataIdRef; \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n\n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/min/Message/Metadata/Subject.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::min::Message::Metadata::Subject"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::min::Message::Metadata::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::min::Message::Metadata::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::min::Message::Metadata::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'min');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/min/Message/Metadata/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::min::Message::Metadata::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap timeType ttl numBytes value name valueUnits timeValue seqNum   );\n\nperfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime->mk_accessors(perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime';\nuse constant  LOCALNAME => 'commonTime';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'pinger');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $commonTime = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['timeType' =>  $self->timeType],\n                                               ['ttl' =>  $self->ttl],\n                                               ['numBytes' =>  $self->numBytes],\n                                               ['value' =>  $self->value],\n                                     ['name' =>  (($self->name    =~ m/(minRtt|maxRtt|meanRtt|medianRtt|lossPercent|clp|minIpd|maxIpd|iqrIpd|meanIpd|duplicates|outOfOrder)$/)?$self->name:undef)],\n                                               ['valueUnits' =>  $self->valueUnits],\n                                               ['timeValue' =>  $self->timeValue],\n                                               ['seqNum' =>  $self->seqNum],\n                                           ],\n        \t             }); \n    return $commonTime;\n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n    my %defined_table = (  'data' => [  'minRtt',   'ttl',   'numBytes',   'outOfOrder',   'maxRtt',   'rtts',   'clp',   'medianRtt',   'meanRtt',   'duplicates',   'maxIpd',   'meanIpd',   'minIpd',   'seqNums',   'lossPercent',   'iqrIpd',  ],  );\n    $query->{data}{numBytes}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{numBytes}) || ref($query->{data}{numBytes});\n    $query->{data}{ttl}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{ttl}) || ref($query->{data}{ttl});\n    $query->{data}{minRtt}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{minRtt}) || ref($query->{data}{minRtt});\n    $query->{data}{maxRtt}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{maxRtt}) || ref($query->{data}{maxRtt});\n    $query->{data}{outOfOrder}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{outOfOrder}) || ref($query->{data}{outOfOrder});\n    $query->{data}{medianRtt}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{medianRtt}) || ref($query->{data}{medianRtt});\n    $query->{data}{clp}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{clp}) || ref($query->{data}{clp});\n    $query->{data}{meanRtt}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{meanRtt}) || ref($query->{data}{meanRtt});\n    $query->{data}{duplicates}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{duplicates}) || ref($query->{data}{duplicates});\n    $query->{data}{maxIpd}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{maxIpd}) || ref($query->{data}{maxIpd});\n    $query->{data}{minIpd}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{minIpd}) || ref($query->{data}{minIpd});\n    $query->{data}{meanIpd}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{meanIpd}) || ref($query->{data}{meanIpd});\n    $query->{data}{iqrIpd}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{iqrIpd}) || ref($query->{data}{iqrIpd});\n    $query->{data}{lossPercent}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{lossPercent}) || ref($query->{data}{lossPercent});\n    $query->{data}{minRtt}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{minRtt}) || ref($query->{data}{minRtt});\n    $query->{data}{maxRtt}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{maxRtt}) || ref($query->{data}{maxRtt});\n    $query->{data}{outOfOrder}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{outOfOrder}) || ref($query->{data}{outOfOrder});\n    $query->{data}{rtts}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{rtts}) || ref($query->{data}{rtts});\n    $query->{data}{medianRtt}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{medianRtt}) || ref($query->{data}{medianRtt});\n    $query->{data}{clp}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{clp}) || ref($query->{data}{clp});\n    $query->{data}{meanRtt}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{meanRtt}) || ref($query->{data}{meanRtt});\n    $query->{data}{maxIpd}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{maxIpd}) || ref($query->{data}{maxIpd});\n    $query->{data}{duplicates}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{duplicates}) || ref($query->{data}{duplicates});\n    $query->{data}{minIpd}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{minIpd}) || ref($query->{data}{minIpd});\n    $query->{data}{meanIpd}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{meanIpd}) || ref($query->{data}{meanIpd});\n    $query->{data}{iqrIpd}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{iqrIpd}) || ref($query->{data}{iqrIpd});\n    $query->{data}{lossPercent}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{lossPercent}) || ref($query->{data}{lossPercent});\n    $query->{data}{seqNums}= [ 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ] if!(defined $query->{data}{seqNums}) || ref($query->{data}{seqNums});\n    eval { \n        foreach my $table  ( keys %defined_table) {  \n            foreach my $entry (@{$defined_table{$table}}) {  \n                if(ref($query->{$table}{$entry}) eq 'ARRAY') {\n                    foreach my $classes (@{$query->{$table}{$entry}}) {  \n                        if($classes && $classes eq 'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime' ) { \n                            if    ($self->ttl && ( (  ($entry eq 'ttl')) )) {\n                                $query->{$table}{$entry} =  $self->ttl;\n                                $logger->debug(\" Got value for SQL query $table.$entry: \" . $self->ttl);\n                                last;  \n                            }\n                            elsif ($self->numBytes && ( (  ($entry eq 'numBytes')) )) {\n                                $query->{$table}{$entry} =  $self->numBytes;\n                                $logger->debug(\" Got value for SQL query $table.$entry: \" . $self->numBytes);\n                                last;  \n                            }\n                            elsif ($self->value && ( (  ( ($self->name eq 'minRtt')  && $entry eq 'minRtt') or  ( ($self->name eq 'maxRtt')  && $entry eq 'maxRtt') or  ( ($self->name eq 'outOfOrder')  && $entry eq 'outOfOrder') or  ($entry eq 'rtts') or  ( ($self->name eq 'medianRtt')  && $entry eq 'medianRtt') or  ( ($self->name eq 'clp')  && $entry eq 'clp') or  ( ($self->name eq 'meanRtt')  && $entry eq 'meanRtt') or  ( ($self->name eq 'maxIpd')  && $entry eq 'maxIpd') or  ( ($self->name eq 'duplicates')  && $entry eq 'duplicates') or  ( ($self->name eq 'minIpd')  && $entry eq 'minIpd') or  ( ($self->name eq 'meanIpd')  && $entry eq 'meanIpd') or  ( ($self->name eq 'iqrIpd')  && $entry eq 'iqrIpd') or  ( ($self->name eq 'lossPercent')  && $entry eq 'lossPercent')) )) {\n                                $query->{$table}{$entry} =  $self->value;\n                                $logger->debug(\" Got value for SQL query $table.$entry: \" . $self->value);\n                                last;  \n                            }\n                            elsif ($self->seqNum && ( (  ($entry eq 'seqNums')) )) {\n                                $query->{$table}{$entry} =  $self->seqNum;\n                                $logger->debug(\" Got value for SQL query $table.$entry: \" . $self->seqNum);\n                                last;  \n                            }\n                            elsif ($self->text && ( (  ( ($self->name eq 'minRtt')  && $entry eq 'minRtt') or  ( ($self->name eq 'maxRtt')  && $entry eq 'maxRtt') or  ( ($self->name eq 'outOfOrder')  && $entry eq 'outOfOrder') or  ( ($self->name eq 'medianRtt')  && $entry eq 'medianRtt') or  ( ($self->name eq 'clp')  && $entry eq 'clp') or  ( ($self->name eq 'meanRtt')  && $entry eq 'meanRtt') or  ( ($self->name eq 'duplicates')  && $entry eq 'duplicates') or  ( ($self->name eq 'maxIpd')  && $entry eq 'maxIpd') or  ( ($self->name eq 'minIpd')  && $entry eq 'minIpd') or  ( ($self->name eq 'meanIpd')  && $entry eq 'meanIpd') or  ( ($self->name eq 'iqrIpd')  && $entry eq 'iqrIpd') or  ( ($self->name eq 'lossPercent')  && $entry eq 'lossPercent')) )) {\n                                $query->{$table}{$entry} =  $self->text;\n                                $logger->debug(\" Got value for SQL query $table.$entry: \" . $self->text);\n                                last;  \n                            }\n                         }\n                     }\n                 }\n             }\n         }\n    }; \n    if ($@) { $logger->logcroak(\" SQL query building is failed  here \" . $@)};\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_commonTime = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_commonTime && blessed $new_commonTime && $new_commonTime->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of commonTime  \");\n        return undef;\n    } \n    foreach my $member ($new_commonTime->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_commonTime->{$member}); \n                 } else {\n                     $mem = $new_commonTime->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->timeType($dom->getAttribute('timeType')) if($dom->getAttribute('timeType'));\n    $logger->debug(\" Attribute timeType= \". $self->timeType) if $self->timeType; \n    $self->ttl($dom->getAttribute('ttl')) if($dom->getAttribute('ttl'));\n    $logger->debug(\" Attribute ttl= \". $self->ttl) if $self->ttl; \n    $self->numBytes($dom->getAttribute('numBytes')) if($dom->getAttribute('numBytes'));\n    $logger->debug(\" Attribute numBytes= \". $self->numBytes) if $self->numBytes; \n    $self->value($dom->getAttribute('value')) if($dom->getAttribute('value'));\n    $logger->debug(\" Attribute value= \". $self->value) if $self->value; \n    $self->name($dom->getAttribute('name')) if($dom->getAttribute('name') && ($dom->getAttribute('name')   =~ m/(minRtt|maxRtt|meanRtt|medianRtt|lossPercent|clp|minIpd|maxIpd|iqrIpd|meanIpd|duplicates|outOfOrder)$/));\n    $logger->debug(\" Attribute name= \". $self->name) if $self->name; \n    $self->valueUnits($dom->getAttribute('valueUnits')) if($dom->getAttribute('valueUnits'));\n    $logger->debug(\" Attribute valueUnits= \". $self->valueUnits) if $self->valueUnits; \n    $self->timeValue($dom->getAttribute('timeValue')) if($dom->getAttribute('timeValue'));\n    $logger->debug(\" Attribute timeValue= \". $self->timeValue) if $self->timeValue; \n    $self->seqNum($dom->getAttribute('seqNum')) if($dom->getAttribute('seqNum'));\n    $logger->debug(\" Attribute seqNum= \". $self->seqNum) if $self->seqNum; \n\n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/pinger/Message/Data/CommonTime.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::CommonTime"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Data::Key::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::Key::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::Key::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::Key::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'pinger');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Data::Key::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/pinger/Message/Data/Key/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::pinger::Message::Data::Key::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Key::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::pinger::Message::Metadata::Key::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::pinger::Message::Metadata::Key::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::pinger::Message::Metadata::Key::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'pinger');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Key::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/pinger/Message/Metadata/Key/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::pinger::Message::Metadata::Key::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::select::Message::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::select::Message::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::select::Message::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'select');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/select/Message/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::select::Message::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::histogram::Message::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::histogram::Message::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::histogram::Message::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'histogram');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/histogram/Message/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::histogram::Message::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap metadataIdRef id   );\n\nperfSONAR_PS::Datatypes::v2_0::histogram::Message::Metadata::Subject->mk_accessors(perfSONAR_PS::Datatypes::v2_0::histogram::Message::Metadata::Subject->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::histogram::Message::Metadata::Subject';\nuse constant  LOCALNAME => 'subject';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'histogram');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $subject = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['metadataIdRef' =>  $self->metadataIdRef],\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    return $subject;\n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_subject = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_subject && blessed $new_subject && $new_subject->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of subject  \");\n        return undef;\n    } \n    foreach my $member ($new_subject->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_subject->{$member}); \n                 } else {\n                     $mem = $new_subject->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->metadataIdRef($dom->getAttribute('metadataIdRef')) if($dom->getAttribute('metadataIdRef'));\n    $logger->debug(\" Attribute metadataIdRef= \". $self->metadataIdRef) if $self->metadataIdRef; \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n\n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/histogram/Message/Metadata/Subject.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::histogram::Message::Metadata::Subject"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::histogram::Message::Metadata::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::histogram::Message::Metadata::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::histogram::Message::Metadata::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'histogram');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/histogram/Message/Metadata/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::histogram::Message::Metadata::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::average::Message::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::average::Message::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::average::Message::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'average');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/average/Message/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::average::Message::Parameters"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap metadataIdRef id   );\n\nperfSONAR_PS::Datatypes::v2_0::average::Message::Metadata::Subject->mk_accessors(perfSONAR_PS::Datatypes::v2_0::average::Message::Metadata::Subject->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::average::Message::Metadata::Subject';\nuse constant  LOCALNAME => 'subject';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'average');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $subject = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['metadataIdRef' =>  $self->metadataIdRef],\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    return $subject;\n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_subject = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_subject && blessed $new_subject && $new_subject->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of subject  \");\n        return undef;\n    } \n    foreach my $member ($new_subject->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_subject->{$member}); \n                 } else {\n                     $mem = $new_subject->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    return undef;\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->metadataIdRef($dom->getAttribute('metadataIdRef')) if($dom->getAttribute('metadataIdRef'));\n    $logger->debug(\" Attribute metadataIdRef= \". $self->metadataIdRef) if $self->metadataIdRef; \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n\n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/average/Message/Metadata/Subject.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::average::Message::Metadata::Subject"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n \nuse strict;\nuse warnings;\nuse XML::LibXML;\nuse Scalar::Util qw(blessed);\nuse Log::Log4perl qw(get_logger); \nuse perfSONAR_PS::Datatypes::Element qw(getElement);\nuse perfSONAR_PS::Datatypes::Namespace;\nuse perfSONAR_PS::Datatypes::NSMap;\nuse perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter;\nuse Class::Accessor;\nuse Class::Fields;\nuse base qw(Class::Accessor Class::Fields);\nuse fields qw(nsmap idmap refidmap id parameter  );\n\nperfSONAR_PS::Datatypes::v2_0::average::Message::Metadata::Parameters->mk_accessors(perfSONAR_PS::Datatypes::v2_0::average::Message::Metadata::Parameters->show_fields('Public'));\n  \n\nuse constant  CLASSPATH =>  'perfSONAR_PS::Datatypes::v2_0::average::Message::Metadata::Parameters';\nuse constant  LOCALNAME => 'parameters';\n \t       \nsub new { \n    my $that = shift;\n    my $param = shift;\n \n    my $logger  = get_logger( CLASSPATH ); \n    my $class = ref($that) || $that;\n    my $self =  fields::new($class );\n    $self->nsmap(perfSONAR_PS::Datatypes::NSMap->new()); \n    $self->nsmap->mapname( LOCALNAME, 'average');\n    \n    if($param) {\n        if(blessed $param && $param->can('getName')  && ($param->getName =~ m/(${\\LOCALNAME})$/x) ) {\n            return  $self->fromDOM($param);  \n\t      \n        } elsif(ref($param) ne 'HASH')   {\n            $logger->error(\"ONLY hash ref accepted as param \" . $param ); \n            return undef;\n        }\n\tif($param->{xml}) {\n\t     my $parser = XML::LibXML->new();\n             my $dom;\n             eval {\n                  my $doc = $parser->parse_string( $param->{xml});\n\t\t  $dom = $doc->getDocumentElement;\n             };\n             if($@) {\n                 $logger->error(\" Failed to parse XML :\" . $param->{xml} . \" \\n ERROR: \\n\" . $@);\n                return undef;\n             }\n             return  $self->fromDOM( $dom );  \n\t} \n        $logger->debug(\"Parsing parameters: \" . (join \" : \", keys %{$param}));\n     \n        no strict 'refs';\n        map { $self->$_ ( $param->{$_} ) if $self->can($_)} keys %{$param}; \n        use strict;     \n   \n       $logger->debug(\"Done \");     \n    }  \n    return $self;\n}\n\nsub AUTOLOAD {}  \n\nsub DESTROY {\n    my $self = shift;\n    $self->SUPER::DESTROY  if $self->can(\"SUPER::DESTROY\");\n}\n \n \nsub getDOM {\n    my $self = shift;\n    my $parent = shift; \n    my $logger  = get_logger( CLASSPATH ); \n    my $parameters = getElement({name =>   LOCALNAME, parent => $parent , ns => [$self->nsmap->mapname( LOCALNAME )],\n                             attributes => [\n\n                                               ['id' =>  $self->id],\n                                           ],\n        \t             }); \n    if($self->parameter && ref($self->parameter) eq 'ARRAY' ) {\n        foreach my $subel (@{$self->parameter}) { \n            if(blessed  $subel  &&  $subel->can(\"getDOM\")) { \n                 my  $subDOM =  $subel->getDOM($parameters);\n                $subDOM?$parameters->appendChild($subDOM):$logger->error(\"Failed to append  parameter elements  with value: \" .  $subDOM->toString ); \n            }\n         }\n    }\n    return $parameters;\n}\n  \n\nsub addParameter {\n    my $self = shift;\n    my $new = shift;\n    my $logger  = get_logger( CLASSPATH ); \n   \n    $self->parameter && ref($self->parameter) eq 'ARRAY'?push @{$self->parameter}, $new:$self->parameter([$new]); \n    $logger->debug(\"Added new to parameter\"); \n    $self->buildIdMap; \n    $self->buildRefIdMap; \n    return $self->parameter;\n}\n\n\nsub removeParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->idmap->{parameter} ) { \n        $self->parameter->[$self->idmap->{parameter}{$id}] = undef; \n\tmy @tmp =  grep { defined $_ } @{$self->parameter};  \n\t$self->parameter([@tmp]);\n\t$self->buildRefIdMap; \n\t$self->buildIdMap; \n\t\n    } elsif(!ref($self->parameter)  || ref($self->parameter) ne 'ARRAY')  {\n        $logger->warn(\"Failed to remove  element because parameter not an array for non-existent id:$id\");  \n    } else {\n        $logger->warn(\"Failed to remove element for non-existant id:$id\"); \n        return undef;\n    } \n}   \n\nsub getParameterByMetadataIdRef {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY' && $self->refidmap->{parameter}) {\n        my $parameter = $self->parameter->[$self->refidmap->{parameter}{$id}];\n\treturn ($parameter->can(\"metadataIdRef\") &&   $parameter->metadataIdRef eq  $id)?$parameter:undef; \n    } elsif($self->parameter && (!ref($self->parameter) || \n                                    (ref($self->parameter) ne 'ARRAY' &&\n\t                                 blessed $self->parameter && $self->parameter->can(\"metadataIdRef\") &&\n\t\t\t\t\t $self->parameter->metadataIdRef eq  $id)))  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent metadataIdRef:$id\"); \n    return;\n    \n}\n\n\nsub getParameterById {\n    my $self = shift;\n    my $id = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    if(ref($self->parameter) eq 'ARRAY') {\n        return $self->parameter->[$self->idmap->{parameter}{$id}];\n    } elsif(!ref($self->parameter) || ref($self->parameter) ne 'ARRAY')  {\n        return $self->parameter;\n    }  \n    $logger->warn(\"Requested element for non-existent id:$id\"); \n    return;\n    \n}\n\n\nsub  querySQL {\n    my $self = shift;\n    my $query = shift; \n    my $logger  = get_logger( CLASSPATH );\n     \n  foreach my $subname (qw/parameter/) {\n        if($self->{$subname} && (ref($self->{$subname}) eq 'ARRAY' ||  blessed $self->{$subname}))   {\n          my @array = ref($self->{$subname}) eq 'ARRAY'?@{$self->{$subname}}:($self->{$subname});\n\t  foreach my $el  (@array) {\n\t     if(blessed  $el  &&  $el->can(\"querySQL\"))  {\n\t\t  $el->querySQL($query);\t\t \n\t\t   $logger->debug(\"Quering parameters  for subclass $subname\");\n\t     } else {\n\t        $logger->error(\" Failed for parameters Unblessed member or querySQL is not implemented by subclass $subname\");\n\t     }\n\t  }  \n       }\n    }\t\n    return $query;\n}\n\n\n\nsub merge {\n    my $self = shift;\n    my $new_parameters = shift;\n    my $logger  = get_logger( CLASSPATH );  \n    unless($new_parameters && blessed $new_parameters && $new_parameters->can(\"getDOM\")) {\n        $logger->error(\" Please supply defined object of parameters  \");\n        return undef;\n    } \n    foreach my $member ($new_parameters->show_fields) {\n        if($self->can($member)) {\n\t     my $mergeList = $self->{$member};\n\t     $mergeList = [ $self->{$member} ]  unless(ref($mergeList) eq 'ARRAY');\n\t     foreach my $mem (@{ $mergeList }) {\n\t         if(blessed $mem && $mem->can(\"merge\")) {\n\t             $mem->merge($new_parameters->{$member}); \n                 } else {\n                     $mem = $new_parameters->{$member};\n\t         }\n\t     }\n\t} else {\n\t    $logger->error(\" This field $member,  found in supplied  metadata is not supported by MetaData class\");\n\t    return undef;\n        }\n    }\n    return $self;\n} \n \n\nsub  buildIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el && $el->can(\"id\") &&  $el->id)  { \n                $map{$field}{$el->id} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->idmap(\\%map);\n}\n\nsub  buildRefIdMap {\n    my $self = shift;\n    my %map = (); \n    my $logger  = get_logger( CLASSPATH );\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        my $i = 0;\n        foreach my $el ( @array)  {\n            if($el && blessed $el  && $el->can(\"metadataIdRef\") &&  $el->metadataIdRef )  { \n                $map{$field}{$el->metadataIdRef} = $i;   \n            }\n            $i++;\n        }\n    }\n    return $self->refidmap(\\%map);\n}\n\nsub asString {\n    my $self = shift;\n    my $dom = $self->getDOM();\n    return $dom->toString();\n}\n\n\nsub registerNamespaces {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH );\n    my $nsids = shift;\n    my $local_nss = {reverse %{$self->nsmap->mapname}};\n    unless($nsids) {\n        $nsids =  $local_nss;\n    }  else {\n        %{$nsids} = ( %{$local_nss},  %{$nsids});\n    }\n    foreach my $field (qw/parameter/) {\n        my @array = ref($self->{$field}) eq 'ARRAY'?@{$self->{$field}}:($self->{$field});\n        foreach my $el ( @array)  {\n            if(blessed $el &&   $el->can(\"registerNamespaces\") )  { \n                my $fromNSmap =  $el->registerNamespaces($nsids); \n                my %ns_idmap =   %{$fromNSmap};  \n                foreach my $ns ( keys %ns_idmap)  {\n                      $nsids->{$ns}++\n                }\n            }\n        }\n    }\n    return     $nsids;\n}\n\nsub fromDOM {\n    my $self = shift;\n    my $logger  = get_logger( CLASSPATH ); \n    my $dom = shift;\n     \n    $self->id($dom->getAttribute('id')) if($dom->getAttribute('id'));\n    $logger->debug(\" Attribute id= \". $self->id) if $self->id; \n    foreach my $childnode ($dom->childNodes) { \n        my  $getname  = $childnode->getName;\n        my ($nsid, $tagname) = split ':',  $getname ; \n        unless($nsid && $tagname) {   \n            next;\n        }\n        if ($tagname eq  'parameter' && $nsid eq 'nmwg' && $self->can($tagname)) { \n           my $element = undef;\n           eval {\n               $element = perfSONAR_PS::Datatypes::v2_0::nmwg::Message::Metadata::Parameters::Parameter->new($childnode) \n           };\n           unless(!$@ && $element  && blessed $element) {\n               $logger->error(\" Failed to load and add  Parameter : \" . $dom->toString . \" error: \" . $@);\n               return undef;\n           }\n           ($self->parameter && ref($self->parameter) eq 'ARRAY')?push @{$self->parameter}, $element:$self->parameter([$element]);; \n        }      \n    }\n  $self->buildIdMap;\n $self->buildRefIdMap;\n $self->registerNamespaces;\n  \n return $self;\n}\n\n1; \n}",
      "file" : "/var/tmp/arv_AzDzNI/perfSONAR_PS-Services-PingER-0.09/lib/perfSONAR_PS/Datatypes/v2_0/average/Message/Metadata/Parameters.pm",
      "package" : "perfSONAR_PS::Datatypes::v2_0::average::Message::Metadata::Parameters"
   }
]
