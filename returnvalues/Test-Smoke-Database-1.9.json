[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub add_to_db {\n  my ($self, $ref)=@_;\n  return if (!ref($ref) || ref($ref) ne 'HASH' || !$ref->{os});\n  my ($nbco, $nbcf, $nbcm, $nbcc)=(0,0,0,0);\n  my ($cc,$ccf,$f,$r) = ($ref->{cc}||' ',$ref->{ccver} || ' ',\n\t\t\t $ref->{failure},$ref->{report});\n  foreach ($cc,$ccf,$f,$r) { s/'/\\\\'/g if ($_); }\n  $ref->{osver}=~s/[\\s]+$//g;\n  foreach my $c (keys %{$$ref{build}}) {\n    foreach (split(/ /,$$ref{build}{$c})) {\n      if ($_ eq 'O') { $nbco++; }\n      elsif ($_ eq 'F') { $nbcf++; }\n      elsif ($_ eq 'm') { $nbcm++; }\n      elsif ($_ eq 'c') { $nbcc++; }\n    }\n  }\n  my $pass = 1;\n  $pass = 0 if ($ref->{failure});\n  printf( \"\\t =>%25s %s %5d (%s)\\n\",\n\t  $ref->{os}.\" \".$ref->{osver}, ($pass ? \"PASS\" : \"FAIL\"),\n\t  $ref->{smoke}, basename($ref->{file}))\n    if ($self->{opts}->{verbose});\n  my $v2 = ($ref->{matrix} ? join(\"|\", @{$ref->{matrix}}) : '');\n  my $req = \"INSERT INTO builds(\";\n  $req.= 'id,' if ($ref->{id});\n  $req.= \"os,osver,cc,ccver,date,smoke,nbc,nbco,nbcf,nbcm,nbcc,nbte,archi,matrix) \".\n    \"VALUES (\";\n  $req.= \"$ref->{id},\" if ($ref->{id});\n  $req.= <<EOF;\n\n  print $req,\"\\n\" if ($self->{opts}->{debug});\n  my $st = $self->{DBH}->prepare($req);\n  if (!$st->execute) {\n    print STDERR \"SQL: $req\\n\", Data::Dumper->Dump([$ref]);\n    cluck($DBI::errstr);\n    return;\n  }\n  my $id =  $st->{'mysql_insertid'};\n  $ref->{id}=$id;\n  print STDERR Data::Dumper->Dump([$ref]) if ($self->{opts}->{debug});\n\n  $r = ' ' if (!$r);\n  $f = ' ' if (!$f);\n  $req = <<EOF;\n    $self->rundb($req,1) || print STDERR \"On $req\\n\";\n\n  foreach my $config (keys %{$$ref{build}}) {\n    my $co = $config; $co=~s/'/\\\\'/g;\n    my $v = $$ref{build}{$config};\n    $v=~s/'/\\\\'/g;\n    $req = <<EOF;\n    $self->rundb($req,1) or print STDERR \"On $req\\n\";\n  }\n  return ($DBI::errstr ? 0 : 1);\n}",
      "file" : "/var/tmp/arv_4NSUDg/Test-Smoke-Database-1.9/lib/Test/Smoke/Database.pm",
      "package" : "Test::Smoke::Database"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub graph_cpan {\n  my ($name, $title, %perl)=@_;\n  foreach my $r (keys %perl) {\n    if ($perl{$r} <2) {\n      $perl{\"others\"}+=$perl{$r};\n      delete $perl{$r};\n    }\n  }\n  my @l = sort { $perl{$a} <=> $perl{$b} } keys %perl;\n  my @l2;\n  foreach (@l) { push(@l2, $perl{$_}); }\n  my $ref = [ \\@l, \\@l2];\n  my $my_graph = GD::Graph::bars->new(1000,300);\n  $my_graph->set( \n\t\t title           => $title,\n\t\t show_values => 1,\n\t\t axis_space => 20,\n\t\t t_margin => 40,\n\t\t b_margin => 20,\n\t\t box_axis => 0,\n\t\t transparent     => 0,\n\t\t shadowclr       => 'dred',\n\t\t legend_spacing => 40,\n\t\t shadow_depth    => 4,\n\t\t transparent     => 0,\n\t\t bar_spacing => 20,\n\t\t values_format       => \"%2.1f %%\"\n\t\t)\n    or warn $my_graph->error;\n  go($my_graph, $ref, \"cpan/$name\");\n}",
      "file" : "/var/tmp/arv_4NSUDg/Test-Smoke-Database-1.9/lib/Test/Smoke/Database/Graph.pm",
      "package" : "Test::Smoke::Database::Graph"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub parse_rpt {\n  my $file = shift;\n  my ($nbr,$fail,$col,$content)=(0);\n  return if (!$file);\n  if (!-r $file) { warn \"Can't found $file\"; return; }\n  open(FILE,$file) or die \"Can't read $file:$!\\n\";\n  my %h = ( file => $file );\n  my @content = <FILE>;\n  close(FILE);\n  my $r = 0;\n  my $cont;\n  foreach my $l (@content) {\n    chomp($l);\n    $l=~s/=3D/=/g;\n    if ($l=~/=$/) { chop($l); $r=1; }\n    if ($r) { $cont.=$l; $r=0; }\n    else { $cont.=$l.\"\\n\"; }\n  }\n  return undef if (!$cont);\n  my $irix = 0;\n  my $re = qr/(?:\\w|-|\\?) /;\n  foreach my $l (split(/\\n/, $cont)) {\n    $content.=$l;\n    chomp($l);\n    $nbr++ if ($l=~/^>/);\n    if ($l=~/^From:/ && $l=~/Brand/) { $col=-1; }\n    elsif ($l=~/^From:/ && $l=~/Alian/) { $col=-3; }\n    elsif ($l=~/^Return-Path: <h.m.brand\\@hccnet.nl>/) { $col=-1; }\n    elsif ($l=~/^Subject: Re:/) { return -2; }\n    elsif (($l=~/Automated smoke report for patch (\\d+) on  - $/) or\n\t   ($l=~/Automated smoke report for patch (\\d*) on  -  \\(\\)$/)) {\n      return -2;\n    }\n    elsif (($l=~/Automated smoke report for patch (\\d+) on (.*) - (.*)$/) or\n\t   ($l=~/Automated smoke report for .* patch (\\d+) on (.*) - (.*)$/)) {\n      ($h{smoke},$h{os}, $h{osver}) = ($1,$2,$3);\n      if (!$h{os} and !$h{osver}) {\n\treturn undef;\n      }\n    }\n    elsif ($l=~/Automated smoke report for patch (\\d*) on (.*)$/) {\n      ($h{smoke},$h{os}, $h{osver}) = ($1,$2,\"??\");\n      if ($l=~/(irix\\d*)$/) { $irix = 1; $h{os}=$1;}\n    }\n    elsif ($l=~/Automated smoke report for patch (\\d*)$/) {\n      ($h{smoke}) = ($1);\n    }\n    elsif ($irix==1) {\n      $irix=0;\n      $h{osver} = $1 if ($l=~/^ - (.*)$/);\n    }\n    elsif ($l=~/on (.*) using (.*) version (.*)$/) {\n      ($h{os}, $h{cc},$h{ccver},$h{osver}) = ($1,$2,$3,\"??\");\n    }\n    elsif ($l=~/using (.*) version (.*)$/) {\n      ($h{cc}, $h{ccver}) = ($1,$2);\n    }\n    elsif (($l=~/^($re{3,}(?:\\w|-|\\?)) +(-.+)$/)\n\t    || ($l=~/^($re{3,}(?:\\w|-|\\?))$/)) {\n      next if (!$1 or $1 eq '? ? ? ?' or $1 eq 't t t t');\n      my $c = $2; \n      $c=' ' if (!$c);\n      $h{\"build\"}{$c} = $1;\n    }\n    elsif (!$fail && $l=~/^[\\| ]*\\+-+ (.*)$/ && $1!~/^-*$/) {\n      push(@{$h{matrix}}, $1) if ($1 ne 'Configuration');\n    }\n    elsif ($fail) {\n      $h{\"failure\"}.=$l.\"\\n\" if ($l);\n      $h{nbte}++ if ($l=~/\\.\\.\\./); \n    }\n    elsif ($l=~/Failures(.*):/) { $fail=1; }\n  }\n  if ($h{build} && $h{os}) {\n    if (!$h{ccver}) { $h{ccver}=\"??\"; }\n    else {\n      $h{ccver}=~s/\\(prerelease\\)//g;\n      $h{ccver}=~s/\\(release\\)//g;\n    }\n    $h{nbte} = 0 if (!$h{nbte});\n    if (!$h{cc}) { $h{cc}=\"??\"; }\n    elsif ($h{cc}=~m!/([^/]*)$!) { $h{cc}=$1 }\n    $h{nbc} = scalar keys %{$h{build}};\n    $h{nbco} = 0;\n    if ($h{osver}=~m!^(.*)\\((.*)/.*\\)! or $h{osver}=~m!^(.*)\\((.*)\\)!) {\n      $h{osver} = $1;\n      $h{archi} = $2;\n      if ($h{archi}=~m!^([^-]*)-!) { $h{archi} = $1; }\n      $h{archi} = \"i386\" if ($h{archi}=~/86$/);\n    } else {$h{archi}= '??';}\n    if ($h{os}=~/^irix/ && $h{osver}=~/^(.*) (IP\\d*)/) {\n      $h{osver}=$1; $h{archi}=$2;\n    }\n    @{$h{matrix}}=reverse @{$h{matrix}} if ($h{matrix});\n    $h{id}=$1 if (($file=~/(\\d+)\\.rpt/ or\n\t\t  $file=~/(\\d+)\\.normal\\.rpt/));\n    return \\%h\n  }\n  if ($nbr>8) {\n    warn \"$file seems to be a reply\\n\";\n    return -2;\n  }\n  return ($col ? $col : undef);\n}",
      "file" : "/var/tmp/arv_4NSUDg/Test-Smoke-Database-1.9/lib/Test/Smoke/Database/Parsing.pm",
      "package" : "Test::Smoke::Database::Parsing"
   }
]
