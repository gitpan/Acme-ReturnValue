[
   {
      "PPI" : "PPI::Statement::Variable",
      "bad" : "our $VERSION = 6.002013",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/lib/Perl6/Pugs.pm",
      "package" : "Perl6::Pugs"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub Match_new {\n    my($b,$s,$a,$h,$from,$to)=@_;\n    Match->new('$.val_bool' => $b,\n               '$.val_string' => $s,\n               '$.val_array' => $a,\n               '$.val_hash' => $h,\n               '$.from' => $from,\n               '$.to' => $to);\n}",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/old_pugs_perl5_backend/PIL-Run/lib/PIL/Run/PrimP5.pm",
      "package" : "PrimFilter"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "sub _ {\n    my $attr = shift;\n    ($::SELF != $::CLASS)\n        || confess 'You cannot change an attribute in $::CLASS using this function';\n    ($::CLASS->find_attribute_spec($attr))\n        || confess \"Attribute ($attr) is not a valid attribute for $::SELF\";\n    ::opaque_instance_attr($::SELF => $attr) = shift if @_;\n    ::opaque_instance_attr($::SELF => $attr);    \n}\n\nsub __ {\n    my $attr = shift;\n    $::CLASS->STORE($attr => shift) if @_;\n    $::CLASS->FETCH($attr);  \n}\n\nsub class {\n    my ($full_name, $body) = @_;\n    if (defined($body) && defined($_[2]) && ref($body) && ref($body) =~ 'ARRAY') {\n        my ($body, @param_names) = ($_[2], @{$_[1]});\n        my ($name, $version, $authority) = split '-' => $full_name;       \n        return sub {\n            confess \"No parameters passed, looking for { \"  . (join \", \" => @param_names) . \" }\"\n                unless @_;\n            my %params = @_;\n            return _build_class($name, $version, $authority, sub { $body->(%params) });\n        };\n    }\n    if (!defined($body) && ref($full_name) && ref($full_name) =~ /HASH|CODE/) {\n        return _build_class('', undef, undef, $full_name);\n    }\n    my ($name, $version, $authority) = split '-' => $full_name;       \n    my $new_class = _build_class($name, $version, $authority, $body);\n    $::{'*'}->STORE('::' . $new_class->name => $new_class);\n    return $new_class;\n}\n\nsub role {\n    my ($full_name, $body) = @_;\n    if (!defined($body) && ref($full_name) && ref($full_name) =~ /HASH|CODE/) {\n        return _build_role(undef, undef, undef, $full_name);\n    }\n    my ($name, $version, $authority) = split '-' => $full_name;       \n    my $new_role = _build_role($name, $version, $authority, $body);\n    $::{'*'}->STORE('::' . $new_role->name => $new_role);    \n    return $new_role;    \n}\n\nsub _build_class {\n    my ($name, $version, $authority, $body) = @_;\n    \n    my $metaclass = $::Class;\n    $metaclass = $body->{metaclass} \n        if ref($body) eq 'HASH' && exists $body->{metaclass};\n    \n    my $new_class = $metaclass->new();    \n    \n    $new_class->name($name)           if defined $name;\n    $new_class->version($version)     if defined $version;\n    $new_class->authority($authority) if defined $authority;     \n    \n    if (ref($body) eq 'CODE') {\n        local $::CLASS = $new_class;\n        $body->();\n    }\n    elsif (ref($body) eq 'HASH') {\n        $new_class->superclasses($body->{is}) if exists $body->{is};\n        $new_class->roles($body->{does}) if exists $body->{does};        \n        \n        if ($body->{attributes}) {\n            foreach my $attribute_name (@{$body->{attributes}}) {\n                $new_class->add_attribute($attribute_name => ::make_attribute($attribute_name));\n            }\n        }\n        if ($body->{class_attributes}) {\n            foreach my $attr_name (@{$body->{class_attributes}}) {\n                $new_class->STORE($attr_name => ($attr_name =~ /^@/ ? [] : $attr_name =~ /^%/ ? {} : undef));\n            }\n        }        \n        if ($body->{methods}) {\n            foreach my $method_name (keys %{$body->{methods}}) {\n                if ($method_name =~ /^_/) {\n                    $new_class->add_method($method_name => ::make_private_method(\n                        $body->{methods}->{$method_name}\n                    ));                   \n                }\n                else {\n                    $new_class->add_method($method_name => ::make_method(\n                        $body->{methods}->{$method_name}\n                    ));\n                }\n            }\n        }\n        if ($body->{submethods}) {\n            foreach my $method_name (keys %{$body->{submethods}}) {\n                $new_class->add_method($method_name => ::make_submethod(\n                    $body->{submethods}->{$method_name}\n                ));\n            }\n        }                \n        if ($body->{class_methods}) {\n            foreach my $method_name (keys %{$body->{class_methods}}) {\n                if ($method_name =~ /^_/) {\n                    $new_class->add_singleton_method($method_name => ::make_private_method(\n                        $body->{class_methods}->{$method_name}\n                    ));\n                }\n                else {\n                    $new_class->add_singleton_method($method_name => ::make_method(\n                        $body->{class_methods}->{$method_name}\n                    ));                    \n                }\n            }\n        }        \n    }\n    \n    $new_class->resolve; \n    return $new_class;\n}\n\n\nsub _build_role {\n    my ($name, $version, $authority, $body) = @_;\n\n    my $new_role = $::Role->new();    \n\n    $new_role->name($name)           if defined $name;\n    $new_role->version($version)     if defined $version;\n    $new_role->authority($authority) if defined $authority;     \n\n    if (ref($body) eq 'CODE') {\n        local $::ROLE = $new_role;\n        $body->();\n    }\n    elsif (ref($body) eq 'HASH') {\n        $new_role->roles($body->{does}) if exists $body->{does};        \n        if ($body->{attributes}) {\n            foreach my $attribute_name (@{$body->{attributes}}) {\n                $new_role->add_attribute($attribute_name => ::make_attribute($attribute_name));\n            }\n        }     \n        if ($body->{methods}) {\n            foreach my $method_name (keys %{$body->{methods}}) {\n                if ($method_name =~ /^_/) {\n                    $new_role->add_method($method_name => ::make_private_method(\n                        $body->{methods}->{$method_name}\n                    ));                    \n                }\n                else {\n                    $new_role->add_method($method_name => ::make_method(\n                        $body->{methods}->{$method_name}\n                    ));\n                }\n            }\n        }\n        if ($body->{submethods}) {\n            foreach my $method_name (keys %{$body->{submethods}}) {\n                $new_role->add_method($method_name => ::make_submethod(\n                    $body->{submethods}->{$method_name}\n                ));\n            }\n        }  \n        if ($body->{class_methods}) {\n            foreach my $method_name (keys %{$body->{class_methods}}) {\n                if ($method_name =~ /^_/) {\n                    $new_role->add_method($method_name => ::make_private_method(\n                        $body->{class_methods}->{$method_name}\n                    ));\n                }\n                else {\n                    $new_role->add_method($method_name => ::make_class_method(\n                        $body->{class_methods}->{$method_name}\n                    ));                    \n                }\n            }\n        }                               \n    }\n\n    return $new_role;\n}\n\n\n1",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/old_pugs_perl5_backend/Perl6-MetaModel/lib/Perl6/MetaModel.pm",
      "package" : "Perl6::MetaModel"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub rcvd_msg_from_server {\n\tmy ( $conn, $msg, $err ) = @_;\n\tif ( defined $msg ) {\n\t\tdie \"Strange... shouldn't really be coming here\\n\";\n\t}\n}",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/runpugs/lib/WebTerminal/Dispatcher.pm",
      "package" : "WebTerminal::Dispatcher"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub spawn {\n\tmy (@cmd) = @_;\n\tmy ( $pid, $pty, $tty, $tty_fd );\n\n\tuse IO::Pty ();\n\t$pty = new IO::Pty\n\t  or die $!;\n\n\tunless ( $pid = fork ) {    \n\t\tdie \"problem spawning program: $!\\n\" unless defined $pid;\n\n\t\tuse POSIX ();\n\t\tPOSIX::setsid\n\t\t  or die \"setsid failed: $!\";\n\n\t\t$tty    = $pty->slave;\n\t\t$tty_fd = $tty->fileno;\n\t\tclose $pty;\n\n\t\topen STDIN,  \"<&$tty_fd\" or die $!;\n\t\topen STDOUT, \">&$tty_fd\" or die $!;\n\t\topen STDERR, \">&STDOUT\"  or die $!;\n\t\tclose $tty;\n\n\t\texec @cmd\n\t\t  or die \"problem executing $cmd[0]\\n\";\n\t}    \n\n\treturn ( $pty, $pid );\n}",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/runpugs/lib/WebTerminal/Server/Terminal.pm",
      "package" : "WebTerminal::Server::Terminal"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub rcvd_msg_from_server {\n\tmy ( $conn, $msg, $err ) = @_;\n\tif ( defined $msg ) {\n\t\tdie \"Strange... shouldn't really be coming here\\n\";\n\t}\n}",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/runpugs/lib/Web/Terminal/Dispatcher.pm",
      "package" : "Web::Terminal::Dispatcher"
   },
   {
      "PPI" : "PPI::Statement::Variable",
      "bad" : "our $check_interval=300",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/runpugs/lib/Web/Terminal/Config.pm",
      "package" : "Web::Terminal::Config"
   },
   {
      "PPI" : "PPI::Statement::Variable",
      "bad" : "our $check_interval=300",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/runpugs/lib/Web/Terminal/Settings.pm",
      "package" : "Web::Terminal::Settings"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub spawn {\n\tmy (@cmd) = @_;\n\tmy ( $pid, $pty, $tty, $tty_fd );\n\n\tuse IO::Pty ();\n\t$pty = new IO::Pty\n\t  or die $!;\n    binmode $pty, ':utf8';\n\tunless ( $pid = fork ) {    \n\t\tdie \"problem spawning program: $!\\n\" unless defined $pid;\n\n\t\tuse POSIX ();\n\t\tPOSIX::setsid\n\t\t  or die \"setsid failed: $!\";\n\n\t\t$tty    = $pty->slave;\n        binmode $tty, ':utf8';\n\t\t$tty_fd = $tty->fileno;\n\t\tclose $pty;\n\n\t\topen STDIN,  \"<&$tty_fd\" or die $!;\n\t\topen STDOUT, \">&$tty_fd\" or die $!;\n\t\topen STDERR, \">&STDOUT\"  or die $!;\n\t\tclose $tty;\n\n\t\texec @cmd\n\t\t  or die \"problem executing $cmd[0]\\n\";\n\t}    \n\n\treturn ( $pty, $pid );\n}",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/runpugs/lib/Web/Terminal/Server/Terminal.pm",
      "package" : "Web::Terminal::Server::Terminal"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub spawn {\n\tmy (@cmd) = @_;\n\tmy ( $pid, $pty, $tty, $tty_fd );\n\n\tuse IO::Pty ();\n\t$pty = new IO::Pty\n\t  or die $!;\n    binmode $pty, \":utf8\"; \n\tunless ( $pid = fork ) {    \n\t\tdie \"problem spawning program: $!\\n\" unless defined $pid;\n\n\t\tuse POSIX ();\n\t\tPOSIX::setsid\n\t\t  or die \"setsid failed: $!\";\n\n\t\t$tty    = $pty->slave;\n        binmode $tty, \":utf8\";\n\t\t$tty_fd = $tty->fileno;\n\t\tclose $pty;\n\n\t\topen STDIN,  \"<&$tty_fd\" or die $!;\n\t\topen STDOUT, \">&$tty_fd\" or die $!;\n\t\topen STDERR, \">&STDOUT\"  or die $!;\n        binmode STDIN, \":utf8\";\n        binmode STDOUT, \":utf8\";\n        binmode STDERR, \":utf8\";\n\t\tclose $tty;\n\n\t\texec @cmd\n\t\t  or die \"problem executing $cmd[0]\\n\";\n\t}    \n\n\treturn ( $pty, $pid );\n}",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/runpugs/lib/Web/Terminal/Server/Session.pm",
      "package" : "Web::Terminal::Server::Session"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "type Perl::Cxt is CxtVoid | CxtItem | CxtSlurpy",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/Perl-MetaModel/lib/Pugs/Cxt.pm",
      "package" : "Perl::Cxt"
   },
   {
      "PPI" : "PPI::Statement::Variable",
      "bad" : "our $iso8601_duration_re is export = rx:perl5:ix/\\s*\n       (?:  ( # $0\n              $iso8601_dur_re ( # $8\n                                \\057 $iso8601_re )? )\n       |    ( # $18\n              $iso8601_re \\057 (?: ( # $28\n                                 $iso8601_dur_re ) |\n                                 ( # $36\n                                 $iso8601_re ) ) )\n        )/",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/Date/lib/Date/Format/ISO8601.pm",
      "package" : "Date::Format::ISO8601"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub get_array {\n  my ( $self ) =  @_;\n  return $self->capture();\n}",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/pX/tewk/Rules-P5/lib/P6RulesInP5/Match.pm",
      "package" : "P6RulesInP5::Match"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub parse_ws_lit {\n  my ($matchObj) = @_;\n  $target = $matchObj->target();\n  $position = $matchObj->position();\n  $lastPosition = length $target;\n\n  if matches( /\\s/, $target, $pos )\n  {\n    goto term_ws;\n  }\n\n  $initchar = substr $target, $pos, 1;\n  if (( index \"<>[](){}:*?+|&^\\$.\", $initchar) >= 0 )\n  {\n    goto err_noterm;\n  }\n  $pos++;\n  if (initchar eq \"#\" ) goto term_ws;\n  if (initchar ne \"\\\\\") goto term_literal;\n  {\n  }\n  else\n  {\n    if (matches(/\\d/, $target, $pos))\n    {\n      goto err_backslash_digit;\n    }\n    $initchar = substr $target, $pos, 1;\n    $isnegated = matches (/[:upper:]/, $target, $pos);\n    $pos++;\n    $initchar = lc $initchar;\n    my $base\n    if $initchar eq 'x'; { $base = 16; goto term_bx0; }\n    elsif ( $initchar eq 'o' ) { $baase = 8; goto term_bx0; }\n    else\n    {\n      if ( exists $escape{$initchar} )\n      {\n        if ( not $isnegated and (length $initchar < 2))\n        {\n          goto term_literal;\n        }\n        $matchObj->{value} = $initchar;\n        $matchObj->{isnegated} = $isnegated;\n        goto end;\n      }\n      else\n      {\n        goto term_literal;\n      }\n    }\n  }\n  \n  term_bx0:\n    $I0 = 0\n    $S0 = substr target, pos, 1\n    $I2 = index \"[{(<\", $S0\n    if $I2 < 0 goto term_bx1\n    $S2 = substr \"]})>\", $I0\n    inc pos\n  term_bx1:\n    $S0 = substr target, pos, 1\n    downcase $S0\n    $I1 = index \"0123456789abcdef\", $S0\n    if $I1 < 0 goto term_bx2\n    if $I1 >= base goto term_bx2\n    $I0 *= base\n    $If0 += $I1\n    inc pos\n    goto term_bx1\n  term_bx2:\n    initchar = chr $I0\n    if $I2 < 0 goto term_bx3\n    $S0 = substr target, pos, 1\n    if $S0 != $S2 goto err_close\n    inc pos\n  term_bx3:\n    if isnegated goto term_charlist                \n\n  term_literal:                                    \n    mob = newfrom(mob, 0, \"PGE::Exp::Literal\")\n    litstart = pos\n    litlen = 0\n  term_literal_loop:\n    if pos >= lastpos goto term_literal_end\n    $I0 = is_cclass .CCLASS_WHITESPACE, target, pos\n    if $I0 goto term_literal_end\n    $S0 = substr target, pos, 1\n    $I0 = index \"<>[](){}:*?+\\\\|&#^$.\", $S0\n    if $I0 >= 0 goto term_literal_end\n    inc pos\n    inc litlen\n    goto term_literal_loop\n  term_literal_end:\n    if litlen < 1 goto term_literal_one\n    dec pos\n  term_literal_one:\n    $I0 = pos - litstart\n    $S0 = substr target, litstart, $I0\n    $S0 = concat initchar, $S0\n    mob[\"value\"] = $S0\n    goto end\n\n  term_ws:\n    mob = newfrom(mob, 0, \"PGE::Exp::WS\")\n  term_ws_1:\n    pos = find_not_cclass .CCLASS_WHITESPACE, target, pos, lastpos\n    $S0 = substr target, pos, 1\n    if $S0 != \"#\" goto end\n    $I0 = index target, \"\\n\", pos\n    pos = $I0 + 1\n    if pos > 0 goto term_ws_1\n    pos = lastpos\n  end:\n    $P0 = getattribute mob, \"PGE::Match\\x0$:pos\"\n    $P0 = pos\n    .return (mob)\n\n  err_noterm:\n    parse_error(mob, pos, \"Term expected\")\n    goto end\n  err_backslash_digit:\n    parse_error(mob, pos, \"\\\\1 and \\\\012 illegal, use $1, \\\\o012, or \\\\x0a\")\n    goto end\n  err_nodigits:\n    parse_error(mob, pos, \"No digits found in \\\\x...\")\n    goto end\n  err_close:\n    parse_error(mob, pos, \"Missing close bracket for \\\\x...\")\n    goto end\n.end\n\n.sub \"parse_modifier\"\n    .param pmc mob\n    .local int pos, lastpos\n    .local string target, value\n    .local pmc mfrom, mpos\n    $P0 = find_global \"PGE::Match\", \"newfrom\"\n    (mob, target, mfrom, mpos) = $P0(mob, 0, \"PGE::Exp::Modifier\")\n    pos = mfrom\n    lastpos = length target\n    value = \"1\"\n    inc pos\n    $I0 = pos\n    pos = find_not_cclass .CCLASS_NUMERIC, target, pos, lastpos\n    if pos == $I0 goto name\n    $I1 = pos - $I0\n    value = substr target, $I0, $I1\n    $I0 = pos\n  name:\n    pos = find_not_cclass .CCLASS_WORD, target, pos, lastpos\n    $I1 = pos - $I0\n    $S0 = substr target, $I0, $I1\n    $S0 = concat \":\", $S0\n    mob[\"mname\"] = $S0\n    mob[\"value\"] = value\n    $S0 = substr target, pos, 1\n    if $S0 != \"(\" goto end\n    $I0 = pos + 1\n    pos = index target, \")\", pos\n    $I1 = pos - $I0\n    $S0 = substr target, $I0, $I1\n    mob[\"value\"] = $S0\n    inc pos\n  end:\n    mpos = pos\n    .return (mob)\n.end\n\n\n.sub \"parse_closure\"\n    .param pmc mob\n    .local pmc newfrom\n    .local string target\n    .local pmc mfrom, mpos\n    .local int pos, len\n    $P0 = find_global \"PGE::Match\", \"newfrom\"\n    (mob, target, mfrom, mpos) = $P0(mob, 0, \"PGE::Exp::Closure\")\n    pos = mfrom\n    len = 0\n  init:\n    $S0 = substr target, pos, 1\n    if $S0 != \"{\" goto body\n    inc len\n    inc pos\n    goto init\n  body:\n    $S0 = repeat \"}\", len\n    $I0 = index target, $S0, pos\n    if $I0 < pos goto err_noclose\n    $I1 = $I0 - pos\n    $S1 = substr target, pos, $I1\n    mob[\"value\"] = $S1\n    pos = $I0 + len\n    mpos = pos\n    .return (mob)\n err_noclose:\n    parse_error(mob, pos, \"Missing closing braces for closure\")\n    .return (mob)\n.end\n    \n\n.sub \"parse_quant\"\n    .param pmc mob\n    .local string target\n    .local int min, max, islazy\n    .local int pos, lastpos\n    .local pmc mfrom, mpos\n    $P0 = find_global \"PGE::Match\", \"newfrom\"\n    (mob, target, mfrom, mpos) = $P0(mob, 0, \"PGE::Exp::Quant\")\n    pos = mfrom\n    lastpos = length target\n    min = 1\n    max = 1\n    islazy = 0\n    $S0 = substr target, pos, 2\n    if $S0 == \"**\" goto quant_closure\n    $S0 = substr target, pos, 1\n    if $S0 == \"+\" goto quant_max\n    min = 0\n  quant_max:\n    if $S0 == \"?\" goto quant_lazy\n    max = PGE_INF\n    goto quant_lazy\n  quant_lazy:\n    inc pos\n    $I0 = find_not_cclass .CCLASS_WHITESPACE, target, pos, lastpos\n    $S0 = substr target, $I0, 1\n    if $S0 != \"?\" goto end\n    islazy = 1\n    pos = $I0 + 1\n    goto end\n  quant_closure:\n    pos += 2\n    pos = find_not_cclass .CCLASS_WHITESPACE, target, pos, lastpos\n    $S0 = substr target, pos, 1\n    if $S0 != \"{\" goto err_closure\n    inc pos\n    $I1 = find_not_cclass .CCLASS_NUMERIC, target, pos, lastpos\n    if $I1 <= pos goto err_closure\n    $S0 = substr target, pos\n    min = $S0\n    max = $S0\n    pos = $I1\n    $S0 = substr target, pos, 2\n    if $S0 != '..' goto quant_closure_end\n    pos += 2\n    max = PGE_INF\n    $S0 = substr target, pos, 1\n    if $S0 == '.' goto quant_closure_end\n    $I1 = find_not_cclass .CCLASS_NUMERIC, target, pos, lastpos\n    if $I1 <= pos goto err_closure\n    $S0 = substr target, pos\n    max = $S0\n    pos = $I1\n  quant_closure_end:\n    $S0 = substr target, pos, 1\n    if $S0 != \"}\" goto err_closure\n    inc pos\n  end:\n    mob[\"min\"] = min\n    mob[\"max\"] = max\n    mob[\"islazy\"] = islazy\n    mpos = pos\n    .return (mob)\n  err_closure:\n    parse_error(mob, pos, \"Error in closure quantifier\")\n.end\n\n.sub \"parse_subrule\"\n    .param pmc mob\n    .local string target\n    .local pmc mfrom, mpos\n    .local int pos, lastpos\n    .local int iscapture\n    .local string subname\n    $P0 = find_global \"PGE::Match\", \"newfrom\"\n    (mob, target, mfrom, mpos) = $P0(mob, 0, \"PGE::Exp::Subrule\")\n    pos = mfrom \n    lastpos = length target\n    $S0 = substr target, pos, 2\n    if $S0 == \"<?\" goto nocapture\n    if $S0 == \"<!\" goto negated\n    iscapture = 1\n    inc pos\n    goto subrule_name\n  negated:\n    mob[\"isnegated\"] = 1\n  nocapture:\n    iscapture = 0\n    pos += 2\n  subrule_name:\n    $I0 = pos\n  subrule_name_1:\n    pos = find_not_cclass .CCLASS_WORD, target, pos, lastpos\n    $S0 = substr target, pos, 2\n    if $S0 != \"::\" goto subrule_name_2\n    pos += 2\n    goto subrule_name_1\n  subrule_name_2:\n    $I1 = pos - $I0\n    subname = substr target, $I0, $I1\n    $S0 = substr target, pos, 2\n    if $S0 == \": \" goto subrule_text\n    $S0 = substr target, pos, 1\n    if $S0 != \" \" goto subrule_end\n    inc pos\n    mpos = pos\n    $P0 = find_global \"PGE::Rule\", \"p6rule\"\n    $P1 = $P0(mob)\n    unless $P1 goto end\n    $S0 = $P1\n    mob[\"arg\"] = $S0\n    pos = $P1.to()\n    mpos = -1\n    $S0 = substr target, pos, 1\n    goto subrule_end\n  subrule_text:\n    pos += 2\n    $I0 = index target, \">\", pos\n    if $I0 < 0 goto end\n    $I0 -= pos\n    $S0 = substr target, pos, $I0\n    mob[\"arg\"] = $S0\n    pos += $I0\n    $S0 = substr target, pos, 1\n  subrule_end:\n    if $S0 != \">\" goto end\n    inc pos\n    mpos = pos\n    mob[\"subname\"] = subname\n    mob[\"iscapture\"] = iscapture\n    if iscapture == 0 goto end\n    $S0 = escape subname\n    $S0 = concat '\"', $S0\n    $S0 = concat $S0, '\"'\n    mob[\"cname\"] = $S0\n  end:\n    .return (mob)\n.end \n\n\n.sub \"parse_enumclass\"\n    .param pmc mob\n    .local string target\n    .local pmc mfrom, mpos\n    .local int pos, lastpos\n    .local int isrange\n    .local string charlist\n    $P0 = find_global \"PGE::Match\", \"newfrom\"\n    (mob, target, mfrom, mpos) = $P0(mob, 0, \"PGE::Exp::EnumCharList\")\n    lastpos = length target\n    charlist = \"\"\n    mob[\"isnegated\"] = 0\n    pos = mfrom\n    isrange = 0\n    $S0 = substr target, pos, 3\n    pos += 2\n    if $S0 != \"<-[\" goto scan\n    mob[\"isnegated\"] = 1\n    inc pos\n  scan:\n    if pos >= lastpos goto err_close\n    $S0 = substr target, pos, 1\n    if $S0 == \"]\" goto endclass\n    if $S0 == \"-\" goto err_hyphen\n    if $S0 == \".\" goto dotrange\n    if $S0 != \"\\\\\" goto addchar\n  backslash:\n    inc pos\n    $S0 = substr target, pos, 1\n    $I0 = index \"nrtfae0\", $S0\n    if $I0 == -1 goto addchar\n    $S0 = substr \"\\n\\r\\t\\f\\a\\e\\0\", $I0, 1\n  addchar:\n    inc pos\n    if isrange goto addrange\n    charlist .= $S0\n    goto scan\n  addrange:\n    isrange = 0\n    $I2 = ord charlist, -1\n    $I0 = ord $S0\n  addrange_1:\n    inc $I2\n    if $I2 > $I0 goto scan\n    $S1 = chr $I2\n    charlist .= $S1\n    goto addrange_1\n  dotrange:\n    if isrange goto addrange\n    $S1 = substr target, pos, 2\n    if $S1 != \"..\" goto addchar\n    pos += 2\n    isrange = 1\n    goto scan\n  endclass:\n    $S0 = substr target, pos, 2\n    if $S0 != \"]>\" goto err_bracket\n    pos += 2\n    mpos = pos\n    mob[\"value\"] = charlist\n    goto end\n  err_bracket:\n    parse_error(mob, pos, \"Unescaped ']' in charlist\")\n    goto end\n  err_hyphen:\n    parse_error(mob, pos, \"Unescaped '-' in charlist (use '..' or '\\-')\")\n    goto end\n  err_close:\n    parse_error(mob, pos, \"No closing ']>' for charlist\")\n  end:\n    .return (mob)\n.end\n\n.sub \"parse_dollar\"\n    .param pmc mob\n    .local string target\n    .local int pos, lastpos\n    .local pmc newfrom, mfrom, mpos\n    .local string cname\n    newfrom = find_global \"PGE::Match\", \"newfrom\"\n    $P0 = getattribute mob, \"PGE::Match\\x0$:target\"\n    target = $P0\n    $P0 = getattribute mob, \"PGE::Match\\x0$:pos\"\n    pos = $P0\n    lastpos = length target\n    inc pos\n    $S0 = substr target, pos, 1\n    if $S0 == '<' goto name\n    $I0 = find_not_cclass .CCLASS_NUMERIC, target, pos, lastpos\n    if $I0 > pos goto numeric\n    $I0 = find_not_cclass .CCLASS_WORD, target, pos, lastpos\n    if $I0 > pos goto scalar\n  eos_anchor:\n    (mob, $P0, mfrom, mpos) = newfrom(mob, 0, \"PGE::Exp::Anchor\")\n    mob[\"value\"] = \"$\"\n    goto end\n  scalar:\n    (mob, $P0, mfrom, mpos) = newfrom(mob, 0, \"PGE::Exp::Scalar\")\n    dec pos\n    $I1 = $I0 - pos\n    cname = substr target, pos, $I1\n    cname = concat '\"', cname\n    cname = concat cname, '\"'\n    mob[\"cname\"] = cname\n    pos = $I0\n    goto end\n  numeric:\n    (mob, $P0, mfrom, mpos) = newfrom(mob, 0, \"PGE::Exp::Scalar\")\n    $I1 = $I0 - pos\n    cname = substr target, pos, $I1\n    mob[\"cname\"] = cname\n    pos = $I0\n    goto end\n  name:\n    inc pos\n    (mob, $P0, mfrom, mpos) = newfrom(mob, 0, \"PGE::Exp::Scalar\")\n    $I0 = index target, \">\", pos\n    if $I0 < pos goto err_close\n  name_1:\n    $I1 = $I0 - pos\n    cname = substr target, pos, $I1\n    cname = escape cname\n    cname = concat '\"', cname\n    cname = concat cname, '\"'\n    mob[\"cname\"] = cname\n    pos = $I0 + 1\n    goto end\n  err_close:\n    parse_error(mob, pos, \"Missing close '>' in scalar\")\n  end:\n    mpos = pos\n    .return (mob)\n.end\n    \n.sub \"parse_error\"\n    .param pmc mob\n    .param int pos\n    .param string message\n    $P0 = getattribute mob, \"PGE::Match\\x0$:pos\"\n    $P0 = pos\n    $P0 = new .Exception\n    $S0 = \"p6rule parse error: \"\n    $S0 .= message\n    $S0 .= \" at offset \"\n    $S1 = pos\n    $S0 .= $S1\n    $S0 .= \", found '\"\n    $P1 = getattribute mob, \"PGE::Match\\x0$:target\"\n    $S1 = $P1\n    $S1 = substr $S1, pos, 1\n    $S0 .= $S1\n    $S0 .= \"'\"\n    $P0[\"_message\"] = $S0\n    throw $P0\n    .return ()\n.end\n\n.namespace [ \"PGE::Rule\" ]\n\n.sub \"p6rule\"\n    .param pmc mob\n    .local pmc optable\n    optable = find_global \"PGE::P6Rule\", \"$optable\"\n    $P0 = optable.\"parse\"(mob)\n    .return ($P0)\n.end\n\n.namespace [ \"PGE\" ]\n\n.sub \"p6rule\"\n    .param string pattern\n    .param string grammar      :optional\n    .param int has_gram        :opt_flag\n    .param string name         :optional\n    .param int has_name        :opt_flag\n    .local pmc exp\n    .local pmc newfrom\n    .local pmc code\n    .local pmc sub\n    .local pmc pad\n\n    null code\n    null sub\n    if has_name goto p6rule_1\n    name = \"_pge_rule\"\n    if has_gram goto p6rule_1\n    grammar = \"PGE::Rule\"\n  p6rule_1:\n    newfrom = find_global \"PGE::Match\", \"newfrom\"\n    (exp, $P99, $P99, $P0) = newfrom(pattern, 0, \"PGE::Exp\")\n    $P0 = 0\n\n    $P0 = find_global \"PGE::Rule\", \"p6rule\"\n    exp = $P0(exp)\n    unless exp goto end\n    $S0 = exp\n    if $S0 != pattern goto end\n    pad = new .Hash\n    $P0 = new .Hash\n    pad[\"reps\"] = $P0\n    pad[\"cutnum\"] = PGE_CUT_GROUP\n    pad[\"subpats\"] = 0\n    pad[\":lang\"] = \"PIR\"\n    $P0 = exp[\"expr\"]\n    $P0 = $P0.p6analyze(pad)\n    exp[\"expr\"] = $P0\n    if_null $P0, end\n\n    $P0 = new .String\n    $P0 = \"\\n.namespace [ \\\"\"\n    $P0 .= grammar\n    $P0 .= \"\\\" ]\\n\\n\"\n    code = exp.\"as_pir\"(name)\n    code = concat $P0, code\n\n    $P0 = compreg \"PIR\"\n    sub = $P0(code)\n    if has_name == 0 goto end\n    $I0 = find_type grammar\n    if $I0 > 0 goto end\n    $P0 = getclass \"PGE::Rule\"\n    $P1 = subclass $P0, grammar \n  end:\n    .return (sub, code, exp)\n.end\n\n.namespace [ \"PGE::Exp\" ]\n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    $I0 = defined self[\"value\"]\n    if $I0 goto end\n    $S0 = self\n    self[\"value\"] = $S0\n  end:\n    .return (self)\n.end\n\n.namespace [ \"PGE::Exp::Literal\" ]\n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    $I0 = pad[\":i\"]\n    self[\"ignorecase\"] = $I0\n    .return (self)\n.end\n\n.namespace [ \"PGE::Exp::Cut\" ]\n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    .local string token\n    token = self\n    if token == \":\" goto cutatom\n    $I0 = PGE_CUT_RULE\n    if token == \":::\" goto cut_1\n    $I0 = pad[\"cutnum\"]\n  cut_1:\n    self[\"cutnum\"] = $I0\n    .return (self)\n  cutatom:\n    $P0 = self[0]\n    $P0 = $P0.reduce(pad)\n    $P0[\"iscut\"] = 1\n    $P0[\"isquant\"] = 1\n    .return ($P0)\n.end\n\n.namespace [ \"PGE::Exp::Concat\" ]\n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    .local pmc exp0, exp1\n    exp0 = self[0]\n    exp0 = exp0.p6analyze(pad)\n    exp1 = self[1]\n    exp1 = exp1.p6analyze(pad)\n    unless_null exp0, exp1null\n    .return (exp1)\n  exp1null:\n    self[0] = exp0\n    unless_null exp1, end\n    .return (exp0)\n  end:\n    self[1] = exp1\n    .return (self)\n.end\n\n.namespace [ \"PGE::Exp::Alt\" ]\n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    .local pmc reps, savereps\n    .local pmc exp0, exp1\n\n    reps = pad[\"reps\"]\n    savereps = new .Hash\n    $P0 = new .Iterator, reps\n  reps_1:\n    unless $P0 goto reps_2\n    $P1 = shift $P0\n    $P2 = reps[$P1]\n    savereps[$P1] = $P2\n    goto reps_1\n  reps_2:\n    $I0 = pad[\"subpats\"]\n    exp0 = self[0]\n    exp0 = exp0.p6analyze(pad)\n    self[0] = exp0\n\n    $I1 = pad[\"subpats\"]\n    pad[\"subpats\"] = $I0\n    pad[\"reps\"] = savereps\n    exp1 = self[1]\n    exp1 = exp1.p6analyze(pad)\n    self[1] = exp1\n    $I0 = pad[\"subpats\"]\n    if $I0 >= $I1 goto end\n    pad[\"subpats\"] = $I1\n  end:\n    .return (self)\n.end\n\n.namespace [ \"PGE::Exp::Conj\" ]\n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    $P0 = self[0]\n    $P0 = $P0.p6analyze(pad)\n    self[0] = $P0\n    $P1 = self[1]\n    $P1 = $P1.p6analyze(pad)\n    self[1] = $P1\n    .return (self)\n.end\n    \n    \n.namespace [ \"PGE::Exp::Quant\" ]\n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    .local pmc exp\n    .local int padarray\n    padarray = pad[\"isarray\"]\n    pad[\"isarray\"] = 1\n    exp = self[0]\n    exp = exp.p6analyze(pad)\n    self[0] = exp\n    pad[\"isarray\"] = padarray\n    .return (self)\n.end\n    \n.namespace [ \"PGE::Exp::Group\" ] \n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    .local pmc reps, exp\n    .local string cname\n    .local int cutnum, padarray, isarray, subpats\n\n    cutnum = pad[\"cutnum\"]\n    ($S0, $I0) = self.serno()\n    pad[\"cutnum\"] = $I0\n    self[\"cutnum\"] = $I0\n\n    if self != \"(\" goto init\n    self[\"iscapture\"] = 1\n    self[\"isscope\"] = 1\n\n  init:\n    $I0 = self[\"iscapture\"]\n    if $I0 == 0 goto unscoped\n\n  capture:\n    $I0 = exists self[\"cname\"]\n    if $I0 goto setsubpats\n    $I0 = pad[\"subpats\"]\n    self[\"cname\"] = $I0\n    \n  setsubpats:\n    cname = self[\"cname\"]\n    $S0 = substr cname, 0, 1\n    if $S0 == '\"' goto setreps\n    $I0 = cname\n    inc $I0\n    pad[\"subpats\"] = $I0\n\n  setreps:\n    isarray = 0\n    reps = pad[\"reps\"]\n    $I0 = exists reps[cname]\n    if $I0 == 0 goto setreps_1\n    $P0 = reps[cname]\n    $P0[\"isarray\"] = 1\n    isarray = 1\n  setreps_1:\n    reps[cname] = self\n\n    padarray = pad[\"isarray\"]\n    isarray |= padarray\n    self[\"isarray\"] = isarray\n    $I0 = self[\"isscope\"]\n    if $I0 == 0 goto unscoped\n\n  scoped:\n    subpats = pad[\"subpats\"]\n    pad[\"subpats\"] = 0\n    pad[\"isarray\"] = 0\n    $P0 = new .Hash\n    pad[\"reps\"] = $P0\n    exp = self[0]\n    exp = exp.p6analyze(pad)\n    self[0] = exp\n    pad[\"reps\"] = reps\n    pad[\"subpats\"] = subpats\n    pad[\"isarray\"] = padarray\n    pad[\"cutnum\"] = cutnum\n    goto end\n  unscoped:\n    exp = self[0]\n    exp = exp.p6analyze(pad)\n    self[0] = exp\n    pad[\"cutnum\"] = cutnum\n  end:\n    .return (self)\n.end\n\n.namespace [ \"PGE::Exp::Subrule\" ]\n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    .local int isarray, iscapture\n    .local string cname\n    .local pmc reps\n\n    iscapture = self[\"iscapture\"]\n    if iscapture == 0 goto end\n    cname = self[\"cname\"]\n    isarray = pad[\"isarray\"]\n    reps = pad[\"reps\"]\n    $I0 = exists reps[cname]\n    if $I0 == 0 goto reps_1\n    $P0 = reps[cname]\n    $P0[\"isarray\"] = 1\n    isarray = 1\n  reps_1:\n    reps[cname] = self\n    self[\"isarray\"] = isarray\n  \n  next_cname:\n    $S0 = substr cname, 0, 1\n    if $S0 == '\"' goto end\n    $I0 = cname\n    inc $I0\n    pad[\"subpats\"] = $I0\n\n  end:\n    .return (self)\n.end\n\n.namespace [ \"PGE::Exp::WS\" ]\n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    $I0 = pad[\":s\"]\n    if $I0 goto ws\n    null $P0\n    .return ($P0)\n  ws:\n    self[\"subname\"] = \"ws\"\n    self[\"iscapture\"] = 0\n    .return (self)\n.end\n\n.namespace [ \"PGE::Exp::Modifier\" ]\n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    .local string mname\n    .local pmc value\n    .local pmc exp\n    mname = self[\"mname\"]\n    value = self[\"value\"]\n    if mname == \":sigspace\" goto words\n    if mname == \":ignorecase\" goto ignorecase\n    goto setpad\n  words:\n    mname = \":s\"\n    goto setpad\n  ignorecase:\n    mname = \":i\"\n  setpad:\n    $P0 = pad[mname]\n    pad[mname] = value\n    exp = self[0]\n    exp = exp.p6analyze(pad)\n    self[0] = exp\n    pad[mname] = $P0\n    .return (exp)\n.end\n\n\n.namespace [ \"PGE::Exp::Alias\" ]\n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    .local string cname\n    .local pmc exp0, exp1\n\n    exp0 = self[0]\n    cname = exp0[\"cname\"]\n    exp1 = self[1]\n    exp1[\"cname\"] = cname\n    exp1[\"iscapture\"] = 1\n    exp1 = exp1.p6analyze(pad)\n    .return (exp1)\n.end\n\n.namespace [ \"PGE::Exp::Closure\" ]\n\n.sub \"p6analyze\" :method\n    .param pmc pad\n    $S0 = pad[\":lang\"]\n    self[\"lang\"] = $S0\n    if $S0 != \"PIR\" goto end\n    $S1 = self[\"value\"]\n    $I0 = index $S1, \".sub\"\n    if $I0 >= 0 goto end\n    $S1 = concat \".sub anon :anon\\n.param pmc match\\n\", $S1\n    $S1 .= \"\\n.end\\n\"\n    self[\"value\"] = $S1\n  end:\n    .return (self)\n.end\n",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/pX/tewk/Rules-P5/lib/P6RulesInP5/P6Rule.pm",
      "package" : "P6RulesInP5::P6Rule"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub ws {\n  my ( $matchObj ) = @_\n}",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/pX/tewk/Rules-P5/lib/P6RulesInP5/Rule.pm",
      "package" : "P6RulesInP5::Rule"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "FILTER_ONLY\ncode => sub {\n\ts{^(sub \\s+ (\\w+::\\w+) \\s* \\{)}{\n\t\t$orginal = $1;\n\t\t$sub = $2;\n\t\tif ($sub =~ /$regex/) {\n\t\t\t\"warn 'Filtered:$sub';\\nuse Smart::Comments;\\n\" . $orginal\n\t\t} else {\n\t\t\t\"no Smart::Comments;\\n\" . $orginal;\n\t\t}\n\t}egmx;\n}",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/pX/Common/Filtered-Comments.pm",
      "package" : "Filtered::Comments"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "push @Grammar::Perl6::ops, Runtime::Perl5::RuleOps::compile_rule( 'infix\\:\\<\\~\\>' )",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/pX/Common/lrep-compiler/Grammar/Perl6Primitives.pm",
      "package" : "main"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub _indent_except_top {my($o,$s)=@_; $s =~ s/^(?<!\\A)(?!\\Z)/  /mg; $s}",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/pX/Common/regexp_and_parser_spike/Match.pm",
      "package" : "Match"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "- Introduction\n- Documentation Index\n- Compiler internals:\n    Compiler\n    Compiler::Perl6\n    Compiler::Rule\n    Compiler::YAML\n    Compiler::Perl5\n    Compiler::Parrot\n- AST, Grammar, Optimizer internals:\n    AST::Perl6::API\n    Grammar::Perl6\n    Optimizer::AST   -- optimizes an AST\n    Grammar::MOP     -- implements OO using macros",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/pX/Common/lrep/Notes-Pugs.pm",
      "package" : "Pugs"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub init {\n  my ($self) = @_;\n\n  $self->add_handler('atom' => sub {\n    my ($S) = @_;\n    $S->nextchar;\n\n    ${&Rx} =~ m{ \\G (.) }xgcs or return;\n    my $c = $1;\n\n    push @{ $S->{next} }, qw< atom >;\n    return $S->$c if $S->can($c);\n    return $S->object(exact => $c);\n  });\n\n\n  $self->add_handler('\\\\' => sub {\n    my ($S, $cc) = @_;\n    my $c = '\\\\';\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      $c .= (my $n = $1);\n\n      return $S->$c($cc) if $S->can($c);\n      --&RxPOS;\n\n      $S->warn(RPe_BADESC, $c = $n, \"\") if $n =~ /[a-zA-Z]/;\n\n      return $S->object(exact => $n, $c);\n    }\n\n    $S->error(RPe_ESLASH);\n  });\n\n  $self->add_handler('\\b' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char => \"\\b\", '\\b') if $cc;\n    return $S->object(bound => bound => '\\b');\n  });\n\n  $self->add_handler('\\B' => sub {\n    my ($S, $cc) = @_;\n    $S->warn(RPe_BADESC, \"B\", \" in character class\") if $cc;\n    return $S->force_object(anyof_char => 'B') if $cc;\n    return $S->object(bound => nbound => '\\B');\n  });\n\n  $self->add_handler('\\c' => sub {\n    my ($S, $cc) = @_;\n\n    if (${&Rx} =~ m{ \\G ($non_nest_brack) }xgc) {\n      my $n = substr($1, 1, -1);\n      my @names = split /;/, $n;\n\n      if ($cc) {\n        $S->error(0, \"\\\\c[A;B] in character class\") if @names > 1;\n        return $S->force_object(anyof_char => $S->nchar($n), \"\\\\c[$n]\");\n      }\n\n      return $S->object(exact => join(\"\", $S->nchar(@names)), \"\\\\c[$n]\");\n    }\n\n    $S->error(0, \"Missing right %s on \\\\%s\", 'brace', \"c$1\") if ${&Rx} =~ m{ \\G ([[({<]) }xgc;\n    $S->error(0, \"Missing brackets on \\\\%s\", 'c');\n  });\n\n  $self->add_handler('\\C' => sub {\n    my ($S, $cc) = @_;\n\n    if (${&Rx} =~ m{ \\G ($non_nest_brack) }xgc) {\n      my $n = substr($1, 1, -1);\n      my @names = split /;/, $n;\n\n      if ($cc) {\n        $S->error(0, \"\\\\C[A;B] in character class\") if @names > 1;\n        return $S->force_object(anyof_char_comp => $S->nchar($n), \"\\\\C[$n]\");\n      }\n\n      return $S->object(exact_comp => join(\"\", $S->nchar(@names)), \"\\\\C[$n]\");\n    }\n\n    $S->error(0, \"Missing right %s on \\\\%s\", 'brace', \"C$1\") if ${&Rx} =~ m{ \\G ([[({<]) }xgc;\n    $S->error(0, \"Missing brackets on \\\\%s\", 'C');\n  });\n\n  $self->add_handler('\\d' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(digit => 0)) if $cc;\n    return $S->object(digit => 0);\n  });\n\n  $self->add_handler('\\D' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(digit => 1)) if $cc;\n    return $S->object(digit => 1);\n  });\n\n  $self->add_handler('\\e' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char => \"\\e\", '\\e') if $cc;\n    return $S->object(exact => \"\\e\", '\\e');\n  });\n\n  $self->add_handler('\\E' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char_comp => \"\\e\", '\\E') if $cc;\n    return $S->object(exact_comp => \"\\e\", '\\E');\n  });\n\n  $self->add_handler('\\f' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char => \"\\f\", '\\f') if $cc;\n    return $S->object(exact => \"\\f\", '\\f');\n  });\n\n  $self->add_handler('\\F' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char_comp => \"\\f\", '\\F') if $cc;\n    return $S->object(exact_comp => \"\\f\", '\\F');\n  });\n\n  $self->add_handler('\\h' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(horiz => 0)) if $cc;\n    return $S->object(horiz => 0);\n  });\n\n  $self->add_handler('\\H' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(horiz => 1)) if $cc;\n    return $S->object(horiz => 1);\n  });\n\n  $self->add_handler('\\n' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char => \"\\n\", '\\n') if $cc;\n    return $S->object(exact => \"\\n\", '\\n');\n  });\n\n  $self->add_handler('\\N' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char_comp => \"\\n\", '\\N') if $cc;\n    return $S->object(exact_comp => \"\\n\", '\\N');\n  });\n\n  $self->add_handler('\\r' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char => \"\\r\", '\\r') if $cc;\n    return $S->object(exact => \"\\r\", '\\r');\n  });\n\n  $self->add_handler('\\R' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char_comp => \"\\r\", '\\R') if $cc;\n    return $S->object(exact_comp => \"\\r\", '\\R');\n  });\n\n  $self->add_handler('\\s' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(space => 0)) if $cc;\n    return $S->object(space => 0);\n  });\n\n  $self->add_handler('\\S' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(space => 1)) if $cc;\n    return $S->object(space => 1);\n  });\n\n  $self->add_handler('\\t' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char => \"\\t\", '\\t') if $cc;\n    return $S->object(exact => \"\\t\", '\\t');\n  });\n\n  $self->add_handler('\\T' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char_comp => \"\\t\", '\\T') if $cc;\n    return $S->object(exact_comp => \"\\t\", '\\T');\n  });\n\n  $self->add_handler('\\v' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(vert => 0)) if $cc;\n    return $S->object(vert => 0);\n  });\n\n  $self->add_handler('\\V' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(vert => 1)) if $cc;\n    return $S->object(vert => 1);\n  });\n\n  $self->add_handler('\\w' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(alnum => 0)) if $cc;\n    return $S->object(alnum => 0);\n  });\n\n  $self->add_handler('\\W' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(alnum => 1)) if $cc;\n    return $S->object(alnum => 1);\n  });\n\n  $self->add_handler('\\x' => sub {\n    my ($S, $cc) = @_;\n\n    if (${&Rx} =~ m{ \\G ($non_nest_brack) }xgc) {\n      my $h = substr($1, 1, -1);\n      my @hex = split /;/, $h;\n\n      $S->warn(0, \"Illegal hexadecimal digit '%s' ignored\", $1) if $h =~ /([^a-fA-F0-9;])/;\n\n      if ($cc) {\n        $S->error(0, \"\\\\x[A;B] in character class\") if @hex > 1;\n        return $S->force_object(anyof_char => chr(hex $h), \"\\\\x[$h]\");\n      }\n\n      return $S->object(exact => join(\"\", map chr(hex), @hex), \"\\\\x[$h]\");\n    }\n\n    $S->error(0, \"Missing right %s on \\\\%s\", 'brace', \"x$1\") if ${&Rx} =~ m{ \\G ([[({<]) }xgc;\n\n    if (${&Rx} =~ m{ \\G ( [a-fA-F0-9]+ ) }xgc) {\n      return $S->force_object(anyof_char => chr(hex $1), \"\\\\x$1\") if $cc;\n      return $S->object(exact => chr(hex $1), \"\\\\x$1\");\n    }\n\n    $S->warn(0, \"Illegal hexadecimal digit '%s' ignored\", substr(${&Rx}, &RxPOS, 1));\n    return $S->force_object(anyof_char => \"\\0\", \"\\\\x[0]\") if $cc;\n    return $S->object(exact => \"\\0\", \"\\\\x[0]\");\n  }\n\n  $self->add_handler('\\X' => sub {\n    my ($S, $cc) = @_;\n\n    if (${&Rx} =~ m{ \\G ($non_nest_brack) }xgc) {\n      my $h = substr($1, 1, -1);\n      my @hex = split /;/, $h;\n\n      $S->warn(0, \"Illegal hexadecimal digit '%s' ignored\", $1) if $h =~ /([^a-fA-F0-9;])/;\n\n      if ($cc) {\n        $S->error(0, \"\\\\X[A;B] in character class\") if @hex > 1;\n        return $S->force_object(anyof_char_comp => chr(hex $h), \"\\\\X[$h]\");\n      }\n\n      return $S->object(exact_comp => join(\"\", map chr(hex), @hex), \"\\\\X[$h]\");\n    }\n\n    $S->error(0, \"Missing right %s on \\\\%s\", 'brace', \"X$1\") if ${&Rx} =~ m{ \\G ([[({<]) }xgc;\n\n    if (${&Rx} =~ m{ \\G ( [a-fA-F0-9]+ ) }xgc) {\n      return $S->force_object(anyof_char_comp => chr(hex $1), \"\\\\X$1\") if $cc;\n      return $S->object(exact_comp => chr(hex $1), \"\\\\X$1\");\n    }\n\n    $S->warn(0, \"Illegal hexadecimal digit '%s' ignored\", substr(${&Rx}, &RxPOS, 1));\n    return $S->force_object(anyof_char_comp => \"\\0\", \"\\\\X[0]\") if $cc;\n    return $S->object(exact_comp => \"\\0\", \"\\\\X[0]\");\n  }\n\n  $self->add_handler('\\0' => sub {\n    my ($S, $cc) = @_;\n\n    if (${&Rx} =~ m{ \\G ($non_nest_brack) }xgc) {\n      my $o = substr($1, 1, -1);\n      my @oct = split /;/, $o;\n\n      $S->warn(0, \"Illegal octal digit '%s' ignored\", $1) if $o =~ /([^0-7;])/;\n\n      if ($cc) {\n        $S->error(0, \"\\\\0[A;B] in character class\") if @oct > 1;\n        return $S->force_object(anyof_char => chr(oct $o), \"\\\\0[$o]\");\n      }\n\n      return $S->object(exact => join(\"\", map chr(oct), @oct), \"\\\\0[$o]\");\n    }\n\n    $S->error(0, \"Missing right %s on \\\\%s\", 'brace', \"0$1\") if ${&Rx} =~ m{ \\G ([[({<]) }xgc;\n\n    if (${&Rx} =~ m{ \\G ( [0-7]+ ) }xgc) {\n      return $S->force_object(anyof_char => chr(oct $1), \"\\\\0$1\") if $cc;\n      return $S->object(exact => chr(oct $1), \"\\\\0$1\");\n    }\n\n    $S->warn(0, \"Illegal octal digit '%s' ignored\", substr(${&Rx}, &RxPOS, 1));\n    return $S->force_object(anyof_char => \"\\0\", \"\\\\0[0]\") if $cc;\n    return $S->object(exact => \"\\0\", \"\\\\0[0]\");\n  });\n\n\n\n  $self->add_flag('i' =>  sub { 0x01 });\n\n  $self->add_handler(':' => sub {\n    my ($S) = @_;\n\n    if (${&Rx} =~ m{ \\G \\: }xgc) {\n      my $n = '::';\n      return $S->$n;\n    }\n\n    if (${&Rx} =~ m{ \\G ([a-z]+) }xgc) {\n    }\n\n  });\n\n  $self->add_handler('::' => sub {\n    my ($S) = @_;\n\n    if (${&Rx} =~ m{ \\G \\: }xgc) {\n      my $n = ':::';\n      return $S->$n;\n    }\n  });\n\n  $self->add_handler(':::' => sub {\n    my ($S) = @_;\n  });\n\n\n\n\n\n\n  $self->add_handler('$' => sub {\n    my ($S) = @_;\n\n    if (${&Rx} =~ m{ \\G \\$ }xgc) {\n      my $n = '$$';\n      return $S->$n;\n    }\n\n    if ($S->match_scalar) {\n    }\n\n    return $S->object(eol => eos => '$');\n  });\n\n  $self->add_handler('$$' => sub {\n    my ($S) = @_;\n\n    if ($S->match_scalar) {\n    }\n\n    return $S->object(eol => eol => '$$');\n  });\n\n\n\n\n\n\n\n  $self->add_handler('^' => sub {\n    my ($S) = @_;\n\n    if (${&Rx} =~ m{ \\G \\^ }xgc) {\n      my $n = '^^';\n      return $S->$n;\n    }\n\n    return $S->object(bol => bos => '^');\n  });\n\n  $self->add_handler('^^' => sub {\n    my ($S) = @_;\n    return $S->object(bol => bol => '^^');\n  });\n\n\n\n\n\n  $self->add_handler('*' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< minmod >;\n    return $S->object(quant => 0, '');\n  });\n\n\n\n  $self->add_handler('+' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< minmod >;\n    return $S->object(quant => 1, '');\n  });\n\n\n\n  $self->add_handler('?' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< minmod >;\n    return $S->object(quant => 0, 1);\n  });\n\n\n\n  $self->add_handler('(' => sub {\n    my ($S) = @_;\n    $S->nextchar;\n\n    push @{ $S->{next} }, qw< c) atom >;\n    &SIZE_ONLY ? ++$S->{maxpar} : ++$S->{nparen};\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(open => $S->{nparen});\n  });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  $self->add_handler('.' => sub {\n    my ($S) = @_;\n    return $S->object(reg_any => sany => '.');\n  });\n\n\n\n  $self->add_handler('|' => sub {\n    my ($S) = @_;\n    return $S->object(branch =>);\n  });\n\n\n  return;\n\n  $self->add_handler('\\c' => sub {\n    my ($S, $cc) = @_;\n    ${&Rx} =~ m{ \\G (.?) }xgc;\n    my $c = $1;\n    return $S->force_object(anyof_char => chr(64 ^ ord $c), \"\\\\c$c\") if $cc;\n    return $S->object(exact => chr(64 ^ ord $c), \"\\\\c$c\");\n  });\n\n  $self->add_handler('\\P' => sub {\n    my ($S, $cc) = @_;\n    $S->error(RPe_EMPTYB, 'P') if ${&Rx} !~ m{ \\G (.) }xgcs;\n\n    my $name = $1;\n    if ($name eq '{') {\n      $S->error(RPe_RBRACE, 'P') if ${&Rx} !~ m{ \\G ([^\\}]*) \\} }xgc;\n      $name = $1;\n    }\n\n    return $S->force_object(anyof_class => $S->force_object(prop => $name, 1)) if $cc;\n    return $S->object(prop => $name, 1);\n  });\n\n  $self->add_handler('\\p' => sub {\n    my ($S, $cc) = @_;\n    $S->error(RPe_EMPTYB, 'p') if ${&Rx} !~ m{ \\G (.) }xgcs;\n\n    my $name = $1;\n    if ($name eq '{') {\n      $S->error(RPe_RBRACE, 'p') if ${&Rx} !~ m{ \\G ([^\\}]*) \\} }xgc;\n      $name = $1;\n    }\n\n    return $S->force_object(anyof_class => $S->force_object(prop => $name, 0)) if $cc;\n    return $S->object(prop => $name, 0);\n  });\n\n  $self->add_handler('\\X' => sub {\n    my ($S, $cc) = @_;\n    $S->warn(RPe_BADESC, 'X', ' in character class') if $cc;\n    return $S->force_object(anyof_char => 'X') if $cc;\n    return $S->object(clump => '\\X');\n  });\n\n  $self->add_handler('\\x' => sub {\n    my ($S, $cc) = @_;\n    ${&Rx} =~ m{ \\G ( \\{ | .{0,2} ) }sxgc;\n    my $brace = 0;\n    my $num = $1;\n\n    if ($num eq '{') {\n      $S->error(RPe_RBRACE, 'x') if ${&Rx} !~ m{ \\G ( [^\\}]* ) \\} }xgc;\n      $num = $1;\n      $brace = 1;\n    }\n    else {\n      my $good = ($num =~ s/^([a-fA-F0-9]*)// and $1);\n      &RxPOS -= length $num;\n      $num = $good;\n    }\n\n    my $rep = $brace ? \"\\\\x{$num}\" : sprintf(\"\\\\x%02s\", $num);\n    return $S->force_object(anyof_char => chr hex $num, $rep) if $cc;\n    return $S->object(exact => chr hex $num, $rep);\n  });\n\n  $self->add_handler('POSIX_alpha' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => alpha => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_alnum' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => alnum => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_ascii' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => ascii => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_cntrl' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => cntrl => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_digit' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => digit => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_graph' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => graph => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_lower' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => lower => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_print' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => print => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_punct' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => punct => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_space' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => space => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_upper' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => upper => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_word' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => word => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_xdigit' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => xdigit => $neg, \\$how);\n  });\n\n  $self->add_handler('{' => sub {\n    my ($S) = @_;\n    if (${&Rx} =~ m{ \\G (\\d+) (,?) (\\d*) \\} }xgc) {\n      my ($min, $range, $max) = ($1, $2, $3);\n      $max = $min unless $range;\n      push @{ $S->{next} }, qw< minmod >;\n      $S->error(RPe_BCURLY) if length($max) and $min > $max;\n      return $S->object(quant => $min, $max);\n    }\n    return $S->object(exact => '{');\n  });\n\n  $self->add_handler('minmod' => sub {\n    my ($S) = @_;\n    $S->nextchar;\n    return $S->object(minmod =>) if ${&Rx} =~ m{ \\G \\? }xgc;\n    return;\n  });\n\n\n\n\n\n  $self->add_handler('[' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< cce] cc cc] >;\n    my $neg = ${&Rx} =~ m{ \\G \\^ }xgc;\n\n    my $pos = &RxPOS;\n    if (${&Rx} =~ m{ \\G ([:.=]) .*? \\1 ] }xgc) {\n      $S->warn(RPe_OUTPOS, $1, $1);\n      &RxPOS = $pos;\n    }\n\n    return $S->object(anyof => $neg);\n  });\n\n  $self->add_handler('cc]' => sub {\n    my ($S) = @_;\n    return unless ${&Rx} =~ m{ \\G ] }xgc;\n    return $S->object(anyof_char => \"]\");\n  });\n\n  $self->add_handler('cc' => sub {\n    my ($S) = @_;\n    return if ${&Rx} =~ m{ \\G (?= ] | \\z ) }xgc;\n    push @{ $S->{next} }, qw< cc >;\n    my ($lhs, $rhs, $before_range);\n    my $ret = \\$lhs;\n\n    {\n      if (${&Rx} =~ m{ \\G ( \\\\ ) }xgcs) {\n        my $c = $1;\n        $$ret = $S->$c(1);\n      }\n      elsif (${&Rx} =~ m{ \\G \\[ ([.=:]) (\\^?) (.*?) \\1 \\] }xgcs) {\n        my ($how, $neg, $name) = ($1, $2, $3);\n        my $posix = \"POSIX_$name\";\n        if ($S->can($posix)) { $$ret = $S->$posix($neg, $how) }\n        else { $S->error(RPe_BADPOS, \"$how$neg$name$how\") }\n      }\n      elsif (${&Rx} =~ m{ \\G (.) }xgcs) {\n        $$ret = $S->force_object(anyof_char => $1);\n      }\n\n      if ($ret == \\$lhs) {\n        if (${&Rx} =~ m{ \\G (?= - ) }xgc) {\n          if ($lhs->visual =~ /^(?:\\[[:.=]|\\\\[dDsSwWpP])/) {\n            $S->warn(RPe_FRANGE, $lhs->visual, \"\");\n            $ret = $lhs;\n            last;\n          }\n          $before_range = &RxPOS++;\n          $ret = \\$rhs;\n          redo;\n        }\n        $ret = $lhs;\n      }\n      elsif ($ret == \\$rhs) {\n        if ($rhs->visual =~ /^(?:\\[[:.=]|\\\\[dDsSwWpP])/) {\n          $S->warn(RPe_FRANGE, $lhs->visual, $rhs->visual);\n          &RxPOS = $before_range;\n          $ret = $lhs;\n        }\n        elsif ($lhs->visual gt $rhs->visual) {\n          $S->error(RPe_IRANGE, $lhs->visual, $rhs->visual);\n        }\n        else {\n          $ret = $S->object(anyof_range => $lhs, $rhs);\n        }\n      }\n    }\n\n    return if &SIZE_ONLY;\n    return $ret;\n  });\n\n  $self->add_handler('cce]' => sub {\n    my ($S) = @_;\n    $S->error(RPe_LBRACK) if ${&Rx} !~ m{ \\G ] }xgc;\n    return $S->object(anyof_close => \"]\");\n  });\n\n  $self->add_handler(')' => sub {\n    my ($S) = @_;\n    pop @{ $S->{next} };\n    &RxPOS--;\n    return;\n  });\n\n  $self->add_handler('c)' => sub {\n    my ($S) = @_;\n    $S->error(RPe_LPAREN) if ${&Rx} !~ m{ \\G \\) }xgc;\n    pop @{ $S->{flags} };\n    return $S->object(close =>);\n  });\n\n  $self->add_handler('(?' => sub {\n    my ($S) = @_;\n    my $c = '(?';\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n      &RxPOS--;\n    }\n    else {\n      $S->error(RPe_SEQINC);\n    }\n\n    ${&Rx} =~ m{ \\G ([a-zA-Z]*) (-? [a-zA-Z]*) }xgc;\n    my ($on, $off) = ($1, $2);\n    my ($r_on, $r_off) = (\"\", \"\");\n    my ($f_on, $f_off) = (0,0);\n\n    &RxPOS -= length($on.$off);\n    my $old = &RxPOS;\n\n    for (split //, $on) {\n      &RxPOS++;\n      if (my $f = $S->can(\"FLAG_$_\")) {\n        my $v = $S->$f(1) and $r_on .= $_;\n        $f_on |= $v;\n        next;\n      }\n      my $bad = substr ${&Rx}, $old;\n      $S->error(RPe_NOTREC, &RxPOS - $old, $bad);\n    }\n\n    &RxPOS++ if $off =~ s/^-//;\n\n    for (split //, $off) {\n      &RxPOS++;\n      if (my $f = $S->can(\"FLAG_$_\")) {\n        my $v = $S->$f(0) and $r_off .= $_;\n        $f_off |= $v;\n        next;\n      }\n      my $bad = substr ${&Rx}, $old;\n      $S->error(RPe_NOTREC, &RxPOS - $old, $bad);\n    }\n\n    if (${&Rx} =~ m{ \\G ([:)]) }xgc) {\n      my $type = $1 eq ':' ? 'group' : 'flags';\n      if ($type eq 'group') {\n        push @{ $S->{flags} }, &Rf;\n        push @{ $S->{next} }, qw< c) atom >;\n      }\n      &Rf |= $f_on;\n      &Rf &= ~$f_off;\n      return $S->object($type => $r_on, $r_off);\n    }\n\n    &RxPOS++;\n    my $l = length($on.$off) + 2;\n    $S->error(RPe_NOTREC, $l, substr(${&Rx}, $old));\n  });\n\n  $self->add_handler('(?#' => sub {\n    my ($S) = @_;\n    ${&Rx} =~ m{ \\G [^)]* }xgc;\n    $S->error(RPe_NOTERM) unless ${&Rx} =~ m{ \\G \\) }xgc;\n    return;\n  });\n\n  $self->add_handler('(?$' => sub {\n    my ($S) = @_;\n    $S->error(RPe_NOTREC, 1, substr(${&Rx}, &RxPOS - 1));\n  });\n\n  $self->add_handler('(?@' => sub {\n    my ($S) = @_;\n    $S->error(RPe_NOTREC, 1, substr(${&Rx}, &RxPOS - 1));\n  });\n\n  $self->add_handler('(?=' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< c) atom >;\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(ifmatch => 1);\n  });\n\n  $self->add_handler('(?!' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< c) atom >;\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(unlessm => 1);\n  });\n\n  $self->add_handler('(?<' => sub {\n    my ($S) = @_;\n    my $c = '(?<';\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n    }\n\n    $S->error(RPe_NOTREC, 2, substr(${&Rx}, &RxPOS - 2));\n  });\n\n  $self->add_handler('(?<=' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< c) atom >;\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(ifmatch => -1);\n  });\n\n  $self->add_handler('(?<!' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< c) atom >;\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(unlessm => -1);\n  });\n\n  $self->add_handler('(?>' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< c) atom >;\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(suspend =>);\n  });\n\n  $self->add_handler('(?{' => sub {\n    my ($S) = @_;\n    my $nest;\n    $nest = qr[ (?> [^\\\\{}]+ | \\\\. | { (??{ $nest }) } )* ]x;\n    if (${&Rx} =~ m{ \\G ($nest) \\} \\) }xgc) {\n      push @{ $S->{flags} }, &Rf;\n      return $S->object(eval => $1);\n    }\n    $S->error(RPe_NOTBAL);\n  });\n\n  $self->add_handler('(??' => sub {\n    my ($S) = @_;\n    my $c = '(??';\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n    }\n\n    $S->error(RPe_NOTREC, 2, substr(${&Rx}, &RxPOS - 2));\n  });\n\n  $self->add_handler('(??{' => sub {\n    my ($S) = @_;\n    my $nest;\n    $nest = qr[ (?> [^\\\\{}]+ | \\\\. | { (??{ $nest }) } )* ]x;\n    if (${&Rx} =~ m{ \\G ($nest) \\} \\) }xgc) {\n      push @{ $S->{flags} }, &Rf;\n      return $S->object(logical => $1);\n    }\n    $S->error(RPe_NOTBAL);\n  });\n\n  $self->add_handler('(?p' => sub {\n    my ($S) = @_;\n    my $c = '(?p';\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n    }\n\n    $S->error(RPe_NOTREC, 2, substr(${&Rx}, &RxPOS - 2));\n  });\n\n  $self->add_handler('(?p{' => sub {\n    my ($S) = @_;\n    $S->warn(RPe_LOGDEP);\n    my $c = \"(??{\";\n    return $S->$c;\n  });\n\n  $self->add_handler('(?(' => sub {\n    my ($S) = @_;\n    my $c = '(?(';\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n      &RxPOS--;\n    }\n\n    push @{ $S->{next} }, qw< ifthen( >;\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(ifthen =>);\n  });\n\n  $self->add_handler('ifthen(' => sub {\n    my ($S) = @_;\n    my $c = 'ifthen(';\n\n    push @{ $S->{next} }, qw< c) atom >;\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n      &RxPOS--;\n    }\n\n    if (${&Rx} =~ m{ \\G ( [1-9]\\d* ) }xgc) {\n      my $n = $1;\n      $S->error(RPe_SWNREC) if ${&Rx} !~ m{ \\G \\) }xgc;\n      push @{ $S->{next} }, qw< ifthen|2 ifthen| ifthen_atom >;\n      return $S->object(groupp => $n);\n    }\n\n    $S->error(RPe_SWUNKN, &RxCUR);\n  });\n\n  $self->add_handler('ifthen_atom' => sub {\n    my ($S) = @_;\n    $S->nextchar;\n    ${&Rx} =~ m{ \\G ([^|]) }xgcs or return;\n    my $c = $1;\n\n    push @{ $S->{next} }, qw< ifthen_atom >;\n    return $S->$c if $S->can($c);\n    return $S->object(exact => $c);\n  });\n\n  $self->add_handler('ifthen|' => sub {\n    my ($S) = @_;\n    return if ${&Rx} !~ m{ \\G \\| }xgc;\n    push @{ $S->{next} }, qw< ifthen_atom >;\n    return $S->object(branch =>);\n  });\n\n  $self->add_handler('ifthen|2' => sub {\n    my ($S) = @_;\n    return if ${&Rx} !~ m{ \\G \\| }xgc;\n    $S->error(RPe_SWBRAN);\n  });\n\n  $self->add_handler('ifthen(?' => sub {\n    my ($S) = @_;\n    my $c = '(?';\n\n    push @{ $S->{next} }, qw< ifthen|2 ifthen| ifthen_atom >;\n\n    if (${&Rx} =~ m{ \\G ( (?: <? [!=] | \\{ ) ) }xgc) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n      &RxPOS -= length $1;\n    }\n\n    $S->error(RPe_SEQINC);\n  });\n}\n\n\n1;\n\n__END__\n",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/pX/Common/Regexp-Parser/Regexp-Parser-0.20-modified/lib/Perl6/Rule/Parser.pm",
      "package" : "Perl6::Rule::Parser"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "eval <<'END'",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/misc/pX/Aside/Regexp-ReplaceEngine.pm",
      "package" : "Regexp::StructHook"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub scalar  {        $_data{refaddr $_[0]}->{scalar}  }\n\n1",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/perl5/Pugs-Compiler-Perl6/lib/Pugs/Runtime/Capture.pm",
      "package" : "Pugs::Runtime::Capture"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub scalar {\n    return \\( $_[0]->flat );\n}\n\n1",
      "file" : "/var/tmp/arv_9ib559/Perl6-Pugs-6.2.13/perl5/Pugs-Compiler-Rule/lib/Pugs/Runtime/Match.pm",
      "package" : "Pugs::Runtime::Match"
   }
]
