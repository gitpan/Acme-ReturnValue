[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub run \n{\n\n\tmy %opts;\n\texit unless GetOptions(\n\t\t'config_file|config-file|c=s'\t\t=> \\$opts{config_file},\n\t\t'test=s'\t\t\t\t=> \\$opts{test},\n\t\t'yaml'\t\t\t\t\t=> \\$opts{yaml},\n\t\t'job=s'\t\t\t\t\t=> \\$opts{job},\n\t);\n\n\tBAIL_OUT(\"--config_file required\") unless $opts{config_file};\n\n\tmy $config;\n\teval { $config = get_config($opts{config_file}) };\n\n\tok(defined $config);\n\tis(\"$@\", \"\", \"we have a config\");\n\n\teval { validate_config($config); };\n\tis(\"$@\", \"\", \"the config is valid\");\n\n\tmy $cdir = dirname($opts{config_file});\n\n\tmy %output_readers = (\n\t\ttsv\t\t=> sub {\n\t\t\tmy ($file, $job, $test, $timeinfo, $opts) = @_;\n\t\t\topen my $fh, \"<\", $file || die \"open $file: $!\";\n\t\t\tmy $header = <$fh>;\n\t\t\tchomp($header);\n\t\t\tmy @cols = split(\"\\t\", $header);\n\t\t\treturn sub {\n\t\t\t\tmy $line = <$fh>;\n\t\t\t\tchomp($line);\n\t\t\t\tmy %ret;\n\t\t\t\t@ret{@cols} = split(\"\\t\", $line, -1);\n\t\t\t\treturn \\%ret;\n\t\t\t};\n\t\t},\n\t\tyml\t\t=> sub {\n\t\t\tmy ($file, $job, $test, $timeinfo, $opts) = @_;\n\t\t\tmy @r = LoadFile($file);\n\t\t\tif (@r == 1 && ref($r[0]) eq 'ARRAY') {\n\t\t\t\t@r = @{$r[0]};\n\t\t\t}\n\t\t\t@r = reverse(@r);\n\t\t\treturn sub {\n\t\t\t\tpop @r;\n\t\t\t};\n\t\t},\n\t);\n\n\n\tJOB:\n\tfor my $job (@{$config->{jobs}}) {\n\t\tnext if $job->{DISABLED};\n\t\tnext unless $job->{tests};\n\t\tnext unless @{$job->{tests}};\n\t\tnext if $opts{job} && $opts{job} ne $job->{name};\n\t\tfor my $test (@{$job->{tests}}) {\n\t\t\tnext if $opts{test} && $test ne $opts{test};\n\n\t\t\tmy $timeinfo = {\n\t\t\t\tYYYY\t=> 2000,\n\t\t\t\tMM\t=> '01',\n\t\t\t\tDD\t=> '01',\n\t\t\t};\n\n\t\t\tmy $opts = {};\n\n\t\t\tmy $input_stream;\n\t\t\teval { \n\t\t\t\t$input_stream = get_input($job, $test, $timeinfo, $opts);\n\t\t\t};\n\t\t\tis($@, \"\", \"we have inputs for $test for $job->{name}\");\n\t\t\tnext if $@;\n\n\t\t\tmy $output_stream;\n\t\t\teval { \n\t\t\t\t$output_stream = get_output($job, $test, $timeinfo, $opts);\n\t\t\t};\n\t\t\tis($@, \"\", \"we have expected outputs for $test for $job->{name}\");\n\t\t\tnext if $@;\n\n\t\t\tmy %code;\n\t\t\tundef $@;\n\t\t\tfor my $field (keys %Log::Parallel::Task::compile_fields) {\n\t\t\t\tmy ($s, $eval) = compile_user_code($job, $timeinfo, $field, {}, '', {}, mode => 'test');\n\t\t\t\tmy $e;\n\t\t\t\t$e = \"$@:\\nEVAL:\\n$eval\" if $@;\n\t\t\t\tis($@, \"\", \"compile $field for $job->{name}\");\n\t\t\t\tnext JOB if $@;\n\t\t\t\t$code{$field} = $s;\n\t\t\t}\n\n\t\t\t$code{grouper} = grouper_wrap($code{grouper}) if $job->{grouper};\n\n\t\t\tmy $c = 0;\n\t\t\tmy $d = 0;\n\t\t\twhile (my $input = $input_stream->()) {\n\t\t\t\teval {\n\t\t\t\t\tif (defined $input) {\n\t\t\t\t\t\treturn unless $code{filter}->($input);\n\t\t\t\t\t}\n\t\t\t\t\tfor my $output ($code{transform}->($code{grouper}->($input))) {\n\t\t\t\t\t\tmy $reference = $output_stream->();\n\t\t\t\t\t\tdiag Dump($output) if $opts{yaml};\n\t\t\t\t\t\tis_deeply($output, $reference, \"result $c from $job->{name} $test\");\n\t\t\t\t\t\tmy $bucket_data;\n\t\t\t\t\t\t$bucket_data = $code{bucketizer}->($output) if defined $output;\n\t\t\t\t\t\t$c++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tis($@, \"\", \"process input $d for $job->{name} $test\");\n\t\t\t\t$d++;\n\t\t\t}\n\t\t\teval {\n\t\t\t\tfor my $output ($code{transform}->($code{grouper}->(undef))) {\n\t\t\t\t\tmy $reference = $output_stream->();\n\t\t\t\t\tdiag Dump($output) if $opts{yaml};\n\t\t\t\t\tis_deeply($output, $reference, \"result $c (final) from $job->{name} $test\");\n\t\t\t\t\tmy $bucket_data;\n\t\t\t\t\t$bucket_data = $code{bucketizer}->($output) if defined $output;\n\t\t\t\t\t$c++;\n\t\t\t\t}\n\t\t\t};\n\t\t\tis($@, \"\", \"process eof for $job->{name} $test\");\n\t\t\tmy $o = $output_stream->();\n\t\t\tis(undef, $o, \"remaining reference outputs for $job->{name} $test\");\n\t\t}\n\t}\n\n\t$finished = 1;\n\n\tsub get_input\n\t{\n\t\tmy ($job, $test, $timeinfo, $opts) = @_;\n\t\t$test =~ m/\\.([^\\.]+)$/ or die \"need a suffix for $test\";\n\t\tmy $suffix = $1;\n\t\topen my $fh, \"<\", \"$cdir/$test\" \n\t\t\tor die \"open $cdir/$test: $!\";\n\t\tmy $p;\n\t\tif ($suffix eq 'tsv') {\n\t\t\tmy $header = <$fh>;\n\t\t\tchomp($header);\n\t\t\tmy @cols = split(\"\\t\", $header);\n\t\t\treturn sub {\n\t\t\t\tmy $line = <$fh>;\n\t\t\t\treturn undef unless $line;\n\t\t\t\tchomp($line);\n\t\t\t\tmy %ret;\n\t\t\t\t@ret{@cols} = split(\"\\t\", $line, -1);\n\t\t\t\treturn \\%ret;\n\t\t\t};\n\t\t} else {\n\t\t\tmy $header;\n\t\t\t$header = LoadFile(\"$cdir/$test.header\") if -e \"$cdir/$test.header\";\n\t\t\t$header ||= {};\n\t\t\teval { $p = get_parser($suffix, $fh, sorted_by => $header->{sort_by} || [], filename => \"$cdir/$test\", header => $header) }; \n\t\t\tif ($@) {\n\t\t\t\tif ($@ ne \"no such parser '$suffix'\\n\") {\n\t\t\t\t\tdie \"Error when trying to get parser for $suffix: $@\";\n\t\t\t\t}\n\t\t\t} elsif ($p) {\n\t\t\t\treturn $p;\n\t\t\t}\n\t\t\tdie \"don't know how to handle the .$suffix suffix\";\n\t\t}\n\t}\n\n\tsub get_output\n\t{\n\t\tmy ($job, $test, $timeinfo, $opts) = @_;\n\t\t$test =~ m/(.*)\\.[^\\.]+$/ or die \"need a suffix for $test\";\n\t\tmy $base = $1;\n\n\t\tfor my $suffix (keys %output_readers) {\n\t\t\tnext unless -e \"$cdir/$base.expected.$suffix\";\n\t\t\treturn $output_readers{$suffix}->(\"$cdir/$base.expected.$suffix\", $job, $test, $timeinfo, $opts);\n\t\t}\n\t\tdie \"Could not find reference output\";\n\t}\n}",
      "file" : "/var/tmp/arv_63_vCG/Log-Parallel-0.303/lib/Log/Parallel/test_log_configs.pm",
      "package" : "Log::Parallel::test_log_configs"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub run \n{\n\tdie \"$0: Usage [--add_source] metafile(s)\" unless @ARGV;\n\n\tmy $add_source;\n\tdie unless GetOptions(\n\t\t'add_source'\t=> \\$add_source,\n\t);\n\n\tmy @metafiles;\n\n\tfor my $mf (@ARGV) {\n\t\tdie \"no such file '$mf'\\n\" unless -e $mf;\n\t\tmy $meta = LoadFile($mf);\n\t\tpush(@metafiles, $meta);\n\t}\n\n\tmy $colcount = 0;\n\tmy %allcols;\n\tmy %cols;\n\n\tfor my $meta (@metafiles) {\n\t\tfor my $file (@{$meta->{FILES}}) {\n\t\t\tnext unless $file->{items};\n\t\t\t$cols{$file} = $file->{header}{columns};\n\t\t\tfor my $col (@{$cols{$file}}) {\n\t\t\t\tnext if defined $allcols{$col};\n\t\t\t\t$allcols{$col} = $colcount++ \n\t\t\t}\n\t\t}\n\t}\n\n\tprint \"BUCKET\\tFILE\\t\" if $add_source;\n\tprint join(\"\\t\", sort { $allcols{$a} <=> $allcols{$b} } keys %allcols) . \"\\n\";\n\n\tfor my $meta (@metafiles) {\n\t\tfor my $file (@{$meta->{FILES}}) {\n\t\t\tmy $prefix = '';\n\t\t\t$prefix = \"$file->{bucket}\\t$file->{host}:$file->{filename}\\t\" if $add_source;\n\t\t\tmy $data;\n\t\t\tsmartopen(\"$file->{host}:$file->{filename}\", $data, \"r\");\n\t\t\tmy @cols = map { $allcols{$_} } @{$cols{$file}};\n\t\t\tmy %present = map { $_ => 1 } @{$cols{$file}};\n\t\t\tmy @missing = map { $allcols{$_} } grep { ! defined($present{$_}) } keys %allcols;\n\t\t\tmy @blanks = ( '' ) x @missing;\n\t\t\twhile (<$data>) {\n\t\t\t\tchomp;\n\t\t\t\tmy @d = split(\"\\t\", $_, -1);\n\t\t\t\tmy @rec;\n\t\t\t\t@rec[@cols] = @d;\n\t\t\t\t@rec[@missing] = @blanks;\n\t\t\t\tprint $prefix . join(\"\\t\", map { defined $_ ? $_ : '' } @rec) . \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}",
      "file" : "/var/tmp/arv_63_vCG/Log-Parallel-0.303/lib/Log/Parallel/ltsv_to_tsv.pm",
      "package" : "Log::Parallel::ltsv_to_tsv"
   }
]
