[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class POE::Filter::XML {\n    use MooseX::NonMoose;\n    extends 'Moose::Object','POE::Filter';\n\n    use Carp;\n    use Try::Tiny;\n    use XML::LibXML;\n    use POE::Filter::XML::Handler;\n    use Moose::Util::TypeConstraints;\n    use MooseX::Types::Moose(':all');\n\n\n    has buffer =>\n    (\n        is => 'ro',\n        traits => [ 'Array' ],\n        isa => ArrayRef,\n        lazy => 1,\n        clearer => '_clear_buffer',\n        default => sub { [] },\n        handles =>\n        {\n            has_buffer => 'count',\n            all_buffer => 'elements',\n            push_buffer => 'push',\n            shift_buffer => 'shift',\n            join_buffer => 'join',\n        }\n    );\n\n\n    has callback =>\n    (\n        is => 'ro',\n        isa => CodeRef,\n        lazy => 1,\n        default => sub { Carp::confess('Parsing error happened: '. shift) },\n    );\n\n\n    has handler =>\n    (\n        is => 'ro',\n        isa => class_type('POE::Filter::XML::Handler'),\n        lazy => 1,\n        builder => '_build_handler',\n        handles =>\n        {\n            '_reset_handler' => 'reset',\n            'finished_nodes' => 'has_finished_nodes',\n            'get_node' => 'get_finished_node',\n        }\n    );\n\n\n    has parser =>\n    (\n        is => 'ro',\n        isa => class_type('XML::LibXML'),\n        lazy => 1,\n        builder => '_build_parser',\n        clearer => '_clear_parser'\n    );\n\n\n    has not_streaming =>\n    (\n        is => 'ro',\n        isa => Bool,\n        default => 0,\n    );\n\n    method _build_handler {\n        POE::Filter::XML::Handler->new(not_streaming => $self->not_streaming)\n    }\n\n    method _build_parser {\n        XML::LibXML->new(Handler => $self->handler)\n    }\n\n\n    method BUILDARGS(ClassName $class: @args) returns (HashRef) {\n\n        my $config = {};\n        my @keys;\n        while($#args != -1)\n        {\n            my $key = shift(@args);\n            if($key =~ m/[A-Z]+/)\n            {\n                push(@keys, $key);\n                $key = lc($key);\n            }\n\n            my $val = shift(@args);\n            $config->{$key} = $val;\n        }\n\n        if(@keys)\n        {\n            Carp::cluck\n            (\n                q|ALL CAPS usage of parameters (| . join(' ', @keys) . q|)|.\n                q| to the constructor |.\n                q|is DEPRECATED. Please correct this usage soon. Next |.\n                q|version will NOT support these arguments|\n            );\n        }\n        return $config;\n    }\n\n\n    method BUILD {\n\n        if($self->has_buffer)\n        {\n            try\n            {\n                $self->parser->parse_chunk($self->join_buffer(\"\\n\"));\n\n            }\n            catch\n            {\n                $self->callback->($_);\n            }\n            finally\n            {\n                $self->_clear_buffer();\n            }\n        }\n    }\n\n\n    method reset {\n\n        $self->_reset_handler();\n        $self->_clear_parser();\n        $self->_clear_buffer();\n    }\n\n\n    method get_one_start(ArrayRef $raw?) {\n\n        if (defined $raw)\n        {\n            foreach my $raw_data (@$raw)\n            {\n                $self->push_buffer(split(/(?=\\x0a?\\x0d|\\x0d\\x0a?)/s, $raw_data));\n            }\n        }\n    }\n\n\n    method get_one returns (ArrayRef) {\n\n        if($self->finished_nodes())\n        {\n            return [$self->get_node()];\n\n        }\n        else\n        {\n            while($self->has_buffer())\n            {\n                my $line = $self->shift_buffer();\n\n                try\n                {\n                    $self->parser->parse_chunk($line);\n                }\n                catch\n                {\n                    $self->callback->($_);\n                };\n\n                if($self->finished_nodes())\n                {\n                    my $node = $self->get_node();\n\n                    if($node->stream_end() or $self->not_streaming)\n                    {\n                        $self->parser->parse_chunk('', 1);\n                        $self->reset();\n                    }\n\n                    return [$node];\n                }\n            }\n            return [];\n        }\n    }\n\n\n    method put(ArrayRef $nodes) returns (ArrayRef) {\n\n        my $output = [];\n\n        foreach my $node (@$nodes)\n        {\n            if($node->stream_start())\n            {\n                $self->reset();\n            }\n            push(@$output, $node->toString());\n        }\n\n        return $output;\n    }\n}\n1",
      "file" : "/var/tmp/arv_BFwIzs/POE-Filter-XML-1.102960/lib/POE/Filter/XML.pm",
      "package" : "POE::Filter::XML"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class POE::Filter::XML::Node {\n    use MooseX::NonMoose::InsideOut;\n    extends 'XML::LibXML::Element';\n\n    use XML::LibXML(':libxml');\n    use MooseX::Types::Moose(':all');\n\n\n    has stream_start => (is => 'ro', writer => '_set_stream_start', isa => Bool, default => 0);\n    has stream_end => (is => 'ro', writer => '_set_stream_end', isa => Bool, default => 0);\n\n\n    method BUILDARGS(ClassName $class: $name) {\n\n        return { name => $name };\n    }\n\n\n    override cloneNode(Bool $deep) {\n        \n        my $clone = super();\n        \n        bless($clone, $self->meta->name());\n        \n        $clone->_set_stream_start($self->stream_start());\n        $clone->_set_stream_end($self->stream_end());\n        \n        return $clone;\n    }\n\n    override getChildrenByTagName(Str $name) {\n\n        return (map { bless($_, $self->meta->name()) } @{ super() });\n    }\n\n    override getChildrenByTagNameNS(Str $nsURI, $localname) {\n\n        return (map { bless($_, $self->meta->name()) } @{ super() });\n    }\n\n    override getChildrenByLocalName(Str $localname) {\n        \n        return (map { bless($_, $self->meta->name()) } @{ super() });\n    }\n    \n    override getElementsByTagName(Str $name) {\n\n        return (map { bless($_, $self->meta->name()) } @{ super() });\n    }\n\n    override getElementsByTagNameNS(Str $nsURI, $localname) {\n\n        return (map { bless($_, $self->meta->name()) } @{ super() });\n    }\n\n    override getElementsByLocalName(Str $localname) {\n        \n        return (map { bless($_, $self->meta->name()) } @{ super() });\n    }\n    \n\n    override toString(Bool $formatted?) returns (Str) {\n\n        if($self->stream_start())\n        {\n            my $string = '<';\n            $string .= $self->nodeName();\n            foreach my $attr ($self->attributes())\n            {\n                $string .= sprintf(' %s=\"%s\"', $attr->nodeName(), $attr->value());\n            }\n            $string .= '>';\n            return $string;\n        }\n        elsif ($self->stream_end())\n        {\n            return sprintf('</%s>', $self->nodeName()); \n        }\n        else\n        {\n            return super();\n        }\n    }\n\n\n    method setAttributes(ArrayRef $array) {\n\n        for(my $i = 0; $i < scalar(@$array); $i++)\n        {\n            if($array->[$i] eq 'xmlns')\n            {\n                $self->setNamespace($array->[++$i], '', 0);\n            }\n            else\n            {\n                $self->setAttribute($array->[$i], $array->[++$i]);\n            }\n        }\n    }\n\n\n    method getAttributes() returns (HashRef) {\n\n        my $attributes = {};\n\n        foreach my $attrib ($self->attributes())\n        {\n            if($attrib->nodeType == XML_ATTRIBUTE_NODE)\n            {\n                $attributes->{$attrib->nodeName()} = $attrib->value();\n            }\n        }\n\n        return $attributes;\n    }\n\n\n    method getSingleChildByTagName(Str $name) returns (Maybe[POE::Filter::XML::Node]) {\n\n        my $node = ($self->getChildrenByTagName($name))[0];\n        return undef if not defined($node);\n        return $node;\n    }\n\n\n    method getChildrenHash() returns (HashRef) {\n\n        my $children = {};\n\n        foreach my $child ($self->getChildrenByTagName(\"*\"))\n        {\n            my $name = $child->nodeName();\n            \n            if(!exists($children->{$name}))\n            {\n                $children->{$name} = [];\n            }\n            \n            push(@{$children->{$name}}, $child);\n        }\n\n        return $children;\n    }\n}",
      "file" : "/var/tmp/arv_BFwIzs/POE-Filter-XML-1.102960/lib/POE/Filter/XML/Node.pm",
      "package" : "POE::Filter::XML::Node"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class POE::Filter::XML::Handler {\n    use MooseX::NonMoose;\n    extends 'XML::SAX::Base';\n\n    use Moose::Util::TypeConstraints;\n    use MooseX::Types::Moose(':all');\n    use POE::Filter::XML::Node;\n\n\n    has current_node =>\n    (\n        is => 'rw',\n        isa => class_type('POE::Filter::XML::Node'),\n        predicate => '_has_current_node',\n        clearer => '_clear_current_node'\n    );\n\n    has finished_nodes =>\n    (\n        is => 'ro',\n        traits => ['Array'],\n        isa => ArrayRef,\n        default => sub { [] },\n        clearer => '_clear_finished_nodes',\n        handles =>\n        {\n            all_finished_nodes => 'elements',\n            has_finished_nodes => 'count',\n            add_finished_node => 'push',\n            get_finished_node => 'shift',\n        }\n    );\n\n\n    has depth_stack =>\n    (\n        is => 'ro',\n        traits => ['Array'],\n        isa => ArrayRef,\n        default => sub { [] },\n        clearer => '_clear_depth_stack',\n        handles =>\n        {\n            push_depth_stack => 'push',\n            pop_depth_stack => 'pop',\n            depth => 'count',\n        }\n    );\n\n\n    has not_streaming => ( is => 'ro', isa => Bool, default => 0 );\n\n\n    method reset {\n\n        $self->_clear_current_node();\n        $self->_clear_finished_nodes();\n        $self->_clear_depth_stack();\n    }\n\n\n\n    override start_element(HashRef $data) {\n\n        my $node = POE::Filter::XML::Node->new($data->{'Name'});\n\n        foreach my $attrib (values %{$data->{'Attributes'}})\n        {\n            $node->setAttribute\n            (\n                $attrib->{'Name'},\n                $attrib->{'Value'}\n            );\n        }\n\n\n        if($self->depth() == 0)\n        {\n            $self->push_depth_stack($node);\n\n            if($self->not_streaming)\n            {\n                $self->current_node($node);\n            }\n            else\n            {\n                $node->_set_stream_start(1);\n                $self->add_finished_node($node);\n            }\n\n        }\n        else\n        {\n            $self->push_depth_stack($self->current_node);\n\n            if($self->depth() == 2)\n            {\n                if($self->not_streaming)\n                {\n                    $self->current_node->appendChild($node);\n                }\n                $self->current_node($node);\n            }\n            else\n            {\n                $self->current_node->appendChild($node);\n                $self->current_node($node);\n            }\n        }\n\n        super();\n    }\n\n\n    method end_element(HashRef $data) {\n\n        if($self->depth() == 1)\n        {\n            if($self->not_streaming)\n            {\n                $self->add_finished_node($self->pop_depth_stack());\n            }\n            else\n            {\n                my $end = POE::Filter::XML::Node->new($data->{'Name'});\n                $end->_set_stream_end(1);\n                $self->add_finished_node($end);\n            }\n\n        }\n        elsif($self->depth() == 2)\n        {\n            if($self->not_streaming)\n            {\n                $self->current_node($self->pop_depth_stack());\n            }\n            else\n            {\n                $self->add_finished_node($self->current_node);\n                $self->_clear_current_node();\n                $self->pop_depth_stack();\n            }\n\n        }\n        else\n        {\n            $self->current_node($self->pop_depth_stack());\n        }\n\n        super();\n    }\n\n\n    override characters(HashRef $data) {\n\n        if($self->depth() == 1)\n        {\n            return;\n        }\n\n        $self->current_node->appendText($data->{'Data'});\n\n        super();\n    }\n}",
      "file" : "/var/tmp/arv_BFwIzs/POE-Filter-XML-1.102960/lib/POE/Filter/XML/Handler.pm",
      "package" : "POE::Filter::XML::Handler"
   }
]
