[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "%VRML::Nodes = (\nDEF => new VRML::NodeType(\"DEF\",{node => [SFNode, NULL]}, id => [SFString,\"\"]),\nUSE => new VRML::NodeType(\"USE\",{node => [SFNode, NULL]}, id => [SFString,\"\"]),\n\nShape => new VRML::NodeType (\"Shape\",\n\t{appearance => [SFNode, NULL],\n\t geometry => [SFNode, NULL]}\n),\n\nAppearance => new VRML::NodeType (\"Appearance\",\n\t{material => [SFNode,NULL],\n\t texture => [SFNode,NULL],\n\ttextureTransform => [SFNode,NULL]\n\t }\n),\n\nMaterial => new VRML::NodeType (\"Material\",\n\t{diffuseColor => [SFColor, [0.8, 0.8, 0.8]],\n\t ambientIntensity => [SFFloat, 0.2],\n\t specularColor => [SFColor, [0,0,0]],\n\t emissiveColor => [SFColor, [0,0,0]],\n\t shininess => [SFFloat, 0.2],\n\t transparency => [SFFloat, 0]}\n),\n\nImageTexture => new VRML::NodeType(\"ImageTexture\",\n\t{url => [MFString, []],\n\t repeatS => [SFBool, 1],\n\t repeatT => [SFBool, 1],\n\t __depth => [SFInt32, 1],\n\t __x => [SFInt32,0],\n\t __y => [SFInt32,0],\n\t __data => [SFString, \"\"],\n\t},{\n\tInitialize => sub {\n\t\tmy($t,$f,$time,$scene) = @_;\n\t\tinit_image(\"\",\"url\",$t,$f,$scene);\n\t\treturn ();\n\t}\n\t}\n),\n\nBox => new VRML::NodeType(\"Box\",\n\t{size => [SFVec3f, [2,2,2]]}\n),\n\nCylinder => new VRML::NodeType (\"Cylinder\",\n\t{radius => [SFFloat,1],\n\t height => [SFFloat,2],\n\t side => [SFBool,1],\n\t top => [SFBool,1],\n\t bottom => [SFBool,1]},\n),\n\nCone => new VRML::NodeType (\"Cone\",\n\t{bottomRadius => [SFFloat,1],\n\t height => [SFFloat,2],\n\t side => [SFBool,1],\n\t bottom => [SFBool,1]},\n),\n\nCoordinate => new VRML::NodeType(\"Coordinate\",\n\t{point => [MFVec3f, []]}\n),\nColor => new VRML::NodeType(\"Color\",\n\t{color => [MFColor, []]}\n),\nNormal => new VRML::NodeType(\"Normal\",\n\t{vector => [MFVec3f, []]}\n),\n\nTextureCoordinate => new VRML::NodeType(\"TextureCoordinate\",\n\t{point => [MFVec2f, []]}\n),\n\n\nElevationGrid => new VRML::NodeType(\"ElevationGrid\",\n\t{height => [MFFloat, []],\n\t xDimension => [SFInt32, 0],\n\t zDimension => [SFInt32, 0],\n\t xSpacing => [SFFloat, 1.0],\n\t zSpacing => [SFFloat, 1.0],\n\t solid => [SFBool, 1],\n\t creaseAngle => [SFFloat, 0],\n\t color => [SFNode, NULL],\n\t normal => [SFNode, NULL],\n\n\t colorPerVertex => [SFBool, 1],\n\t normalPerVertex => [SFBool, 1],\n\t}\n),\n\nExtrusion => new VRML::NodeType(\"Extrusion\",\n\t{beginCap => [SFBool, 1],\n\t ccw => [SFBool, 1],\n\t convex => [SFBool, 1],\n\t creaseAngle => [SFFloat, 0],\n\t crossSection => [MFVec2f, [[1,1],[1,-1],[-1,-1],[-1,1],[1,1]]],\n\t endCap => [SFBool, 1],\n\t orientation => [MFRotation, [[0,0,1,0]]],\n\t scale => [MFVec2f, [[1,1]]],\n\t solid => [SFBool, 1],\n\t spine => [MFVec3f, [[0,0,0],[0,1,0]]]\n\t}\n),\n\nSphere => new VRML::NodeType(\"Sphere\",\n\t{radius => [SFFloat, 1]}\n),\n\nIndexedFaceSet => new VRML::NodeType(\"IndexedFaceSet\",\n\t{coord => [SFNode, NULL],\n\t coordIndex => [MFInt32, []],\n\t colorIndex => [MFInt32, []],\n\t normal => [SFNode, NULL],\n\t normalIndex => [MFInt32, []],\n\t solid => [SFBool, 1],\n\t creaseAngle => [SFFloat, 0],\n\t texCoord => [SFNode, NULL],\n\t texCoordIndex => [MFInt32, []],\n\t convex => [SFBool, 1],\n\t color => [SFNode, NULL],\n\t colorPerVertex => [SFBool, 1],\n\t ccw => [SFBool, 1],\n\t}\n),\n\n\nIndexedLineSet => new VRML::NodeType(\"IndexedLineSet\",\n\t{coord => [SFNode, NULL],\n\t color => [SFNode, NULL],\n\t colorIndex => [MFInt32, []],\n\t coordIndex => [MFInt32, []],\n\t colorPerVertex => [SFBool, 1],\n\t}\n),\n\nPointSet => new VRML::NodeType(\"PointSet\",\n\t{color => [SFNode, NULL],\n\t coord => [SFNode, NULL]\n\t}\n),\n\nText => new VRML::NodeType (\"Text\",\n\t{string => [MFString, []],\n\t fontStyle => [SFNode, NULL],\n\t length => [MFFloat, []],\n\t maxExtent => [SFFloat, 0.0],\n\t __rendersub => [SFInt32, 0],   \n\t}, {\n\tInitialize => sub {\n\t\tmy($t,$f) = @_;\n\t\tmy $a = eval 'require VRML::Text; VRML::Text::get_rendptr();';\n\t\tif($@) {die(\"Warning: text loading error: '$@'\\n\");}\n\t\t$f->{__rendersub} = $a;\n\t\treturn ();\n\t}\n\t}\n),\n\nFontStyle => new VRML::NodeType(\"FontStyle\",\n\t{family => [MFString, [\"SERIF\"]],\n\t horizontal => [SFBool, 1],\n\t justify => [MFString, [\"BEGIN\"]],\n\t language => [SFString, \"\"],\n\t leftToRight => [SFBool, 1],\n\t size => [SFFloat, 1.0],\n\t spacing => [SFFloat, 1.0],\n\t style => [SFString, [\"PLAIN\"]],\n\t topToBottom => [SFBool, 1],\n\t}\n),\n\nSwitch => new VRML::NodeType(\"Switch\",\n\t{choice => [MFNode, []],\n\t whichChoice => [SFInt32, -1]\n\t}\n),\n\nLOD => new VRML::NodeType(\"LOD\",\n\t{level => [MFNode, []],\n\t center => [SFVec3f, [0,0,0],  field],\n\t range => [MFFloat, []]\n\t}\n),\n\nTransform => new VRML::NodeType (\"Transform\",\n\t{translation => [SFVec3f, [0,0,0]],\n\t rotation => [SFRotation, [0,0,1,0]],\n\t scale => [SFVec3f, [1,1,1]],\n\t scaleOrientation => [SFRotation, [0,0,1,0]],\n\t children => [MFNode, []],\n\t center => [SFVec3f, [0,0,0]],\n\t bboxCenter => [SFVec3f, [0,0,0]],\n\t bboxSize => [SFVec3f, [-1,-1,-1]],\n\t},\n),\n\nTextureTransform => new VRML::NodeType (\"TextureTransform\",\n\t{center => [SFVec2f, [0,0]],\n\t rotation => [SFFloat, 0],\n\t scale => [SFVec2f, [1,1]],\n\t translation => [SFVec2f, [0,0]],\n\t}\n),\n\nGroup => new VRML::NodeType(\"Group\",\n\t{children => [MFNode, []],\n\t bboxCenter => [SFVec3f, [0,0,0]],\n\t bboxSize => [SFVec3f, [-1,-1,-1]],\n\t}\n),\n\nAnchor => new VRML::NodeType(\"Anchor\",\n\t{children => [MFNode, []],\n\t url => [MFString, []],\n\t description => [SFString, \"\"],\n\t parameter => [MFString, []],\n\t bboxCenter => [SFVec3f, [0,0,0]],\n\t bboxSize => [SFVec3f, [-1,-1,-1]],\n\t}\n),\n\nBillboard => new VRML::NodeType(\"Billboard\",\n\t{children => [MFNode, []],\n\t axisOfRotation => [SFVec3f, [0,1,0]],\n\t bboxCenter => [SFVec3f, [0,0,0]],\n\t bboxSize => [SFVec3f, [-1,-1,-1]],\n\t}\n),\n\nWorldInfo => new VRML::NodeType(\"WorldInfo\",\n\t{title => [SFString, \"\"],\n\t info => [MFString, []]\n\t}\n),\n\nScalarInterpolator => new VRML::NodeType(\"ScalarInterpolator\",\n\t{key => [MFFloat, []],\n\t keyValue => [MFFloat, []],\n\t set_fraction => [SFFloat, undef, in],\n\t value_changed => [SFFloat, undef, out],\n\t},\n\t{Initialize => sub {\n\t\tmy($t,$f) = @_;\n\t\t$t->{Fields}->{value_changed} = \n\t\t (defined $f->{keyValue}[0] ?\n\t\t \t$f->{keyValue}[0] : 0);\n\t\treturn [$t, value_changed, $f->{keyValue}[0]];\n\t },\n\t EventsProcessed => sub {\n\t\tmy($t, $f) = @_;\n\t\tmy $k = $f->{key};\n\t\tmy $kv = $f->{keyValue};\n\t\tmy $fr = $f->{set_fraction};\n\t\tmy $v;\n\t\tif($f->{set_fraction} <= $k->[0]) {\n\t\t\t$v = $kv->[0]\n\t\t} elsif($f->{set_fraction} >= $k->[-1]) {\n\t\t\t$v = $kv->[-1]\n\t\t} else {\n\t\t\tmy $i;\n\t\t\tfor($i=1; $i<=$#$k; $i++) {\n\t\t\t\tif($f->{set_fraction} < $k->[$i]) {\n\t\t\t\t\tprint \"SCALARX: $i\\n\"\n\t\t\t\t\t\tif $VRML::verbose;\n\t\t\t\t\t$v = ($f->{set_fraction} - $k->[$i-1]) /\n\t\t\t\t\t     ($k->[$i] - $k->[$i-1]) *\n\t\t\t\t\t     ($kv->[$i] - $kv->[$i-1]) +\n\t\t\t\t\t     $kv->[$i-1];\n\t\t\t\t\tlast\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprint \"SCALAR: NEW_VALUE $v ($k $kv $f->{set_fraction}, $k->[0] $k->[1] $k->[2] $kv->[0] $kv->[1] $kv->[2])\\n\"\n\t\t\tif $VRML::verbose;\n\t\treturn [$t, value_changed, $v];\n\t}\n\t}\n),\n\nOrientationInterpolator => new VRML::NodeType(\"OrientationInterpolator\",\n\t{key => [MFFloat, []],\n\t keyValue => [MFRotation, []],\n\t set_fraction => [SFFloat, undef, in],\n\t value_changed => [SFRotation, undef, out],\n\t},\n\t{Initialize => sub {\n\t\tmy($t,$f) = @_;\n\t\t$t->{Fields}{value_changed} = ($f->{keyValue}[0] or [0,0,1,0]);\n\t\treturn ();\n\t },\n\t EventsProcessed => sub {\n\t\tmy($t, $f) = @_;\n\t\tmy $k = $f->{key};\n\t\tmy $kv = $f->{keyValue};\n\t\tmy $fr = $f->{set_fraction};\n\t\tmy $v;\n\t\tif($f->{set_fraction} <= $k->[0]) {\n\t\t\t$v = $kv->[0]\n\t\t} elsif($f->{set_fraction} >= $k->[-1]) {\n\t\t\t$v = $kv->[-1]\n\t\t} else {\n\t\t\tmy $i;\n\t\t\tfor($i=1; $i<=$#$k; $i++) {\n\t\t\t\tif($f->{set_fraction} < $k->[$i]) {\n\t\t\t\t\tprint \"ORIENTX: $i ($#$k) $k->[$i] $k->[$i-1] @{$kv->[$i]} | @{$kv->[$i-1]}\\n\"\n\t\t\t\t\t\tif $VRML::verbose::oint;\n\t\t\t\t\tmy $f = ($f->{set_fraction} - $k->[$i-1]) /\n\t\t\t\t\t     ($k->[$i] - $k->[$i-1]) ;\n\t\t\t\t\tmy $s = VRML::Quaternion->\n\t\t\t\t\t\tnew_vrmlrot(@{$kv->[$i-1]});\n\t\t\t\t\tmy $e = VRML::Quaternion->\n\t\t\t\t\t\tnew_vrmlrot(@{$kv->[$i]});\n\t\t\t\t\tprint \"Start: \",$s->as_str,\"\\n\" if $VRML::verbose::oint;\n\t\t\t\t\tprint \"End: \",$e->as_str,\"\\n\" if $VRML::verbose::oint;\n\t\t\t\t\tmy $step = $e->multiply($s->invert);\n\t\t\t\t\tprint \"Step: \",$step->as_str,\"\\n\" if $VRML::verbose::oint;\n\t\t\t\t\t$step = $step->multiply_scalar($f);\n\t\t\t\t\tprint \"StepMult $f: \",$step->as_str,\"\\n\" if $VRML::verbose::oint;\n\t\t\t\t\tmy $tmp = $s->multiply($step);\n\t\t\t\t\tprint \"TMP: \",$tmp->as_str,\"\\n\" if $VRML::verbose::oint;\n\t\t\t\t\t$v = $tmp->to_vrmlrot;\n\t\t\t\t\tprint \"V: \",(join ',  ',@$v),\"\\n\" if $VRML::verbose::oint;\n\t\t\t\t\tlast\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprint \"OR: NEW_VALUE $v ($k $kv $f->{set_fraction}, $k->[0] $k->[1] $k->[2] $kv->[0] $kv->[1] $kv->[2])\\n\"\n\t\t\tif $VRML::verbose::oint;\n\t\treturn [$t, value_changed, $v];\n\t}\n\t}\n),\n\nColorInterpolator => new VRML::NodeType(\"ColorInterpolator\",\n\t{key => [MFFloat, []],\n\t keyValue => [MFColor, []],\n\t set_fraction => [SFFloat, undef, in],\n\t value_changed => [SFColor, undef, out],\n\t},\n    @x = \n\t{Initialize => sub {\n\t\tmy($t,$f) = @_;\n\t\t$t->{Fields}->{value_changed} = ($f->{keyValue}[0] or [0,0,0]);\n\t\treturn ();\n\t },\n\t EventsProcessed => sub {\n\t\tmy($t, $f) = @_;\n\t\tmy $k = $f->{key};\n\t\tmy $kv = $f->{keyValue};\n\t\tmy $fr = $f->{set_fraction};\n\t\tmy $v;\n\t\tif($f->{set_fraction} <= $k->[0]) {\n\t\t\t$v = $kv->[0]\n\t\t} elsif($f->{set_fraction} >= $k->[-1]) {\n\t\t\t$v = $kv->[-1]\n\t\t} else {\n\t\t\tmy $i;\n\t\t\tfor($i=1; $i<=$#$k; $i++) {\n\t\t\t\tif($f->{set_fraction} < $k->[$i]) {\n\t\t\t\t\tprint \"COLORX: $i\\n\"\n\t\t\t\t\t\tif $VRML::verbose or\n\t\t\t\t\t\t   $VRML::sverbose =~ /\\binterp\\b/;\n\t\t\t\t\tfor(0..2) {\n\t\t\t\t\t\t$v->[$_] = ($f->{set_fraction} - $k->[$i-1]) /\n\t\t\t\t\t\t     ($k->[$i] - $k->[$i-1]) *\n\t\t\t\t\t\t     ($kv->[$i][$_] - $kv->[$i-1][$_]) +\n\t\t\t\t\t\t     $kv->[$i-1][$_];\n\t\t\t\t\t}\n\t\t\t\t\tlast\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprint \"SCALAR: NEW_VALUE $v ($k $kv $f->{set_fraction}, $k->[0] $k->[1] $k->[2] $kv->[0] $kv->[1] $kv->[2])\\n\"\n\t\t\tif $VRML::verbose or\n\t\t\t   $VRML::sverbose =~ /\\binterp\\b/;\n\t\treturn [$t, value_changed, $v];\n\t}\n\t}\n),\n\nPositionInterpolator => new VRML::NodeType(\"PositionInterpolator\",\n\t{key => [MFFloat, []],\n\t keyValue => [MFVec3f, []],\n\t set_fraction => [SFFloat, undef, in],\n\t value_changed => [SFVec3f, undef, out],\n\t},\n\t@x\n),\n\t\nCoordinateInterpolator => new VRML::NodeType(\"ColorInterpolator\",\n\t{key => [MFFloat, []],\n\t keyValue => [MFVec3f, []],\n\t set_fraction => [SFFloat, undef, in],\n\t value_changed => [MVVec3f, undef, out],\n\t},\n    @x = \n\t{Initialize => sub {\n\t\tmy($t,$f) = @_;\n\t\tmy $nkv = scalar(@{$f->{keyValue}}) / \n\t\t\t\tscalar(@{$f->{key}});\n\t\t$t->{Fields}->{value_changed} = \n\t\t   ([@{$f->{keyValue}}[0..$nkv-1]] or []);\n\t\treturn ();\n\t },\n\t EventsProcessed => sub {\n\t\tmy($t, $f) = @_;\n\t\tmy $k = $f->{key};\n\t\tmy $kv = $f->{keyValue};\n\t\tmy $n = scalar(@{$f->{keyValue}});\n\t\tmy $nkv = scalar(@{$f->{keyValue}}) / \n\t\t\t\tscalar(@{$f->{key}});\n\t\tmy $fr = $f->{set_fraction};\n\t\tmy $v;\n\t\tif($f->{set_fraction} <= $k->[0]) {\n\t\t\t$v = [@{$kv}[0..$nkv-1]];\n\t\t} elsif($f->{set_fraction} >= $k->[-1]) {\n\t\t\t$v = [@{$kv}[$n-$nkv .. $n-1]];\n\t\t} else {\n\t\t\tmy $i;\n\t\t\tfor($i=1; $i<=$#$k; $i++) {\n\t\t\t\tif($f->{set_fraction} < $k->[$i]) {\n\t\t\t\t\tprint \"COLORX: $f->{set_fraction} $i $k->[$i] - $k->[$i-1]\\n\"\n\t\t\t\t\t\tif $VRML::verbose::interp;\n\t\t\t\t\t$v = [];\n\t\t\t\t\tmy $o = $i * $nkv;\n\t\t\t\t\tfor my $kn (0..$nkv-1) {\n\t\t\t\t\t\tfor(0..2) {\n\t\t\t\t\t\t\t$v->[$kn][$_] \n\t\t\t\t\t\t\t = ($f->{set_fraction} - $k->[$i-1]) /\n\t\t\t\t\t\t\t     ($k->[$i] - $k->[$i-1]) *\n\t\t\t\t\t\t\t     ($kv->[$o+$kn][$_] - $kv->[$o+$kn-$nkv][$_]) +\n\t\t\t\t\t\t\t     $kv->[$o+$kn-$nkv][$_];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlast\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprint \"CoordinateI: NEW_VALUE $v ($k $kv $f->{set_fraction}, $k->[0] $k->[1] $k->[2] $kv->[0] $kv->[1] $kv->[2])\\n\"\n\t\t\tif $VRML::verbose::interp;\n\t\treturn [$t, value_changed, $v];\n\t}\n\t}\n),\n\n\nTimeSensor => new VRML::NodeType(\"TimeSensor\",\n\t{cycleInterval => [SFTime, 1],\n\t enabled => [SFBool, 1],\n\t loop => [SFBool, 0],\n\t startTime => [SFTime, 0],\n\t stopTime => [SFTime, 0],\n\t isActive => [SFBool, undef, out],\n\t cycleTime => [SFTime, undef, out],\n\t fraction_changed => [SFFloat, undef, out],\n\t time => [SFTime, undef, out]\n\t}, \n\t{\n\t Initialize => sub {\n\t \tmy($t,$f) = @_;\n\t \treturn ();\n\t },\n\t EventsProcessed => sub {\n\t \treturn ();\n\t },\n\t startTime => sub {\n\t \tmy($t,$f,$val) = @_;\n\t\tif($t->{Priv}{active}) {\n\t\t} else {\n\t\t}\n\t },\n\t cycleInterval => sub {\n\t \tmy($t,$f,$val) = @_;\n\t\tif($t->{Priv}{active}) {\n\t\t} else {\n\t\t}\n\t },\n\t stopTime => sub {\n\t \tmy($t,$f,$val) = @_;\n\t\tif($t->{Priv}{active} and $val < $f->{startTime}) {\n\t\t} else {\n\t\t}\n\t },\n\n\t ClockTick => sub {\n\t\tmy($t,$f,$tick) = @_;\n\t\tmy @e;\n\t\tmy $act = 0; \n\t\tif(!$f->{enabled}) {\n\t\t\tif($f->{isActive}) {\n\t\t\t\tpush @e, [$t, \"isActive\", 0];\n\t\t\t}\n\t\t\treturn @e;\n\t\t}\n\t\tif($tick > $f->{startTime}) {\n\t\t\tif($f->{startTime} >= $f->{stopTime}) {\n\t\t\t\tif($f->{loop}) {\n\t\t\t\t\t$act = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif($f->{startTime} + $f->{cycleInterval} >=\n\t\t\t\t\t\t$tick) {\n\t\t\t\t\t\t$act = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif($tick < $f->{stopTime}) {\n\t\t\t\t\tif($f->{loop}) {\n\t\t\t\t\t\t$act = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif($f->{startTime} + $f->{cycleInterval} >=\n\t\t\t\t\t\t\t$tick) {\n\t\t\t\t\t\t\t$act = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmy $ct = 0, $frac = 0;\n\t\tmy $time = ($tick - $f->{startTime}) / $f->{cycleInterval};\n\t\tprint \"TIMESENS: $time '$act'\\n\" if $VRML::verbose::timesens;\n\t\tif($act) {\n\t\t\tif($f->{loop}) {\n\t\t\t\t$frac = $time - int $time;\n\t\t\t} else {\n\t\t\t\t$frac = ($time > 1 ? 1 : $time);\n\t\t\t}\n\t\t} else {$frac = 1}\n\t\t$ct = int $time;\n\t\tif($act || $f->{isActive}) {\n\t\t\tpush @e, [$t, \"time\", $tick];\n\t\t\tpush @e, [$t, fraction_changed, $frac];\n\t\t\tprint \"TIME: FRAC: $frac ($time $act $ct $tick $f->{startTime} $f->{cycleInterval} $f->{stopTime})\\n\"\n\t\t\t\tif $VRML::verbose;\n\t\t\tif($ct != $f->{cycleTime}) {\n\t\t\t\tpush @e, [$t, cycleTime, $ct];\n\t\t\t}\n\t\t} \n\t\tif($act) {\n\t\t\tif(!$f->{isActive}) {\n\t\t\t\tpush @e, [$t, isActive, 1];\n\t\t\t}\n\t\t} else {\n\t\t\tif($f->{isActive}) {\n\t\t\t\tpush @e, [$t, isActive, 0];\n\t\t\t}\n\t\t}\n\t\t$this->{Priv}{active} = $act;\n\t\treturn @e;\n\t },\n\t}\n),\n\nTouchSensor => new VRML::NodeType(\"TouchSensor\",\n\t{enabled => [SFBool, 1],\n\t isOver => [SFBool, undef, out],\n\t isActive => [SFBool, undef, out],\n\t hitPoint_changed => [SFVec3f, undef, out],\n\t hitNormal_changed => [SFVec3f, undef, out],\n\t hitTexCoord_changed => [SFVec2f, undef, out],\n\t touchTime => [SFTime, undef, out],\n\t},\n\t{\n\t__mouse__ => sub {\n\t\tmy($t,$f,$time,$moved,$button,$over,$pos,$norm,$texc) = @_; \n\t\tprint \"MOUSE: over $over but $button moved $moved\\n\"\n\t\t\tif $VRML::verbose::tsens;\n\t\tif($button eq \"DRAG\") {return}\n\t\tif($moved and $t->{MouseOver} != $over) {\n\t\t\tprint \"OVCH\\n\"\n\t\t\t\tif $VRML::verbose::tsens;\n\t\t\t$f->{isOver} = $over;\n\t\t\t$t->{MouseOver} = $over;\n\t\t}\n\t\tif($over) {\n\t\t\t$f->{hitPoint_changed} = $pos;\n\t\t\t$f->{hitNormal_changed} = $norm;\n\t\t}\n\t\tif($t->{MouseOver} and $button) {\n\t\t\tif($button eq \"PRESS\") {\n\t\t\t\tprint \"ISACT\\n\"\n\t\t\t\t\tif $VRML::verbose::tsens;\n\t\t\t\t$f->{isActive} = 1;\n\t\t\t\t$t->{MouseActive} = 1;\n\t\t\t} else {\n\t\t\t\tif($t->{MouseActive}) {\n\t\t\t\t\tprint \"TOUCHTIM\\n\"\n\t\t\t\t\t\tif $VRML::verbose::tsens;\n\t\t\t\t\t$f->{touchTime} = $time;\n\t\t\t\t}\n\t\t\t\tprint \"ISACT 0\\n\"\n\t\t\t\t\tif $VRML::verbose::tsens;\n\t\t\t\t$f->{isActive} = 0;\n\t\t\t\t$t->{MouseActive} = 0;\n\t\t\t}\n\t\t}\n\t}\n\t}\n),\n\nPlaneSensor => new VRML::NodeType(\"PlaneSensor\",\n\t{\n\t enabled => [SFBool, 1],\n\t maxPosition => [SFVec2f, [-1,-1]],\n\t minPosition => [SFVec2f, [0,0]],\n\t offset => [SFVec3f, [0,0,0]],\n\t autoOffset => [SFBool, 1],\n\t isActive => [SFBool, undef, eventOut],\n\t trackPoint_changed => [SFVec3f, undef, eventOut],\n\t translation_changed => [SFVec3f, undef, eventOut],\n\t},\n\t{\n\t__mouse__ => sub {\n\t\tmy($t,$f,$time,$moved,$button,$over,$pos,$norm,$texc) = @_;\n\t\tif($button eq \"PRESS\") {\n\t\t\t$t->{OrigPoint} = $pos;\n\t\t\t$f->{isActive} = 1;\n\t\t} elsif($button eq \"RELEASE\") {\n\t\t\tprint \"PLREL!\\n\";\n\t\t\tundef $t->{OrigPoint};\n\t\t\t$t->{isActive} = 0;\n\t\t\tif($f->{autoOffset}) {\n\t\t\t\t$f->{offset} = $f->{translation_changed};\n\t\t\t}\n\t\t} elsif($button eq \"DRAG\") {\n\t\t\tmy $op = $t->{OrigPoint};\n\t\t\tmy $of = $f->{offset};\n\t\t\tmy $mult = \n\t\t\t   ($op->[2] - $pos->[2]) / \n\t\t\t\t($norm->[2] - $pos->[2]);\n\t\t\tmy $nx = $pos->[0] + $mult * ($norm->[0] - $pos->[0]);\n\t\t\tmy $ny = $pos->[1] + $mult * ($norm->[1] - $pos->[1]);\n\t\t\t$f->{trackPoint_changed} = [$nx,$ny,$op->[2]];\n\t\t\tmy $tr = [\n\t\t\t\t$nx - $op->[0] + $of->[0], $ny - $op->[1] + $of->[1], 0 + $of->[2]];\n\t\t\tprint \"TR: @$tr\\n\";\n\t\t\tfor(0..1) {\n\t\t\t\tif($f->{maxPosition}[$_] >=\n\t\t\t\t   $f->{minPosition}[$_]) {\n\t\t\t\t\tif($tr->[$_] < $f->{minPosition}[$_]) {\n\t\t\t\t\t\t$tr->[$_] =\n\t\t\t\t\t\t $f->{minPosition}[$_];\n\t\t\t\t\t} elsif($tr->[$_] > $f->{maxPosition}[$_]) {\n\t\t\t\t\t\t$tr->[$_] =\n\t\t\t\t\t\t $f->{maxPosition}[$_];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprint \"TRC: (@$tr) (@$pos)\\n\";\n\t\t\t$f->{translation_changed} = $tr;\n\t\t}\n\t}\n\t}\n),\n\nSphereSensor => new VRML::NodeType(\"SphereSensor\",\n\t{\n\t enabled => [SFBool, 1],\n\t offset => [SFRotation, [0,1,0,0]],\n\t autoOffset => [SFBool, 1],\n\t isActive => [SFBool, undef, eventOut],\n\t trackPoint_changed => [SFVec3f, undef, eventOut],\n\t rotation_changed => [SFRotation, undef, eventOut],\n\t}, \n\t{\n\t__mouse__ => sub {\n\t\tmy($t,$f,$time,$moved,$button,$over,$pos,$norm,$texc) = @_;\n\t\tif($button eq \"PRESS\") {\n\t\t\t$t->{OrigPoint} = $pos;\n\t\t\t$t->{Radius} = $pos->[0] ** 2 +\n\t\t\t\t$pos->[1] ** 2 + $pos->[2] ** 2;\n\t\t\t$f->{isActive} = 1;\n\t\t} elsif($button eq \"RELEASE\") {\n\t\t\tundef $t->{OrigPoint};\n\t\t\t$t->{isActive} = 0;\n\t\t\tif($f->{autoOffset}) {\n\t\t\t\t$f->{offset} = $f->{rotation_changed};\n\t\t\t}\n\t\t} elsif($button eq \"DRAG\") {\n\t\t\tmy $op = $t->{OrigPoint};\n\t\t\tmy $r = $t->{Radius};\n\t\t\tmy $of = $f->{offset};\n\n\t\t\tmy $tr1sq = $pos->[0]**2 + $pos->[1]**2 + $pos->[2]**2;\n\t\t\tmy $tr2sq = $norm->[0]**2 + $norm->[1]**2 + $norm->[2]**2;\n\t\t\tmy $tr1tr2 = $pos->[0]*$norm->[0] +$pos->[1]*$norm->[1] +$pos->[2]*$norm->[2];\n\t\t\tmy @d = map {$norm->[$_]-$pos->[$_]} 0..2;\n\t\t\tmy $dlen = $d[0]**2 + $d[1]**2 + $d[2]**2;\n\n\t\t\tmy $a = $dlen;\n\t\t\tmy $b = 2*($d[0]*$pos->[0] + $d[1]*$pos->[1] + $d[2]*$pos->[2]);\n\t\t\tmy $c = $tr1sq - $r*$r;\n\n\t\t\t$b /= $a; $c /= $a;\n\n\t\t\tmy $und = $b*$b - 4*$c;\n\t\t\tif($und >= 0) {\n\t\t\t\tmy $sol;\n\t\t\t\tif($b >= 0) {\n\t\t\t\t\t$sol = (-$b + sqrt($und))/2;\n\t\t\t\t} else {\n\t\t\t\t\t$sol = (-$b - sqrt($und))/2;\n\t\t\t\t}\n\t\t\t\tmy @r = map {\n\t\t\t\t\t$pos->[$_] + $sol * ($norm->[$_] - $pos->[$_])\n\t\t\t\t} 0..2;\n\t\t\t\tmy @cp = (\n\t\t\t\t\t$r[1] * $op->[2] - $op->[1] * $r[2],\n\t\t\t\t\t$r[2] * $op->[0] - $op->[2] * $r[0],\n\t\t\t\t\t$r[0] * $op->[1] - $op->[0] * $r[1],\n\t\t\t\t) ;\n\t\t\t\tmy @dot = (\n\t\t\t\t\t$r[0] * $op->[0],\n\t\t\t\t\t$r[1] * $op->[1],\n\t\t\t\t\t$r[2] * $op->[2]\n\t\t\t\t);\n\t\t\t\tmy $an = atan2((my $cl\n\t\t\t\t\t = $cp[0]**2+$cp[1]**2+$cp[2]**2),\n\t\t\t\t      $dot[0]**2+$dot[1]**2+$dot[2]**2);\n\t\t\t\tfor(@cp) {$_ /= $cl}\n\t\t\t\t$f->{trackPoint_changed} = [@r];\n\t\t\t\t\n\t\t\t\tmy $q = VRML::Quaternion->new_vrmlrot(\n\t\t\t\t\t@cp, -$an\n\t\t\t\t);\n\t\t\t\tmy $q2 = VRML::Quaternion->new_vrmlrot(\n\t\t\t\t\t@$of\n\t\t\t\t);\n\n\t\t\t\t$f->{rotation_changed} = \n\t\t\t\t\t$q->multiply($q2)->to_vrmlrot();\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t}\n),\n\nVisibilitySensor => new VRML::NodeType(\"VisibilitySensor\",\n\t{center => [SFVec3f, [0,0,0]],\n\t enabled => [SFBool, 1],\n\t size => [SFVec3f, [0,0,0]],\n\t enterTime => [SFTime, undef, out],\n\t exitTime => [SFTime, undef, out],\n\t isActive => [SFBool, undef, out],\n\t},\n\t{\n\tInitialize => sub {\n\t\tmy($t,$f,$time,$scene) = @_;\n\t\tif($f->{enabled}) {\n\t\t\treturn ([$t, enterTime, $time],\n\t\t\t\t[$t, isActive, 1]);\n\t\t}\n\t\treturn ();\n\t}\n\t}\n),\n\nProximitySensor => new VRML::NodeType(\"ProximitySensor\",\n\t{center => [SFVec3f, [0,0,0]],\n\t size => [SFVec3f, [0,0,0]],\n\t enabled => [SFBool, 1],\n\t enterTime => [SFTime, undef, out],\n\t exitTime => [SFTime, undef, out],\n\t isActive => [SFBool, undef, out],\n\t position_changed => [SFVec3f, undef, out],\n\t orientation_changed => [SFRotation, undef, out],\n         __hit => [SFInt32, 0],\n\t __t1 => [SFVec3f, [10000000,0,0]],\n\t __t2 => [SFRotation, [0,1,0,0]],\n\t},\n\t{\n\t ClockTick => sub {\n\t \tmy($t,$f,$tick) = @_;\n\t\treturn if !$f->{enabled};\n\t\treturn if !$t->{BackEnd};\n\t\tmy $r = $t->{BackEnd}->get_proximitysensor_stuff($t->{BackNode});\n\t\tif($VRML::verbose::prox) {\n\t\t\tprint \"PROX: $r->[0] ($r->[1][0] $r->[1][1] $r->[1][2]) ($r->[2][0] $r->[2][1] $r->[2][2] $r->[2][3])\\n\";\n\t\t}\n\t\tif($r->[0]) {\n\t\t\tif(!$f->{isActive})  {\n\t\t\t\t$f->{isActive} = 1;\n\t\t\t\t$f->{enterTime} = $tick;\n\t\t\t}\n\t\t\t$f->{position_changed} = $r->[1];\n\t\t\t$f->{orientation_changed} = $r->[2];\n\t\t} else {\n\t\t\tif($f->{isActive}) {\n\t\t\t\t$f->{isActive} = 0;\n\t\t\t\t$f->{exitTime} = $tick;\n\t\t\t}\n\t\t}\n\t }\n\t}\n),\n\n\nDirectionalLight => new VRML::NodeType(\"DirectionalLight\",\n\t{ambientIntensity => [SFFloat, 0],\n\t color => [SFColor, [1,1,1]],\n\t direction => [SFVec3f, [0,0,-1]],\n\t intensity => [SFFloat, 1],\n\t on => [SFBool, 1]\n\t}\n),\n\nPointLight => new VRML::NodeType(\"DirectionalLight\",\n\t{ambientIntensity => [SFFloat, 0],\n\t color => [SFColor, [1,1,1]],\n\t direction => [SFVec3f, [0,0,-1]],\n\t intensity => [SFFloat, 1],\n\t on => [SFBool, 1],\n\n\t attenuation => [SFVec3f, [1,0,0]],\n\t location => [SFVec3f, [0,0,0]],\n\t radius => [SFFloat, 100],\n\t}\n),\n\nSpotLight => new VRML::NodeType(\"DirectionalLight\",\n\t{ambientIntensity => [SFFloat, 0],\n\t color => [SFColor, [1,1,1]],\n\t direction => [SFVec3f, [0,0,-1]],\n\t intensity => [SFFloat, 1],\n\t on => [SFBool, 1],\n\n\t attenuation => [SFVec3f, [1,0,0]],\n\t beamWidth => [SFFloat, 1.570796],\n\t cutOffAngle => [SFFloat, 0.785398],\n\t location => [SFVec3f, [0,0,0]],\n\t radius => [SFFloat, 100],\n\t}\n),\n\nBackground => new VRML::NodeType(\"Background\",\n\t{\n\t set_bind => [SFBool, undef, eventIn],\n\t skyAngle => [MFFloat, []],\n\t skyColor => [MFColor, [[0,0,0]]],\n\t groundAngle => [MFFloat, []],\n\t groundColor => [MFColor, []],\n\t isBound => [SFBool, undef, eventOut],\n\t bindTime => [SFTime, undef, eventOut],\n\t (map {(\n\t\t $_.Url => [MFString, []],\n\t\t __x_.$_ => [SFInt32,0],\n\t\t __y_.$_ => [SFInt32,0],\n\t\t __data_.$_ => [SFString, \"\"],\n\t\t __depth_.$_ => [SFInt32, 1],\n\t )} qw/back front top bottom left right/),\n\t},\n\t{\n\tInitialize => sub {\n\t\tmy($t,$f,$time,$scene) = @_;\n\t\tfor(qw/back front top bottom left right/) {\n\t\t\tinit_image(\"_$_\",\"${_}Url\",$t,$f,$scene);\n\t\t}\n\t\treturn ();\n\t}\n\t}\n),\n\nViewpoint => new VRML::NodeType(\"Viewpoint\",\n\t{position => [SFVec3f,[0,0,10]],\n\t orientation => [SFRotation, [0,0,1,0]],\n\t fieldOfView => [SFFloat, 0.785398],\n\t description => [SFString, \"\"],\n\t jump => [SFBool, 1],\n\t set_bind => [SFBool, undef, in],\n\t bindTime => [SFTime, undef, out],\n\t isBound => [SFBool, undef, out],\n\t},\n\t{\n\tInitialize => sub {\n\t\tmy($t,$f) = @_;\n\t\treturn ();\n\t},\n\tWhenBound => sub {\n\t\tmy($t,$scene,$revealed) = @_;\n\t\tprint \"VP_BOUND!\\n\" if $VRML::verbose::bind;\n\t\t$t->{BackEnd}->bind_viewpoint($t,\n\t\t\t($revealed?$t->{VP_Info}:undef));\n\t},\n\tWhenUnBound => sub {\n\t\tmy($t,$scene) = @_;\n\t\tprint \"VP_UNBOUND!\\n\" if $VRML::verbose::bind;\n\t\t$t->{VP_Info} = $t->{BackEnd}->unbind_viewpoint($t);\n\t}\n\t}\n),\n\nNavigationInfo => new VRML::NodeType(\"NavigationInfo\",\n\t{type => [MFString, \"\"],\n\t headlight => [SFBool, 1],\n\t avatarSize => [MFFloat, [0.25, 1.6, 0.75]],\n\t visibilityLimit => [SFFloat, 0.0],\n\t set_bind => [SFBool, undef, eventIn],\n\t isBound => [SFBool, undef, eventOut],\n\t speed => [SFFloat, 1.0],\n\t },\n\t{\n\t \tWhenBound => sub {\n\t\t\tmy($t) = @_;\n\t\t\t$t->{BackEnd}->bind_navi_info($t);\n\t\t},\n\t},\n),\n\nScript => new VRML::NodeType(\"Script\",\n\t{url => [MFString, []],\n\t directOutput => [SFBool, 0, \"\"], \n\t mustEvaluate => [SFBool, 0, \"\"]\n\t},\n\t{\n\t\tInitialize => sub {\n\t\t\tmy($t,$f,$time,$scene) = @_;\n\t\t\tprint \"ScriptInit $_[0] $_[1]!!\\n\" if $VRML::verbose::script;\n\t\t\tprint \"Parsing script\\n\" if $VRML::verbose::script;\n\t\t\tmy $h;\n\t\t\tmy $Browser = $scene->get_browser();\n\t\t\tfor(@{$f->{url}}) {\n\t\t\t\tmy $str = $_;\n\t\t\t\tprint \"TRY $str\\n\" if $VRML::verbose::script;\n\t\t\t\tif(s/^perl_tjl_xxx://) {\n\t\t\t\t\tcheck_perl_script();\n\t\t\t\t\t$h = eval \"({$_})\";\n\t\t\t\t\tif($@) {\n\t\t\t\t\t\tdie \"Inv script '$@'\"\n\t\t\t\t\t}\n\t\t\t\t\tlast;\n\t\t\t\t} elsif(s/^perl_tjl_xxx1://) {\n\t\t\t\t\t{\n\t\t\t\t\tprint \"XXX1 script\\n\" if $VRML::verbose::script;\n\t\t\t\t\tcheck_perl_script();\n\t\t\t\t\tmy $t = $t->{RFields};\n\t\t\t\t\t$h = eval \"({$_})\";\n\t\t\t\t\tprint \"Evaled: $h\\n\" if $VRML::verbose::script;\n\t\t\t\t\tif($@) {\n\t\t\t\t\t\tdie \"Inv script '$@'\"\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlast;\n\t\t\t\t} elsif(/\\.class$/) {\n\t\t\t\t\t$t->{PURL} = $scene->get_url;\n\t\t\t\t\tif(!defined $VRML::J) {\n\t\t\t\t\t\teval('require \"VRML/VRMLJava.pm\"');\n\t\t\t\t\t\tif($@) {die $@;}\n\t\t\t\t\t\t$VRML::J = \n\t\t\t\t\t\t\tVRML::JavaCom->new();\n\t\t\t\t\t}\n\t\t\t\t\t$VRML::J->newscript($t->{PURL},$_,$t);\n\t\t\t\t\t$t->{J} = $VRML::J;\n\t\t\t\t\t$t->{J}->sendinit($t);\n\t\t\t\t\tlast;\n\t\t\t\t} elsif(/\\.js/) {\n\t\t\t\t\tdie(\"Sorry, no javascript files yet -- XXX FIXME (trivial fix!)\");\n\t\t\t\t} elsif(s/^(java|vrml)script://) {\n\t\t\t\t\teval('require VRML::JS;');\n\t\t\t\t\tif($@) {die $@}\n\t\t\t\t\t$t->{J} = VRML::JS->new($_,$t,$Browser);\n\t\t\t\t\tlast;\n\t\t\t\t} else {\n\t\t\t\t\twarn(\"unknown script: $_\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!defined $h and !defined $t->{J}) {\n\t\t\t\tdie \"Didn't found a valid perl_tjl_xxx(1) or java script\";\n\t\t\t}\n\t\t\tprint \"GOT EVS: \",(join ',',keys %$h),\"\\n\" if $VRML::verbose::script;\n\t\t\t$t->{ScriptScript} = $h;\n\t\t\tmy $s;\n\t\t\tif(($s = $t->{ScriptScript}{\"initialize\"})) {\n\t\t\t\tprint \"CALL $s\\n if $VRML::verbose::script\"\n\t\t\t\t if $VRML::verbose::script;\n\t\t\t\treturn &{$s}();\n\t\t\t} elsif($t->{J}) {\n\t\t\t\treturn $t->{J}->initialize($scene);\n\t\t\t}\n\t\t\treturn ();\n\t\t},\n\t\turl => sub {\n\t\t\tprint \"ScriptURL $_[0] $_[1]!!\\n\" if $VRML::verbose::script;\n\t\t\tdie \"URL setting not enabled\";\n\t\t},\n\t\t__any__ => sub {\n\t\t\tmy($t,$f,$v,$time,$ev) = @_;\n\t\t\tprint \"ScriptANY $_[0] $_[1] $_[2] $_[3] $_[4]!!\\n\"\n\t\t\t\tif $VRML::verbose::script;\n\t\t\tmy $s;\n\t\t\tif(($s = $t->{ScriptScript}{$ev})) {\n\t\t\t\tprint \"CALL $s\\n\"\n\t\t\t\t if $VRML::verbose::script;\n\t\t\t\treturn &{$s}();\n\t\t\t} elsif($t->{J}) {\n\t\t\t\treturn $t->{J}->sendevent($t, $ev, $v, $time);\n\t\t\t}\n\t\t\treturn ();\n\t\t},\n\t\tEventsProcessed => sub {\n\t\t\tmy($t,$f) = @_;\n\t\t\tprint \"ScriptEP $_[0] $_[1]!!\\n\"\n\t\t\t\tif $VRML::verbose::script;\n\t\t\tif($t->{J}) {\n\t\t\t\treturn $t->{J}->sendeventsproc($t);\n\t\t\t}\n\t\t\treturn ();\n\t\t},\n\t}\n),\n\nCollision => new VRML::NodeType(\"Collision\",\n\t{collide => [SFBool, 1],\n\t children => [MFNode, []],\n\t}\n),\n\nInline => new VRML::NodeType(\"Inline\",\n\t{bboxSize => [SFVec3f, [-1,-1,-1]],\n\t bboxCenter => [SFVec3f, [0,0,0]],\n\t url => [MFString, []]\n\t},\n\t{\n\tInitialize => sub {\n\t\tmy($t,$f,$time,$scene) = @_;\n\t\tmy $purl = $scene->get_url();\n\n\t\tmy $urls = $f->{url};\n\t\tmy ($text,$url) = VRML::URL::get_relative($purl, $urls->[0]);\n\n\t\t$p = $scene->new_proto(\"__proto\".$protono++);\n\t\t$p->set_url($url);\n\t\tVRML::Parser::parse($p, $text);\n\n\t\tif(!defined $p) {\n\t\t\tdie(\"Inline not found\");\n\t\t}\n\t\t$t->{ProtoExp} = $p;\n\t\t$t->{ProtoExp}->set_parentnode($t);\n\t\t$t->{ProtoExp}->make_executable();\n\t\t$t->{ProtoExp}{IsInline} = 1;\n\t\t$t->{IsProto} = 1;\n\t\treturn ();\n\t}\n\t}\n),\n\n)",
      "file" : "/var/tmp/arv_jW2xCM/FreeWRL-0.14/VRMLNodes.pm",
      "package" : "VRML::NodeType"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub load_data {\n\tmy $n = \\%VRML::CNodes;\n {\n\t\tmy $s = '';\n\t\tmy $v = get_PointLight_offsets($s);\n\t\t@{$n->{PointLight}{Offs}}{\"radius\",\"location\",\"direction\",\"attenuation\",\"on\",\"color\",\"ambientIntensity\",\"intensity\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{PointLight}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_DirectionalLight_offsets($s);\n\t\t@{$n->{DirectionalLight}{Offs}}{\"direction\",\"on\",\"ambientIntensity\",\"color\",\"intensity\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{DirectionalLight}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Sphere_offsets($s);\n\t\t@{$n->{Sphere}{Offs}}{\"radius\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Sphere}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Coordinate_offsets($s);\n\t\t@{$n->{Coordinate}{Offs}}{\"point\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Coordinate}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_FontStyle_offsets($s);\n\t\t@{$n->{FontStyle}{Offs}}{\"style\",\"family\",\"language\",\"spacing\",\"horizontal\",\"topToBottom\",\"size\",\"leftToRight\",\"justify\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{FontStyle}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Normal_offsets($s);\n\t\t@{$n->{Normal}{Offs}}{\"vector\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Normal}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Box_offsets($s);\n\t\t@{$n->{Box}{Offs}}{\"size\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Box}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Billboard_offsets($s);\n\t\t@{$n->{Billboard}{Offs}}{\"children\",\"axisOfRotation\",\"bboxCenter\",\"bboxSize\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Billboard}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_ElevationGrid_offsets($s);\n\t\t@{$n->{ElevationGrid}{Offs}}{\"zDimension\",\"colorPerVertex\",\"height\",\"normal\",\"creaseAngle\",\"solid\",\"xSpacing\",\"xDimension\",\"normalPerVertex\",\"color\",\"zSpacing\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{ElevationGrid}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Extrusion_offsets($s);\n\t\t@{$n->{Extrusion}{Offs}}{\"convex\",\"scale\",\"beginCap\",\"creaseAngle\",\"solid\",\"endCap\",\"orientation\",\"ccw\",\"crossSection\",\"spine\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Extrusion}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Switch_offsets($s);\n\t\t@{$n->{Switch}{Offs}}{\"choice\",\"whichChoice\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Switch}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_ImageTexture_offsets($s);\n\t\t@{$n->{ImageTexture}{Offs}}{\"__data\",\"url\",\"__depth\",\"repeatS\",\"repeatT\",\"__x\",\"__y\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{ImageTexture}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_TextureCoordinate_offsets($s);\n\t\t@{$n->{TextureCoordinate}{Offs}}{\"point\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{TextureCoordinate}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_IndexedFaceSet_offsets($s);\n\t\t@{$n->{IndexedFaceSet}{Offs}}{\"texCoordIndex\",\"normalIndex\",\"convex\",\"colorPerVertex\",\"coord\",\"colorIndex\",\"texCoord\",\"normal\",\"creaseAngle\",\"solid\",\"ccw\",\"coordIndex\",\"color\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{IndexedFaceSet}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Background_offsets($s);\n\t\t@{$n->{Background}{Offs}}{\"__y_left\",\"__data_left\",\"__depth_back\",\"backUrl\",\"__depth_top\",\"topUrl\",\"__y_back\",\"__depth_bottom\",\"__data_back\",\"__x_top\",\"bottomUrl\",\"__y_top\",\"__y_bottom\",\"bindTime\",\"__data_bottom\",\"__depth_right\",\"__x_right\",\"isBound\",\"__y_right\",\"groundAngle\",\"skyColor\",\"__data_front\",\"__x_left\",\"__x_back\",\"set_bind\",\"__data_top\",\"__x_bottom\",\"groundColor\",\"rightUrl\",\"__data_right\",\"__depth_front\",\"frontUrl\",\"__depth_left\",\"leftUrl\",\"skyAngle\",\"__x_front\",\"__y_front\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Background}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Text_offsets($s);\n\t\t@{$n->{Text}{Offs}}{\"fontStyle\",\"__rendersub\",\"length\",\"maxExtent\",\"string\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Text}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Cone_offsets($s);\n\t\t@{$n->{Cone}{Offs}}{\"height\",\"bottomRadius\",\"side\",\"bottom\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Cone}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Viewpoint_offsets($s);\n\t\t@{$n->{Viewpoint}{Offs}}{\"fieldOfView\",\"description\",\"isBound\",\"position\",\"set_bind\",\"bindTime\",\"jump\",\"orientation\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Viewpoint}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_TextureTransform_offsets($s);\n\t\t@{$n->{TextureTransform}{Offs}}{\"rotation\",\"scale\",\"center\",\"translation\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{TextureTransform}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Group_offsets($s);\n\t\t@{$n->{Group}{Offs}}{\"children\",\"bboxCenter\",\"bboxSize\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Group}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_ProximitySensor_offsets($s);\n\t\t@{$n->{ProximitySensor}{Offs}}{\"center\",\"__hit\",\"__t1\",\"__t2\",\"orientation_changed\",\"isActive\",\"exitTime\",\"size\",\"enabled\",\"enterTime\",\"position_changed\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{ProximitySensor}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Material_offsets($s);\n\t\t@{$n->{Material}{Offs}}{\"transparency\",\"emissiveColor\",\"shininess\",\"diffuseColor\",\"specularColor\",\"ambientIntensity\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Material}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Appearance_offsets($s);\n\t\t@{$n->{Appearance}{Offs}}{\"texture\",\"textureTransform\",\"material\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Appearance}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Shape_offsets($s);\n\t\t@{$n->{Shape}{Offs}}{\"appearance\",\"geometry\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Shape}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_IndexedLineSet_offsets($s);\n\t\t@{$n->{IndexedLineSet}{Offs}}{\"colorPerVertex\",\"coord\",\"color\",\"colorIndex\",\"coordIndex\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{IndexedLineSet}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_PointSet_offsets($s);\n\t\t@{$n->{PointSet}{Offs}}{\"color\",\"coord\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{PointSet}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Cylinder_offsets($s);\n\t\t@{$n->{Cylinder}{Offs}}{\"radius\",\"height\",\"top\",\"side\",\"bottom\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Cylinder}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Anchor_offsets($s);\n\t\t@{$n->{Anchor}{Offs}}{\"children\",\"parameter\",\"url\",\"description\",\"bboxCenter\",\"bboxSize\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Anchor}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Transform_offsets($s);\n\t\t@{$n->{Transform}{Offs}}{\"rotation\",\"center\",\"scaleOrientation\",\"bboxSize\",\"scale\",\"children\",\"bboxCenter\",\"translation\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Transform}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_SpotLight_offsets($s);\n\t\t@{$n->{SpotLight}{Offs}}{\"direction\",\"beamWidth\",\"ambientIntensity\",\"intensity\",\"radius\",\"location\",\"attenuation\",\"on\",\"cutOffAngle\",\"color\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{SpotLight}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_LOD_offsets($s);\n\t\t@{$n->{LOD}{Offs}}{\"level\",\"center\",\"range\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{LOD}{Virt} = $v;\n }\n\t {\n\t\tmy $s = '';\n\t\tmy $v = get_Color_offsets($s);\n\t\t@{$n->{Color}{Offs}}{\"color\",\"_end_\"} =\n\t\t\tunpack(\"i*\",$s);\n\t\t$n->{Color}{Virt} = $v;\n }\n\t\n}",
      "file" : "/var/tmp/arv_jW2xCM/FreeWRL-0.14/VRMLFunc.pm",
      "package" : "VRML::VRMLFunc"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub js_default { 'new SFNode(\"\",\"NULL\")' }",
      "file" : "/var/tmp/arv_jW2xCM/FreeWRL-0.14/VRMLFields.pm",
      "package" : "VRML::Field"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "bootstrap VRML::PNG",
      "file" : "/var/tmp/arv_jW2xCM/FreeWRL-0.14/PNG/PNG.pm",
      "package" : "VRML::PNG"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "bootstrap VRML::JPEG",
      "file" : "/var/tmp/arv_jW2xCM/FreeWRL-0.14/JPEG/JPEG.pm",
      "package" : "VRML::JPEG"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub brow_createVrmlFromString {\n\tmy($this) = @_; my $rs;\n\trunscript($this->{CX},$this->{GLO},\"Browser.__arg0\",$rs);\n\tprint \"BROW_CVRLFSTR '$rs'\\n\"\n\t\tif $VRML::verbose::js;\n\tmy $mfn = $this->{Browser}->createVrmlFromString(\n\t\t$rs\n\t);\n\tmy @hs = map {VRML::Handles::reserve($_)} @$mfn;\n\tmy $sc = \"Browser.__bret = new MFNode(\".\n\t\t(join ',',map {qq'new SFNode(\"\",\"$_\")'} @hs).\")\";\n\trunscript($this->{CX},$this->{GLO},$sc,$rs);\n}",
      "file" : "/var/tmp/arv_jW2xCM/FreeWRL-0.14/JS/JS.pm",
      "package" : "VRML::JS"
   }
]
