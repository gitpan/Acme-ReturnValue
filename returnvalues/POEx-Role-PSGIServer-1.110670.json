[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "role POEx::Role::PSGIServer {\n    use aliased 'POEx::Role::Event';\n\n    use MooseX::Types::Moose(':all');\n    use POEx::Types::PSGIServer(':all');\n    use POEx::Types(':all');\n    use Moose::Autobox;\n    use HTTP::Message::PSGI;\n    use HTTP::Status qw(status_message);\n    use Plack::Util;\n    use POE::Filter::HTTP::Parser;\n    use POE::Filter::Stream;\n    use POEx::Role::PSGIServer::Streamer;\n    use POEx::Role::PSGIServer::ProxyWriter;\n\n\n    has psgi_app => (\n        is => 'ro',\n        isa => CodeRef,\n        writer => 'register_service',\n    );\n\n\n    has wheel_flushers => (\n        is      => 'ro',\n        traits  => ['Hash'],\n        isa     => 'HashRef',\n        default => sub { {} },\n        handles => {\n            has_wheel_flusher   => 'exists',\n            get_wheel_flusher   => 'get',\n            set_wheel_flusher   => 'set',\n            clear_wheel_flusher => 'delete',\n        }\n    );\n\n\n\n    around BUILDARGS(ClassName $class: @args) {\n        my $hash = $class->$orig(@args);\n\n        $hash->{listen_port} ||= delete $hash->{port} || 5000;\n        $hash->{listen_ip}   ||= delete $hash->{host} || '0.0.0.0';\n        $hash;\n    }\n\n\n    after _start is Event {\n        $self->input_filter(POE::Filter::HTTP::Parser->new(type => 'server'));\n        $self->output_filter(POE::Filter::Stream->new());\n    }\n\n\n    method write(PSGIServerContext $c, Str $data) {\n        if($c->{chunked}) {\n            my $len = sprintf \"%X\", do { use bytes; length($data) };\n            $self->_write($c, \"$len\\r\\n$data\\r\\n\");\n        }\n        else {\n            $self->_write($c, $data);\n        }\n        \n    }\n\n\n    method _write(PSGIServerContext $c, Str $data) {\n        $c->{wheel}->put($data);\n    }\n\n\n    method close(PSGIServerContext $c) {\n        if($c->{chunked}) {\n            $self->_write($c, \"0\\r\\n\\r\\n\");\n        }\n\n        $c->{wheel}->flush() while $c->{wheel}->get_driver_out_octets();\n        $c->{wheel}->shutdown_output();\n        $self->delete_wheel((delete $c->{wheel})->ID);\n    }\n\n\n    method handle_socket_error(Str $action, Int $code, Str $message, WheelID $id) is Event {\n        $self->delete_wheel($id);\n    }\n\n\n    method handle_listen_error(Str $action, Int $code, Str $message, WheelID $id) is Event {\n        die \"Failed to '$action' to the specified port. Code: $code, Message: $message\";\n    }\n\n\n\n    method process_headers(PSGIServerContext $c, PSGIResponse $response) {\n        my $headers = $response->[1];\n        $headers->keys\n            ->each(\n                sub {\n                    my $index = shift;\n                    return if $index == $#$headers;\n                    my ($k, $v) = ($headers->[$index], $headers->[$index+1]) ;\n                    $c->{keep_alive} = 0 if $k eq 'Connection' && $v eq 'close';\n                    $c->{explicit_length} = 1 if $k eq 'Content-Length';\n                    $self->_write($c, \"$k:$v\\r\\n\");\n                }\n            );\n        \n        $c->{chunked} = ($c->{keep_alive} && !$c->{explicit_length});\n    }\n\n\n    method http_preamble(PSGIServerContext $c, PSGIResponse $response) {\n        $self->_write($c, \"${\\ $c->{protocol}} ${\\ $response->[0] } ${ \\status_message($response->[0]) }\\r\\n\");\n    }\n\n\n    method http_body_allowed(PSGIServerContext $c, PSGIResponse $response) returns (Bool) {\n        my $code = $response->[0];\n\n        my $no_body_allowed = ($c->{request}->method =~ /^head$/i)\n           || ($code < 200)\n           || ($code == 204)\n           || ($code == 304);\n\n        if ($no_body_allowed) {\n            $self->_write($c, \"\\r\\n\");\n            $self->close($c);\n            return Plack::Util::FALSE;\n        }\n\n        return Plack::Util::TRUE;\n    }\n\n\n    method respond(PSGIServerContext $c, PSGIResponse $response) is Event {\n        $self->http_preamble($c, $response);\n        $self->process_headers($c, $response);\n        return unless ($self->http_body_allowed($c, $response));\n\n       \n        $self->_write($c, \"Transfer-Encoding: chunked\\r\\n\") if $c->{chunked};\n        $self->_write($c, \"\\r\\n\");\n        \n        my $body = $response->[2];\n        if ($body) {\n            if (Plack::Util::is_real_fh($body)) {\n                $c->{wheel}->flush();\n                $self->delete_wheel($c->{wheel}->ID);\n                my $handle = (delete $c->{wheel})->get_input_handle();\n                my $streamer = POEx::Role::PSGIServer::Streamer->new(\n                    input_handle => $body,\n                    output_handle => $handle,\n                    server_context => $c,\n                );\n            }\n            else {\n                Plack::Util::foreach($body, sub{$self->write($c, @_)});\n                $self->close($c);\n            }\n\n            return;\n        }\n\n        return $self->generate_push_writer($c);\n    }\n\n\n    method generate_push_writer(PSGIServerContext $c) returns (Object) {\n        return POEx::Role::PSGIServer::ProxyWriter->new(server_context => $c, proxied => $self);\n    }\n\n\n    method generate_psgi_env(PSGIServerContext $c) returns (HashRef) {\n        return req_to_psgi(\n            $c->{request},\n            SERVER_NAME         => $self->listen_ip,\n            SERVER_PORT         => $self->listen_port,\n            SERVER_PROTOCOL     => $c->{protocol},\n            'psgi.streaming'    => Plack::Util::TRUE,\n            'psgi.nonblocking'  => Plack::Util::TRUE,\n            'psgi.runonce'      => Plack::Util::FALSE,\n        );\n    }\n\n\n    method build_server_context(HTTPRequest $req, WheelID $wheel_id) returns (PSGIServerContext) {\n        my $version  = $req->header('X-HTTP-Version') || '0.9';\n        my $protocol = \"HTTP/$version\";\n        my $connection = $req->header('Connection') || '';\n        my $keep_alive = ($version eq '1.1' && $connection ne 'close');\n        \n        my $context = {\n            request => $req,\n            wheel => $self->get_wheel($wheel_id),\n            version => $version,\n            protocol => $protocol,\n            connection => $connection,\n            keep_alive => $keep_alive,\n            explicit_length => 0,\n        };\n\n        return $context;\n    }\n\n\n    method handle_inbound_data(HTTPRequest $req, WheelID $wheel_id) is Event {\n        my $context = $self->build_server_context($req, $wheel_id);\n        my $env = $self->generate_psgi_env($context);\n        my $response = Plack::Util::run_app($self->psgi_app, $env);\n\n        if (ref($response) eq 'CODE') {\n            $response->(sub { $self->respond($context, @_) });\n        }\n        else {\n            $self->yield('respond', $context, $response);\n        }\n    }\n\n\n    method run(CodeRef $app) {\n        $self->register_service($app);\n        POE::Kernel->run();\n    }\n\n    method handle_on_flushed(WheelID $id) is Event {\n        if ($self->has_wheel_flusher($id)) {\n            $self->get_wheel_flusher($id)->();\n        }\n        1;\n    }\n\n    after delete_wheel(WheelID $id) {\n        $self->clear_wheel_flusher($id);\n    }\n\n    with 'POEx::Role::TCPServer' => {\n        -excludes => [\n            qw/handle_socket_error handle_listen_error handle_on_flushed/\n        ]\n    };\n}",
      "file" : "/var/tmp/arv_DhUcxX/POEx-Role-PSGIServer-1.110670/lib/POEx/Role/PSGIServer.pm",
      "package" : "POEx::Role::PSGIServer"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class POEx::Role::PSGIServer::ProxyWriter {\n    use MooseX::Types::Moose(':all');\n    use POEx::Types::PSGIServer(':all');\n\n\n    has server_context => (\n        is => 'ro',\n        isa => PSGIServerContext,\n        required => 1\n    );\n\n\n    has proxied => (\n        is => 'ro',\n        isa => Object,\n        weak_ref => 1,\n        required => 1,\n    );\n\n\n    method write($data) {\n        $self->proxied->write($self->server_context, $data);\n    }\n\n\n    method close() {\n        $self->proxied->close($self->server_context);\n    }\n\n\n    method poll_cb(CodeRef $coderef) {\n        my $on_flush = sub { $self->$coderef() };\n        my $id = $self->server_context->{wheel}->ID;\n        $self->proxied->set_wheel_flusher($id => $on_flush);\n        $on_flush->();\n    }\n}\n1",
      "file" : "/var/tmp/arv_DhUcxX/POEx-Role-PSGIServer-1.110670/lib/POEx/Role/PSGIServer/ProxyWriter.pm",
      "package" : "POEx::Role::PSGIServer::ProxyWriter"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class POEx::Role::PSGIServer::Streamer {\n    use POE::Filter::Map;\n    use POE::Filter::Stream;\n    use MooseX::Types::Moose(':all');\n    use POEx::Types::PSGIServer(':all');\n    \n\n    has server_context => (is => 'ro', isa => PSGIServerContext, required => 1);\n\n\n    has closed_chunk => ( is => 'rw', isa => Bool, default => 0 );\n\n    with 'POEx::Role::Streaming';\n\n\n    method _build_filter {\n        if($self->server_context->{chunked}) {\n            POE::Filter::Map->new(\n                Get => sub { $_ },\n                Put => sub { \n                    my $data = shift;\n                    return $data if $data =~ /0\\r\\n\\r\\n/;\n                    my $len = sprintf \"%X\", do { use bytes; length($data) };\n                    return \"$len\\r\\n$data\\r\\n\";\n                }\n            );\n        }\n        else {\n            return POE::Filter::Stream->new();\n        }\n    }\n\n\n    around done_writing {\n        if($self->server_context->{chunked} && !$self->closed_chunk) {\n            $self->closed_chunk(1);\n            $self->put(\"0\\r\\n\\r\\n\");\n            return;\n        }\n\n        $self->$orig;\n    }\n}\n\n1",
      "file" : "/var/tmp/arv_DhUcxX/POEx-Role-PSGIServer-1.110670/lib/POEx/Role/PSGIServer/Streamer.pm",
      "package" : "POEx::Role::PSGIServer::Streamer"
   }
]
