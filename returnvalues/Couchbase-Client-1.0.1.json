[
   {
      "PPI" : "PPI::Statement::Break (but very likely crap)",
      "bad" : "$params",
      "file" : "/var/tmp/arv_DjrTIS/Couchbase-Client-1.0.1/PLCB_Config.pm",
      "package" : "PLCB_Config"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "sub v2k {\n    my ($self,$v) = @_;\n    reverse($v);\n}\n\nsub set_ok {\n    my ($self,$msg,@args) = @_;\n    my $ret = $self->cbo->set(@args);\n    ok($ret->is_ok, $msg);\n    $self->err_ok();\n    if(!$ret->is_ok) {\n        diag($ret->errstr);\n    }\n}\n\nsub get_ok {\n    my ($self,$key,$expected) = @_;\n    my $ret = $self->cbo->get($key);\n    ok($ret->is_ok, \"Status OK for GET($key)\");\n    ok($ret->value eq $expected, \"Got expected value for $key\");\n}\n\nsub T00_set_values_simple :Test(no_plan) {\n    my $self = shift;\n    $self->err_ok();\n    foreach my $k (@{$self->{basic_keys}}) {\n        $self->set_ok(\"Key '$k'\", $k, $self->k2v($k));\n        $self->get_ok($k, $self->k2v($k))\n    }\n}\n\nsub T01_get_nonexistent :Test(no_plan) {\n    my $self = shift;\n    my $v = $self->cbo->get('NonExistent');\n    is($v->errnum, COUCHBASE_KEY_ENOENT, \"Got ENOENT for nonexistent key\");\n    $self->err_ok();\n}\n\nsub T02_mutators :Test(no_plan) {\n    my $self = shift;\n    my $o = $self->cbo;\n    \n    my $key = \"mutate_key\";\n    $o->remove($key); \n    is($o->add($key, \"BASE\")->errnum, 0, \"No error for add on new key\");\n    is($o->prepend($key, \"PREFIX_\")->errnum, 0, \"No error for prepend\");\n    is($o->append($key, \"_SUFFIX\")->errnum, 0, \"No error for append\");\n    is($o->get($key)->value, \"PREFIX_BASE_SUFFIX\", \"Got expected mutated value\");\n}\n\nsub T03_arithmetic :Test(no_plan) {\n    my $self = shift;\n    my $o = $self->cbo;\n    my $key = \"ArithmeticKey\";\n    $o->remove($key);\n    my $wv;\n    \n    $wv = $o->arithmetic($key, -12, 42);\n    ok($wv->is_ok, \"Set arithmetic with initial value\");\n    \n    $o->remove($key);\n    \n    $wv = $o->arithmetic($key, -12, undef);   \n    is($wv->errnum, COUCHBASE_KEY_ENOENT, \"Error without initial value (undef)\");\n    \n    $wv = $o->arithmetic($key, -12, 0, 120);\n    ok($wv->is_ok, \"No error with initial value=0\");\n    is($wv->value, 0, \"Initial value is 0\");\n    \n    $wv = $o->incr($key);\n    is($wv->value, 1, \"incr() == 1\");\n    \n    $wv = $o->decr($key);\n    is($wv->value, 0, \"decr() == 0\");\n}\n\nsub T04_atomic :Test(no_plan) {\n    my $self = shift;\n    my $o = $self->cbo;\n    my $key = \"AtomicKey\";\n    $o->delete($key);\n    \n    is($o->replace($key, \"blargh\")->errnum, COUCHBASE_KEY_ENOENT,\n       \"Can't replace non-existent value\");\n    \n    my $wv = $o->set($key, \"initial\");\n    ok($wv->errnum == 0, \"No error\");\n    ok(length($wv->cas), \"Have cas\");\n    $o->set($key, \"next\");\n    my $newv = $o->cas($key, \"my_next\", $wv->cas);\n    \n    is($newv->errnum,\n       COUCHBASE_KEY_EEXISTS, \"Got EEXISTS for outdated CAS\");\n    \n    $newv = $o->get($key);\n    ok($newv->cas, \"Have CAS for new value\");\n    $wv = $o->cas($key, \"synchronized\", $newv->cas);\n    ok($wv->errnum == 0, \"Got no error for CAS with updated CAS\");\n    is($o->get($key)->value, \"synchronized\", \"Got expected value\");\n    \n    $o->delete($key);\n    ok($o->add($key, \"value\")->is_ok, \"No error for ADD with nonexistent key\");\n    is($o->add($key, \"value\")->errnum,\n       COUCHBASE_KEY_EEXISTS, \"Got eexists for ADD on existing key\");\n    \n    ok($o->delete($key, $newv->cas)->errnum, \"Got error for DELETE with bad CAS\");\n    $newv = $o->get($key);\n    ok($o->delete($key, $newv->cas)->errnum == 0,\n       \"No error for delete with updated CAS\");\n}\n\nsub T05_conversion :Test(no_plan) {\n    my $self = shift;\n    my $o = $self->cbo;\n    my $structure = [ qw(foo bar baz) ];\n    my $key = \"Serialization\";\n    my $rv;\n    \n    ok($o->set($key, $structure)->is_ok, \"Serialized OK\");\n    \n    $rv = $o->get($key);\n    ok($rv->is_ok, \"Got serialized structure OK\");\n    is_deeply($rv->value, $structure, \"Got back our array reference\");\n    eval {\n        $o->append($key, $structure);\n    };\n    ok($@, \"Got error for append/prepending a serialized structure ($@)\");\n}\n\nsub _multi_check_ret {\n    my ($rv,$keys) = @_;    \n    my $nkeys = scalar @$keys;\n    my $defined = scalar grep defined $_, values %$rv;\n    my $n_ok = scalar grep $_->is_ok, values %$rv;\n    \n    is(scalar keys %$rv, $nkeys, \"Expected number of keys\");\n    is($defined, $nkeys, \"All values defined\");\n    is($n_ok,$nkeys, \"All returned ok (no errors)\");\n    \n}\n\nsub T06_multi :Test(no_plan) {\n    my $self = shift;\n    my $o = $self->cbo;\n    my @keys = @{$self->{basic_keys}};\n    \n    my $rv = $o->set_multi(\n        map { [$_, $_] } @keys);\n    \n    ok($rv && ref $rv eq 'HASH', \"Got hash result for multi operation\");\n    ok(scalar keys %$rv == scalar @keys,\n       \"got expected number of results\");\n    \n    is(grep(defined $_, values %$rv), scalar @keys, \"All values defined\");\n    is(scalar grep(!$rv->{$_}->is_ok, @keys), 0, \"No errors\");\n    \n    $rv = $o->get_multi(@keys);\n    _multi_check_ret($rv, \\@keys);\n    \n    is(scalar grep($rv->{$_}->value eq $_, @keys), scalar @keys,\n       \"get_multi: Got expected values\");\n    \n    $rv = $o->cas_multi(\n        map { [$_, scalar(reverse $_), $rv->{$_}->cas ] } @keys );\n    _multi_check_ret($rv, \\@keys);\n    \n    \n    note \"Remove (no CAS)\";\n    $rv = $o->remove_multi(@keys);\n    _multi_check_ret($rv, \\@keys);\n    \n    $rv = $o->set_multi(map { [$_, $_] } @keys);\n    _multi_check_ret($rv, \\@keys);\n    \n    note \"Remove (with CAS)\";\n    $rv = $o->remove_multi(map { [ $_, $rv->{$_}->cas] } @keys);\n    _multi_check_ret($rv, \\@keys);\n    \n    note \"Trying arithmetic..\";\n    \n    $rv = $o->arithmetic_multi(\n         map { [$_, 666, undef, 120] } @keys \n    );\n    ok(scalar(\n        grep {$_->errnum == COUCHBASE_KEY_ENOENT} values %$rv\n        ) == scalar @keys,\n       \"ENOENT for non-existent deleted arithmetic keys\");\n    \n    \n    $rv = $o->arithmetic_multi(\n        map { [$_, 666, 42, 120] } @keys);\n    _multi_check_ret($rv, \\@keys);\n    \n    is(scalar grep($_->value == 42, values %$rv), scalar @keys,\n       \"all keys have expected value\");\n    \n    $rv = $o->incr_multi(@keys);\n    _multi_check_ret($rv, \\@keys);\n    \n    is(scalar grep($_->value == 43, values %$rv), scalar @keys,\n       \"all keys have been incremented\");\n    \n    $rv = $o->decr_multi(\n        map {[ $_, 41 ]} @keys);\n    _multi_check_ret($rv, \\@keys);\n    is(scalar grep($_->value == 2, values %$rv), scalar @keys,\n       \"all keys have been decremented\");\n}\n\nsub T06_multi_GH4 :Test(no_plan) {\n    my $self = shift;\n    my $o = $self->cbo;\n    my $rv = $o->set_multi(['single_key', 'single_value']);\n    ok($rv->{\"single_key\"}->is_ok, \"Single arrayref on setmulti does not fail\");\n}\n\n\nsub T07_stats :Test(no_plan) {\n    my $self = shift;\n    my $o = $self->cbo;\n    my $stats = $o->stats();\n    \n    ok($stats && ref $stats eq 'HASH', \"Got a hashref\");\n    ok(scalar keys %$stats, \"stats not empty\");\n    \n    if($self->mock && $self->mock->nodes) {\n        ok(scalar keys %$stats == $self->mock->nodes, \"Got expected stat count\");\n    } else {\n        diag \"Cannot determine expected stat count for real cluster\";\n    }\n}\n\nsub T08_expiry :Test(no_plan) {\n    my $self = shift;\n    my $o = $self->cbo;\n    $self->set_ok(\n        \"Setting with numeric expiry\",\n        \"key\", \"value\", 1);\n\n    $self->set_ok(\n        \"Setting with stringified expiry\",\n        \"key\", \"value\", \"1\");\n\n\n    eval {\n        $o->set(\"key\", \"Value\", \"bad-expiry\");\n    };\n    ok($@, \"Got error for invalid expiry\");\n\n    sleep(1.5);\n    my $rv = $o->get(\"key\");\n    is($rv->errnum, COUCHBASE_KEY_ENOENT, \"key has expired\");\n}\n\n1",
      "file" : "/var/tmp/arv_DjrTIS/Couchbase-Client-1.0.1/lib/Couchbase/Test/ClientSync.pm",
      "package" : "Couchbase::Test::ClientSync"
   },
   {
      "PPI" : "PPI::Statement::Variable",
      "bad" : "our $VERSION = '1.0.4'",
      "file" : "/var/tmp/arv_DjrTIS/Couchbase-Client-1.0.1/src/libcouchbase.pm",
      "package" : "Couchbase::libcouchbase"
   }
]
