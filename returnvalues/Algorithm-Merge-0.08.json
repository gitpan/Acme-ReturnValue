[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub merge {\n    my $pivot             = shift;                                  \n    my $doca              = shift;                                  \n    my $docb              = shift;                                  \n    my $callbacks         = shift || {};\n    my $keyGen            = shift;\n\n    my $conflictCallback  = $callbacks -> {'CONFLICT'} || sub ($$) { (\n        q{<!-- ------ START CONFLICT ------ -->},\n        (@{$_[0]}),\n        q{<!-- ---------------------------- -->},\n        (@{$_[1]}),\n        q{<!-- ------  END  CONFLICT ------ -->},\n    ) };\n\n    my $diff = diff3($pivot, $doca, $docb, $keyGen, @_);\n\n\n    my @ret;\n\n    my @conflict = ( [], [] );\n\n    foreach my $h (@{$diff}) {\n        my $i = 0;\n        if($h -> [0] eq 'c') { \n            push @{$conflict[0]}, $h -> [2] if defined $h -> [2];\n            push @{$conflict[1]}, $h -> [3] if defined $h -> [3];\n        }\n        else {\n            if(@{$conflict[0]} || @{$conflict[1]}) {\n                push @ret, &$conflictCallback(@conflict);\n                @conflict = ( [], [] );\n            }\n            if($h -> [0] eq 'u') { \n                push @ret, $h -> [2] || $h -> [3];\n            }\n            elsif($h -> [0] eq 'o') { \n                push @ret, $h -> [2] if defined $h -> [2];\n            }\n            elsif($h -> [0] eq 'l') { \n                push @ret, $h -> [2] if defined $h -> [2];\n            }\n            elsif($h -> [0] eq 'r') { \n                push @ret, $h -> [3] if defined $h -> [3];\n            }\n        }\n    }\n\n    if(@{$conflict[0]} || @{$conflict[1]}) {\n        push @ret, &$conflictCallback(@conflict);\n    }\n\n    if(wantarray) {\n        return @ret;\n    }\n    return \\@ret;\n}",
      "file" : "/var/tmp/arv_yWdh5e/Algorithm-Merge-0.08/Merge.pm",
      "package" : "Algorithm::Merge"
   }
]
