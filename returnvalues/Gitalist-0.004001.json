[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class Gitalist::Git::Object::Commit\n    extends Gitalist::Git::Object\n    with Gitalist::Git::Object::HasTree {\n        use MooseX::Types::Moose qw/Str Int Bool Maybe ArrayRef/;\n        use MooseX::Types::Common::String qw/NonEmptySimpleStr SimpleStr/;\n        use Moose::Autobox;\n        use List::MoreUtils qw/any zip/;\n        our $SHA1RE = qr/[0-9a-fA-F]{40}/;\n\n        has '+type' => ( default => 'commit' );\n        has '+_gpp_obj' => ( handles => [ 'comment',\n                                          'tree_sha1',\n                                          'committer',\n                                          'committed_time',\n                                          'author',\n                                          'authored_time',\n                                          'parents',\n                                          'parent_sha1',\n                                          'parent_sha1s',\n                                      ],\n                         );\n\n        method _build_tree {\n            return [$self->repository->get_object($self->tree_sha1)];\n        }\n\n        method sha_by_path ($path) {\n            $path =~ s{/+$}();\n            my @paths = $self->repository->run_cmd('ls-tree', $self->sha1, '--', $path)\n                or return;\n            my $line = $paths[0];\n\n            $line =~ m/^([0-9]+) (.+) ($SHA1RE)\\t/;\n            my $sha1 = $3;\n            return $self->repository->get_object($sha1);\n    }\n\n        method get_patch ( Maybe[NonEmptySimpleStr] $parent_hash?,\n                           Int $patch_count?) {\n            my @cmd = qw/format-patch --encoding=utf8 --stdout/;\n\n            push @cmd,\n                defined $patch_count\n                ? \"-$patch_count -n\" : \"-1\";\n\n            if (defined $parent_hash) {\n                push @cmd, \"$parent_hash..\" . $self->sha1;\n            } else {\n                push @cmd, $self->parents->length > 1\n                    ? '--cc' : '--root';\n                push @cmd, $self->sha1;\n            }\n            return $self->_run_cmd_fh( @cmd );\n        }\n\n        method diff ( Bool              :$patch?,\n                      NonEmptySimpleStr :$parent?,\n                      NonEmptySimpleStr :$filename?\n                    ) {\n            $parent = $parent\n                ? $parent\n                    : $self->parents <= 1\n                        ? $self->parent_sha1\n                            : '-c';\n            my @etc = (\n                ( $filename  ? ('--', $filename) : () ),\n            );\n\n            my $sha1 = $parent && $parent eq '-c' && @{[$self->parents]} > 1\n                 ? sprintf(\"%s^1..%s^2\", ($self->sha1) x 2)\n                      : $self->sha1;\n\n            my @out = $self->_raw_diff(\n                ( $patch ? '--patch-with-raw' : () ),\n                ( $parent ? $parent : () ),\n                $sha1, @etc,\n            );\n\n            my @difftree = $self->_parse_diff_tree(\\@out);\n\n            return \\@difftree\n                unless $patch;\n\n            shift @out;\n\n            return \\@difftree, [$self->_parse_diff(@out)];\n        }\n\n        method _raw_diff (@args) {\n            return $self->_run_cmd_list(\n                qw(diff-tree -r -M --no-commit-id --full-index),\n                @args\n            );\n        }\n\n        method _parse_diff_tree ($diff) {\n            my @keys = qw(modesrc modedst sha1src sha1dst status src dst);\n            my @ret;\n            while (@$diff and $diff->[0] =~ /^:\\d+/) {\n                my $line = shift @$diff;\n                my @vals = $line =~ /^:(\\d+) (\\d+) ($SHA1RE) ($SHA1RE) ([ACDMRTUX]\\d*)\\t([^\\t]+)(?:\\t([^\\n]+))?$/;\n                my %line = zip @keys, @vals;\n                $line{file}   = $line{src};\n                $line{sha1}   = $line{sha1dst};\n                $line{is_new} = $line{sha1src} =~ /^0+$/\n                    if $line{sha1src};\n                @line{qw/status sim/} = $line{status} =~ /(R)0*(\\d+)/\n                    if $line{status} =~ /^R/;\n                push @ret, \\%line;\n            }\n\n            return @ret;\n        }\n\n        method _parse_diff (@diff) {\n            my @ret;\n            for (@diff) {\n                if (m{^diff --git (a/(.*?)) (b/\\2)}) {\n                    push @ret, {\n                        head => $_,\n                        a    => $1,\n                        b    => $3,\n                        file => $2,\n                        diff => '',\n                    };\n                    next;\n                }\n\n                if (/^index (\\w+)\\.\\.(\\w+)(?: (\\d+))?$/) {\n                    @{$ret[-1]}{qw(index src dst mode)} = ($_, $1, $2, $3);\n                    next\n                }\n\n                $ret[@ret ? -1 : 0]{diff} .= \"$_\\n\";\n            }\n\n            return @ret;\n        }\n\n\n  method blame ( NonEmptySimpleStr $filename, SimpleStr $sha1 ) {\n    my @blameout = $self->_run_cmd_list(\n      blame => '-p', $sha1 ? $sha1 : $self->sha1, '--', $filename\n    );\n\n    my(%commitdata, @filedata);\n    while(defined(local $_ = shift @blameout)) {\n      my ($sha1, $orig_lineno, $lineno, $group_size) =\n        /^([0-9a-f]{40}) (\\d+) (\\d+)(?: (\\d+))?$/;\n\n      $commitdata{$sha1} = {}\n        unless exists $commitdata{$sha1};\n\n      my $commit = $commitdata{$sha1};\n      my $line;\n\n      until(@blameout == 0 || ($line = shift @blameout) =~ s/^\\t//) {\n        $commit->{$1} = $2 if $line =~ /^(\\S+) (.*)/;\n      }\n\n      unless(exists $commit->{author_dt}) {\n        for my $t (qw/author committer/) {\n          my $dt = DateTime->from_epoch(epoch => $commit->{\"$t-time\"});\n          $dt->set_time_zone($commit->{\"$t-tz\"});\n          $commit->{\"$t\\_dt\"} = $dt;\n        }\n      }\n\n      push @filedata, {\n        line => $line,\n        commit => { sha1 => $sha1, %$commit },\n        meta => {\n          orig_lineno => $orig_lineno,\n          lineno => $lineno,\n          ( $group_size ? (group_size => $group_size) : () ),\n        },\n      };\n    }\n\n    return \\@filedata;\n  }\n}\n\n\n1",
      "file" : "/var/tmp/arv_kwiG2l/Gitalist-0.004001/lib/Gitalist/Git/Object/Commit.pm",
      "package" : "Gitalist::Git::Object::Commit"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class Gitalist::Git::Object::Tree\n    extends Gitalist::Git::Object\n    with Gitalist::Git::Object::HasTree {\n        has '+type' => ( default => 'tree' );\n        has '+_gpp_obj' => ( handles => [ 'directory_entries',\n                                      ],\n                         );\n    }\n\n1",
      "file" : "/var/tmp/arv_kwiG2l/Gitalist-0.004001/lib/Gitalist/Git/Object/Tree.pm",
      "package" : "Gitalist::Git::Object::Tree"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class Gitalist::Git::Object::Blob extends Gitalist::Git::Object {\n  has '+type' => ( default => 'blob' );\n}\n\n1",
      "file" : "/var/tmp/arv_kwiG2l/Gitalist-0.004001/lib/Gitalist/Git/Object/Blob.pm",
      "package" : "Gitalist::Git::Object::Blob"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class Gitalist::Git::Object::Tag extends Gitalist::Git::Object {\n    has '+type' => ( default => 'tag' );\n    has '+_gpp_obj' => ( handles => [ 'object',\n                                      'tag',\n                                      'tagger',\n                                      'tagged_time',\n                                  ],\n                         );\n\n}\n\n1",
      "file" : "/var/tmp/arv_kwiG2l/Gitalist-0.004001/lib/Gitalist/Git/Object/Tag.pm",
      "package" : "Gitalist::Git::Object::Tag"
   }
]
