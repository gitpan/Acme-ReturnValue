[
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\npackage DBD::Chart::st; \nuse DBI qw(:sql_types);\nuse Carp;\nuse Time::Local;\n\n$DBD::Chart::st::imp_data_size = 0;\n\nuse GD;\nuse DBD::Chart::Plot;\n\nuse constant SQL_INTERVAL_HR2SEC => 110;\n\nmy %strpredops = (\n'=', 'eq',\n'<>', 'ne',\n'<', 'lt',\n'<=', 'le',\n'>', 'gt',\n'>=', 'ge'\n);\n\nmy %numpredops = (\n'=', '==',\n'<>', '!=',\n'<', '<',\n'<=', '<=',\n'>', '>',\n'>=', '>='\n);\n\nmy %numtype = (\nSQL_INTEGER, 1,\nSQL_SMALLINT, 1,\nSQL_TINYINT, 1,\nSQL_DECIMAL, 1,\nSQL_FLOAT, 1\n);\n\nmy %symboltype = (\nSQL_CHAR, 1,\nSQL_VARCHAR, 1\n);\n\nmy %timetype = (\nSQL_DATE, 'YYYY-MM-DD',\nSQL_TIME, 'HH:MM:SS',\nSQL_TIMESTAMP, 'YYYY-MM-DD HH:MM:SS',\nSQL_INTERVAL_HR2SEC, '+HH:MM:SS'\n);\n\nmy %month = ( 'JAN', 0, 'FEB', 1, 'MAR', 2, 'APR', 3, 'MAY', 4, 'JUN', 5,\n'JUL', 6, 'AUG', 7, 'SEP', 8, 'OCT', 9, 'NOV', 10, 'DEC', 11);\n\nmy @quadcolors = qw(\nblack blue purple green red orange yellow white\n);\n\nsub check_color {\n\tmy ($color) = @_;\n\n\tmy $table = $DBD::Chart::charts{COLORMAP};\n\tmy $col1 = $table->{data}->[0];\n\tmy $c;\n\tforeach $c (@$col1) {\n\t\treturn 1 if ($color eq $c);\n\t}\n\treturn undef;\n}\n\nsub get_colormap {\n\tmy $table = $DBD::Chart::charts{COLORMAP};\n\tmy ($color, $r, $g, $b) = @{$table->{data}};\n\tmy %map;\n\tfor (my $i = 0; $i <= $#$color; $i++) {\n\t\t$map{$$color[$i]} = [ $$r[$i], $$g[$i], $$b[$i] ];\n\t}\n\treturn \\%map;\n}\n\nsub validate_value {\n\tmy ($sth, $p, $ttype, $parmsts, $k, $i) = @_;\n\n\treturn 1\n\t\tif (($ttype == SQL_CHAR) || ($ttype == SQL_VARCHAR));\n\n\treturn 1\n\t\tif (($p=~/^[\\-\\+]?\\d+$/) &&\n\t\t\t(($ttype == SQL_INTEGER) ||\n\t\t\t (($ttype == SQL_SMALLINT) && ($p > -32768) && ($p < 32768)) ||\n\t\t\t (($ttype == SQL_TINYINT) && ($p > -128) && ($p < 128)))\n\t\t\t);\n\n\treturn 1\n\t\tif ((($ttype == SQL_FLOAT) || ($ttype == SQL_DECIMAL)) &&\n\t\t\t($p=~/^[\\-\\+]?\\d+(\\.\\d+(E[\\-\\+]?\\d+)?)?$/i));\n\n\tif (($ttype == SQL_DATE) &&\n\t\t($p=~/^(\\d+)[\\-\\.\\/](\\w+)[\\-\\.\\/](\\d+)$/i)) {\n\n\t\tmy ($yr, $mo, $day) = ($1, uc $2, $3);\n\t\treturn 1\n\t\t\tif (((($mo=~/^\\d+$/) && ($mo > 0) && ($mo < 13)) ||\n\t\t\t\t($mo=~/^(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)$/i)) &&\n\t\t\t\t($day < 32) && ($day > 0));\n\t}\n\tif (($ttype == SQL_INTERVAL_HR2SEC) &&\n\t\t($p=~/^[\\-\\+]?((\\d+):)?((\\d+):)?(\\d+)(\\.\\d+)?/)) {\n\t\tmy ($hr, $min, $sec, $subsec) = ($2, $4, $5, $6);\n\t\treturn 1\n\t\t\tif (((! $min) || ($min < 60)) && ($sec < 60));\n\t}\n\tif (($ttype == SQL_TIME) &&\n\t\t($p=~/^(\\d+):(\\d+):(\\d+)(\\.\\d+)?$/)) {\n\t\tmy ($hr, $min, $sec, $subsec) = ($1, $2, $3, $4);\n\t\treturn 1\n\t\t\tif (($hr < 24) && ($min < 60) && ($sec < 60));\n\t}\n\tif (($ttype == SQL_TIMESTAMP) &&\n\t\t($p=~/^(\\d+)[\\-\\.\\/](\\w+)[\\-\\.\\/](\\d+)\\s+(\\d+):(\\d+):(\\d+)(\\.\\d+)?$/i)) {\n\t\tmy ($yr, $mo, $day, $hr, $min, $sec, $subsec) = ($1, $2, uc $3, $4, $5, $6, $7);\n\t\treturn 1\n\t\t\tif (((($mo=~/^\\d+$/) && ($mo > 0) && ($mo < 13)) ||\n\t\t\t\t($mo=~/^(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)$/i)) &&\n\t\t\t\t($day < 32) && ($day > 0) &&\n\t\t\t\t($hr < 24) && ($min < 60) && ($sec < 60));\n\t}\n\n\tif ($parmsts) {\n\t\t$$parmsts[$k] =\n\t\"Supplied value not compatible with target field at parameter $i.\",\n\t\treturn undef\n\t\t\tif (ref $parmsts eq 'ARRAY');\n\t\t$$parmsts{$k} =\n\t\"Supplied value not compatible with target field at parameter $i.\"\n\t}\n\treturn $sth->DBI::set_err(-1, \"Supplied value not compatible with target field at parameter $i.\", 'S1000');\n}\n\nsub validate_properties {\n\tmy ($sth, $props, $parms) = @_;\n\tforeach my $prop (keys(%$props)) {\n\t\tnext if ((! $$props{$prop}) || ($$props{$prop} !~/^\\?(\\d+)$/));\n\t\tmy $phnum = $1;\n\t\tmy $t = $$parms[$phnum];\n\t\treturn $sth->DBI::set_err(-1, 'Insufficient parameters provided.', 'S1000')\n\t\t\tif ($phnum > scalar(@$parms));\n\n\t\t$$props{$prop} = $$parms[$phnum];\n\n\t\tnext if (($binary_props{$prop}) && ($t=~/^(0|1)$/));\n\n\t\tnext if ($string_props{$prop});\n\n\t\tnext if ((($prop eq 'WIDTH') || ($prop eq 'HEIGHT')) &&\n\t\t\t(($t=~/^\\d+$/) && ($t >= 10) && ($t <= 100000)));\n\n\t\tnext if ((($prop eq 'BACKGROUND') || ($prop eq 'GRIDCOLOR') ||\n\t\t\t($prop eq 'TEXTCOLOR')) && (check_color($t)));\n\n\t\tnext if (($prop eq 'X_ORIENT') &&\n\t\t\t($t=~/^(HORIZONTAL|VERTICAL|DEFAULT)$/i));\n\n \t\tnext if (($prop eq 'COLOR') && (check_color($t)));\n\n \t\tnext if (($prop eq 'SHAPE') && ($valid_shapes{$t}));\n\t\treturn $sth->DBI::set_err(-1, \"Invalid value for $prop property.\", 'S1000');\n\t}\n\treturn 1;\n}\nsub execute_array {\n\tmy($sth, $attribs, @bind_values) = @_;\n\n\t$sth->bind_param_status($$attribs{ArrayTupleStatus}) if $$attribs{ArrayTupleStatus};\n\n\tif (@bind_values) {\n\t\t$sth->bind_param_array($_, $bind_values[$_])\n\t\t\tforeach (1..@bind_values);\n\t}\n\n\treturn $sth->execute();\n}\n\nsub execute {\n\tmy($sth, @bind_values) = @_;\n\tmy $parms = (@bind_values) ?\n\t\t\\@bind_values : $sth->{chart_params};\n\n\tmy ($i, $j, $k, $p, $t);\n\tmy ($predval, $is_parmref, $data, $pctype, $is_parmary, $ttype);\n\tmy ($paramcols, $maxary, $chart, $props, $predtype);\n\tmy ($columns, $types, $precs, $scales, $verify, $numcols);\n\n\tmy $cmd = $sth->{chart_cmd};\n\tmy $dbh = $sth->{chart_dbh};\n\tmy $name = $sth->{chart_name};\n\tmy $typeary = $sth->{chart_types};\n\t$precs = $sth->{chart_precisions};\n\t$scales = $sth->{chart_scales};\n\n\tmy $cols = $sth->{chart_columns}\n\t\tif ($cmd eq 'CREATE');\n\n\tmy $setcols = $sth->{chart_columns}\n\t\tif (($cmd eq 'UPDATE') || ($cmd eq 'INSERT'));\n\n\tmy $predicate = $sth->{chart_predicate}\n\t\tif (($cmd eq 'UPDATE') || ($cmd eq 'DELETE'));\n\n\tif ($cmd eq 'CREATE') {\n\t\tmy @ary;\n\t\tfor ($i = 0; $i < scalar(keys(%$cols)); $i++) {\n\t\t\tmy @colary = ();\n\t\t\tpush(@ary, \\@colary);\n\t\t}\n\n\t\t$DBD::Chart::charts{$name} = {\n\t\t\t'columns' => $cols,\n\t\t\t'types' => $typeary,\n\t\t\t'precisions' => $precs,\n\t\t\t'scales' => $scales,\n\t\t\t'version' => $DBD::Chart::seqno++,\n\t\t\t'data' => \\@ary\n\t\t};\n\t\treturn -1;\n\t}\n\n\tif ($cmd eq 'DROP') {\n\t\t$chart = $DBD::Chart::charts{$name};\n\t\tdelete $$chart{columns};\n\t\tdelete $$chart{types};\n\t\tdelete $$chart{precisions};\n\t\tdelete $$chart{scales};\n\t\tmy $ary = $$chart{data};\n\t\tif ($ary) {\n\t\t\tforeach my $g (@$ary) {\n\t\t\t\t@$g = ();\n\t\t\t}\n\t\t}\n\t\tdelete $$chart{data};\n\t\tdelete $DBD::Chart::charts{$name};\n\t\treturn -1;\n\t}\n\n\tmy $parmsts = $sth->{chart_parmsts};\n\tif ($cmd ne 'SELECT') {\n\t\t$chart = $DBD::Chart::charts{$name};\n\t\treturn $sth->DBI::set_err(-1, \"Chart $name does not exist.\", 'S1000')\n\t\t\tunless $chart;\n\t\treturn $sth->DBI::set_err(-1, \"Prepared version of $chart differs from current version.\", 'S1000')\n\t\t\tunless ($$chart{version} == $sth->{chart_version});\n\t\t$columns = $$chart{columns};\n\t\t$types = $$chart{types};\n\t\t$precs = $$chart{precisions};\n\t\t$scales = $$chart{scales};\n\t\t$data = $$chart{data};\n\t\t($is_parmref, $is_parmary, $maxary) = (0, 0, 1);\n\t\t$verify = ($sth->{chart_noverify}) ? 0 : 1;\n\n\t\treturn $sth->DBI::set_err(-1, 'Number of parameters supplied does not match number required.','S1000')\n\t\t\tif (($sth->{NUM_OF_PARAMS}) && ((! $parms) ||\n\t\t\t\t(scalar(@$parms) != $sth->{NUM_OF_PARAMS})));\n\n\t\t$parmsts = $sth->{chart_parmsts};\n\t\t$predicate = $sth->{chart_predicate};\n\t\t$predtype = $$types[$$predicate[0]] if ($predicate);\n\t\t$paramcols = $sth->{chart_param_cols};\n\t\t$numcols = scalar(@$paramcols);\n\t\tif (($verify) && ($parms)) {\n\t\t\t$p = $$parms[0];\n\t\t\t$is_parmref = 1 if ((ref $$parms[0]));\n\t\t\t$is_parmary = 1\n\t\t\t\tif (($is_parmref) && (ref $$parms[0] eq 'ARRAY'));\n\t\t\t$maxary = scalar(@$p) if ($is_parmary);\n\t\t\tfor ($i = 1; $i < $sth->{NUM_OF_PARAMS}; $i++) {\n\t\t\t\tmy $p = $$parms[$i];\n\t\t\t\treturn $sth->DBI::set_err(-1,\n\t\t\t\t\t'All parameters must be of same type (scalar, scalarref, or arrayref).', 'S1000')\n\t\t\t\t\tif ( (($is_parmref) && (! (ref $p) ) ) ||\n\t\t\t\t\t\t((! $is_parmref) && (ref $p)));\n\n\t\t\t\treturn $sth->DBI::set_err(-1,\n\t\t\t\t\t'All parameters must be of same type (scalar, scalarref, or arrayref).', 'S1000')\n\t\t\t\t\tif ((($is_parmary) && ((! (ref $p)) || (ref $p ne 'ARRAY'))) ||\n\t\t\t\t\t\t((! $is_parmary) && (ref $p) && (ref $p eq 'ARRAY')));\n\t\t\t\treturn $sth->DBI::set_err(-1,\n\t\t\t\t\t'All parameter arrays must be the same size.','S1000')\n\t\t\t\t\tif (($is_parmary) && (scalar(@$p) != $maxary));\n\t\t\t}\n\t\t\tfor ($k = 0; $k < $maxary; $k++) {\n\t\t\t\tfor ($i = 0; $i < $numcols; $i++) {\n\t\t\t\t\t$ttype = $$types[$$paramcols[$i]];\n\t\t\t\t\t$p = $$parms[$i];\n\t\t\t\t\t$p = (($is_parmary) ? $$p[$k] : $$p) if ($is_parmref);\n\t\t\t\t\tnext if (! defined($p));\n\t\t\t\t\treturn undef unless validate_value($sth, $p, $ttype, $parmsts, $k, $i);\n\t\t\t\t}\n\t\t\t\tif (($predicate) && ($$predicate[2] eq '?')) {\n\t\t\t\t\t$ttype = $$types[$$predicate[0]];\n\t\t\t\t\t$p = $$parms[$i];\n\t\t\t\t\t$p = (($is_parmary) ? $$p[$k] : $$p) if ($is_parmref);\n\t\t\t\t\tif (! defined($p))\n\t\t\t\t\t{\n\t\t\t\t\t\tif ($parmsts) {\n\t\t\t\t\t\t\t$$parmsts[$k] =\n\t\t\t\t\t\t\t'NULL values not allowed in predicates.',\n\t\t\t\t\t\t\treturn undef\n\t\t\t\t\t\t\t\tif (ref $parmsts eq 'ARRAY');\n\t\t\t\t\t\t\t$$parmsts{$k} =\n\t\t\t\t\t\t\t'NULL values not allowed in predicates.';\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn $sth->DBI::set_err(-1, 'NULL values not allowed in predicates.', 'S1000');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn undef unless validate_value($sth, $p, $ttype, $parmsts, $k, $i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif ($name eq 'COLORMAP') {\n\t\tforeach $i (keys(%$setcols)) {\n\t\t\tmy $v = $$setcols{$i};\n\t\t\treturn $sth->DBI::set_err(-1, 'NULL values not valid for COLORMAP fields.', 'S1000')\n\t\t\t\tunless defined($v);\n\n\t\t\tnext unless $i;\t\n\n\t\t\treturn $sth->DBI::set_err(-1, 'Invalid value for COLORMAP component field.','S1000')\n\t\t\t\tif (($v < 0) || ($v > 255));\n\t\t}\n\t\tfor ($j = 0; $j < scalar(@$paramcols); $j++) {\n\t\t\t$i = $$paramcols[$j];\n\n\t\t\tfor ($k = 0; $k < $maxary; $k++) {\n\n\t\t\t\t$p = $$parms[$j];\n\t\t\t\t$p = (($is_parmary) ? $$p[$k] : $$p) if ($is_parmref);\n\n\t\t\t\treturn $sth->DBI::set_err(-1, 'NULL values not valid for COLORMAP fields.', 'S1000')\n\t\t\t\t\tunless defined($p);\n\t\t\t\tnext unless $i; \n\n\t\t\t\treturn $sth->DBI::set_err(-1,\n\t\t\t\t\t\"Invalid value for COLORMAP component field.\", 'S1000')\n\t\t\t\t\tif (($p!~/^\\d+$/) || ($p > 255));\n\t\t\t}\n\t\t}\n\t}\n\n\tif ($cmd eq 'INSERT') {\n\t\tforeach $i (keys(%$setcols)) {\n\t\t\t$t = $$data[$i];\n\t\t\tmy $v = $$setcols{$i};\n\t\t\tpush(@$t, (($v) x $maxary));\n\t\t}\n\t\t$k = 1;\n\t\tfor ($j = 0; $j < scalar(@$paramcols); $j++) {\n\t\t\t$i = $$paramcols[$j];\n\t\t\t$t = $$data[$i];\n\t\t\t$ttype = $$types[$i];\n\t\t\tfor ($k = 0; $k < $maxary; $k++) {\n\t\t\t\t$p = $$parms[$j];\n\t\t\t\t$p = (($is_parmary) ? $$p[$k] : $$p) if ($is_parmref);\n\n\t\t\t\tif (defined($p) &&\n\t\t\t\t\t(($ttype == SQL_CHAR) || ($ttype == SQL_VARCHAR)) &&\n\t\t\t\t\t(length($p) > $$precs[$i])) {\n\t\t\t\t\t$DBD::Chart::errstr =\n\t\t\t\t\"Supplied value truncated at parameter $j.\";\n\n\t\t\t\t\t$p = substr($p, 0, $$precs[$i]);\n\n\t\t\t\t\t$$parmsts[$k] =\n\t\t\t\t\"Supplied value truncated at parameter $j.\"\n\t\t\t\t\t\tif ($parmsts && (ref $parmsts eq 'ARRAY'));\n\t\t\t\t\t$$parmsts{$k} =\n\t\t\t\t\"Supplied value truncated at parameter $j.\"\n\t\t\t\t\t\tif ($parmsts && (ref $parmsts ne 'ARRAY'));\n\t\t\t\t}\n\t\t\t\tpush(@$t, $p);\n\t\t\t}\n\t\t} \n\t\treturn $k;\n\t}\n\n\tif ($cmd eq 'UPDATE') {\n\t\tif (! $predicate) {\n\t\t\treturn $sth->DBI::set_err(-1, 'Parameter arrays not allowed for unqualified UPDATE.', 'S1000')\n\t\t\t\tif ($is_parmary);\n\t\t\tforeach $i (keys(%$setcols)) {\n\t\t\t\t$t = $$data[$i];\n\t\t\t\tmy $v = $$setcols{$i};\n\t\t\t\t$j = scalar(@$t);\n\t\t\t\t@$t = ($v) x $j;\n\t\t\t}\n\t\t\tfor ($j = 0; $j < scalar(@$paramcols); $j++) {\n\t\t\t\t$i = $$paramcols[$j];\n\t\t\t\t$t = $$data[$i];\n\t\t\t\t$k = scalar(@$t);\n\t\t\t\t$ttype = $$types[$i];\n\t\t\t\t$p = $$parms[$j];\n\t\t\t\t$p = $$p if ($is_parmref);\n\n\t\t\t\tif (defined($p) &&\n\t\t\t\t\t(($ttype == SQL_CHAR) || ($ttype == SQL_VARCHAR)) &&\n\t\t\t\t\t(length($p) > $$precs[$i])) {\n\t\t\t\t\t$DBD::Chart::errstr =\n\t\t\t\t\"Supplied value truncated at parameter $j.\";\n\n\t\t\t\t\t$p = substr($p, 0, $$precs[$i]);\n\n\t\t\t\t\t$$parmsts[$k] =\n\t\t\t\t\"Supplied value truncated at parameter $j.\"\n\t\t\t\t\t\tif ($parmsts && (ref $parmsts eq 'ARRAY'));\n\t\t\t\t\t$$parmsts{$k} =\n\t\t\t\t\"Supplied value truncated at parameter $j.\"\n\t\t\t\t\t\tif ($parmsts && (ref $parmsts ne 'ARRAY'));\n\t\t\t\t}\n\t\t\t\t@$t = ($p) x $k;\n\t\t\t}\n\t\t\treturn 1;\n\t\t} \n\t\t$predval = $$predicate[2];\n\t\treturn $sth->DBI::set_err(-1, 'Parameter arrays not allowed for literally qualified UPDATE.', 'S1000')\n\t\t\tif (($predval ne '?') && ($is_parmary));\n\n\t\tmy %rowmap = eval_predicate($$predicate[0], $$predicate[1],\n\t\t\t$predval, $types, $data, $parms, $is_parmary, $is_parmref,\n\t\t\t$maxary);\n\n\t\treturn 0 unless scalar(%rowmap);\n\t\tmy ($x, $y);\n\t\tforeach $i (keys(%$setcols)) {\n\t\t\t$t = $$data[$i];\n\t\t\twhile (($x, $y) = each(%rowmap)) {\n\t\t\t\t$$t[$x] = $$setcols{$i};\n\t\t\t}\n\t\t}\n\t\tfor ($j = 0; $j < scalar(@$paramcols); $j++) {\n\t\t\t$i = $$paramcols[$j];\n\t\t\t$t = $$data[$i];\n\t\t\t$ttype = $$types[$i];\n\t\t\twhile (($x, $y) = each(%rowmap)) {\n\t\t\t\t$p = $$parms[$j];\n\t\t\t\t$p = (($is_parmary) ? $$p[$y] : $$p) if ($is_parmref);\n\t\t\t\tif ((($ttype == SQL_CHAR) || ($ttype == SQL_VARCHAR) ||\n\t\t\t\t\t($ttype == SQL_BINARY) || ($ttype == SQL_VARBINARY)) &&\n\t\t\t\t\t(length($p) > $$precs[$i])) {\n\t\t\t\t\t$DBD::Chart::errstr =\n\t\t\t\t\t\"Supplied value truncated at parameter $j.\";\n\n\t\t\t\t\t$p = substr($p, 0, $$precs[$i]);\n\t\t\t\t}\n\t\t\t\t$$t[$x] = $p;\n\t\t\t}\n\t\t}\n\t\treturn scalar(keys(%rowmap));\n\t}\n\n\tif ($cmd eq 'DELETE') {\n\t\tif (! $predicate) {\n\t\t\t$k = scalar(@{$$data[0]});\n\t\t\tforeach $t (@$data) {\n\t\t\t\t@$t = ();\n\t\t\t}\n\t\t\treturn $k;\n\t\t} \n\t\tmy %rowmap = eval_predicate($$predicate[0], $$predicate[1],\n\t\t\t$$predicate[2], $types, $data, $parms, $is_parmary,\n\t\t\t$is_parmref, $maxary);\n\n\t\treturn 0 unless scalar(%rowmap);\n\n\t\tmy @rownums = sort(keys(%rowmap));\n\t\t$j = scalar(@rownums);\n\t\twhile ($k = pop(@rownums)) {\n\t\t\tfor ($i = 0; $i < scalar(@$data); $i++) {\n\t\t\t\t$t = $$data[$i];\n\t\t\t\tsplice(@$t, $k, 1);\n\t\t\t}\n\t\t}\n\t\treturn $j;\n\t}\n\tmy $dtypes = $sth->{chart_charttypes};\n\tmy $dcharts = $sth->{chart_sources};\n\tmy $dprops = $sth->{chart_properties};\n\tmy $dversions = $sth->{chart_version};\n\tmy $dcols = $sth->{chart_columns};\n\tmy $dnames = $sth->{chart_qnames};\n\tmy $srcsth;\n\tmy @dcolidxs = ();\n\tif ($$dcharts[0] && ($$dcharts[0] eq 'COLORMAP')) {\n\t\tmy $table = $DBD::Chart::charts{COLORMAP};\n\t\tmy $col1 = $table->{data}->[0];\n\t\tif (defined($$props{NAME})) {\n\t\t\tif ($$props{NAME}=~/^\\?(\\d+)$/) {\n\t\t\t\tmy $phnum = $1;\n\n\t\t\t\treturn $sth->DBI::set_err(-1, 'Insufficient parameters provided.', 'S1000')\n\t\t\t\t\tif ($phnum > scalar(@$parms));\n\n\t\t\t\t$sth->{chart_colormap} = $$parms[$phnum];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$sth->{chart_colormap} = $$props{NAME};\n\t\t\t}\n\t\t\tmy $color;\n\t\t\tforeach $color (@$col1) {\n\t\t\t\tlast if ($color eq $sth->{chart_colormap});\n\t\t\t}\n\t\t\treturn '0E0' if ($color ne $sth->{chart_colormap});\n\t\t\t$sth->{chart_1_color} = 1;\n\t\t\treturn 1;\n\t\t}\n\t\tdelete $sth->{chart_1_color};\n\t\t$sth->{chart_colormap} = 0;\n\t\treturn scalar @$col1;\n\t}\n\tmy $img;\n\tmy $xdomain;\n\tmy $ydomain;\n\tmy $zdomain;\n\tmy @legends = ();\n\tmy $is_symbolic = undef;\n\tfor ($i = 0; $i < scalar(@$dtypes); $i++) {\n\t\t$is_symbolic = 1, last\n\t\t\tif (($$dtypes[$i] eq 'BARCHART') ||\n\t\t\t\t($$dtypes[$i] eq 'HISTOGRAM') ||\n\t\t\t\t($$dtypes[$i] eq 'CANDLESTICK'));\n\t}\n\n\tfor ($i = 0; $i < scalar(@$dtypes); $i++) {\n\n\t\tif ($$dtypes[$i] ne 'IMAGE') {\n\n\t\t\t$name = $$dcharts[$i];\n\t\t\tnext unless (($i > 0) || $name); \n\t\t\t$srcsth = undef;\n\t\t\tif ($name!~/^\\?(\\d+)$/) {\n\t\t\t\t$chart = $DBD::Chart::charts{$name};\n\n\t\t\t\treturn $sth->DBI::set_err(-1, \"Chart $name does not exist.\", 'S1000')\n\t\t\t\t\tunless $chart;\n\n\t\t\t\treturn $sth->DBI::set_err(-1, \"Prepared version of $name differs from current version.\", 'S1000')\n\t\t\t\t\tif ($$chart{version} != $$dversions{$name});\n\n\t\t\t\t$chart = $DBD::Chart::charts{$$dcharts[$i]};\n\t\t\t\t$columns = $$chart{columns};\n\t\t\t\t$types = $$chart{types};\n\t\t\t\t$precs = $$chart{precisions};\n\t\t\t\t$scales = $$chart{scales};\n\t\t\t\t$data = $$chart{data};\n\t\t\t}\n\t\t\telse {\t\n\t\t\t\tmy $phn = $1;\n\n\t\t\t\treturn $sth->DBI::set_err(-1, 'Parameterized chartsource not provided.','S1000')\n\t\t\t\t\tunless $$parms[$phn];\n\t\t\t\t$srcsth = $$parms[$phn];\n\t\t\t\treturn $sth->DBI::set_err(-1,\n\t\t\t\t\t'Parameterized chartsource value must be a prepared and executed DBI statement handle.','S1000')\n\t\t\t\t\tif ((ref $srcsth ne 'DBI::st') && (ref $srcsth ne 'DBIx::Chart::SthContainer'));\n\t\t\t\tmy $ctype = $$dtypes[$i];\n\t\t\t\tmy $numflds;\n\t\t\t\tif (ref $srcsth eq 'DBIx::Chart::SthContainer') {\n\t\t\t\t\treturn undef\n\t\t\t\t\t\tunless $srcsth->execute();\n\n\t\t\t\t\t$numflds = $srcsth->num_of_fields;\n\t\t\t\t}\n\t\t\t\telse {\t\n\t\t\t\t\t$numflds = $srcsth->{NUM_OF_FIELDS};\n\t\t\t\t}\n\n\t\t\t\treturn $sth->DBI::set_err(-1, \"$ctype chart requires at least $mincols{$ctype} columns.\",'S1000')\n\t\t\t\t\tif ($numflds < $mincols{$ctype});\n\n\t\t\t\treturn $sth->DBI::set_err(-1, 'CANDLESTICK chart requires 2N + 1 columns.','S1000')\n\t\t\t\t\tif (($ctype eq 'CANDLESTICK') && (! $$dprops[$i]->{STACK}) &&\n\t\t\t\t\t\t(($numflds - 1) & 1));\n\t\t\t\tmy $cols = $$dcols[$i];\n\t\t\t\tmy $colidxs = [ ];\n\t\t\t\t$dcolidxs[$i] = $colidxs;\n\t\t\t\tif ($$cols[0] eq '*') {\n\t\t\t\t\t@$colidxs = (0..($numflds - 1));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmy ($d, $idx);\n\t\t\t\t\t$columns = get_ext_type_info($sth, $srcsth, 'NAME', ($i ? $i-1 : 0) );\n\t\t\t\t\tforeach $d (0..$#$columns) {\n\t\t\t\t\t\t$$columns[$d] = uc $$columns[$d] ;\n\t\t\t\t\t}\n\t\t\t\t\tforeach my $c (@$cols) {\n\t\t\t\t\t\tforeach $d (0..$#$columns) {\n\t\t\t\t\t\t\t$idx = $d,\n\t\t\t\t\t\t\tlast if ($c eq $$columns[$d]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn $sth->DBI::set_err(-1, \"Column $c not found in datasource.\", 'S1000')\n\t\t\t\t\t\t\tunless ($c eq $$columns[$idx]);\n\t\t\t\t\t\tpush @$colidxs, $idx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmy $srcsth = $$parms[$1];\n\t\t\t\t$columns = get_ext_type_info($sth, $srcsth, 'NAME', ($i ? $i-1 : 0) );\n\t\t\t\t$types = get_ext_type_info($sth, $srcsth, 'TYPE', ($i ? $i-1 : 0));\n\t\t\t\t$srcsth->finish,\n\t\t\t\treturn $sth->DBI::set_err(-1, 'Datasource does not provide one of NAME or TYPE information.', 'S1000')\n\t\t\t\t\tunless ($types || $columns);\n\n\t\t\t\t$data = [];\n\t\t\t\tmy $rowcnt = 0;\n\t\t\t\tmy $row;\n\t\t\t\t$colidxs = $dcolidxs[$i];\n\n\t\t\t\tpush(@$data, [ ])\n\t\t\t\t\tforeach (@$colidxs);\n\n\t\t\t\t$row = $srcsth->fetchall_arrayref(undef, 10000);\n\t\t\t\tforeach my $r (@$row) {\n\t\t\t\t\tpush(@{$$data[$_]}, $$r[$$colidxs[$_]])\n\t\t\t\t\t\tforeach (0..$#$colidxs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$props = $$dprops[$i];\n\t\treturn undef unless validate_properties($sth, $props, $parms);\n\n\t\tif ($i == 0) {\n\t\t\t$img = DBD::Chart::Plot->new($$props{WIDTH}, $$props{HEIGHT},\n\t\t\t\tget_colormap());\n\t\t\treturn undef unless $img;\n\t\t\t$img->setOptions( bgColor => $$props{BACKGROUND},\n\t\t\t\ttextColor => $$props{TEXTCOLOR},\n\t\t\t\tgridColor => $$props{GRIDCOLOR},\n\t\t\t\tthreed => $$props{THREE_D});\n\n\t\t\t$img->setOptions( title => $$props{TITLE})\n\t\t\t\tif $$props{TITLE};\n\n\t\t\t$img->setOptions( signature => $$props{SIGNATURE})\n\t\t\t\tif $$props{SIGNATURE};\n\n\t\t\t$img->setOptions(\n\t\t\t\tgenMap => ($$props{MAPNAME}) ? $$props{MAPNAME} : 'plot',\n\t\t\t\tmapType => $sth->{chart_imagemap},\n\t\t\t\tmapURL => $$props{MAPURL},\n\t\t\t\tmapScript => $$props{MAPSCRIPT},\n\t\t\t\tmapType => ($$props{MAPTYPE}) ? $$props{MAPTYPE} : 'HTML',\n\t\t\t\tmapModifier => $sth->{chart_map_modifier},\n\t\t\t\tborder => $$props{BORDER}\n\t\t\t)\n\t\t\t\tif $sth->{chart_imagemap};\n\n\t\t\t$img->setOptions( logo => $$props{LOGO}) if $$props{LOGO};\n\n\t\t\t$img->setOptions( 'xAxisLabel' => $$props{X_AXIS})\n\t\t\t\tif $$props{X_AXIS};\n\t\t\t$img->setOptions( 'yAxisLabel' => $$props{Y_AXIS})\n\t\t\t\tif $$props{Y_AXIS};\n\t\t\t$img->setOptions( 'zAxisLabel' => $$props{Z_AXIS})\n\t\t\t\tif $$props{Z_AXIS};\n\n\t\t\t$img->setOptions( 'xAxisVert' => ($$props{X_ORIENT} eq 'VERTICAL'))\n\t\t\t\tif $$props{X_ORIENT};\n\n\t\t\t$img->setOptions( 'horizGrid' => 1,\n\t\t\t\t'vertGrid' => ($$dtypes[$i] ne 'BARCHART'))\n\t\t\t\tif $$props{SHOWGRID};\n\n\t\t\t$img->setOptions( 'xLog' => 1)\n\t\t\t\tif $$props{X_LOG};\n\n\t\t\t$img->setOptions( 'yLog' => 1)\n\t\t\t\tif $$props{Y_LOG};\n\n\t\t\t$img->setOptions( 'keepOrigin' => 1)\n\t\t\t\tif $$props{KEEPORIGIN};\n\n\t\t\t$img->setOptions( 'font' => $$props{FONT})\n\t\t\t\tif $$props{FONT};\n\t\t}\n\n\t\tnext if ($$dtypes[$i] eq 'IMAGE');\t\n\t\tmy @colors = ();\n\t\tmy $clist = ($$props{COLOR}) ? $$props{COLOR} : \\@dfltcolors;\n\t\tif ($$dtypes[$i] eq 'QUADTREE') {\n\t\t\t@colors = $$props{COLOR} ? @{$$props{COLOR}} : @quadcolors;\n\t\t}\n\t\telse {\n\t\t\t$t = ($$dtypes[$i] eq 'PIECHART') ? scalar @{$$data[0]} : scalar @$data;\n\t\t\t$t-- unless (($$dtypes[$i] eq 'BOXCHART') || \n\t\t\t\t($$dtypes[$i] eq 'PIECHART'));\n\t\t\t$t /= 2 if ($$dtypes[$i] eq 'CANDLESTICK');\n\t\t\t$t = 1 if ($$props{Z_AXIS});\n\t\t\t$t = scalar @{$$data[0]}\n\t\t\t\tif ((($$dtypes[$i] eq 'BARCHART') || ($$dtypes[$i] eq 'HISTOGRAM')) &&\n\t\t\t\t(scalar @$clist > 1) && (scalar @$data == 2));\n\t\t\tfor ($k = 0, $j = 0; $k < $t; $k++) {\n\t\t\t\tpush(@colors, $$clist[$j++]);\n\t\t\t\t$j = 0 if ($j >= scalar(@$clist));\n\t\t\t}\n\t\t}\n\n\t\tmy $propstr = '';\n\t\treturn $sth->DBI::set_err(-1, 'Incompatible domain types for composite image.', 'S1000')\n\t\t\tunless ((! $xdomain) ||\n\t\t\t\t($numtype{$xdomain} && $numtype{$$types[0]}) ||\n\t\t\t\t($timetype{$xdomain} && $timetype{$$types[0]} &&\n\t\t\t\t\t($timetype{$xdomain} eq $timetype{$$types[0]})) ||\n\t\t\t\t($symboltype{$xdomain} && $symboltype{$$types[0]}));\n\t\t$xdomain = $$types[0] unless $xdomain;\n\n\t\treturn $sth->DBI::set_err(-1, 'Incompatible range types for composite image.','S1000')\n\t\t\tunless ((! $ydomain) || ($$dtypes[$i] eq 'BOXCHART') ||\n\t\t\t\t($numtype{$ydomain} && $numtype{$$types[1]}) ||\n\t\t\t\t($timetype{$ydomain} && $timetype{$$types[1]} &&\n\t\t\t\t\t($timetype{$ydomain} eq $timetype{$$types[1]})));\n\t\t$ydomain = $$types[1]\n\t\t\tunless ($ydomain || ($$dtypes[$i] eq 'BOXCHART'));\n\n\t\treturn $sth->DBI::set_err(-1, 'Incompatible Z axis types for composite image.','S1000')\n\t\t\tunless ((! $zdomain) ||\n\t\t\t\t($numtype{$zdomain} && $numtype{$$types[2]}) ||\n\t\t\t\t($timetype{$zdomain} && $timetype{$$types[2]} &&\n\t\t\t\t\t($timetype{$zdomain} eq $timetype{$$types[2]})) ||\n\t\t\t\t($symboltype{$zdomain} && $symboltype{$$types[2]}));\n\n\t\t$zdomain = $$types[2] if ((! $zdomain) && $$props{Z_AXIS});\n\t\t$img->setOptions( 'symDomain' => 1)\n\t\t\tif (($$dtypes[$i] ne 'GANTT') && ($$dtypes[$i] ne 'QUADTREE') &&\n\t\t\t\t($is_symbolic || $symboltype{$xdomain}));\n\t\t$img->setOptions( 'timeDomain' => $timetype{$xdomain})\n\t\t\tif (defined($xdomain) && $timetype{$xdomain});\n\t\t$img->setOptions( 'timeRange' => $timetype{$ydomain})\n\t\t\tif (defined($ydomain) && $timetype{$ydomain});\n\t\tif ($$dtypes[$i] eq 'PIECHART') {\n\t\t\t$propstr = 'pie ' . join(' ', @colors);\n\t\t\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\t\t\tunless $img->setPoints($$data[0], $$data[1], $propstr);\n\t\t\tnext;\n\t\t}\n\t\tif ($$dtypes[$i] eq 'QUADTREE') {\n\t\t\t$propstr = 'quadtree ' . join(' ', @colors);\n\t\t\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\t\t\tunless $img->setPoints(@$data, $propstr);\n\t\t\tnext;\n\t\t}\n\t\tif ($$dtypes[$i] eq 'GANTT') {\n\t\t\t$propstr = \"gantt $colors[0]\";\n\t\t\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\t\t\tunless $img->setPoints(@$data, $propstr);\n\t\t\tnext;\n\t\t}\n\t\tmy @colnames = ();\n\t\tif (! $srcsth) {\n\t\t\t$colnames[$$columns{$_}] = $_\n\t\t\t\tforeach (keys(%$columns));\n\t\t}\n\t\telse {\n\t\t\t@colnames = @$columns;\n\t\t}\n\t\tshift @colnames unless ($$dtypes[$i] eq 'BOXCHART');\n\n\t\t$propstr .= ' showvalues:' . (($$props{SHOWVALUES} == 1) ? 5 : $$props{SHOWVALUES}) . ' '\n\t\t\tif ($$props{SHOWVALUES});\n\t\t$propstr .= ' stack '\n\t\t\tif ($$props{STACK});\n\t\t$img->setOptions(\n\t\t\t'xAxisVert' => ($$props{X_ORIENT} ? ($$props{X_ORIENT} ne 'HORIZONTAL') : 1))\n\t\t\tif ((! $numtype{$$types[0]}) || ($$dtypes[$i] eq 'CANDLESTICK'));\n\t\tif (! $$props{Z_AXIS}) {\n\t\t\tif ((($$dtypes[$i] ne 'CANDLESTICK') && (scalar(@$data) > 2)) ||\n\t\t\t\t(($$dtypes[$i] eq 'BOXCHART') && (scalar(@$data) > 1)) ||\n\t\t\t\t(scalar(@$data) > 3)) {\n\t\t\t\tmy $incr = ($$dtypes[$i] ne 'CANDLESTICK') ? 1 : 2;\n\t\t\t\tmy $legary = ($$props{STACK}) ? [ ] : \\@legends;\n\t\t\t\tpush(@legends, $legary) if ($$props{STACK});\n\t\t\t\tfor (my $c = 0; $c <= $#colnames; $c += $incr) {\n\t\t\t\t\tlast if ((! $$props{ANCHORED}) && ($c == $#colnames) &&\n\t\t\t\t\t\t(($$dtypes[$i] eq 'BARCHART') ||\n\t\t\t\t\t\t($$dtypes[$i] eq 'HISTOGRAM')));\n\t\t\t\t\tpush(@$legary, ($$dnames[$i] . '.' . $colnames[$c])),\n\t\t\t\t\tnext\n\t\t\t\t\t\tif ($$dnames[$i]);\n\t\t\t\t\tpush(@$legary, $colnames[$c]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telsif ($#$dtypes > 1) {\n\t\t\t\tpush(@legends, ($$dnames[$i] ? $$dnames[$i] : \"PLOT$i\"));\n\t\t\t}\n\t\t}\n\t\tmy @icons = ();\n\t\tmy $iconlist = $$props{ICON};\n\t\tif ($$props{ICON}) {\n\t\t\tfor ($k = 1, $j = 0; $k <= $#$data; $k++) {\n\t\t\t\tpush(@icons, $$iconlist[$j++]);\n\t\t\t\t$j = 0 if ($j > $#$iconlist);\n\t\t\t}\n\t\t\t$img->setOptions( icons => \\@icons );\n\t\t}\n\n\t\tif (($$dtypes[$i] eq 'BARCHART') ||\n\t\t\t($$dtypes[$i] eq 'HISTOGRAM')) {\n\t\t\t$propstr .= ($$dtypes[$i] eq 'HISTOGRAM') ? 'histo ' : 'bar ';\n\t\t\tif ($$props{Z_AXIS}) {\n\t\t\t\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\t\t\t\tunless $img->setPoints($$data[0], $$data[1], $$data[2],\n\t\t\t\t\t\t$propstr . $colors[0]),\n\t\t\t\tnext;\n\t\t\t}\n\t\t\t$propstr.= ' float' unless $$props{ANCHORED};\n\t\t\tif (($#$data == 1) && (! $$props{ICON})) {\n\t\t\t\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\t\t\t\tunless $img->setPoints($$data[0], $$data[1],\n\t\t\t\t\t\t$propstr . ' ' . join(' ', @colors)),\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tif ($$props{STACK}) {\n\t\t\t\t$propstr .= ' ' . ($$props{ICON} ? 'icon:' . join(' icon:', @icons) : join(' ', @colors));\n\t\t\t\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\t\t\t\tunless $img->setPoints(@$data, $propstr);\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\tfor ($i=1; $i <= $#$data; $i++) {\n\t\t\t\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\t\t\t\tunless $img->setPoints($$data[0], $$data[$i],\n\t\t\t\t\t\t$propstr . ($$props{ICON} ? 'icon:' . $icons[$i-1] : $colors[$i-1]));\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\t\tmy @shapes = ();\n\t\tmy $shapelist = ($$props{SHAPE}) ? $$props{SHAPE} :\n\t\t\t[ 'fillcircle' ];\n\t\t$$props{SHOWPOINTS} = 1 if $$props{SHAPE};\n\t\tfor ($k = 1, $j = 0, my $n = 0; $k <= $#$data; $k++) {\n\t\t\tpush(@shapes, ($$shapelist[$j] eq 'icon') ? 'icon:' . $$iconlist[$n++] : $$shapelist[$j]);\n\t\t\t$n = 0 if ($n > $#$iconlist);\n\t\t\t$j++;\n\t\t\t$j = 0 if ($j > $#$shapelist);\n\t\t}\n\n\t\tif ($$dtypes[$i] eq 'CANDLESTICK') {\n\t\t\tif ($$props{STACK}) {\n\t\t\t\t$propstr .= ' candle ' . join(' ', @colors);\n\t\t\t\t$propstr .= ' ' . $shapes[0]\n\t\t\t\t\tif ($$props{SHOWPOINTS});\n\t\t\t\t$propstr .= ' width:' . ($$props{LINEWIDTH} ? $$props{LINEWIDTH} : 2);\n\t\t\t\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\t\t\t\tunless $img->setPoints(@$data, $propstr);\n\t\t\t\tnext;\n\t\t\t}\n\t\t\tfor (my $n = 0, $k = 1; $k <= $#$data; $k += 2, $n++) {\n\t\t\t\t$propstr .= ' candle ' . $colors[$n];\n\t\t\t\t$propstr .= ' ' . $shapes[$n]\n\t\t\t\t\tif ($$props{SHOWPOINTS});\n\t\t\t\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\t\t\t\tunless $img->setPoints($$data[0], $$data[$k], $$data[$k+1], $propstr);\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\n\t\tif ($$dtypes[$i] eq 'BOXCHART') {\n\t\t\tfor (my $n = 0, $k = 0; $k <= $#$data; $k++, $n++) {\n\t\t\t\t$propstr .= ' box ' . $colors[$n];\n\t\t\t\t$propstr .= ' ' . $shapes[$n]\n\t\t\t\t\tif ($$props{SHOWPOINTS});\n\t\t\t\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\t\t\t\tunless $img->setPoints($$data[$k], $propstr);\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\t\t$img->setOptions( lineWidth => ($$props{LINEWIDTH} ? $$props{LINEWIDTH} : 1));\n\t\tif (($$dtypes[$i] eq 'AREAGRAPH') && ($$props{STACK})) {\n\t\t\t$propstr .= ' fill ' . join(' ', @colors) ;\n\t\t\t$propstr .= ' ' . join(' ', @shapes)\n\t\t\t\tif ($$props{SHOWPOINTS} || $$props{SHAPE});\n\t\t\t$propstr .= ' float' unless $$props{ANCHORED};\n\t\t\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\t\t\tunless $img->setPoints(@$data, $propstr);\n\t\t\tnext;\n\t\t}\n\t\tfor ($k = 1; $k <= $#$data; $k++) {\n\t\t\tmy $tprops = $propstr . ' ';\n\t\t\t$tprops .= ($$dtypes[$i] eq 'POINTGRAPH') ?\n\t\t\t\t'noline ' . $colors[$k-1] . ' ' . $shapes[$k-1] :\n\t\t\t\t($$dtypes[$i] eq 'LINEGRAPH') ?\n\t\t\t\t\t$colors[$k-1] :\n\t\t\t\t\t'fill ' . $colors[$k-1] ;\n\t\t\t$tprops .= ' ' . $shapes[$k-1]\n\t\t\t\tif ($$props{SHOWPOINTS} || $$props{SHAPE});\n\t\t\t$tprops .= ' width:' . ($$props{LINEWIDTH} ? $$props{LINEWIDTH} : 1);\n\t\t\t$tprops .= ' float' unless $$props{ANCHORED};\n\t\t\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\t\t\tunless $img->setPoints($$data[0], $$data[$k], $tprops);\n\t\t}\n\t}\n\t$img->setOptions( legend => \\@legends)\n\t\tif ($#legends >= 0);\n\t$sth->{chart_image} = $img->plot($dprops->[0]->{FORMAT});\n\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\tunless $sth->{chart_image};\n\n\t$sth->{chart_imagemap} =\n\t\t($sth->{chart_imagemap}) ? $img->getMap() : undef;\n\treturn $sth->DBI::set_err(-1, $img->{errmsg}, 'S1000')\n\t\tunless $sth->{chart_image};\n\t$precs = $sth->{PRECISION};\n\t$$precs[0] = length($sth->{chart_image});\n\t$$precs[1] = length($sth->{chart_imagemap}) if $sth->{chart_imagemap};\n    return 1;\n}\n\nsub convert_time {\n\tmy ($value, $type) = @_;\n\treturn timegm(0, 0, 0, $3, $2 - 1, $1)\n\t\tif (($type == SQL_DATE) &&\n\t\t\t($value=~/^(\\d+)[\\-\\.\\/](\\d+)[\\-\\.\\/](\\d+)$/));\n\n\treturn timegm(0, 0, 0, $3, $month{uc $2}, $1)\n\t\tif (($type == SQL_DATE) &&\n\t\t\t($value=~/^(\\d+)[\\-\\.\\/](\\w+)[\\-\\.\\/](\\d+)$/));\n\n\treturn timegm($6, $5, $4, $3, $2 - 1, $1) + ($7 ? $7 : 0)\n\t\tif (($type == SQL_TIMESTAMP) &&\n\t\t\t($value=~/^(\\d+)[\\-\\.\\/](\\d+)[\\-\\.\\/](\\d+)\\s+(\\d+):(\\d+):(\\d+)(\\.\\d+)?$/));\n\n\treturn timegm($6, $5, $4, $3, $month{uc $2}, $1) + ($7 ? $7 : 0)\n\t\tif (($type == SQL_TIMESTAMP) &&\n\t\t\t($value=~/^(\\d+)[\\-\\.\\/](\\w+)[\\-\\.\\/](\\d+)\\s+(\\d+):(\\d+):(\\d+)(\\.\\d+)?$/));\n\n\treturn (($1 ? (($1 eq '-') ? -1 : 1) : 1) *\n\t\t(($3 ? ($3 * 3600) : 0) + ($5 ? ($5 * 60) : 0) + $6 + ($7 ? $7 : 0)))\n\t\tif ((($type == SQL_INTERVAL_HR2SEC) || ($type == SQL_TIME)) &&\n\t\t\t($value=~/^([\\-\\+])?((\\d+):)?((\\d+):)?(\\d+)(\\.\\d+)?$/));\n\n\treturn undef; \n}\n\nsub test_predicate {\n\tmy ($rowmap, $pctype, $pc, $predop, $predval, $rownum) = @_;\n\tfor (my $i = 0; $i <= $#$pc; $i++) {\n\t\t$$rowmap{$i} = -1, next\n\t\t\tif ((($pctype == SQL_CHAR) || ($pctype == SQL_VARCHAR)) &&\n\t\t\t\t(eval \"\\'$$pc[$i]\\' $strpredops{$predop} \\'$predval\\'\"));\n\n\t\t$$rowmap{$i} = -1, next\n\t\t\tif (($numtype{$pctype}) &&\n\t\t\t\t(eval \"$$pc[$i] $numpredops{$predop} $predval\"));\n\n\t\tif ($timetype{$pctype}) {\n\t\t\tmy ($col, $operand) = (convert_time($$pc[$i], $pctype), convert_time($predval, $pctype));\n\t\t\t$$rowmap{$i} = -1\n\t\t\t\tif (eval \"$col $numpredops{$predop} $operand\");\n\t\t}\n\t}\n\treturn 1;\n}\n\nsub eval_predicate {\n\tmy ($predcol, $predop, $predval, $types, $data, $parms, $is_ary,\n\t\t$is_ref, $maxary) = @_;\n\tmy %rowmap = ();\n\tmy $pc = $$data[$predcol];\n\tmy $pctype = $$types[$predcol];\n\tmy ($k, $p);\n\n\t$predval=~s/^'(.+)'$/$1/,\t\n\ttest_predicate(\\%rowmap, $pctype, $pc, $predop, $predval, -1),\n\treturn %rowmap\n\t\tif ($predval ne '?');\n\tmy $parmnum = $#$parms;\n\tfor ($k = 0; $k < $maxary; $k++) {\n\t\t$p = $$parms[$parmnum];\n\t\t$p = (($is_ary) ? $$p[$k] : $$p) if ($is_ref);\n\t\ttest_predicate(\\%rowmap, $pctype, $pc, $predop, $p, $k);\n\t}\n\treturn %rowmap;\n}\n\n\nsub fetch {\n\tmy($sth) = @_;\n\n\tif ($sth->{chart_colormap}) {\n\t\tmy $i = uc $sth->{chart_colormap};\n\t\tmy $table = $DBD::Chart::charts{COLORMAP};\n\t\tmy $ary = $table->{data};\n\t\tmy ($col1, $col2, $col3, $col4) = ($$ary[0], $$ary[1], $$ary[2], $$ary[3]) ;\n\t\tif ($sth->{chart_1_color}) {\n\t\t\tmy $color;\n\t\t\tforeach $color (@$col1) {\n\t\t\t\tlast if ($i eq uc $color);\n\t\t\t}\n\t\t\treturn '0E0' if ($i ne uc $color);\n\t\t\t$sth->{chart_colormap} = undef;\n\t\t}\n\n\t\tmy @row = ($$col1[$i], $$col2[$i], $$col3[$i], $$col4[$i]);\n\t\t$sth->{chart_colormap}++;\n\t\treturn $sth->_set_fbav(\\@row);\n\t}\n\tmy $buf = $sth->{chart_image};\n\treturn 0 if (! $buf);\n\tmy @row = ($buf);\n\tpush(@row, $sth->{chart_imagemap})\n\t\tif ($sth->{NUM_OF_FIELDS} > 1);\n\treturn $sth->_set_fbav(\\@row);\n}\n\nsub finish {\n\tmy($sth) = @_;\n}\n\nsub bind_param {\n\tmy ($sth, $pNum, $val, $attr) = @_;\n\treturn $sth->DBI::set_err(-1, 'Statement does not contain placeholders.','S1000')\n\t\tunless $sth->{NUM_OF_PARAMS};\n\n\tmy $params = $sth->{chart_params};\n\t$params = [ ],\n\t$sth->{chart_params} = $params\n\t\tunless defined($params);\n\n\t$$params[$pNum-1] = $val;\n\t1;\n}\n*chart_bind_param_array = \\&bind_param;\n*bind_param_array = \\&bind_param;\n\nsub chart_bind_param_status {\n\tmy ($sth, $stsary) = @_;\n\n\treturn $sth->DBI::set_err(-1, 'bind_param_status () requires arrayref or hashref parameter.', 'S1000')\n\t\tif ((ref $stsary ne 'ARRAY') && (ref $stsary ne 'HASH'));\n\n\t$sth->{chart_paramsts} = $stsary;\n\treturn 1;\n}\n*bind_param_status = \\&chart_bind_param_status;\n\nsub bind_param_inout {\n\tmy ($sth, $pNum, $val, $maxlen, $attr) = @_;\n\treturn bind_param($sth, $pNum, $val, $attr);\n}\nsub get_ext_type_info {\n\tmy ($sth, $srcsth, $item, $entry) = @_;\n\n\tmy $t;\n\tif (ref $srcsth eq 'DBIx::Chart::SthContainer') {\n\t\t$t = $srcsth->get_metadata($item);\n\t\treturn $t if $t;\n\t}\n\telse {\n\t\treturn $srcsth->{$item}\n\t\t\tif eval { $t = $srcsth->{$item}; };\n\t}\n\treturn undef\n\t\tunless (ref $sth->{chart_type_map} &&\n\t\t\t(ref $sth->{chart_type_map} eq 'ARRAY') &&\n\t\t\t$sth->{chart_type_map}->[$entry] &&\n\t\t\tref $sth->{chart_type_map}->[$entry] &&\n\t\t\t\t(($entry == 0) &&\n\t\t\t\t((ref $sth->{chart_type_map}->[$entry] eq 'HASH') &&\n\t\t\t\t$sth->{chart_type_map}->[$entry]->{$item}) ||\n\t\t\t((ref $sth->{chart_type_map}->[$entry] eq 'ARRAY') &&\n\t\t\t$sth->{chart_type_map}->[$entry]->[0]->{$item})));\n\tmy $srcary = (($entry == 0) && (ref $sth->{chart_type_map}->[$entry] eq 'HASH')) ?\n\t\t$sth->{chart_type_map} : $sth->{chart_type_map}->[$entry];\n\tmy @outary = ();\n\tpush @outary, $_->{$item}\n\t\tforeach (@$srcary);\n\treturn \\@outary;\n}\n\nsub STORE {\n\tmy ($sth, $attr, $val) = @_;\n\treturn $sth->SUPER::STORE($attr, $val) unless ($attr=~/^chart_/) ;\n\t$sth->{$attr} = $val;\n\treturn 1;\n}\n\nsub FETCH {\n\tmy($sth, $attr) = @_;\n\treturn $sth->{$attr} if ($attr =~ /^chart_/);\n\treturn $sth->SUPER::FETCH($attr);\n}\n\nsub DESTROY { undef }\n\n1;\n}",
      "file" : "/var/tmp/arv_Gqz_Te/DBD-Chart-0.82/Chart.pm",
      "package" : "DBD::Chart"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\npackage DBD::Chart::Plot;\n\nuse GD;\nuse GD::Text;\nuse GD::Text::Align;\nuse Time::Local;\nuse GD qw(gdBrushed gdSmallFont gdTinyFont gdMediumBoldFont);\n\n$DBD::Chart::Plot::VERSION = '0.81';\n\nour @clrlist = qw(\n\twhite lgray\tgray dgray black lblue blue dblue gold lyellow\t\n\tyellow\tdyellow\tlgreen\tgreen dgreen lred red dred lpurple\t\n\tpurple dpurple lorange orange pink dpink marine\tcyan\t\n\tlbrown dbrown );\nour %colors = (\n\twhite\t=> [255,255,255], \n\tlgray\t=> [191,191,191], \n\tgray\t=> [127,127,127],\n\tdgray\t=> [63,63,63],\n\tblack\t=> [0,0,0],\n\tlblue\t=> [0,0,255], \n\tblue\t=> [0,0,191],\n\tdblue\t=> [0,0,127], \n\tgold\t=> [255,215,0],\n\tlyellow\t=> [255,255,0], \n\tyellow\t=> [191,191,0], \n\tdyellow\t=> [127,127,0],\n\tlgreen\t=> [0,255,0], \n\tgreen\t=> [0,191,0], \n\tdgreen\t=> [0,127,0],\n\tlred\t=> [255,0,0], \n\tred\t\t=> [191,0,0],\n\tdred\t=> [127,0,0],\n\tlpurple\t=> [255,0,255], \n\tpurple\t=> [191,0,191],\n\tdpurple\t=> [127,0,127],\n\tlorange\t=> [255,183,0], \n\torange\t=> [255,127,0],\n\tpink\t=> [255,183,193], \n\tdpink\t=> [255,105,180],\n\tmarine\t=> [127,127,255], \n\tcyan\t=> [0,255,255],\n\tlbrown\t=> [210,180,140], \n\tdbrown\t=> [165,42,42],\n\ttransparent => [1,1,1]\n);\nour %valid_shapes = (\n'fillsquare', 1,\n'opensquare', 2,\n'horizcross', 3,\n'diagcross', 4,\n'filldiamond', 5,\n'opendiamond', 6,\n'fillcircle', 7,\n'opencircle', 8,\n'icon', 9,\n'dot', 10,\n'null', 11);\n\nour @logsteps = (0, log(2)/log(10), log(3)/log(10), log(4)/log(10), \n\tlog(5)/log(10), 1.0);\nour @polyverts = ( \n[ 1*2, 2*2,\t3*2, 4*2 ],\t\n[ 0*2, 1*2, 4*2, 5*2 ],\t\n[ 4*2, 3*2, 6*2, 5*2 ]\t\n);\nour @vert2lines = (\n1*2, 4*2, \t\n0*2, 1*2,\t\n0*2, 5*2,\t\n4*2, 5*2,\t\n1*2, 2*2,\t\n2*2, 3*2,\t\n3*2, 4*2,   \n3*2, 6*2,   \n5*2, 6*2,   \n);\n\nour @axesverts = (\n\t0*2, 1*2,\t\n\t1*2, 3*2,\n\t3*2, 2*2,\n\t2*2, 0*2,\n\t\t\n\t3*2, 6*2,\t\n\t6*2, 5*2,\t\n\t5*2, 1*2,\t\n\n\t9*2, 10*2,\t\n\t10*2, 7*2,\t\n\t\n\t9*2, 8*2,\t\n\t7*2, 8*2,\t\n);\nour ($sfw,$sfh) = (gdSmallFont->width, gdSmallFont->height);\nour ($tfw,$tfh) = (gdTinyFont->width, gdTinyFont->height);\n\nour %valid_attr = qw(\n\twidth 1\n\theight 1\n\tgenMap 1\n\tmapType 1\n\tmapURL 1\n\tmapScript 1\n\thorizMargin 1\n\tvertMargin 1\n\txAxisLabel 1\n\tyAxisLabel 1\n\tzAxisLabel 1\n\txLog 1\n\tyLog 1\n\tzLog 1\n\ttitle 1\n\tsignature 1\n\tlegend 1\n\thorizGrid 1\n\tvertGrid 1\n\txAxisVert 1\n\tkeepOrigin 1\n\tbgColor 1\n\tthreed 1\n\ticons 1\n\tsymDomain 1\n\ttimeDomain 1\n\tgridColor 1\n\ttextColor 1\n\tfont 1\n\tlogo 1\n\ttimeRange 1\n\tmapModifier 1\n\tborder 1\n);\nour @lines = ( \n[ 0*2, 4*2,\t5*2, 1*2 ],\t\n[ 0*2, 1*2, 3*2, 2*2 ],\t\n[ 1*2, 5*2, 7*2, 3*2 ]\t\n);\n\nour %gdfontmap = (\n5, gdTinyFont,\n6, gdSmallFont,\n7, gdMediumBoldFont,\n8, gdLargeFont,\n9, gdGiantFont\n);\n\nour %fontMap = ();\n\nour %month = ( 'JAN', 0, 'FEB', 1, 'MAR', 2, 'APR', 3, 'MAY', 4, 'JUN', 5, \n'JUL', 6, 'AUG', 7, 'SEP', 8, 'OCT', 9, 'NOV', 10, 'DEC', 11);\nour @monthmap = qw( JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC );\nour %escapes = ();\nfor (0..255) {\n    $escapes{chr($_)} = sprintf(\"%%%02X\", $_);\n}\n\nuse constant LINE => 1;\nuse constant POINT => 2;\nuse constant AREA => 4;\nuse constant BOX => 8;\nuse constant PIE => 16;\nuse constant HISTO => 32;\nuse constant BAR => 64;\nuse constant CANDLE => 128;\nuse constant GANTT => 256;\nuse constant QUADTREE => 512;\n\nour %typemap = ( 'BAR', BAR, 'HISTO', HISTO, 'FILL', AREA, \n\t'CANDLE', CANDLE, 'BOX', BOX, 'GANTT', GANTT, 'QUADTREE', QUADTREE );\n\nsub new {\n    my $class = shift;\n    my $obj = {};\n    bless $obj, $class;\n    $obj->init (@_);\n\n    return $obj;\n}\nsub init {\n\tmy ($obj, $w, $h, $colormap) = @_;\n\n\t$w = 400 unless $w;\n\t$h = 300 unless $h;\n\tmy $img = new GD::Image($w, $h);\n\tif ($colormap) {\n\t\tforeach my $color (keys(%$colormap)) {\n\t\t\t$colors{lc $color} = $$colormap{$color};\n\t\t}\n\t}\n\t\n\tmy $white = $img->colorAllocate(@{$colors{white}});\n\tmy $black = $img->colorAllocate(@{$colors{black}}); \n\n\t$obj->{width} = $w;\n\t$obj->{height} = $h;\n\t$obj->{img} = $img;\n\n  \t$obj->{genMap} = undef;\t\n  \t$obj->{imgMap} = '';\t\t\n  \t$obj->{mapType} = 'HTML';\t\n  \t$obj->{mapURL} = '';\t\t\n  \t$obj->{mapScript} = '';\t\n  \t\t\n\t$obj->{horizMargin} = 50;\n\t$obj->{vertMargin} = 70;\n\n\t$obj->{data} = [ ];\n\t$obj->{props} = [ ];\n\t$obj->{plotCnt} = 0;\n\t$obj->{plotTypes} = 0;\n\n\t$obj->{xl} = undef;\n\t$obj->{xh} = undef;\n\t$obj->{yl} = undef;\n\t$obj->{yh} = undef;\n\t$obj->{zl} = undef;\n\t$obj->{zh} = undef;\n\t$obj->{xscale} = 0;\n\t$obj->{yscale} = 0;\n\t$obj->{zscale} = 0;\n\t$obj->{horizEdge} = 0;\n\t$obj->{vertEdge} = 0;\n\t$obj->{horizStep} = 0;\n\t$obj->{vertStep} = 0;\n\t$obj->{Xcard} = 0;\t\t\n\t$obj->{Zcard} = 0;\n\t$obj->{plotWidth} = 0;\t\n\t$obj->{plotHeight} = 0;\n\t$obj->{plotDepth} = 0;\n\t$obj->{brushWidth} = 0; \n\t$obj->{brushDepth} = 0;\n\t$obj->{rangeSum} = 0;\t\n\t$obj->{haveScale} = 0;\t\n\t$obj->{domainValues} = { };\t\n\t$obj->{boxCount} = 0;\t\n\t$obj->{barCount} = 0;\t\n\t$obj->{xMaxLen} = 0;\t\n\t$obj->{yMaxLen} = 0;\t\n\t$obj->{zMaxLen} = 0;\t\n\n\t$obj->{xAxisLabel} = '';\n\t$obj->{yAxisLabel} = '';\n\t$obj->{zAxisLabel} = '';\n\n\t$obj->{xLog} = 0;\t\t\n\t$obj->{yLog} = 0;\n\t$obj->{zLog} = 0;\n\n\t$obj->{title} = '';\n\t$obj->{signature} = '';\n\t$obj->{legend} = 0; \t\n\t$obj->{horizGrid} = 0;\t\n\t$obj->{vertGrid} = 0;\t\n\t$obj->{xAxisVert} = 0;\t\n\t$obj->{errmsg} = '';\t\n\t$obj->{keepOrigin} = 0; \n\t$obj->{threed} = 0;\t\t\n\t$obj->{logo} = undef;\n\t\t\n\t$obj->{icons} = [ ];\t\n\t\t\n\t$obj->{symDomain} = 0;\t\n\t$obj->{timeDomain} = undef; \n\t$obj->{timeRange} = undef; \n\n\t$obj->{white} = $white;\n\t$obj->{black} = $black; \n\t$obj->{transparent} = $img->colorAllocate(@{$colors{'transparent'}});\n\n\t$obj->{bgColor} = $white; \n\t$obj->{gridColor} = $black;\n\t$obj->{textColor} = $black;\n\t$obj->{border} = 1;\n\n\t$obj->{mapModifier} = undef;\n\t\n\t$obj->{font} = 'gd';\n\n\t$obj->{_legends} = [ ];\n\n\t$img->transparent($obj->{transparent});\n\t$img->interlaced('true');\n}\n\nsub numerically { $a <=> $b }\n\nsub convert_temporal {\n\tmy ($value, $format) = @_;\n\tmy $t;\n\t$t = timegm(0, 0, 0, $3, $2 - 1, $1),\n\t$t -= ($t%86400), \n\treturn $t\n\t\tif (($format eq 'YYYY-MM-DD') &&\n\t\t\t($value=~/^(\\d+)[\\-\\.\\/](\\d+)[\\-\\.\\/](\\d+)$/));\n\n\t$t = timegm(0, 0, 0, $3, $month{uc $2}, $1),\n\t$t -= ($t%86400), \n\treturn $t\n\t\tif (($format eq 'YYYY-MM-DD') &&\n\t\t\t($value=~/^(\\d+)[\\-\\.\\/](\\w+)[\\-\\.\\/](\\d+)$/) &&\n\t\t\tdefined($month{uc $2}));\n\n\treturn timegm($6, $5, $4, $3, $2 - 1, $1) + ($7 ? $7 : 0)\n\t\tif (($format eq 'YYYY-MM-DD HH:MM:SS') &&\n\t\t\t($value=~/^(\\d+)[\\-\\.\\/](\\d+)[\\-\\.\\/](\\d+)\\s+(\\d+):(\\d+):(\\d+)(\\.\\d+)?$/));\n\n\treturn timegm($6, $5, $4, $3, $month{uc $2}, $1) + ($7 ? $7 : 0)\n\t\tif (($format eq 'YYYY-MM-DD HH:MM:SS') &&\n\t\t\t($value=~/^(\\d+)[\\-\\.\\/](\\w+)[\\-\\.\\/](\\d+)\\s+(\\d+):(\\d+):(\\d+)(\\.\\d+)?$/) &&\n\t\t\t(defined($month{uc $2})));\n\n\treturn (($1 ? (($1 eq '-') ? -1 : 1) : 1) * (($3 ? ($3 * 3600) : 0) + ($5 ? ($5 * 60) : 0) + \n\t\t$6 + ($7 ? $7 : 0)))\n\t\tif ((($format eq '+HH:MM:SS') || ($format eq 'HH:MM:SS')) && \n\t\t\t($value=~/^([\\-\\+])?((\\d+):)?((\\d+):)?(\\d+)(\\.\\d+)?$/));\n\n\treturn undef; \n}\nsub restore_temporal {\n\tmy ($value, $format) = @_;\n\n\tmy ($sign, $subsec, $sec, $min, $hour, $mday, $mon, $yr, $wday, $yday, $isdst);\n\t$sign = ($value < 0);\n\t$value = abs($value);\n\tif (($format eq '+HH:MM:SS') || ($format eq 'HH:MM:SS')) {\n\t\t$hour = int($value/3600);\n\t\t$min = int(($value%3600)/60);\n\t\t$sec = int($value%60);\n\t\t$hour = \"0$hour\" if ($hour < 10);\n\t\t$min = \"0$min\" if ($min < 10);\n\t\t$sec = \"0$sec\" if ($sec < 10);\n\t\t$subsec = int(($value - int($value)) * 100);\n\t\treturn ($sign ? '-' : '') . \"$hour:$min:$sec\" . \n\t\t\t($subsec ? \".$subsec\" : '');\n\t}\n\n\t($sec, $min, $hour, $mday, $mon, $yr, $wday, $yday, $isdst) = gmtime($value);\n\t$yr += 1900;\n\t$mon++;\n\t$mon = \"0$mon\" if ($mon < 10);\n\t$min = \"0$min\" if ($min < 10);\n\t$sec = \"0$sec\" if ($sec < 10);\n\t$mday = \"0$mday\" if ($mday < 10);\n\t\n\treturn \"$yr\\-$mon\\-$mday\"\n\t\tif ($format eq 'YYYY-MM-DD');\n\n\t$mon = $monthmap[$mon-1],\n\treturn \"$yr\\-$mon\\-$mday\"\n\t\tif ($format eq 'YYYY-MMM-DD');\n\n\treturn \"$yr\\-$mon\\-$mday $hour:$min:$sec\"\n\t\tif ($format eq 'YYYY-MM-DD HH:MM:SS');\n\n\t$mon = $monthmap[$mon-1],\n\treturn \"$yr\\-$mon\\-$mday $hour:$min:$sec\"\n\t\tif ($format eq 'YYYY-MMM-DD HH:MM:SS');\n\n\treturn undef; \n}\n\nsub set3DBarPoints {\n\tmy ($obj, $xary, @ranges) = @_;\n\tmy $type = pop @ranges;\n\tmy $props = pop @ranges;\n\tmy ($yary, $zary);\n\tmy ($ymin, $ymax) = ($obj->{yl}, $obj->{yh});\n\tmy $ymaxlen = 0;\n\tmy $hasZaxis = ($obj->{zAxisLabel});\n\t$zary = pop @ranges\n\t\tif $hasZaxis;\n\t\n\tmy @zs = ();\n\tmy %zhash = ();\n\tmy %xhash = ();\n\tmy @xs = ();\n\tmy @xvals = @$xary;\n\tmy $ys;\n\tmy ($xval, $zval) = (0,1);\n\tmy $i = 0;\n\tmy ($x, $y, $z);\n\tmy $maxlen = 0;\n\tforeach (0..$#xvals) {\n\t\t$xvals[$_] = convert_temporal($xvals[$_], $obj->{timeDomain})\n\t\t\tif $obj->{timeDomain};\n\t\tnext if $xhash{$xvals[$_]};\n\t\tpush(@xs, $xvals[$_]);\n\t\t$xhash{$xvals[$_]} = 1;\n\t\t$maxlen = length($xvals[$_]) if (length($xvals[$_]) > $maxlen);\n\t}\n\t$obj->{xMaxLen} = $maxlen;\n\n\tforeach (@ranges) {\n\t\t$obj->{errmsg} = 'Unbalanced dataset.',\n\t\treturn undef\n\t\t\tif ($#$xary != $#$_);\n\t}\n\n\tif ($hasZaxis) {\n\t\t$obj->{errmsg} = 'Incompatible plot types.', return undef\n\t\t\tif $obj->{plotTypes};\n\n\t\t$obj->{errmsg} = 'Unbalanced dataset.',\n\t\treturn undef\n\t\t\tif ($#$xary != $#$zary);\n\t\t$maxlen = 0;\n\t\tforeach $z (0..$#$zary) {\n\t\t\t$zval = $$zary[$z];\n\t\t\tpush(@zs, $zval),\n\t\t\t$zhash{$zval} = { }\n\t\t\t\tunless $zhash{$zval};\n\t\t\t$zhash{$zval}->{$xvals[$z]} = [ 0 ] unless $zhash{$zval}->{$xvals[$z]};\n\t\t\t$ys = $zhash{$zval}->{$xvals[$z]};\n\t\t\tforeach (@ranges) {\n\t\t\t\t$ymaxlen = length($$_[$z]) if (length($$_[$z]) > $ymaxlen);\n\t\t\t\tpush(@$ys, $$_[$z]);\n\t\t\t}\n\t\t\t$maxlen = length($zval) if (length($zval) > $maxlen);\n\t\t}\n\t\t$obj->{zMaxLen} = $maxlen;\n\t}\n\telse {\n\t\t$obj->{errmsg} = 'Incompatible plot types.', return undef\n\t\t\tunless (($obj->{plotTypes} == 0) || ($obj->{plotTypes} & $type));\n\t\tpush(@zs, 1);\n\t\t$zhash{1} = { };\n\t\tforeach $x (0..$#$xary) {\n\t\t\t$zhash{1}->{$xvals[$x]} = [ 0 ] unless $zhash{1}->{$xvals[$x]};\n\t\t\t$ys = $zhash{1}->{$xvals[$x]};\n\t\t\tforeach (@ranges) {\n\t\t\t\t$ymaxlen = length($$_[$x]) if (length($$_[$x]) > $ymaxlen);\n\t\t\t\tpush(@$ys, $$_[$x]);\n\t\t\t}\n\t\t}\n\t\t$obj->{zMaxLen} = 0;\n\t}\n\t\n\t@xs = sort numerically @xs\n\t\tif $obj->{timeDomain};\n\n\t$obj->{plotTypes} |= $type;\n\t$obj->{zValues} = \\@zs;\n\t$obj->{xValues} = \\@xs;\n\tmy $zCard = scalar @zs;\t\n\tmy $xCard = scalar @xs;\n\tmy ($znum, $xnum) = (0,0,0);\n\tmy @ary = ();\n\tmy $lasty;\n\tmy $j;\n\tfor (my $z = $zCard; $z > 0; $z--) {\n\t\tforeach $x (1..$xCard) {\n\t\t\t$ys = $zhash{$zs[$z-1]}->{$xs[$x-1]};\n\t\t\tif (($$ys[1] < 0) && (($#$ys == 1) || ($$ys[$#$ys] >= 0))) {\n\t\t\t\t$i = 1;\n\t\t\t\t$$ys[$i-1] = $$ys[$i], \n\t\t\t\t$i++ \n\t\t\t\t\twhile (($i <= $#$ys) && ($$ys[$i] < 0));\n\t\t\t\t$$ys[$i-1] = 0;\n\t\t\t}\n\t\t\t$lasty = 0;\n\t\t\tmy $starts = ($$ys[0] == 0) ? 1 : 0;\n\t\t\tforeach $i ($starts..$#$ys) {\n\t\t\t\t$y = $$ys[$i];\n\t\t\t\t$y = convert_temporal($y, $obj->{timeRange}) \n\t\t\t\t\tif $obj->{timeRange};\n\n\t\t\t\t$obj->{errmsg} = \"Non-numeric range value $y.\",\n\t\t\t\treturn undef\n\t\t\t\t\tunless ($obj->{timeRange} || \n\t\t\t\t\t\t($y=~/^[+-]?\\.?\\d\\d*(\\.\\d*)?([Ee][+-]?\\d+)?$/));\n\t\t\n\t\t\t\t$obj->{errmsg} = \n\t\t\t\t\t'Negative value supplied for logarithmic axis.',\n\t\t\t\treturn undef\n\t\t\t\t\tif (($obj->{yLog}) && ($y <= 0));\n\t\t\t\t$lasty = 0 if (($lasty < 0) && ($y >= 0));\n\n\t\t\t\t$y += $lasty;\n\t\t\t\t$y = log($y)/log(10) if ($obj->{yLog});\n\t\t\t\t$$ys[$i] = $y;\n\t\t\t\t$lasty = $y;\n\n\t\t\t\t$ymin = $y unless (defined($ymin) && ($ymin <= $y));\n\t\t\t\t$ymax = $y unless (defined($ymax) && ($ymax >= $y));\n\t\t\t}\n\t\t\tpush(@ary, $x, $ys, $z);\n\t\t}\n\t}\n\tpush(@{$obj->{data}}, \\@ary);\n\tpush(@{$obj->{props}}, $props);\n\t$obj->{xl} = 1;\n\t$obj->{xh} = $xCard;\n\t$obj->{yl} = $ymin;\n\t$obj->{yh} = $ymax;\n\t$obj->{zl} = 1;\n\t$obj->{zh} = $zCard;\n\t$obj->{Xcard} = $xCard;\n\t$obj->{Zcard} = $zCard;\n\t$obj->{haveScale} = 0;\t\n\t$obj->{barCount}++;\n\t$obj->{symDomain} = 0;\t\n\t$obj->{yMaxlen} = $ymaxlen;\n\treturn 1;\n}\n\nsub set2DBarPoints {\n\tmy ($obj, $xary, @ranges) = @_;\n\n\tmy $type = pop @ranges;\n\tmy $props = pop @ranges;\n\tmy $lwidth = 2;\n\t$lwidth = $1 if ($props=~/\\bwidth:(\\d+)/i);\n\tmy $unanchored = ($props=~/\\bfloat\\b/i);\n\t\n\tforeach (@ranges) {\n\t\t$obj->{errmsg} = 'Unbalanced dataset.',\n\t\treturn undef\n\t\t\tif ($#$xary != $#$_);\n\t}\n\t$obj->{errmsg} = 'Candlesticks require a minimum and maximum range value.', \n\treturn undef\n\t\tunless (($type != CANDLE) || ($#ranges > 0));\n\n\t$obj->{errmsg} = 'Unanchored charts require a minimum and maximum range value.', \n\treturn undef\n\t\tif ($unanchored && ($#ranges <= 0));\n\n\t$obj->{errmsg} = 'Incompatible plot types.', return undef\n\t\tif ((($type == HISTO) && $obj->{plotTypes} && ($obj->{plotTypes}^HISTO)) ||\n\t\t\t(($type != HISTO) && ($obj->{plotTypes} & HISTO)));\n\n\t$obj->{errmsg} = 'Incompatible plot domain types.', return undef\n\t\tif (($obj->{plotTypes} & (BOX|PIE|GANTT|QUADTREE)) ||\n\t\t\t(($obj->{plotTypes} & (LINE|POINT|AREA)) && (! $obj->{symDomain})));\n\n\t$obj->{symDomain} = 1;\n\t$obj->{plotTypes} |= $type;\n\t\n\tmy ($x, $y) = (0,0,0,0);\n\tmy $ty = 0;\n\tmy ($ymin, $ymax) = ($obj->{yl}, $obj->{yh});\n\t$ymin = 1E38 unless $ymin;\n\t$ymax = -1E38 unless $ymax;\n\tmy $domVals = $obj->{domainValues};\n\tmy @data = ();\n\tmy $idx = 0;\n\tmy $i;\n\tfor ($i = 0; $i <= $#$xary; $i++) {\n\t\tnext unless defined($$xary[$i]);\n\t\tnext if (($type == CANDLE) && (! defined($ranges[0]->[$i])));\n\n\t\t$x = $$xary[$i];\n\t\t$x = convert_temporal($x, $obj->{timeDomain}) if $obj->{timeDomain};\n\n\t\t$domVals->{$x} = defined($domVals) ? scalar(keys(%$domVals)) : 0\n\t\t\tunless defined($domVals->{$x});\n\t\t$idx = $domVals->{$x} * 3;\n\t\t$data[$idx++] = $x;\n\t\t$data[$idx] = [ ];\n\t\tmy $yary = $data[$idx];\n\n\t\t$obj->{xMaxLen} = length($x) \n\t\t\tunless ($obj->{xMaxLen} && ($obj->{xMaxLen} >= length($x)));\n\t\tmy $lasty = 0;\n\t\tpush(@$yary, undef) unless (($type == CANDLE) || $unanchored);\n\t\tmy $first_valid = 0;\n\t\tforeach (@ranges) {\n\t\t\t$y = $_->[$i];\n\t\t\tpush(@$yary, undef), next unless defined($y);\n\t\t\t\n\t\t\t$y = convert_temporal($y, $obj->{timeRange})\n\t\t\t\tif $obj->{timeRange};\n\t\t\t$first_valid++;\n\n\t\t\t$obj->{errmsg} = 'Non-numeric range value ' . $y . '.',\n\t\t\treturn undef\n\t\t\t\tunless ($obj->{timeRange} || \n\t\t\t\t\t($y=~/^[+-]?\\d+\\.?\\d*([Ee][+-]?\\d+)?$/));\n\n\t\t\t$obj->{errmsg} = 'Invalid value supplied for logarithmic axis.',\n\t\t\treturn undef\n\t\t\t\tif ($obj->{yLog} && ($y <= 0));\n\t\t\tpush(@$yary, 0), $lasty = 0\n\t\t\t\tif (($lasty < 0) && ($y >= 0) && (! $unanchored));\n\t\t\t$y += $lasty;\n\t\t\tpush(@$yary, ($obj->{yLog} ? log($y)/log(10) : $y));\n\t\t\t$lasty = $y unless (($unanchored || ($type == CANDLE)) && ($first_valid == 1));\n\t\t\t$ymin = $y unless (defined($ymin) && ($y >= $ymin));\n\t\t\t$ymax = $y unless (defined($ymax) && ($y <= $ymax));\n\t\t}\n\t\tunless ($unanchored || ($type == CANDLE)) {\n\t\t\tif (($$yary[1] < 0) && (($#$yary == 1) || ($$yary[2] > $$yary[1]))) {\n\t\t\t\tpush @$yary, 0\n\t\t\t\t\tif ($#$yary == 1);\n\n\t\t\t\tshift @$yary;\t\n\t\t\t\tnext;\n\t\t\t}\n\t\t\t$$yary[0] = 0;\n\t\t}\n\t}\n\tpush(@{$obj->{data}}, \\@data);\n\tpush(@{$obj->{props}}, $props);\n\t$obj->{yl} = $ymin;\n\t$obj->{yh} = $ymax;\n\t$obj->{xl} = 1;\n\t$obj->{xh} = scalar(keys(%$domVals));\n\t\n\t$obj->{haveScale} = 0;\t\n\t$obj->{barCount}++;\n\t$obj->{brushWidth} = $lwidth\n\t\tif ($type == CANDLE);\n\n\treturn 1;\n}\n\nsub setPiePoints {\n\tmy ($obj, $xary, $yary, $props) = @_;\n\t\t\n\tmy @ary = ();\n\n\t$obj->{errmsg} = 'Incompatible plot types.', return undef\n\t\tif $obj->{plotTypes};\n\n\t$obj->{errmsg} = 'Unbalanced dataset.',\n\treturn undef\n\t\tif ($#$xary != $#$yary);\n\t\n\tmy $xtotal = 0;\n\tmy ($i, $y);\n\tforeach (0..$#$xary) {\n\t\tnext unless (defined($$xary[$_]) && defined($$yary[$_]));\n\t\t$y = $$yary[$_];\n\t\t$y = convert_temporal($y, $obj->{timeRange}) if $obj->{timeRange};\n\n\t\t$obj->{errmsg} = 'Non-numeric range value ' . $y . '.',\n\t\treturn undef\n\t\t\tunless ($obj->{timeRange} || \n\t\t\t\t($y=~/^[+-]?\\.?\\d+\\.?\\d*([Ee][+-]?\\d+)?$/));\n\n\t\t$obj->{errmsg} = \n\t\t\t'Negative range values not permitted for piecharts.',\n\t\treturn undef\n\t\t\tif ($y < 0);\n\n\t\t$xtotal += $y;\n\t\tpush(@ary, $$xary[$_], $y);\n\t}\n\t$obj->{plotTypes} |= PIE;\n\tpush(@{$obj->{data}}, \\@ary);\n\tpush(@{$obj->{props}}, $props);\n\t$obj->{rangeSum} = $xtotal;\n\t$obj->{haveScale} = 0; \n\treturn 1;\n}\n\nsub setBoxPoints {\n\tmy ($obj, $xary, $props) = @_;\n\n\t$obj->{errmsg} = 'Incompatible plot types.', return undef\n\t\tif ($obj->{plotTypes} & (PIE|HISTO|BAR|CANDLE|GANTT|QUADTREE));\n\t\t\n\t$obj->{errmsg} = 'Boxchart not compatible with 3-D plot types.', return undef\n\t\tif ($obj->{threed} || $obj->{zAxis});\n\t\t\n\t$obj->{errmsg} = 'Boxchart not compatible with symbolic domains.', return undef\n\t\tif $obj->{symDomain};\n\t\t\n\tmy @data = ();\n\tforeach (@$xary) {\n\t\tnext unless defined($_);\n\t\t$_ = convert_temporal($_, $obj->{timeDomain}) if $obj->{timeDomain};\n\t\t$obj->{errmsg} = 'Non-numeric value ' . $_ . '.',\n\t\treturn undef\n\t\t\tunless ($_=~/^[+-]?\\d+\\.?\\d*([Ee][+-]?\\d+)?$/);\n\t\tpush(@data, $_);\n\t}\n\t@data = sort numerically @data;\n\t$obj->{xl} = $data[0] \n\t\tunless (defined($obj->{xl}) && ($data[0] >= $obj->{xl}));\n\t$obj->{xh} = $data[$#data] \n\t\tunless (defined($obj->{xh}) && ($data[$#data] <= $obj->{xh}));\n\tpush(@{$obj->{data}}, \\@data);\n\tpush(@{$obj->{props}}, $props);\n\t$obj->{boxCount}++;\n\t$obj->{plotTypes} |= BOX;\n\t$obj->{numRanges} = 0;\n\t$obj->{haveScale} = 0; \n\treturn 1;\n}\nsub setPoints {\n\tmy ($obj, $xary, @ranges) = @_;\n\tmy $props = pop @ranges;\n\treturn $obj->set3DBarPoints($xary, @ranges, $props, $typemap{uc $1})\n\t\tif (($props=~/\\b(bar|histo)\\b/i) && \n\t\t\t($obj->{zAxisLabel} || $obj->{threed}));\n\n\treturn $obj->set2DBarPoints($xary, @ranges, $props, $typemap{uc $1})\n\t\tif ($props=~/\\b(bar|histo|candle)\\b/i);\n\n\treturn $obj->setPiePoints($xary, @ranges, $props)\n\t\tif ($props=~/\\bpie\\b/i);\n\n\treturn $obj->setBoxPoints($xary, @ranges, $props)\n\t\tif ($props=~/\\bbox\\b/i);\n\n\treturn $obj->setGanttPoints($xary, @ranges, $props)\n\t\tif ($props=~/\\bgantt\\b/i);\n\n\treturn $obj->setQuadPoints($xary, @ranges, $props)\n\t\tif ($props=~/\\bquadtree\\b/i);\n\t$obj->{errmsg} = 'Incompatible plot types.', return undef\n\t\tif ($obj->{plotTypes} & (PIE|HISTO|GANTT|QUADTREE));\n\t\t\n\t$obj->{errmsg} = \n\t\t'Line/point/area graph not compatible with 3-D plot types.', return undef\n\t\tif ($obj->{threed} || $obj->{zAxis});\n\n\tmy ($x, $y, $yary) = (0,0, [ ]);\n\tmy ($xmin, $xmax, $ymin, $ymax) = \n\t\t($obj->{xl}, $obj->{xh}, $obj->{yl}, $obj->{yh});\n\tmy $is_symbolic = $obj->{symDomain};\n\t$xmin = $is_symbolic ? 1 : 1E38 unless defined($xmin);\n\t$xmax = $is_symbolic ? $#$xary + 1 : -1E38 unless defined($xmax);\n\t$ymin = 1E38 unless defined($ymin);\n\t$ymax = -1E38 unless defined($ymax);\n\t\n\tif (($props=~/\\bstack\\b/i) && ($props=~/\\bfill\\b/i)) {\n\n\t\tforeach (@ranges) {\n\t\t\t$obj->{errmsg} = 'Unbalanced dataset.',\n\t\t\treturn undef\n\t\t\t\tif ($#$xary != $#$_);\n\t\t}\n\t\tforeach my $i (0..$#$xary) {\n\t\t\t$$yary[$i] = [ ];\n\t\t\tmy $ys = $$yary[$i];\n\t\t\tmy $lasty = 0;\n\t\t\tmy $first_valid = 0;\n\t\t\tforeach (@ranges) {\n\n\t\t\t\t$y = $$_[$i];\n\t\t\t\tnext unless defined($y);\n\t\t\t\t$y = convert_temporal($y, $obj->{timeRange}) \n\t\t\t\t\tif $obj->{timeRange};\n\t\t\t\t$obj->{errmsg} = 'Non-numeric range value ' . $y . '.',\n\t\t\t\treturn undef\n\t\t\t\t\tunless ($y=~/^[+-]?\\.?\\d+\\.?\\d*([Ee][+-]?\\d+)?$/);\n\t\t\n\t\t\t\t$obj->{errmsg} = \n\t\t\t\t\t'Invalid value supplied for logarithmic axis.',\n\t\t\t\treturn undef\n\t\t\t\t\tif ($obj->{yLog} && ($y <= 0));\n\n\t\t\t\t$first_valid++;\n\t\t\t\t\n\t\t\t\t$y += $lasty;\n\t\t\t\t$y = log($y)/log(10) if $obj->{yLog};\n\t\t\t\t$ymin = $y if ($y < $ymin);\n\t\t\t\t$ymax = $y if ($y > $ymax);\n\t\t\t\tpush @$ys, $y;\n\t\t\t\t$lasty = $y unless (($props=~/\\bfloat\\b/i) && ($first_valid == 1));\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t$yary = $ranges[0];\n\n\t\t$obj->{errmsg} = 'Unbalanced dataset.',\n\t\treturn undef\n\t\t\tif ($#$xary != $#$yary);\n\t}\n\tmy $domVals = $obj->{domainValues};\n\tmy @data = ();\n\tmy $idx = 0;\n\tmy @xs = ();\n\tmy @ys = ();\n\tmy %xhash = ();\n\tmy $needsort = 0;\n\tforeach (0..$#$xary) {\n\t\t$x = $$xary[$_];\n\t\tnext unless defined($x);\n\t\t\n\t\t$x = convert_temporal($x, $obj->{timeDomain}) if $obj->{timeDomain};\n\n\t\t$obj->{errmsg} = \"Non-numeric domain value $x.\",\n\t\treturn undef\n\t\t\tunless ($is_symbolic ||\n\t\t\t\t($x=~/^[+-]?\\.?\\d+\\.?\\d*([Ee][+-]?\\d+)?$/));\n\n\t\t$obj->{errmsg} = \"Invalid value for logarithmic axis.\",\n\t\treturn undef\n\t\t\tunless ($is_symbolic || (! $obj->{xLog}) ||\t($x > 0));\n\n\t\t$obj->{xMaxLen} = length($x) \n\t\t\tif ($is_symbolic && ((! $obj->{xMaxLen}) || (length($x) > $obj->{xMaxLen})));\n\t\tpush(@xs, $x),\n\t\t$xhash{$x} = $#xs,\n\t\tnext\n\t\t\tif $is_symbolic;\n\n\t\t$x = log($x)/log(10) if $obj->{xLog};\n\t\t$needsort = 1 if (($#xs >= 0) && ($xs[$#xs] > $x));\n\t\tpush @xs, $x;\n\t\t$xhash{$x} = $#xs;\n\t}\n\t@ys = @$yary \n\t\tunless $needsort;\n\n\tif ($needsort) {\n\t\t@xs = sort numerically @xs ;\n\t\tpush @ys, $$yary[$xhash{$_}]\n\t\t\tforeach (@xs);\n\t}\n\t$xmin = $xs[0] unless ($is_symbolic || ($xs[0] >= $xmin));\n\t$xmax = $xs[$#xs] unless ($is_symbolic || ($xs[$#xs] <= $xmax));\n\t$xmax = 1 + $#xs  if ($is_symbolic && ($#xs >= $xmax));\n\n\tforeach (0..$#xs) {\n\t\t($x, $y) = ($xs[$_], $ys[$_]); \n\t\tnext unless (defined($x) && defined($y));\n\t\t\n\t\tunless (ref $y) {\n\t\t\t$y = convert_temporal($y, $obj->{timeRange}) if $obj->{timeRange};\n\t\t\t$obj->{errmsg} = 'Non-numeric range value ' . $y . '.',\n\t\t\treturn undef\n\t\t\t\tunless ($y=~/^[+-]?\\.?\\d+\\.?\\d*([Ee][+-]?\\d+)?$/);\n\t\t\n\t\t\t$obj->{errmsg} = \n\t\t\t\t'Invalid value supplied for logarithmic axis.',\n\t\t\treturn undef\n\t\t\t\tif ($obj->{yLog} && ($y <= 0));\n\n\t\t\t$y = log($y)/log(10) if $obj->{yLog};\n\t\t\t$ymin = $y if ($y < $ymin);\n\t\t\t$ymax = $y if ($y > $ymax);\n\t\t}\t\t\n\t\tpush(@data, $x, $y), next\n\t\t\tunless $obj->{symDomain};\n\t\t$domVals->{$x} = defined($domVals) ? scalar(keys(%$domVals)) : 0\n\t\t\tunless defined($domVals->{$x});\n\t\t$idx = $domVals->{$x} * 2;\n\t\t$data[$idx++] = $x;\n\t\t$data[$idx++] = $y;\n\t}\n\tpush(@{$obj->{data}}, \\@data);\n\t$props .= ' line' unless ($props=~/\\bnoline|line|fill\\b/i);\n\t$props=~s/\\bnoline\\b/line/i if ($props=~/\\bfill\\b/i);\n\tpush(@{$obj->{props}}, $props);\n\t$obj->{haveScale} = 0;\t\n\t$obj->{plotTypes} |= ($props=~/\\bfill\\b/i) ? AREA : \n\t\t($props=~/\\bline\\b/i) ? LINE : POINT;\n\t($obj->{xl}, $obj->{xh}, $obj->{yl}, $obj->{yh}) = \n\t\t($xmin, $xmax, $ymin, $ymax);\n\treturn 1;\n}\nsub sortData {\n\tmy ($obj) = @_;\n\tmy $xhash = $obj->{domainValues};\n\tmy @xsorted = ();\n\tif ($obj->{timeDomain}) {\n\t\t@xsorted = sort numerically keys(%$xhash);\n\t}\n\telse {\n\t\t$xsorted[$$xhash{$_}] = $_\n\t\t\tforeach (keys(%$xhash));\n\t}\n\t$obj->{domain} = \\@xsorted;\n\t$obj->{xh} = scalar @xsorted;\n\treturn 1;\n}\n\nsub error {\n  my $obj = shift;\n  return $obj->{errmsg};\n}\n\nsub setOptions {\n\tmy ($obj, %hash) = @_;\n\n\tforeach (keys (%hash)) {\n\t\t$obj->{errmsg} = \"Unrecognized attribute $_.\",\n\t\treturn undef\n\t\t\tunless ($valid_attr{$_});\n\t\t\n\t\tif (/^(bg|grid|text)Color$/) {\n\t\t\t$obj->{errmsg} = \"Unrecognized color $hash{$_} for $_.\",\n\t\t\treturn undef\n\t\t\t\tunless $colors{$hash{$_}};\n\t\t\tmy $color = $hash{$_};\n\t\t\t$obj->{$color} = $obj->{img}->colorAllocate(@{$colors{$color}})\n\t\t\t\tunless $obj->{$color};\n\t\t\t$obj->{$_} = $obj->{$color};\n\t\t\tnext;\n\t\t}\n\t\t\n\t\tif ($_ eq 'font') {\n\t\t\tdelete $obj->{font};\n\t\t\tforeach my $f (@{$hash{font}}) {\n\t\t\t\t$obj->{font} = $f, last\n\t\t\t\t\tif $obj->loadFont($f);\n\t\t\t}\n\t\t\t$obj->{errmsg} = \"No specified font available.\",\n\t\t\treturn undef\n\t\t\t\tunless $obj->{font};\n\t\t\tnext;\n\t\t}\n\n\t\t$obj->{$_} = $hash{$_};\n\t}\n\treturn 1;\n}\n\nsub plot {\n\tmy ($obj, $format) = @_;\n\t$format = lc $format;\n\t\n\t$obj->{errmsg} = 'No plots defined.' unless $obj->{plotTypes};\n\tmy $color;\n\t$obj->{img}->fill(1, 1, $obj->{bgColor} );\n\t$obj->{img}->rectangle( 0, 0, $obj->{width}-1, $obj->{height}-1,\n\t ($obj->{border} ? $obj->{black} : $obj->{bgColor}));\n\t$obj->addLogo if $obj->{logo};\n\n\t$obj->drawTitle if $obj->{title}; \n\t$obj->drawSignature if $obj->{signature};\n\n\tmy $rc = 1;\n\t$obj->sortData if $obj->{symDomain};\n\n\tmy $plottypes = $obj->{plotTypes};\n\tmy $props = $obj->{props};\n\tmy $prop;\n\t($obj->{yl}, $obj->{yh}) = (1, 100) if ($plottypes == BOX);\n\t$rc = $obj->computeScales()\n\t\tunless ($obj->{haveScale} || \n\t\t\t($plottypes == PIE) || ($plottypes == QUADTREE));\n\treturn undef unless $rc;\n\t$obj->{boxHeight} = int($obj->{plotHeight}/($obj->{boxCount}+1))\n\t\tif $obj->{boxCount};\n\t$rc = $obj->plotPie,\n\treturn ($rc ? (($format) && $obj->{img}->$format) : undef)\n\t\tif ($plottypes == PIE);\n\t$rc = ($plottypes == BOX) ? $obj->plotBoxAxes :\n\t\t($plottypes & (HISTO|GANTT)) ? $obj->plotHistoAxes :\n\t\t$obj->plotAxes\n\t\tunless ($plottypes == QUADTREE);\n\treturn undef unless $rc;\n\tmy @proptypes = ();\n\tforeach (@{$obj->{props}}) {\n\t\tpush(@proptypes, $typemap{uc $1}), next \n\t\t\tif /\\b(candle|fill|box|bar|histo|gantt|quadtree)\\b/i;\n\t\tpush(@proptypes, POINT),next if /\\bnoline\\b/i;\n\t\tpush(@proptypes, LINE);\n\t}\n\tmy $plotcnt = $#{$obj->{props}} + 1;\n\tif ($obj->{zAxisLabel} || $obj->{threed}) {\n\t\treturn undef\t\n\t\t\tif (! $obj->plot3DBars);\n\n\t\treturn undef\n\t\t\tunless (($#{$obj->{_legends}} < 0) || $obj->drawLegend);\n\n\t\t$obj->plot3DTicks;\n\t\treturn (($format) && $obj->{img}->$format);\n\t}\n\n\treturn undef\t\n\t\tif (($plottypes & QUADTREE) && (! $obj->plotQuadtree(\\@proptypes)));\n\n\treturn undef\t\n\t\tif (($plottypes & HISTO) && (! $obj->plot2DBars(HISTO, \\@proptypes)));\n\n\treturn undef\t\n\t\tif (($plottypes & GANTT) && (! $obj->plotGantt));\n\n\treturn undef \n\t\tif (($plottypes & AREA) && (! $obj->plotAll(AREA,\\@proptypes)));\n\t\t\n\treturn undef\n\t\tif (($plottypes & BAR) && (! $obj->plot2DBars(BAR, \\@proptypes)));\n\n\treturn undef\n\t\tif (($plottypes & CANDLE) && (! $obj->plot2DBars(CANDLE, \\@proptypes)));\n\n\treturn undef\n\t\tif (($plottypes & BOX) && (! $obj->plotBox(\\@proptypes)));\n\n\treturn undef \n\t\tif (($plottypes & LINE) && (! $obj->plotAll(LINE,\\@proptypes)));\n\t\t\n\treturn undef \n\t\tif (($plottypes & POINT) && (! $obj->plotAll(POINT,\\@proptypes)));\n\treturn undef\n\t\tunless (($#{$obj->{_legends}} < 0) || $obj->drawLegend);\n\treturn (($format) && $obj->{img}->$format);\n}\n\nsub getMap {\n\tmy ($obj) = @_;\n\tmy $mapname = $obj->{genMap};\n\n\treturn \"\\$$mapname = [\\n\" . $obj->{imgMap} . \" ];\"\n\t\tif (uc $obj->{mapType} eq 'PERL');\n\n\treturn \t\"<MAP NAME=\\\"$mapname\\\">\" . \n\t\t$obj->{imgMap} . \"\\n</MAP>\\n\";\n}\n\nsub computeScales {\n\tmy $obj = shift;\n\tmy ($xl, $yl, $zl, $xh, $yh, $zh) = \n\t\t($obj->{xl}, $obj->{yl}, $obj->{zl}, $obj->{xh}, $obj->{yh}, \n\t\t\t$obj->{zh});\n\tmy $i;\n\tif ($obj->{keepOrigin}) {\n\t\tunless ($obj->{xLog} || $obj->{symDomain} ||\n\t\t\t$obj->{zAxisLabel} || $obj->{threed}) {\n\t\t\t$xl = 0 if ($xl > 0);\n\t\t\t$xh = 0 if ($xh < 0);\n\t\t}\n\t\tunless ($obj->{yLog}) {\n\t\t\t$yl = 0 if ($yl > 0);\n\t\t\t$yh = 0 if ($yh < 0);\n\t\t}\n\t}\n\t\n\tmy $plottypes = $obj->{plotTypes};\n\t$obj->{errmsg} = 'Invalid dataset.',\n\treturn undef\n\t\tunless $obj->computeRanges($xl, $xh, $yl, $yh, $zl, $zh);\n\t$obj->{yl} = 0 if (($plottypes & (BAR|HISTO)) && ($yl == 0));\n\tif ($obj->{keepOrigin}) {\n\t\tunless ($obj->{xLog} || $obj->{symDomain} ||\n\t\t\t$obj->{zAxisLabel} || $obj->{threed}) {\n\t\t\t$obj->{xl} = 0 if ($xl >= 0);\n\t\t\t$obj->{xh} = 0 if ($xh <= 0);\n\t\t}\n\t\tunless ($obj->{yLog}) {\n\t\t\t$obj->{yl} = 0 if ($yl >= 0);\n\t\t\t$obj->{yh} = 0 if ($yh <= 0);\n\t\t}\n\t}\n\n\t($xl, $xh, $yl, $yh, $zl, $zh) = \n\t\t($obj->{xl}, $obj->{xh}, $obj->{yl}, $obj->{yh}, \n\t\t\t$obj->{zl}, $obj->{zh});\n\n\tif (($plottypes & (BAR|HISTO)) && ($yl > 0) \n\t\t&& (! $obj->{keepOrigin})) {\n\t\tforeach (0..$#{$obj->{props}}) {\n\t\t\tnext unless ($obj->{props}->[$_]=~/\\b(bar|histo)\\b/i);\n\t\t\tmy $datastack = $obj->{data}->[$_];\n\t\t\tmy $j = 1;\n\n\t\t\t$datastack->[$j]->[0] = $yl, $j += 3\n\t\t\t\twhile ($j <= $#$datastack);\n\t\t}\n\t}\n\tmy ($botmargin, $topmargin, $ltmargin, $rtmargin) = (40, 40, 0, 5*$sfw);\n\t$botmargin += (3 * $tfh) if $obj->{legend};\n\tmy $maxlen = 0;\n\tmy ($tl, $th) = (0, 0);\n\t($tl, $th) = ($obj->{xLog}) ? (10**$xl, 10**$xh) : ($xl, $xh)\n\t\tunless $obj->{symDomain};\n\t$maxlen = $obj->{symDomain} ? $obj->{xMaxLen} : \n\t\t$obj->{timeDomain} ? length($obj->{timeDomain}) :\n\t\t(length($th) > length($tl)) ? length($th) : length($tl);\n\t$maxlen = 25 if ($maxlen > 25);\n\t$maxlen = 7 if ($maxlen < 7);\n\t$botmargin += (($sfw * $maxlen) + 10) unless ($plottypes & (HISTO|GANTT));\n\t$ltmargin = (($sfw * $maxlen) + 20) if ($plottypes & (HISTO|GANTT));\n\t($tl, $th) = ($obj->{yLog}) ? (10**$yl, 10**$yh) : ($yl, $yh);\n\t$maxlen = $obj->{timeRange} ? length($obj->{timeRange}) :\n\t\t(length($th) > length($tl)) ? length($th) : length($tl);\n\t$maxlen = 25 if ($maxlen > 25);\n\t$maxlen = 7 if ($maxlen < 7);\n\t$botmargin += (($sfw * $maxlen) + 10) if ($plottypes & (HISTO|GANTT));\n\t$ltmargin = (($sfw * $maxlen) + 20) unless ($plottypes & (HISTO|GANTT));\n\tif ($obj->{zAxisLabel}) {\n\t\t$maxlen = $obj->{zMaxLen};\n\t\t$maxlen = 25 if ($maxlen > 25);\n\t\t$maxlen = 7 if ($maxlen < 7);\n\t\t$rtmargin = ($sfw * $maxlen) + 10;\n\t}\n\tif ($obj->{zAxisLabel} || $obj->{threed}) {\n\t\tmy $tht = $obj->{height} - $topmargin - $botmargin;\n\t\tmy $twd = $obj->{width} - $ltmargin - $rtmargin;\n\t\tmy $xzratio = \n\t\t\t$obj->{Zcard}/($obj->{Xcard}*(scalar @{$obj->{data}}));\n\t\t$xh = 0.5 + int($xh), $xl = 0.5,\n\t\t$obj->{xh} = $xh, $obj->{xl} = $xl\n\t\t\tif ($xh - $xl < int($xh));\n\t\t$obj->{plotWidth} = int($twd / ($xzratio*sin(3.1415926/6) + 1)),\n\t\t$obj->{plotDepth} = int(($twd - $obj->{plotWidth})/sin(3.1415926/6)),\n\t\t$obj->{plotHeight} = int($tht - ($obj->{plotDepth}*cos(3.1415926/3))),\n\t\t$obj->{xscale} = $obj->{plotWidth}/int($xh),\n\t\t$obj->{yscale} = $obj->{plotHeight}/($yh - $yl),\n\t\t$obj->{zscale} = $obj->{plotDepth}/($zh - $zl)\n\t\t\tunless ($plottypes & (HISTO|GANTT));\n\n\t\t$obj->{plotHeight} = int($tht / ($xzratio*cos(3.1415926/6) + 1)),\n\t\t$obj->{plotDepth} = int(($tht - $obj->{plotHeight})/cos(3.1415926/6)),\n\t\t$obj->{plotWidth} = int($twd - ($obj->{plotDepth}*sin(3.1415926/6))),\n\t\t$obj->{yscale} = $obj->{plotWidth}/($yh - $yl),\n\t\t$obj->{xscale} = $obj->{plotHeight}/($xh - $xl),\n\t\t$obj->{zscale} = $obj->{plotDepth}/($zh - $zl)\n\t\t\tif ($plottypes & (HISTO|GANTT));\n\t}\n\telse {\n\t\t$obj->{xscale} = ($obj->{width} - $ltmargin - $rtmargin)/($xh - $xl),\n\t\t$obj->{yscale} = ($obj->{height} - $topmargin - $botmargin)/($yh - $yl),\n\t\t$obj->{plotWidth} = $obj->{width} - $ltmargin - $rtmargin,\n\t\t$obj->{plotHeight} = $obj->{height} - $topmargin - $botmargin\n\t\t\tunless ($plottypes & (HISTO|GANTT));\n\n\t\t$obj->{yscale} = ($obj->{width} - $ltmargin - $rtmargin)/($yh - $yl),\n\t\t$obj->{xscale} = ($obj->{height} - $topmargin - $botmargin)/($xh - $xl),\n\t\t$obj->{plotWidth} = $obj->{width} - $ltmargin - $rtmargin,\n\t\t$obj->{plotHeight} = $obj->{height} - $topmargin - $botmargin\n\t\t\tif ($plottypes & (HISTO|GANTT));\n\t}\n\n\t$obj->{horizEdge} = $ltmargin;\n\t$obj->{vertEdge} = $obj->{height} - $botmargin;\n\treturn undef\n\t\tif (($plottypes & (BAR|HISTO)) && \n\t\t\t(! $obj->{zAxisLabel}) &&\n\t\t\t(! $obj->computeSpacing($plottypes)));\n\t\n\t$obj->{haveScale} = 1;\n\treturn 1;\n}\n\nsub computeRanges {\n \tmy ($obj, $xl, $xh, $yl, $yh, $zl, $zh) = @_;\n \tmy ($tmp, $om) = (0,0);\n \tmy @sign = ();\n\n\t($obj->{horizStep}, $obj->{vertStep}, $obj->{depthStep}) = (1,1,1),\n\t($obj->{xl}, $obj->{xh}, $obj->{yl}, $obj->{yh}, $obj->{zl}, $obj->{zh}) = \n\t\t(0,1,0,1, 0,1)\n\t\tif (($xl == $xh) || ($yl == $yh) || \n\t\t\t(defined($zl) && ($zl == $zh)) );\n\t\t\n\tforeach ($xl, $xh, $yl, $yh, $zl, $zh) {\n\t\tpush @sign, (($_ < 0) ? -1 : (! $_) ? 0 : 1)\n\t\t\tif defined($_);\n\t}\n\t$xh = 2 if (($xh == 1) && ($xl == 1));\n\tmy ($xr, $xd, $xs);\n\t$xl = int($xl) - ($xl < 0 ? 1 : 0),\n\t$xh = int($xh) + 1\n\t\tif ($obj->{xLog});\n\treturn undef if ($xh == $xl);\n\t$xr = (log($xh - $xl))/log(10),\n\t$xd = $xr - int($xr)\n\t\tunless $obj->{symDomain};\n\t$obj->{horizStep} = $obj->{symDomain} ? 1 : \n\t\t($xd < 0.4) ? (10 ** (int($xr) - 1)) :\n\t\t(($xd >= 0.87) ? (10 ** int($xr)) : (5 * (10 ** (int($xr) - 1))));\n\tif ((! $obj->{symDomain}) && $obj->{timeDomain} \n\t\t&& ($obj->{timeDomain}=~/YYYY/i)) {\n\t\tmy $align = \n\t\t\t(($obj->{timeDomain}!~/HH/i) || \n\t\t\t\t($xh - $xl > (3 * 24 * 60 * 60))) ? 86400 :\n\t\t\t($xh - $xl > (3 * 60 * 60)) ? 3600 : 60;\n\n\t\t$obj->{horizStep} += ($align - $obj->{horizStep}%$align)\n\t\t\tif ($obj->{horizStep}%$align != 0);\n\t}\n\t\n\t($yl, $yh) = (($yl * 0.75), ($yl * 1.25)) if ($yh == $yl);\n\t$yl = int($yl) - ($yl < 0 ? 1 : 0),\n\t$yh = int($yh) + 1\n\t\tif ($obj->{yLog});\n\treturn undef if ($yh == $yl);\n\t$xr = (log($yh - $yl))/log(10);\n\t$xd = $xr - int($xr);\n\t$obj->{vertStep} = ($xd < 0.4) ? (10 ** (int($xr) - 1)) :\n\t\t(($xd >= 0.87) ? (10 ** int($xr)) : (5 * (10 ** (int($xr) - 1))));\n\tif (($obj->{plotTypes} & (HISTO|GANTT)) && \n\t\t$obj->{timeRange} && ($obj->{timeRange}=~/^YYYY/i)) {\n\t\tmy $align = \n\t\t(($obj->{timeRange}!~/HH/i) || \n\t\t\t($yh - $yl > (3 * 24 * 60 * 60))) ? 86400 :\n\t\t($yh - $yl > (3 * 60 * 60)) ? 3600 : 60;\n\n\t\t$obj->{vertStep} += ($align - $obj->{vertStep}%$align)\n\t\t\tif ($obj->{vertStep}%$align != 0);\n\t}\n\t$xs = $obj->{horizStep}, \n\t$obj->{horizStep} = $obj->{vertStep}, \n\t$obj->{vertStep} = $xs\n\t\tif ($obj->{plotTypes} & (HISTO|GANTT));\n\n\tif (($obj->{zAxisLabel} || $obj->{threed}) && ($zh != $zl)) {\n\t\treturn undef if ($zh == $zl);\n\t\t$xr = (log($zh - $zl))/log(10),\n\t\t$xd = $xr - int($xr)\n\t\t\tunless $obj->{symDomain};\n\t\t$obj->{depthStep} = $obj->{symDomain} ? 1 : \n\t\t\t($xd < 0.4) ? (10 ** (int($xr) - 1)) :\n\t\t\t(($xd >= 0.87) ? (10 ** int($xr)) : (5 * (10 ** (int($xr) - 1))));\n\t}\n\tmy ($xm, $ym, $zm) = ($obj->{plotTypes} & (HISTO|GANTT)) ?\n\t\t($obj->{vertStep}, $obj->{horizStep}, $obj->{depthStep}) :\n\t\t($obj->{horizStep}, $obj->{vertStep}, $obj->{depthStep});\n\n\t($zl, $zh) = (0.5, 1.5) if ($obj->{symDomain} && defined($zl) && ($zl == $zh));\n\t($xl, $xh) = (0.5, 1) if ($obj->{symDomain} && ($xl == $xh));\n\t$obj->{zl} = ((! $zm) ? 0 : $zm * (int(($zl-0.00001*$sign[4])/$zm) + $sign[4] - 1)),\n\t$obj->{zh} = ((! $zm) ? 0 : $zm * (int(($zh-0.00001*$sign[5])/$zm) + $sign[5] + 1))\n\t\tif defined($zl);\n\t$obj->{xl} = (! $xm) ? 0 : $xm * (int(($xl-0.00001*$sign[0])/$xm) + $sign[0] - 1);\n\t$obj->{xh} = (! $xm) ? 0 : $xm * (int(($xh-0.00001*$sign[1])/$xm) + $sign[1] + 1);\n\tif ((! $obj->{symDomain}) && \n\t\t$obj->{timeDomain} && ($obj->{timeDomain}=~/^YYYY/i)) {\n\t\tmy $align = \n\t\t\t(($obj->{timeDomain}!~/HH/i) || \n\t\t\t\t($obj->{xh} - $obj->{xl} > (3 * 24 * 60 * 60))) ? 86400 :\n\t\t\t($obj->{xh} - $obj->{xl} > (3 * 60 * 60)) ? 3600 : 60;\n\n\t\t$obj->{xl} = $obj->{xl} - ($obj->{xl}%$align);\n\t\t$obj->{xh} += ($align - ($obj->{xh}%$align));\n\t}\n\n\t$obj->{yl} = ($obj->{yLog}) ? $yl : (! $ym) ? 0 : $ym * (int(($yl-0.00001*$sign[2])/$ym) + $sign[2] - 1);\n\t$obj->{yh} = ($obj->{yLog}) ? $yh : (! $ym) ? 0 : $ym * (int(($yh-0.00001*$sign[3])/$ym) + $sign[3] + 1);\n\tif ($obj->{timeRange} && ($obj->{timeRange}=~/^YYYY/i)) {\n\t\tmy $align = \n\t\t\t(($obj->{timeRange}!~/HH/i) || \n\t\t\t\t($obj->{yh} - $obj->{yl} > (3 * 24 * 60 * 60))) ? 86400 :\n\t\t\t($obj->{yh} - $obj->{yl} > (3 * 60 * 60)) ? 3600 : 60;\n\n\t\t$obj->{yl} = $obj->{yl} - ($obj->{yl}%$align);\n\t\t$obj->{yh} += ($align - ($obj->{yh}%$align));\n\t}\n\treturn 1;\n}\nsub computeSpacing {\n\tmy ($obj, $type) = @_;\n\tmy $domains = 0;\n\t$domains = ($obj->{Xcard}) ? 1 : scalar(@{$obj->{domain}});\n\n\tmy $bars = $obj->{barCount};\n\t$bars = $obj->{Xcard} if ($obj->{Xcard});\n\tmy $spacer = 10;\n\tmy $width = ($type & HISTO) ? $obj->{plotHeight} : $obj->{plotWidth};\n\tmy $pxlsperdom = int($width/($domains+1)) - $spacer;\n\n\t$obj->{errmsg} = 'Insufficient width for number of domain values.',\n\treturn undef\n\t\tif ($pxlsperdom < 2);\n\tmy $pxlsperbar = int($pxlsperdom/$bars);\n\n\t$obj->{errmsg} = 'Insufficient width for number of ranges or values.',\n\treturn undef\n\t\tif ($pxlsperbar < 2);\n\n\t$obj->{brushWidth} = $pxlsperbar;\n\treturn 1;\n}\n\nsub plot2DBars {\n\tmy ($obj, $type, $typeary) = @_;\n\tmy ($i, $j, $k, $x, $n, $ary, $pxl, $pxr, $py, $pyt, $pyb);\n\tmy ($color, $prop, $s, $colorcnt);\n\tmy @barcolors = ();\n\tmy @brushes = ();\n\tmy @markers = ();\n\tmy @props = ();\n\tmy $legend = $obj->{legend};\n\tmy ($xl, $xh, $yl, $yh) = ($obj->{xl}, $obj->{xh}, $obj->{yl}, \n\t\t$obj->{yh});\n\tmy ($brush, $ci, $t);\n\tmy ($useicon, $marker);\n\tmy $img = $obj->{img};\n\tmy $plottypes = $obj->{plotTypes};\n\tmy @tary = ();\n\tmy $bars = $obj->{barCount};\n\tmy $boff = int($obj->{brushWidth}/2);\n\tmy $ttlw = int($bars * $boff);\n\tmy $domain = $obj->{domain};\n\tmy $xhash = $obj->{domainValues};\n\tmy ($prtX,$prtYH,$prtYL);\n\tmy ($iconw, $iconh) = (0,0);\n\tforeach (0..$#$typeary) {\n\t\tpush(@tary, $_)\n\t\t\tif ($$typeary[$_] == $type);\n\t}\n\n\tfor ($n = 0; $n <= $#tary; $n++) {\n\t\t@barcolors = ();\n\t\t@brushes = ();\n\t\t@markers = ();\n\t\t$marker = undef;\n\t\t$color = 'black';\n\t\t$k = $tary[$n];\n\t\t$ary = $obj->{data}->[$k];\n\t\t$t = $obj->{props}->[$k];\n\t\t$t=~s/\\s+/ /g;\n\t\t@props = split (' ', $t);\n\t\tmy $showvals;\n\t\tmy $stacked = 0;\n\t\tforeach (@props) {\n\t\t\tpush(@markers,$1),\n\t\t\tpush (@barcolors, undef),\n\t\t\tnext\n\t\t\t\tif /^icon:(\\S+)$/i;\n\n\t\t\t$_ = lc $_;\n\t\t\t$showvals = $1, next\n\t\t\t\tif /^showvalues:(\\d+)/;\n\n\t\t\t$stacked = 1, next\n\t\t\t\tif ($_ eq 'stack');\n\n\t\t\tpush (@barcolors, $_), \n\t\t\tpush (@markers, undef),\n\t\t\tnext\n\t\t\t\tif (($type != CANDLE) && $colors{$_});\n\t\t\t\n\t\t\tnext unless ($type == CANDLE);\n\t\t\tpush (@barcolors, $_), \n\t\t\tnext\n\t\t\t\tif ($colors{$_});\n\t\t\tpush(@markers, $_),\n\t\t\tnext\n\t\t\t\tif ($valid_shapes{$_} && ($_ ne 'null'));\n\t\t} \n\t\t$colorcnt = 0;\n\t\tmy ($bw, $bh, $bbasew, $bbaseh) = ($plottypes & HISTO) ?\n\t\t\t(1, $obj->{brushWidth}, 0, $obj->{brushWidth}) :\n\t\t\t($obj->{brushWidth}, 1, $obj->{brushWidth}, 0);\n\n\t\tforeach (@barcolors) {\n\t\t\t$colorcnt++;\n\t\t\tpush(@brushes, undef),\n\t\t\tnext \n\t\t\t\tunless $_;\n\t\t\t$obj->{$_} = $obj->{img}->colorAllocate(@{$colors{$_}})\n\t\t\t\tunless $obj->{$_};\n\t\t\t$brush = new GD::Image($bw, $bh),\n\t\t\t$ci = $brush->colorAllocate(@{$colors{$_}}),\n\t\t\t$brush->filledRectangle(0,0,$bbasew, $bbaseh,$ci),\n\t\t\tpush(@brushes, $brush);\n\t\t}\n\t\tforeach (0..$#markers) {\n\t\t\tnext unless $markers[$_];\n\t\t\t$markers[$_] = ($valid_shapes{$markers[$_]} && ($markers[$_] ne 'null')) ? \n\t\t\t\t$obj->make_marker($markers[$_], $barcolors[$_]) : \n\t\t\t\t$obj->getIcon($markers[$_], 1);\n\t\t\treturn undef unless $markers[$_];\n\t\t}\n\t\t$obj->addLegend($barcolors[0], $markers[0], $$legend[$k], undef)\n\t\t\tif ((! $stacked) && $legend && $$legend[$k]);\n\n\t\tif ($stacked && $legend && $$legend[$k]) {\n\t\t\t$obj->addLegend($barcolors[$_], $markers[$_], $$legend[$k]->[$_], undef)\n\t\t\t\tforeach (0..$#{$$legend[$k]});\n\t\t}\n\t\tmy $yorient = (length($yl) > length($yh)) ? length($yl) : length($yh);\n\t\t$yorient *= $tfw;\n\t\tmy $xoffset = ($n * $obj->{brushWidth}) - $ttlw \n\t\t\t+ $boff;\n\t\tmy @val_palette = ();\n\t\tmy ($px, $py);\n\t\t$j = 0;\n\t\tfor ($x = 0; $x <= $#$domain; $x++) {\n\t\t\t($iconw,$iconh) = (0,0);\n\t\t\t$i = $$xhash{$$domain[$x]} * 3;\t\n\t\t\tnext unless defined($$ary[$i+1]);\n\n\t\t\tmy @ppts = ();\n\t\t\tmy $ys = $$ary[$i+1];\n\t\t\t$j = 0 if ($#$ys > 1);\n\t\t\tforeach (0..$#$ys) {\n\t\t\t\t($pxl, $pyb) = $obj->pt2pxl ( $x+1, $$ys[$_] );\n\t\t\t\t($pxr, $pyt) = $obj->pt2pxl ( $x+1, $$ys[$_+1] );\n\t\t\t\tpush @ppts, $pxl, $pyb, $pxr, $pyt, $x+1, $$ys[$_], $$ys[$_+1], $j;\n\t\t\t\t$j++;\n\t\t\t\t$j = 0 if ($j >= $colorcnt);\n\t\t\t\tlast if ($_+1 == $#$ys);\n\t\t\t}\n\t\t\twhile ($#ppts > 0) {\n\t\t\t\t$pxl = shift @ppts;\n\t\t\t\t$pyb = shift @ppts;\n\t\t\t\t$pxr = shift @ppts;\n\t\t\t\t$pyt = shift @ppts;\n\t\t\t\t$prtX = shift @ppts;\n\t\t\t\t$prtYL = shift @ppts;\n\t\t\t\t$prtYH = shift @ppts;\n\t\t\t\tmy $bidx = shift @ppts;\n\t\t\t\t$pxl += $xoffset,\n\t\t\t\t$pxr += $xoffset\n\t\t\t\t\tunless ($plottypes & HISTO);\n\t\t\t\t$pyb += $xoffset,\n\t\t\t\t$pyt += $xoffset\n\t\t\t\t\tif ($plottypes & HISTO);\n\t\t\t\t\n\t\t\t\t$img->setBrush($brushes[$bidx]),\n\t\t\t\t$img->line($pxl, $pyb, $pxr, $pyt, gdBrushed)\n\t\t\t\t\tif $brushes[$bidx];\n\t\t\t\t$obj->drawIcons($markers[$bidx], $pxl, $pyb, $pxr, $pyt)\n\t\t\t\t\tif (($type != CANDLE) && $markers[$bidx]);\n\t\t\t\t$obj->drawIcons($markers[$bidx], $pxl, $pyb, $pxl, 0),\n\t\t\t\t$obj->drawIcons($markers[$bidx], $pxl, $pyt, $pxl, 0),\n\t\t\t\t($iconw, $iconh) = $markers[$bidx]->getBounds()\n\t\t\t\t\tif ($markers[$bidx] && ($type == CANDLE));\n\t\t\t\tnext unless ($obj->{genMap} || $showvals);\n\t\t\t\tif ($type == CANDLE) {\n\t\t\t\t\t$prtYH = 10**$prtYH if $obj->{yLog};\n\t\t\t\t\t$prtYL = 10**$prtYL if $obj->{yLog};\n\t\t\t\t\t$prtYH = restore_temporal($prtYH, $obj->{timeRange}),\n\t\t\t\t\t$prtYL = restore_temporal($prtYL, $obj->{timeRange}) \n\t\t\t\t\t\tif $obj->{timeRange};\n\t\t\t\t\t$prtX = restore_temporal($prtX, $obj->{timeDomain}) \n\t\t\t\t\t\tif $obj->{timeDomain};\n\n\t\t\t\t\t$obj->updateImagemap('CIRCLE', $prtYH, $k, $prtX, \n\t\t\t\t\t\t$prtYH, undef, $pxl, $pyt, 4),\n\t\t\t\t\t$obj->updateImagemap('CIRCLE', $prtYL, $k, $prtX,\n\t\t\t\t\t\t$prtYL, undef, $pxl, $pyb, 4)\n\t\t\t\t\t\tif ($obj->{genMap});\n\n\t\t\t\t\tnext unless ($showvals);\n\t\t\t\t\t$iconh >>= 1;\n\t\t\t\t\t$obj->string($showvals, 0, $pxl-(length($prtYL) * ($tfw>>1)),\n\t\t\t\t\t\t$pyb+4+$iconh, $prtYL, $tfw);\n\t\t\t\t\t$obj->string($showvals, 0, $pxl-(length($prtYH) * ($tfw>>1)),\n\t\t\t\t\t\t$pyt-$tfh-$iconh, $prtYH, $tfw);\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\t$prtYH -= $prtYL if ($stacked && ($prtYL > 0));\n\t\t\t\t$prtYH = 10**($prtYH) if $obj->{yLog};\n\t\t\t\t$prtYH = restore_temporal($prtYH, $obj->{timeRange}) \n\t\t\t\t\tif $obj->{timeRange};\n\t\t\t\t$prtYH = $prtYL if ($prtYL < 0);\n\t\t\t\t$prtX = restore_temporal($prtX, $obj->{timeDomain}) \n\t\t\t\t\tif $obj->{timeDomain};\n\t\t\t\t$obj->updateImagemap('RECT', $prtYH, $k, $prtX, \n\t\t\t\t\t$prtYH, undef, $pxl-$boff, $pyt, $pxl+$boff, $pyb)\n\t\t\t\t\tif (($plottypes & BAR) && $obj->{genMap});\n\n\t\t\t\t$obj->updateImagemap('RECT', $prtYH, $k, $prtX, \n\t\t\t\t\t$prtYH, undef, $pxl, $pyt-$boff, $pxr, $pyt+$boff)\n\t\t\t\t\tif (($plottypes & HISTO) && $obj->{genMap});\n\t\t\t\t\n\t\t\t\tnext unless $showvals;\n\t\t\t\t$py = ($stacked) ?\n\t\t\t\t\t(($prtYL < 0) ? $pyb - 4 : \n\t\t\t\t\t\t$pyt + 4 + int(length($prtYH) * $tfw)) :\n\t\t\t\t\t(($prtYL < 0) ? $pyb + 4 + int(length($prtYH) * $tfw) :\n\t\t\t\t\t\t$pyt - 4);\n\t\t\t\tpush(@val_palette, $pxl-int($tfw/2), $py, $prtYH), next\n\t\t\t\t\tif (($plottypes & BAR) &&\n\t\t\t\t\t\t($obj->{yLog} || ($yorient >= $obj->{brushWidth})));\n\t\t\t\t$py = ($stacked) ? \n\t\t\t\t\t(($prtYL < 0) ? $pyb - $tfh - 4 : $pyt + 4) :\n\t\t\t\t\t(($prtYL < 0) ? $pyb + 4 : $pyt - $tfh - 4);\n\t\t\t\tpush(@val_palette, $pxl-int(length($prtYH) * $tfw/2), $py, $prtYH),\n\t\t\t\tnext\n\t\t\t\t\tif (($plottypes & BAR) &&\n\t\t\t\t\t\t($yorient < $obj->{brushWidth}));\n\n\t\t\t\t$px = ($stacked) ?\n\t\t\t\t\t(($prtYL < 0) ? $pxl + $tfw : $pxr - (length($prtYH) * $tfw) - 4) :\n\t\t\t\t\t(($prtYL < 0) ? $pxl - (length($prtYH) * $tfw) : $pxr + $tfw);\n\t\t\t\tpush(@val_palette, $px, $pyt-4, $prtYH), next\n\t\t\t\t\tif ($plottypes & HISTO);\n\t\t\t} \n\t\t} \n\t\twhile ($#val_palette >= 0) {\n\t\t\t$px = shift @val_palette;\n\t\t\t$py = shift @val_palette;\n\t\t\t$prtYH = shift @val_palette;\n\n\t\t\t$obj->string($showvals, 90, $px, $py, $prtYH, $tfw), \n\t\t\tnext\n\t\t\t\tif (($plottypes & BAR) &&\n\t\t\t\t\t($obj->{yLog} || ($yorient >= $obj->{brushWidth})));\n\n\t\t\t$obj->string($showvals, 0, $px, $py, $prtYH, $tfw);\n\t\t}\n\t} \n\treturn 1;\n}\n\nsub computeMedian {\n\tmy ($ary, $lo, $hi) = @_;\n\tmy $size = $hi - $lo +1;\n\tmy $midi = $size>>1;\n\t$midi-- unless ($size & 1);\n\t$midi += $lo;\n\treturn ($size & 1) ? $$ary[$midi] : (($$ary[$midi] + $$ary[$midi+1])/2);\n}\n\nsub computeBox {\n\tmy ($obj, $k) = @_;\n\tmy ($median, $uq, $lq, $lex, $uex, $midpt, $iqr, $val);\n\t\n\tmy $ary = $obj->{data}->[$k];\n\tmy $size = $#$ary;\n\t$median = computeMedian($ary, 0, $size);\n\t$midpt = ($size)>>1;\n\t$midpt-- unless ($size & 1);\n\t$lq = computeMedian($ary, 0, $midpt);\n\t$midpt += ($size & 1) ? 1 : 2;\n\t$uq = computeMedian($ary, $midpt, $size);\n\t$iqr = $uq - $lq;\n\t$lex = $lq - ($iqr*1.5);\n\t$uex = $uq + ($iqr*1.5);\n\t$lex = $$ary[0] if ($lex < $$ary[0]);\n\t$uex = $$ary[$#$ary] if ($uex > $$ary[$#$ary]);\n\t\n\treturn ($median, $lq, $uq, $lex, $uex);\n}\n\nsub plotBox {\n\tmy ($obj, $typeary) = @_;\n\n\tmy $legend = $obj->{legend};\n\tmy ($i, $j, $k, $n, $x);\n\tmy @tary = ();\n\n\tfor ($i = 0; $i <= $#$typeary; $i++) {\n\t\tnext unless ($$typeary[$i] == BOX);\n\t\tpush @tary, $i;\n\t}\n\tmy $boxht = ($obj->{yh} - $obj->{yl})/($i+1);\n\n\tfor ($n = 0; $n <= $#tary; $n++) {\n\t\t$k = $tary[$n];\n\n\t\tmy $ary = $obj->{data}->[$k];\n\t\tmy $t = lc $obj->{props}->[$k];\n\t\t$t=~s/\\s+/ /g;\n\t\tmy @props = split(' ', $t);\n\t\tmy $color = 'black';\n\t\tmy ($val, $xoff);\n\t\tmy $showvals;\n\t\tforeach (@props) {\n\t\t\t$showvals = $1, next if /^showvalues:(\\d+)/i;\n\n\t\t\t$color = $_\n\t\t\t\tif ($colors{$_});\n\t\t}\n\t\t$obj->{$color} = $obj->{img}->colorAllocate(@{$colors{$color}})\n\t\t\tunless $obj->{$color};\n\t\t\t\n\t\t$obj->addLegend($color, undef, $$legend[$k], undef)\n\t\t\tif (($legend) && ($$legend[$k]));\n\t\tmy ($median, $lq, $uq, $lex, $uex) = $obj->computeBox($k);\n\t\tmy $ytop = $obj->{yl} + ($boxht * ($n + 1));\n\t\tmy $ybot = $ytop - $boxht;\n\t\tmy $dumy = ($ytop + $ybot)/2;\n\t\tmy $py = 0;\n\t\tmy ($p1x, $p1y) = $obj->pt2pxl($lq, $ytop);\n\t\tmy ($p2x, $p2y) = $obj->pt2pxl($uq, $ybot);\n\t\tmy $yoff = (($n+1) * (15 + $tfh));\n\t\t$p1y -= $yoff;\n\t\t$p2y -= $yoff;\n\t\tmy $img = $obj->{img};\n\t\t$img->rectangle($p1x, $p1y, $p2x, $p2y, $obj->{$color});\n\t\t$img->rectangle($p1x+1, $p1y+1, $p2x-1, $p2y-1, $obj->{$color});\n\n\t\tmy ($tmed, $tlex, $tuex) = ($median, $lex, $uex);\n\t\t$tmed = restore_temporal($tmed, $obj->{timeDomain}),\n\t\t$lq = restore_temporal($lq, $obj->{timeDomain}),\n\t\t$uq = restore_temporal($uq, $obj->{timeDomain}) ,\n\t\t$tlex = restore_temporal($tlex, $obj->{timeDomain}),\n\t\t$tuex = restore_temporal($tuex, $obj->{timeDomain}) \n\t\t\tif ($obj->{timeDomain} && ($obj->{genMap} || $showvals));\n\n\t\t$xoff = int(length($lq) * $tfw/2),\n\t\t$obj->string($showvals,0,$p1x-$xoff,$p1y-$tfh, $lq, $tfw),\n\t\t$xoff = int(length($uq) * $tfw/2),\n\t\t$obj->string($showvals,0,$p2x-$xoff,$p1y-$tfh, $uq, $tfw)\n\t\t\tif ($showvals);\n\t\n\t\t$obj->updateImagemap('RECT', \"$tmed\\[$lq..$uq\\]\", 0, $tmed, \n\t\t\t$lq, $uq, $p1x, $p1y, $p2x, $p2y)\n\t\t\tif ($obj->{genMap});\n\t\t($p1x, $py) = $obj->pt2pxl($median, $dumy);\n\t\t$p1y -= 5;\n\t\t$p2y += 5;\n\t\t$img->line($p1x, $p1y, $p1x, $p2y, $obj->{$color});\n\n\t\t$xoff = int(length($median) * $tfw/2),\n\t\t$obj->string($showvals,0,$p1x-$xoff,$p1y-$tfh, $tmed , $tfw)\n\t\t\tif $showvals;\n\t\t($p1x, $p1y) = $obj->pt2pxl($lex, $dumy);\n\t\t($p2x, $py) = $obj->pt2pxl($lq, $dumy);\n\t\t$p1y -= $yoff;\n\t\t$img->line($p1x, $p1y, $p2x, $p1y, $obj->{$color});\n\n\t\t$tmed = restore_temporal($tmed, $obj->{timeDomain}),\n\t\t$lq = restore_temporal($lq, $obj->{timeDomain}),\n\t\t$uq = restore_temporal($uq, $obj->{timeDomain}) \n\t\t\tif ($obj->{timeDomain} && ($obj->{genMap} || $showvals));\n\n\t\t$xoff = int(length($lex) * $tfw/2),\n\t\t$obj->string($showvals,0,$p1x-$xoff,$p1y-$tfh, $tlex, $tfw)\n\t\t\tif $showvals;\n\t\t$obj->updateImagemap('CIRCLE', $tlex, 0, $tlex, undef, undef, \n\t\t\t$p1x, $p1y, 4)\n\t\t\tif ($obj->{genMap});\n\n\t\t($p1x, $p1y) = $obj->pt2pxl($uq, $dumy);\n\t\t($p2x, $py) = $obj->pt2pxl($uex, $dumy);\n\t\t$p1y -= $yoff;\n\t\t$img->line($p1x, $p1y, $p2x, $p1y, $obj->{$color});\n\n\t\t$xoff = int(length($uex) * $tfw/2),\n\n\t\t$obj->string($showvals,0,$p2x-$xoff,$p1y-$tfh, $tuex, $tfw)\n\t\t\tif $showvals;\n\t\t$obj->updateImagemap('CIRCLE', $tuex, 0, $tuex, undef, undef, \n\t\t\t$p2x, $p1y, 4)\n\t\t\tif ($obj->{genMap});\n\t\tmy $marker = $obj->make_marker('filldiamond', $color);\n\t\tforeach (@$ary) {\n\t\t\tlast if ($_ >= $lex);\n\t\t\t($p1x, $p1y) = $obj->pt2pxl($_, $dumy);\n\t\t\t$p1y -= $yoff;\n\t\t\t$img->copy($marker, $p1x-4, $p1y-4, 0, 0, 9, 9);\n\t\t}\n\t\tfor (my $i = $#$ary; ($i > 0) && ($uex < $$ary[$i]); $i--) {\n\t\t\t($p1x, $p1y) = $obj->pt2pxl($$ary[$i], $dumy);\n\t\t\t$p1y -= $yoff;\n\t\t\t$img->copy($marker, $p1x-4, $p1y-4, 0, 0, 9, 9);\n\t\t}\n\t}\t\n\treturn 1;\n}\n\nsub plotBoxAxes {\n\tmy $obj = shift;\n\tmy ($p1x, $p1y, $p2x, $p2y);\n\tmy $img = $obj->{img};\n\tmy ($xl, $xh, $yl, $yh) = ($obj->{xl}, $obj->{xh}, \n\t\t$obj->{yl}, $obj->{yh});\n\n\tmy $yaxpt = ((! $obj->{yLog}) && ($yl < 0) && ($yh > 0)) ? 0 : $yl;\n\tmy $xaxpt = ((! $obj->{xLog}) && ($xl < 0) && ($xh > 0)) ? 0 : $xl;\n\t($p1x, $p1y) = $obj->pt2pxl($xl, $yaxpt);\n\t($p2x, $p2y) = $obj->pt2pxl($xh, $yaxpt);\n\t$img->line($p1x, $p1y, $p2x, $p2y, $obj->{gridColor});\n\tmy ($len, $xStart);\n\t($p2x, $p2y) = $obj->pt2pxl($xh, $yl),\n\t$len = $sfw * length($obj->{xAxisLabel}),\n\t$xStart = ($p2x+$len/2 > $obj->{width}-10)\n\t\t? ($obj->{width}-10-$len) : ($p2x-$len/2),\n\t$obj->string(6, 0, $xStart, $p2y+ int(4*$sfh/3), $obj->{xAxisLabel}, $sfw)\n\t\tif ($obj->{xAxisLabel});\n\tmy ($i,$px,$py);\n\tmy $powk;\n\tif ($obj->{xLog}) {\n\t\t$i = $xl;\n\t\tmy $n = 0;\n\t\tmy $k = $i;\n\t\twhile ($i < $xh) {\n\t\t\t$k = $i + $logsteps[$n++];\n\n\t\t\t($px,$py) = $obj->pt2pxl($k, $yl);\n\t\t\t($p1x, $p1y) = ($obj->{vertGrid}) ? \n\t\t\t\t$obj->pt2pxl($k, $yh) : ($px, $py+2);\n\t\t\t$img->line($px, ($obj->{vertGrid} ? $py : $py-2), \n\t\t\t\t$px, $p1y, $obj->{gridColor});\n\n\t\t\t$powk = ($obj->{timeDomain}) ? \n\t\t\t\trestore_temporal(10**$k, $obj->{timeDomain}) : 10**$k,\n\t\t\t$obj->string(6, 90, $px-$sfh/2, $py+length($powk)*$sfw, $powk, $sfw)\n\t\t\t\tif (($n == 1) && ($px+$sfh < $xStart));\n\n\t\t\t($n, $i)  = (0, $k)\n\t\t\t\tif ($n > $#logsteps);\n\t\t}\n\t\treturn 1;\n\t}\n\n    my $step = $obj->{horizStep}; \n   \tmy $prtX;\n\tfor ($i = $xl; $i <= $xh; $i += $step ) {\n\t\t($px,$py) = $obj->pt2pxl($i, \n\t\t\t((($obj->{yLog}) || \n\t\t\t($obj->{vertGrid}) || ($yl > 0) || ($yh < 0)) ? $yl : 0));\n\t\t($p1x, $p1y) = ($obj->{vertGrid}) ? \n\t\t\t$obj->pt2pxl($i, $yh) : ($px, $py+2);\n\t\t$img->line($px, ($obj->{vertGrid} ? $py : $py-2), $px, $p1y, $obj->{gridColor});\n\n\t\tnext if ($obj->{xAxisVert} && ($px+$sfh >= $xStart));\n\t\t$prtX = $obj->{timeDomain} ? restore_temporal($i, $obj->{timeDomain}) : $i;\n\t\t$obj->string(6, 90, $px-($sfh>>1), $py+2+length($prtX)*$sfw, $prtX, $sfw), next\n\t\t\tif ($obj->{xAxisVert});\n\n\t\t$obj->string(6, 0, $px-length($prtX)*($sfw>>1), $py+($sfh>>1), $prtX, $sfw);\n\t}\n\treturn 1;\n}\n\nsub plotAll {\n\tmy ($obj, $type, $typeary) = @_;\n\tmy ($i, $n, $k);\n\tmy @tary = ();\n\t\n\tforeach (0..$#$typeary) {\n\t\tpush(@tary, $_) \n\t\t\tif ($$typeary[$_] == $type);\n\t}\n\n\tforeach $n (@tary) {\n\t\tmy $ary = $obj->{data}->[$n];\n\t\tmy $t = $obj->{props}->[$n];\n\t\t$t=~s/\\s+/ /g;\n\t\tmy @props = split (' ', $t);\n\t\tmy $color = 'black';\n\t\tmy $marker = undef;\n\t\tmy $line = 'line';\n\t\tmy @areacolors = ();\n\t\tmy $stacked = 0;\n\t\tmy $coloridx = 0;\n\t\tmy $legend;\n\t\tmy $lwidth = 1;\n\t\tmy $anchor = 1;\n\t\tmy $showvals = 0;\n\t\tforeach (@props) {\n\t\t\t$marker = $1,\n\t\t\tnext\n\t\t\t\tif /^icon:(\\S+)/i;\n\n\t\t\t$_ = lc $_;\n\t\t\tpush(@areacolors, $_), next\n\t\t\t\tif ($colors{$_});\n\n\t\t\t$stacked = 1, next\n\t\t\t\tif ($_ eq 'stack');\n\n\t\t\t$showvals = $1, next\n\t\t\t\tif /^showvalues:(\\d+)/i;\n\n\t\t\t$marker = $_,\n\t\t\tnext\n\t\t\t\tif ($valid_shapes{$_} && ($_ ne 'null'));\n\n\t\t\t$marker = 'fillcircle',\n\t\t\tnext\n\t\t\t\tif ((! $marker) && ($_ eq 'points'));\n\t\t\t\t\t\n\t\t\t$marker = undef, next \n\t\t\t\tif ($_ eq 'nopoints');\n\n\t\t\t$line = $_, next\n\t\t\t\tif /^(line|noline|fill)$/;\n\n\t\t\t$lwidth = $1, next if /width:(\\d+)/;\n\t\t\t\n\t\t\t$anchor = undef if ($_ eq 'float');\n\t\t}\n\n\t\tif (($line eq 'fill') && $stacked) {\n\t\t\tmy @newary = ();\n\t\t\tmy $j = $#{$ary->[1]};\n\t\t\tmy $k = 0;\n\t\t\tmy $colorcnt = @areacolors;\n\t\t\twhile ($#areacolors < $j) {\n\t\t\t\tpush @areacolors, $areacolors[$k];\n\t\t\t\t$k++;\n\t\t\t\t$k = 0 if ($k == $colorcnt);\n\t\t\t}\n\t\t\tmy $looplim = ($anchor ? 0 : 1);\n\t\t\tmy $ylo = $obj->{yl};\n\t\t\t$ylo = 0 if ($ylo < 0);\n\t\t\tfor (; $j >= $looplim; $j--) {\n\t\t\t\t@newary = ();\n\t\t\t\t$color = $areacolors[$j-$looplim];\n\t\t\t\t$i = 0;\n\t\t\t\tpush(@newary, $$ary[$i], ($anchor ? $ylo : $ary->[$i+1]->[0]), $ary->[$i+1]->[$j]),\n\t\t\t\t$i += 2\n\t\t\t\t\twhile ($i <= $#$ary);\n\t\t\t\t$legend = $obj->{legend} ? $obj->{legend}->[$n]->[$j] : undef;\n\t\t\t\treturn undef unless $obj->plotData($n, \\@newary, $color, 'fill', $marker,\n\t\t\t\t\t$legend, $lwidth, $anchor, $showvals);\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\n\t\t$legend = $obj->{legend} ? $obj->{legend}->[$n] : undef;\n\n\t\tif (($line eq 'fill') && $anchor) {\n\t\t\tmy @newary = ();\n\t\t\t$i = 0;\n\t\t\tmy $yl = $obj->{yl};\n\t\t\tmy $yh = $obj->{yh};\n\t\t\tmy $yaxpt = ((! $obj->{yLog}) && ($yl < 0) && ($yh > 0)) ? 0 : $yl;\n\n\t\t\tpush(@newary, $$ary[$i], $yaxpt, $$ary[$i+1]), $i += 2\n\t\t\t\twhile ($i <= $#$ary);\n\n\t\t\treturn undef unless $obj->plotData($n, \\@newary, \n\t\t\t\t$areacolors[$coloridx], $line, $marker,\n\t\t\t\t$obj->{legend}->[$n], $lwidth, $anchor, $showvals);\n\t\t}\n\t\telse {\n\t\t\treturn undef unless $obj->plotData($n, $ary, $areacolors[$coloridx], $line, $marker,\n\t\t\t\t$obj->{legend}->[$n], $lwidth, $anchor, $showvals);\n\t\t}\n\t\t$coloridx++;\n\t\t$coloridx = 0 if ($coloridx = $#areacolors);\n\t}\n\treturn 1;\n}\n\nsub plotData {\n\tmy ($obj, $k, $ary, $color, $line, $marker, $legend, $lw, $anchor, $showvals) = @_;\n\tmy ($i, $n, $px, $py, $prevpx, $prevpy, $pyt, $pyb);\n\tmy ($img, $prop, $s, $voff);\n\tmy @props = ();\n\tmy ($xl, $xh, $yl, $yh) = ($obj->{xl}, $obj->{xh}, $obj->{yl}, \n\t\t$obj->{yh});\n\tmy ($markw, $markh, $yoff, $wdelta, $hdelta);\n\t$img = $obj->{img};\t\n\n\t$color = 'black' unless $color;\n\t$obj->{$color} = $obj->{img}->colorAllocate(@{$colors{$color}})\n\t\tunless $obj->{$color};\n\t\t\n\tif ($marker) {\n\t\t$marker = ($valid_shapes{$marker} && ($marker ne 'null')) ? \n\t\t\t$obj->make_marker($marker, $color) :\n\t\t\t$obj->getIcon($marker);\n\t\treturn undef unless $marker;\n\t\t($markw, $markh) = $marker->getBounds();\n\t\t$wdelta = $markw>>1;\n\t\t$hdelta = $markh>>1;\n\t}\n\t$yoff = ($marker) ? $markh : 2;\n\t$obj->addLegend($color, $marker, $legend, ($line eq 'line')) if $legend;\n\t$obj->fill_region($obj->{$color}, $ary, $anchor)\n\t\tif ($line eq 'fill');\n\n\t($prevpx, $prevpy) = (0,0);\n\tmy ($prtX, $prtY);\n\n\tmy $domain = $obj->{symDomain} ? $obj->{domain} : $ary;\n\tmy $xhash = $obj->{symDomain} ? $obj->{domainValues} : undef;\n\tmy $domsize = $obj->{symDomain} ? $#$domain : $#$ary;\n\tmy $x;\n\tmy $incr = $obj->{symDomain} ? 1 : ($line eq 'fill') ? 3 : 2;\n\tmy $offset = ($line eq 'fill') ? 2 : 1;\n\tmy $xd;\n\tmy $lbrush;\n\tif ($line eq 'line') {\n\t\t$lbrush = new GD::Image($lw,$lw);\n\t\tmy $ci = $lbrush->colorAllocate(@{$colors{$color}});\n\t\t$lbrush->filledRectangle(0,0,$lw, $lw,$ci);\n\t\t$img->setBrush($lbrush);\n\t}\n\n\tfor ($x = 0; $x <= $domsize; $x += $incr) {\n\t\t$xd = $$xhash{$$domain[$x]} if $obj->{symDomain};\n\t\t$i = $obj->{symDomain} ? $xd * 2: $x;\n\t\tnext unless defined($$ary[$i+1]);\n\n\t\t($px, $py) = $obj->pt2pxl(($obj->{symDomain} ? $xd+1 : $$ary[$i]),\n\t\t\t$$ary[$i+$offset] );\n\n\t\t$img->line($prevpx, $prevpy, $px, $py, gdBrushed)\n\t\t\tif (($line eq 'line') && $i);\n\t\t($prevpx, $prevpy) = ($px, $py);\n\n\t\t$img->copy($marker, $px-$wdelta, $py-$hdelta, 0, 0, $markw, \n\t\t\t$markh)\n\t\t\tif ($marker);\n\n\t\tif ($obj->{genMap} || $showvals) {\n\t\t\t($prtX, $prtY) = ($$ary[$i], $$ary[$i+$offset]);\n\t\t\t$prtY = 10**$prtY if $obj->{yLog};\n\t\t\t$prtX = 10**$prtX if $obj->{xLog};\n\t\t\t$prtY = restore_temporal($prtY, $obj->{timeRange}) if $obj->{timeRange};\n\t\t\t$prtX = restore_temporal($prtX, $obj->{timeDomain}) if $obj->{timeDomain};\n\t\t\t$s = $obj->{symDomain} ? $prtY : \"($prtX,$prtY)\";\n\t\t}\n\t\t\t\n\t\t$obj->updateImagemap('CIRCLE', $s, $k, $prtX, $prtY,\n\t\t\tundef, $px, $py, 4)\n\t\t\tif ($obj->{genMap});\n\n\t\t$voff = (length($s) * $tfw)>>1,\n\t\t$obj->string($showvals,0,$px-$voff,$py-$yoff, $s, $tfw)\n\t\t\tif $showvals;\n\t}\n\treturn 1;\n}\n\nsub addLegend {\n\tmy ($obj, $color, $shape, $text, $line) = @_;\n\tpush @{$obj->{_legends}}, [ $color, $shape, $text, $line ] ;\n\treturn 1;\n}\n\nsub drawLegend {\n\tmy ($obj) = @_;\n\tmy ($color, $shape, $text, $line, $props);\n\tmy $legary = $obj->{_legends};\n\n\tmy $xadj = 30;\n\tmy $xoff = $obj->{horizEdge};\n\tmy $maxyoff = $obj->{height} - 40;\n\tmy $yoff = $obj->{height} - 40 - 20 - (2 * $tfh);\n\tmy ($w, $h);\n\n\twhile (@$legary) {\n\t\t$props = shift @$legary;\n\t\t($color, $shape, $text, $line) = @$props;\n\t\t\n\t\t$color = 'black' unless $color;\n\t\t$shape = $obj->make_marker('fillsquare', $color)\n\t\t\tunless ($shape || $line);\n\t\t($w, $h) = $shape ? $shape->getBounds() : (20, int($tfh * 1.5));\n\n\t\t$yoff = $obj->{height} - 40 - 20 - (2 * $tfh),\n\t\t$xoff += $xadj\n\t\t\tif ($yoff + $h > $maxyoff);\n\n\t\t$xadj = ((($w < 20) ? 20 : $w) + ($tfw * (length($text)+2)))\n\t\t\tif ($xadj < ((($w < 20) ? 20 : $w) + ($tfw * (length($text)+2))));\n\t\t\n\t\tmy $img = $obj->{img};\n\t\t$img->line($xoff, $yoff+4, $xoff+20, $yoff+4, $obj->{$color})\n\t\t\tif $line;\n\n\t\t$obj->string(5, 0,$xoff + ($line ? 25 : ($w + 5)),$yoff, $text, $tfw);\n\n\t\t$img->copy($shape, $xoff+5, $yoff, 0, 0, $w-1, $w-1)\n\t\t\tif $shape;\n\t\t\n\t\t$yoff += ($h < int($tfh * 1.5)) ? int($tfh * 1.5) : $h;\n\t}\n\treturn 1;\n}\n\nsub pt2pxl {\n\tmy ($obj, $x, $y, $z) = @_;\n\tmy $plottype = $obj->{plotTypes} & (HISTO|GANTT);\n\n\treturn (\n\t\tint($obj->{horizEdge} + ($x - $obj->{xl}) * $obj->{xscale}),\n\t\tint($obj->{vertEdge} - ($y - $obj->{yl}) * $obj->{yscale})\n\t ) unless (defined($z) || $plottype);\n\treturn (\n\t\tint($obj->{horizEdge} + ($y - $obj->{yl}) * $obj->{yscale}),\n\t\tint($obj->{vertEdge} - ($x - $obj->{xl}) * $obj->{xscale})\n\t ) unless defined($z);\n\tmy $tx = ($x - $obj->{xl}) * $obj->{xscale};\n\tmy $ty = ($y - $obj->{yl}) * $obj->{yscale};\n\tmy $tz = ($z - $obj->{zl}) * $obj->{zscale};\n\n\treturn\n\t\t$obj->{horizEdge} + int($tx + ($tz * 0.433)),\n\t\t$obj->{vertEdge} - int($ty + ($tz * 0.25))\n\t\tunless $plottype;\n\treturn\n\t\t$obj->{horizEdge} + int($ty + ($tz * 0.433)),\n\t\t$obj->{vertEdge} - int($tx + ($tz * 0.25));\n}\n\nsub plotAxes {\n\tmy $obj = shift;\n\treturn $obj->plot3DAxes\n\t\tif ($obj->{zAxisLabel} || $obj->{threed});\n\n\tmy ($p1x, $p1y, $p2x, $p2y);\n\tmy $img = $obj->{img};\n\tmy ($xl, $xh, $yl, $yh) = ($obj->{xl}, $obj->{xh}, \n\t\t$obj->{yl}, $obj->{yh});\n\n\tmy $yaxpt = ((! $obj->{yLog}) && ($yl < 0) && ($yh > 0)) ? 0 : $yl;\n\tmy $xaxpt = ((! $obj->{xLog}) && ($xl < 0) && ($xh > 0)) ? 0 : $xl;\n\tmy $plottypes = $obj->{plotTypes};\n\t\n\tif ($obj->{vertGrid} || $obj->{horizGrid}) {\n\t\t($p1x, $p1y) = $obj->pt2pxl ($xl, $yl);\n\t\t($p2x, $p2y) = $obj->pt2pxl ($xh, $yh);\n\n  \t\t$img->rectangle( $p1x, $p1y, $p2x, $p2y, $obj->{gridColor});\n\t\t($p1x, $p1y) = $obj->pt2pxl($xl, $yaxpt);\n\t\t($p2x, $p2y) = $obj->pt2pxl($xh, $yaxpt);\n\t\t$img->filledRectangle($p1x, $p1y-1,$p2x, $p2y-1,$obj->{gridColor}); \n\t\t($p1x, $p1y) = $obj->pt2pxl($xaxpt, $yl);\n\t\t($p2x, $p2y) = $obj->pt2pxl($xaxpt, $yh);\n\t\t$img->filledRectangle($p1x-1, $p2y,$p2x+1, $p1y,$obj->{gridColor}); \n  \t}\n  \telse {\n\t\t($p1x, $p1y) = $obj->pt2pxl($xl, $yaxpt);\n\t\t($p2x, $p2y) = $obj->pt2pxl($xh, $yaxpt);\n\t\t$img->line($p1x, $p1y, $p2x, $p2y, $obj->{gridColor});\n\t\t($p1x, $p1y) = $obj->pt2pxl($xl, $yl),\n\t\t($p2x, $p2y) = $obj->pt2pxl($xh, $yl),\n\t\t$img->line($p1x, $p1y, $p2x, $p2y, $obj->{gridColor})\n\t\t\tif ($yl < 0);\n\t}\n\tmy ($len, $xStart, $xStart2);\n\t($p2x, $p2y) = $obj->pt2pxl($xh, $yl);\n\t$len = $sfw * length($obj->{xAxisLabel}),\n\t$xStart = ($p2x+$len/2 > $obj->{width}-10)\n\t\t? ($obj->{width}-10-$len) : ($p2x-$len/2),\n\t$obj->string(6,0, $xStart, $p2y+ int(4*$sfh/3), $obj->{xAxisLabel}, $sfw)\n\t\tif ($obj->{xAxisLabel});\n\n\t($p1x, $p1y) = $obj->pt2pxl($xaxpt, $yl);\n\t($p2x, $p2y) = $obj->pt2pxl((($obj->{vertGrid}) ? $xl : $xaxpt), $yh);\n\t\n\t$img->line($p1x, $p1y, $p2x, $p2y, $obj->{gridColor})\n\t\tif ((! $obj->{'vertGrid'}) && (! $obj->{horizGrid}));\n\n\t$xStart2 = $p2x - length($obj->{yAxisLabel}) * ($sfw >> 1),\n\t$obj->string(6,0, ($xStart2 > 10 ? $xStart2 : 10), \n\t\t$p2y - 3*($sfh>>1), $obj->{yAxisLabel}, $sfw)\n\t\tif ($obj->{yAxisLabel});\n\tmy ($i,$px,$py, $step, $j, $txt);\n   \tmy $prevx = 0;\n\tmy $powk;\n\tif ($obj->{xLog}) {\n\t\t$i = $xl;\n\t\tmy $n = 0;\n\t\tmy $k = $i;\n\t\twhile ($i < $xh) {\n\t\t\t$k = $i + $logsteps[$n++];\n\n\t\t\t($px,$py) = $obj->pt2pxl($k, $yl);\n\t\t\t($p1x, $p1y) = ($obj->{vertGrid}) ? \n\t\t\t\t$obj->pt2pxl($k, $yh) : ($px, $py+2);\n\t\t\t$img->line($px, ($obj->{vertGrid} ? $py : $py-2), \n\t\t\t\t$px, $p1y, $obj->{gridColor});\n\t\t\t$powk = ($obj->{timeDomain}) ? \n\t\t\t\trestore_temporal(10**$k, $obj->{timeDomain}) : 10**$k,\n\t\t\t$obj->string(6, 90, $px-$sfh/2, \n\t\t\t\t$py+length($powk)*$sfw, $powk)\n\t\t\t\tif (($n == 1) && ($px+$sfh < $xStart));\n\n\t\t\t($n, $i)  = (0 , $k)\n\t\t\t\tif ($n > $#logsteps);\n\t\t}\n\t}\n\telsif ($obj->{symDomain}) {\n\t\tmy $ary = $obj->{domain};\n    \n\t\tfor ($i = 1, $j = 0; $i < $xh; $i++, $j++ ) {\n\t\t\t($px,$py) = $obj->pt2pxl($i, $yl);\n\t\t\t($p1x, $p1y) = ($obj->{vertGrid}) ? \n\t\t\t\t$obj->pt2pxl($i, $yh) : ($px, $py+2);\n\t\t\t$img->line($px, ($obj->{vertGrid} ? $py : $py-2), \n\t\t\t\t$px, $p1y, $obj->{gridColor});\n\t\t\tnext if ($obj->{xAxisVert} && ($sfh+1 > ($px - $prevx)));\n\t\t\t$txt = ($obj->{timeDomain}) ? \n\t\t\t\trestore_temporal($$ary[$j], $obj->{timeDomain}) : $$ary[$j];\n\t\t\t$txt = substr($txt, 0, 22) . '...' \n\t\t\t\tif (length($txt) > 25);\n\n\t\t\tif ($obj->{xAxisVert}) {\n\t\t\t\t$prevx = $px;\n\t\t\t\tnext if ($px+$sfh >= $xStart);\n\t\t\t\t$obj->string(6, 90, $px-($sfh>>1), \n\t\t\t\t\t$py+2+length($txt)*$sfw, $txt, $sfw);\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\tnext if (((length($txt)+1) * $sfw) > ($px - $prevx));\n\t\t\t$prevx = $px;\n\n\t\t\t$obj->string(6,0, $px-length($txt)*($sfw>>1), \n\t\t\t\t$py+($sfh>>1), $txt, $sfw);\n\t\t}\n\t}\n\telse {\n\t    $step = $obj->{horizStep}; \n\t\tfor ($i = $xl; $i <= $xh; $i += $step ) {\n\t\t\t($px,$py) = $obj->pt2pxl($i, $yl);\n\t\t\t($p1x, $p1y) = ($obj->{vertGrid}) ? \n\t\t\t\t$obj->pt2pxl($i, $yh) : ($px, $py+2);\n\t\t\t$img->line($px, ($obj->{vertGrid} ? $py : $py-2), \n\t\t\t\t$px, $p1y, $obj->{gridColor});\n\n\t\t\t$txt = ($obj->{timeDomain}) ? \n\t\t\t\trestore_temporal($i, $obj->{timeDomain}) : $i;\n\t\t\t$txt = substr($txt, 0, 22) . '...' \n\t\t\t\tif (length($txt) > 25);\n\n\t\t\tnext if ((! $obj->{xAxisVert}) && \n\t\t\t\t($px - $prevx < (length($txt) * $sfw)));\n\t\t\tnext if ($obj->{xAxisVert} && ($px - $prevx < $sfw));\n\t\t\t$prevx = $px;\n\t\t\tnext if ($obj->{xAxisVert} &&  ($px+$sfh >= $xStart));\n\t\t\t\n\t\t\t$obj->string(6, 90, $px-($sfh>>1), \n\t\t\t\t$py+2+length($txt)*$sfw, $txt, $sfw),\n\t\t\tnext\n\t\t\t\tif ($obj->{xAxisVert});\n\n\t\t\t$obj->string(6, 0,$px-length($txt)*($sfw>>1), \n\t\t\t\t$py+($sfh>>1), $txt, $sfw);\n\t\t}\n\t}\n\tif ($obj->{yLog}) {\n\t\t$i = $yl;\n\t\tmy $n = 0;\n\t\tmy $k = $yl;\n\t\twhile ($k < $yh) {\n\t\t\t($px,$py) = $obj->pt2pxl(\n\t\t\t\t((($obj->{xLog}) || ($obj->{horizGrid})) ? \n\t\t\t\t$xl : $xaxpt), $k);\n\t\t\t($p1x, $p1y) = ($obj->{horizGrid}) ? \n\t\t\t\t$obj->pt2pxl($xh, $k) : ($px+2, $py);\n\t\t\t$img->line(($obj->{horizGrid} ? $px : $px-2), $py, \n\t\t\t\t$p1x, $py, $obj->{gridColor});\n\n\t\t\t$powk = ($obj->{timeRange}) ? \n\t\t\t\trestore_temporal(10**$k, $obj->{timeRange}) : 10**$k,\n\t\t\t$obj->string(6, 0, $px-5-length($powk)*$sfw, \n\t\t\t\t$py-($sfh>>1), $powk, $sfw)\n\t\t\t\tif ($n == 0);\n\t\t\t\n\t\t\t$k = $i + $logsteps[$n++];\n\t\t\t($n, $i) = (0, $k)\n\t\t\t\tif ($n > $#logsteps);\n\t\t}\n\t\treturn 1;\n\t}\n\n\t$step = $obj->{vertStep};\n\t($px,$py) = $obj->pt2pxl((($obj->{horizGrid}) ? $xl : $xaxpt), $yl);\n\t($p1x,$p1y) = $obj->pt2pxl((($obj->{horizGrid}) ? $xl : $xaxpt), \n\t\t$yl+$step);\n\tmy $skip = ($p1y - $py < ($sfh<<1)) ? 1 : 0;\n\tmy $tickv = $yl;\n\tfor ($i=0, $j = 0; $tickv < $yh; $i++, $j++ ) {\n\t\t$tickv = $yl + ($i * $step);\n\t\tlast if ($tickv > $yh);\n\t\t($px,$py) = $obj->pt2pxl((($obj->{horizGrid}) ? $xl : $xaxpt), $tickv);\n\t\t($p1x, $p1y) = ($obj->{horizGrid}) ? \n\t\t\t$obj->pt2pxl($xh, $tickv) : ($px+2, $py);\n\t\t$img->line(($obj->{horizGrid} ? $px : $px-2), $py, $p1x, $py, \n\t\t\t$obj->{gridColor});\n\n\t\tnext if (($skip) && ($j&1));\n\t\t$txt = $obj->{timeRange} ? restore_temporal($tickv, $obj->{timeRange}) : $tickv,\n\t\t$obj->string(6,0, $px-5-length($txt)*$sfw, $py-($sfh>>1), $txt, $sfw);\n\t}\n\treturn 1;\n}\n\nsub plotHistoAxes {\n\tmy ($obj) = @_;\n\treturn $obj->plot3DAxes\n\t\tif ($obj->{zAxisLabel} || $obj->{threed});\n\n\tmy ($p1x, $p1y, $p2x, $p2y);\n\tmy $img = $obj->{img};\n\tmy ($xl, $xh, $yl, $yh) = ($obj->{xl}, $obj->{xh}, \n\t\t$obj->{yl}, $obj->{yh});\n\tmy $plottypes = $obj->{plotTypes};\n\t($p1x, $p1y) = $obj->pt2pxl ($xl, $yl),\n\t($p2x, $p2y) = $obj->pt2pxl($xh, $yl),\n\t$img->line($p1x, $p1y, $p2x, $p2y, $obj->{gridColor}),\n\t($p2x, $p2y) = $obj->pt2pxl ($xl, $yh),\n\t$img->line($p1x, $p1y, $p2x, $p2y, $obj->{gridColor})\n\t\tunless ($obj->{vertGrid} || $obj->{horizGrid});\n\n\tif ($obj->{vertGrid} || $obj->{horizGrid}) {\n\t\t($p1x, $p1y) = $obj->pt2pxl($xl, $yl);\n\t\t($p2x, $p2y) = $obj->pt2pxl($xl, $yh);\n\t\t$img->filledRectangle($p1x, $p1y-1, $p2x, $p2y-1,$obj->{gridColor}); \n\t\t($p1x, $p1y) = $obj->pt2pxl($xl, $yl);\n\t\t($p2x, $p2y) = $obj->pt2pxl($xh, $yl);\n\t\t$img->filledRectangle($p1x-1, $p2y, $p2x+1, $p1y,$obj->{gridColor}); \n\n\t\t($p1x, $p1y) = $obj->pt2pxl($xl, 0),\n\t\t($p2x, $p2y) = $obj->pt2pxl($xh, 0),\n\t\t$img->filledRectangle($p1x-1, $p2y, $p2x+1, $p1y,$obj->{gridColor})\n\t\t\tif (($yl < 0) && ($yh > 0));\n\t\t($p1x, $p1y) = $obj->pt2pxl ($xh, $yl);\n\t\t($p2x, $p2y) = $obj->pt2pxl ($xl, $yh);\n  \t\t$img->rectangle( $p1x, $p1y, $p2x, $p2y, $obj->{gridColor});\n  \t}\n\tmy ($len, $xStart, $xStart2);\n\t$len = $sfw * length($obj->{yAxisLabel}),\n\t$xStart = ($p2x+$len/2 > $obj->{width}-10) ? \n\t\t($obj->{width}-10-$len) : ($p2x-$len/2),\n\t$obj->string(6,0, $xStart, $p2y+ int(4*$sfh/3), $obj->{yAxisLabel}, $sfw)\n\t\tif ($obj->{yAxisLabel});\n\n\t($p2x, $p2y) = $obj->pt2pxl($xh, $yl),\n\t$xStart2 = $p2x - ((length($obj->{xAxisLabel}) * $sfw) >> 1),\n\t$obj->string(6, 0,($xStart2 > 10 ? $xStart2 : 10), \n\t\t$p2y - 3*($sfh>>1), $obj->{xAxisLabel}, $sfw)\n\t\tif $obj->{xAxisLabel};\n\tmy ($i,$px,$py, $step, $j, $txt);\n\tmy $ary = $obj->{domain};\n    \n\tmy $prevx = $obj->{vertEdge};\n\tfor ($i = 1, $j = 0; $i < $xh; $i++, $j++) {\n\t\t($px,$py) = $obj->pt2pxl($i, $yl);\n\t\t($p1x, $p1y) = ($obj->{horizGrid}) ? \n\t\t\t$obj->pt2pxl($i, $yh) : ($px+2, $py);\n\t\t$img->line(($obj->{horizGrid} ? $px : $px-2), $py, \n\t\t\t$p1x, $py, $obj->{gridColor});\n\t\tnext unless (($plottypes & HISTO) && defined($$ary[$j]) && ($sfh < ($prevx - $py)));\n\t\t$prevx = $py;\n\t\t$txt = ($obj->{timeDomain}) ? \n\t\t\trestore_temporal($$ary[$j], $obj->{timeDomain}) : $$ary[$j];\n\t\t$txt = substr($txt, 0, 22) . '...' \n\t\t\tif (length($txt) > 25);\n\n\t\t$obj->string(6, 0, ($px-(length($txt)*$sfw)-5), \n\t\t\t$py-($sfh>>1), $txt, $sfw);\n\t}\n\t$prevx = 0;\n\tif ($obj->{yLog}) {\n\t\t$i = $yl;\n\t\tmy $n = 0;\n\t\tmy $k = $i;\n\t\tmy $powk;\n\t\twhile ($i < $yh) {\n\t\t\t$k = $i + $logsteps[$n++];\n\t\t\t($px,$py) = $obj->pt2pxl($xl, $k);\n\t\t\t($p1x, $p1y) = ($obj->{vertGrid}) ? \n\t\t\t\t$obj->pt2pxl($xh, $k) : ($px, $py+2);\n\t\t\t$img->line($px, ($obj->{vertGrid} ? $py : $py-2),\n\t\t\t\t$px, $p1y, $obj->{gridColor});\n\t\t\tnext if ($obj->{xAxisVert} && ($sfh > ($px - $prevx)));\n\n\t\t\t$powk = ($obj->{timeRange}) ? \n\t\t\t\trestore_temporal(10**$k, $obj->{timeRange}) : 10**$k;\n\n\t\t\t($n, $i)  = (0, $k)\n\t\t\t\tif ($n > $#logsteps);\n\n\t\t\tnext if (length($powk) * ($sfw>>1) > ($px - $prevx));\n\t\t\tnext unless ($n == 1);\n\n\t\t\t$prevx = $px;\n\n\t\t\tnext if ($obj->{xAxisVert} && ($px+$sfh >= $xStart));\n\t\t\t$obj->string(6, 90, $px-($sfh>>1), \n\t\t\t\t$py+2+length($powk)*$sfw, $powk, $sfw),\n\t\t\tnext\n\t\t\t\tif $obj->{xAxisVert};\n\n\t\t\t$obj->string(6, 0, $px-(length($powk) * ($sfw>>1)),\n\t\t\t\t$py+4, $powk, $sfw);\n\t\t}\n\t\treturn 1;\n\t}\n\n\t$step = $obj->{horizStep};\n\tfor ($i=$yl, $j = 0; $i <= $yh; $i+=$step, $j++ ) {\n\t\t($px,$py) = $obj->pt2pxl($xl, $i);\n\t\t($p1x,$p1y) = ($obj->{vertGrid}) ? $obj->pt2pxl($xh, $i) : ($px, $py+2);\n\t\t$img->line($px, ($obj->{vertGrid} ? $py : $py-2), $px, $p1y, $obj->{gridColor});\n\t\tnext if ($obj->{xAxisVert} && ($px - $prevx < $sfh+3));\n\n\t\t$txt = $obj->{timeRange} ? restore_temporal($i, $obj->{timeRange}) : $i;\n\t\tnext unless ($obj->{xAxisVert} || \n\t\t\t(length($txt) * ($sfw>>1) < ($px - $prevx)));\n\t\t$prevx = $px;\n\n\t\tnext if ($obj->{xAxisVert} && ($px+$sfh >= $xStart));\n\t\t$obj->string(6, 90, $px-($sfh>>1), \n\t\t\t$py+2+length($txt)*$sfw, $txt, $sfw),\n\t\tnext\n\t\t\tif $obj->{xAxisVert};\n\n\t\t$obj->string(6,0, $px-(length($txt) * ($sfw>>1)),\n\t\t\t$py+4, $txt, $sfw);\n\t}\n\treturn 1;\n}\n\nsub drawTitle {\n\tmy ($obj) = @_;\n\tmy ($w,$h) = (gdMediumBoldFont->width, gdMediumBoldFont->height);\n\n\tmy ($px,$py) = ($obj->{width}/2, $obj->{height} - 40 + $h);\n\n\t($px,$py) = ($px - length ($obj->{title}) * $w/2, $py-$h/2);\n\t$obj->string(7, 0, $px, $py, $obj->{title}, $w); \n}\n\nsub drawSignature {\n\tmy ($obj) = @_;\n\tmy $fw = ($tfw * length($obj->{signature})) + 5;\n\tmy ($px,$py) = ($obj->{width} - $fw, $obj->{height} - ($tfh * 2));\n\n\t$obj->string(5, 0, $px, $py, $obj->{signature}, $tfw); \n}\n\nsub fill_region {\n\tmy ($obj, $ci, $ary, $anchor) = @_;\n\tmy $img = $obj->{img};\n\tmy($x, $y, $xbot, $ybot, $xval);\n\tmy @bottom;\n\tmy $poly = GD::Polygon->new();\n\tfor (my $i = 0; $i < @$ary; $i += 3)\n\t{\n\t\tnext unless defined($$ary[$i]);\n\t\t$xval = $obj->{symDomain} ? ($i/3)+1 : $$ary[$i];\n\t\t($x, $y) = $obj->pt2pxl($xval, $$ary[$i+2]);\n\t\t($xbot, $ybot) = $obj->pt2pxl($xval, $$ary[$i+1]);\n\t\t$poly->addPt($x, $y);\n\t\tpush @bottom, [$x, $ybot];\n\t}\n\n\t$poly->addPt($_->[0], $_->[1])\n\t\tforeach (reverse @bottom);\n\n\t$img->filledPolygon($poly, $ci);\n\t$img->polygon($poly, $ci);\n\n\t1;\n}\n\nsub make_marker {\n\tmy ($obj, $mtype, $mclr) = @_;\n\n\tmy $brush = new GD::Image(9,9);\n\tmy $white = $brush->colorAllocate(255, 255, 255);\n\tmy $clr = $brush->colorAllocate(@{$colors{$mclr}});\n\t$brush->transparent($white);\n\t$mtype = $valid_shapes{$mtype};\n\n\t$brush->filledRectangle(0,0,6,6,$clr),\n\treturn $brush\n\t\tif ($mtype == 1);\n\n\t$brush->rectangle( 0, 0, 6, 6, $clr ),\n\treturn $brush\n\t\tif ($mtype == 2);\n\n\t$brush->line( 0, 4, 8, 4, $clr ),\n\t$brush->line( 4, 0, 4, 8, $clr ),\n\treturn $brush\n\t\tif ($mtype == 3);\n\n\t$brush->line( 0, 0, 8, 8, $clr ),\n\t$brush->line( 8, 0, 0, 8, $clr ),\n\treturn $brush\n\t\tif ($mtype == 4);\n\n\t$brush->line( 0, 4, 4, 8, $clr ),\n\t$brush->line( 4, 8, 8, 4, $clr ),\n\t$brush->line( 8, 4, 4, 0, $clr ),\n\t$brush->line( 4, 0, 0, 4, $clr ),\n\t$brush->fillToBorder( 4, 4, $clr, $clr ),\n\treturn $brush\n\t\tif ($mtype == 5);\n\n\t$brush->line( 0, 4, 4, 8, $clr ),\n\t$brush->line( 4, 8, 8, 4, $clr ),\n\t$brush->line( 8, 4, 4, 0, $clr ),\n\t$brush->line( 4, 0, 0, 4, $clr ),\n\treturn $brush\n\t\tif ($mtype == 6);\n\n\t$brush->arc( 4, 4, 8 , 8, 0, 360, $clr ),\n\t$brush->fillToBorder( 4, 4, $clr, $clr ),\n\treturn $brush,\n\t\tif ($mtype == 7);\n\n\t$brush->arc( 4, 4, 8, 8, 0, 360, $clr ),\n\treturn $brush\n\t\tif ($mtype == 8);\n\t$brush->setPixel( 4,4, $clr ),\n\treturn  $brush\n \t\tif ( $mtype == 10 );\n}\n\nsub getIcon {\n\tmy ($obj, $icon, $isbar) = @_;\n\tmy $pat = GD::Image->can('newFromGif') ? \n\t\t'png|jpe?g|gif' : 'png|jpe?g';\n\n\t$obj->{errmsg} = \n\t'Unrecognized icon file format. File qualifier must be .png, .jpg, ' . \n\t\t(GD::Image->can('newFromGif') ? '.jpeg, or .gif.' : 'or .jpeg.'),\n\treturn undef\n\t\tunless ($icon=~/\\.($pat)$/i);\n\n\t$obj->{errmsg} = \"Unable to open icon file $icon.\",\n\treturn undef\n\t\tunless open(ICON, \"<$icon\");\n\n\tmy $iconimg = ($icon=~/\\.png$/i) ? GD::Image->newFromPng(*ICON) :\n\t  ($icon=~/\\.gif$/i) ? GD::Image->newFromGif(*ICON) :\n\t    GD::Image->newFromJpeg(*ICON);\n\tclose(ICON);\n\t$obj->{errmsg} = \"GD cannot read icon file $icon.\",\n\treturn undef\n\t\tunless $iconimg;\n\n\tmy ($iconw, $iconh) = $iconimg->getBounds();\n\t$obj->{errmsg} = \"Icon image $icon too wide for chart image.\",\n\treturn undef\n\t\tif (($isbar && ($iconw > $obj->{brushWidth})) ||\n\t\t\t($iconw > $obj->{plotWidth}));\n\t\t\n\t$obj->{errmsg} = \"Icon image $icon too tall for chart image.\",\n\treturn undef\n\t\tif ($iconh > $obj->{plotHeight});\n\treturn $iconimg;\n}\n\nsub drawIcons {\n\tmy ($obj, $iconimg, $pxl, $pyb, $pxr, $pyt) = @_;\n\tmy ($iconw, $iconh) = $iconimg->getBounds();\n\tmy $img = $obj->{img};\n\tif ($pxl == $pxr) {\n\t\t$pxl -= int($iconw/2);\n\n\t\tmy $srcY = 0;\n\t\tmy $h = $iconh;\n\t\t$img->copy($iconimg, $pxl, $pyb, 0, $srcY, $iconw, $h),\n\t\treturn 1\n\t\t\tif ($pyt == 0);\n\n\t\twhile ($pyb > $pyt) {\t\n\t\t\t$h = $pyb - $pyt,\n\t\t\t$srcY = $iconh - $h,\n\t\t\t\tif ($iconh > ($pyb - $pyt));\n\t\t\t$pyb -= $h;\n\t\t\t$img->copy($iconimg, $pxl, $pyb, 0, $srcY, $iconw, $h);\n\t\t}\n\t\treturn 1;\n\t}\n\t$pyb -= int($iconh/2); \n\n\tmy $limX = $iconw;\n\twhile ($pxl < $pxr) {\t\n\t\t$limX = ($pxr - $pxl) if ($iconw > ($pxr - $pxl));\n\t\t$img->copy($iconimg, $pxl, $pyb, 0, 0, $limX, $iconh);\n\t\t$pxl += $limX;\n\t}\n\t1;\n}\n\nsub plot3DAxes {\n\tmy ($obj) = @_;\n\tmy $img = $obj->{img};\n\tmy ($xl, $xh, $yl, $yh, $zl, $zh) = \n\t\t($obj->{xl}, $obj->{xh}, $obj->{yl}, $obj->{yh}, $obj->{zl}, $obj->{zh});\n\n\tmy $numRanges = scalar @{$obj->{data}};\n\tmy $zbarw = ($obj->{zh} - $obj->{zl})/($obj->{zAxisLabel} ? $obj->{Zcard}*2 : 2);\n\tmy $ishisto = ($obj->{plotTypes} & HISTO);\n\n\t$zl -= (0.8);\n\t$zh += $zbarw;\n\tmy $yc = ($yl < 0) ? 0 : $yl;\n\tmy @v = ($ishisto) ? \n\t(\n\t\t$xl, $yl, $zl,\t\n\t\t$xl, $yl, $zh,\t\n\t\t$xh, $yl, $zl,\t\n\t\t$xh, $yl, $zh,\t\n\t\t$xl, $yh, $zl,\t\n\t\t$xl, $yh, $zh,\t\n\t\t$xh, $yh, $zh,\t\n\t\t$xl, $yl, $zl,\t\n\t\t$xl, $yh, $zl,\t\n\t\t$xl, $yh, $zh,\t\n\t\t$xl, $yl, $zh\t\n\t) :\n\t(\n\t\t$xl, $yl, $zl,\t\n\t\t$xl, $yl, $zh,\t\n\t\t$xl, $yh, $zl,\t\n\t\t$xl, $yh, $zh,\t\n\t\t$xh, $yl, $zl,\t\n\t\t$xh, $yl, $zh,\t\n\t\t$xh, $yh, $zh,\t\n\t\t$xl, $yc, $zl,\t\n\t\t$xh, $yc, $zl,\t\n\t\t$xh, $yc, $zh,\t\n\t\t$xl, $yc, $zh\t\n\t);\n\tmy @xlatverts = ();\n\tmy ($i, $j);\n\tfor ($i = 0; $i <= $#v; $i+=3) {\n\t\tpush(@xlatverts, $obj->pt2pxl($v[$i], $v[$i+1], $v[$i+2]));\n\t}\n\tfor ($i = 0; $i <= $#axesverts; $i+=2) {\n\t\t$img->line($xlatverts[$axesverts[$i]],\n\t\t\t$xlatverts[$axesverts[$i]+1],\n\t\t\t$xlatverts[$axesverts[$i+1]],\n\t\t\t$xlatverts[$axesverts[$i+1]+1], $obj->{gridColor});\n\t}\n\tmy ($gx, $gy, $hx, $hy);\n\tif ($obj->{horizGrid}) {\n\t\tmy ($imax, $imin, $step) = \n\t\t\t($obj->{yh}, $obj->{yl}, \n\t\t\t\t($ishisto ? $obj->{horizStep} : $obj->{vertStep}));\n\t\t\n\t\tfor ($i = $imin; $i < $imax; $i += $step) {\n\t\t\t($gx, $gy) = $obj->pt2pxl($xl, $i, $zl);\n\t\t\t($hx, $hy) = $obj->pt2pxl($xl, $i, $zh);\n\t\t\t$img->line($gx, $gy, $hx, $hy, $obj->{gridColor});\n\t\t\t($gx, $gy) = $obj->pt2pxl($xh, $i, $zh);\n\t\t\t$img->line($gx, $gy, $hx, $hy, $obj->{gridColor});\n\t\t}\n\t}\n\tmy ($xal, $yal, $zal) = ($obj->{plotTypes} & HISTO) ? \n\t\t($obj->{yAxisLabel}, $obj->{xAxisLabel}, $obj->{zAxisLabel}) :\n\t\t($obj->{xAxisLabel}, $obj->{yAxisLabel}, $obj->{zAxisLabel});\n\tif ($xal) {\n\t\t($gx, $gy) = ($yc == $yl) ? $obj->pt2pxl($v[12], $v[13], $v[14]) :\n\t\t\t$obj->pt2pxl($v[15], $v[16], $v[17]);\n\t\t$gx -= ($sfw * length($xal)),\n\t\t$gy += 10,\n\t\t$obj->string(6, 0, $gx, $gy, $xal, $sfw);\n\t}\n\n\t($gx, $gy) = $obj->pt2pxl($v[9], $v[10], $v[11]),\n\t$gx -= ($sfw * length($yal)/2),\n\t$gy -= ($sfh + 5),\n\t$obj->string(6, 0, $gx, $gy, $yal, $sfw)\n\t\tif $yal;\n\n\t($gx, $gy) = $obj->pt2pxl($v[15], $v[16], $v[17]),\n\t$gx += $sfh + 10,\n\t$gy += ($sfw * length($zal)),\n\t$obj->string(6, 90, $gx, $gy, $zal, $sfw)\n\t\tif $zal;\n\n\t$obj->{xlatVerts} = \\@xlatverts;\n\t1;\n}\n\nsub plot3DTicks {\n\tmy ($obj) = @_;\n\tmy $img = $obj->{img};\n\tmy ($xl, $xh, $yl, $yh, $zl, $zh) =\n\t\t($obj->{xl}, $obj->{xh}, $obj->{yl}, $obj->{yh}, $obj->{zl}, $obj->{zh});\n\n\tmy $numRanges = scalar @{$obj->{data}};\n\tmy $zcard = $obj->{zAxisLabel} ? $obj->{Zcard} : 1;\n\tmy $zbarw = ($zh - $zl)/($zcard*2);\n\tmy $ishisto = ($obj->{plotTypes} & HISTO);\n\n\tmy $data = $obj->{data}->[0];\n\t$zl -= (0.8);\n\t$zh += $zbarw;\n\tmy $yc = ($yl < 0) ? 0 : $yl;\n\tmy $i;\n\tmy $xlatverts = $obj->{xlatVerts};\n\n\tmy $text = '';\n\tmy ($gx, $gy, $hx, $hy);\n\tif ($obj->{zAxisLabel}) {\n\t\tmy $zs = $obj->{zValues};\n\t\tmy $xv = $ishisto ? $xl : $xh;\n\t\tmy $yv = $ishisto ? $yh : $yl;\n\t\tforeach (0..$#$zs) {\n\t\t\t($gx, $gy) = $obj->pt2pxl($xv, $yv, $_+1+0.8);\n\t\t\t$text = $$zs[$_];\n\t\t\t$text = substr($text, 0, 22) . '...' if (length($text) > 25);\n\t\t\t$obj->string(6, 0, $gx, $gy, $text, $sfw);\n\t\t}\n\t}\n\tmy $xs = $obj->{xValues};\n\tmy $xoff = ($yl >= 0) ? 1 : $ishisto ? 0 : 0.5;\n\tmy $zv = (($yl >= 0) || $ishisto) ? $zl : $zh; \n\tforeach (0..$#$xs) {\n\t\t($gx, $gy) = $obj->pt2pxl($_+$xoff, $yl, $zv);\n\t\t$text = $$xs[$_];\n\t\t$text = substr($text, 0, 22) . '...' if (length($text) > 25);\n\n\t\t$gy += (length($text) * $sfw) + 5,\n\t\t$obj->string(6, 90, $gx-($sfh>>1), $gy, $text, $sfw),\n\t\tnext\n\t\t\tunless $ishisto;\n\n\t\t$gx -= (length($text) * $sfw) + 5;\n\t\t$obj->string(6, 0, $gx, $gy-($sfw>>1), $text, $sfw);\n\t}\n\tmy $ystep = $ishisto ? $obj->{horizStep} : $obj->{vertStep};\n\tfor ($i = $yl; $i < $yh; $i += $ystep) {\n\t\t($gx, $gy) = $obj->pt2pxl($xl, $i, $zl);\n\t\t$text = $i;\n\t\t$text = substr($text, 0, 22) . '...' if (length($text) > 25);\n\n\t\t$gx -= ((length($text) * $sfw) + 5),\n\t\t$obj->string(6, 0, $gx, $gy-($sfw>>1), $text, $sfw),\n\t\tnext\n\t\t\tunless $ishisto;\n\n\t\t$gy += ((length($text) * $sfw) + 5),\n\t\t$obj->string(6, 90, $gx-($sfh>>1), $gy, $text, $sfw);\n\t}\n\treturn 1 if $ishisto;\n\tfor ($i = 18; $i <= $#axesverts; $i+=2) {\n\t\t$img->line($$xlatverts[$axesverts[$i]],\n\t\t\t$$xlatverts[$axesverts[$i]+1],\n\t\t\t$$xlatverts[$axesverts[$i+1]],\n\t\t\t$$xlatverts[$axesverts[$i+1]+1], $obj->{gridColor});\n\t}\n\n\t1;\n}\n\nsub plot3DBars {\n\tmy ($obj) = @_;\n\t\n\tmy $img = $obj->{img};\n\tmy $numRanges = scalar @{$obj->{data}};\n\tmy ($xoff, $zcard) = ($obj->{zAxisLabel}) ? \n\t\t(1.0, $obj->{Zcard}) : (0.9, 1);\n\tmy $xbarw = $xoff/$numRanges;\n\tmy $zbarw = ($obj->{zh} - $obj->{zl})/($zcard*2);\n\tmy ($xvals, $zvals) = ($obj->{xValues}, $obj->{zValues});\n\tmy @fronts = ();\n\tmy @tops = ();\n\tmy @sides = ();\n\tmy $legend = $obj->{legend};\n\tmy $k = 0;\n\tmy $color = 'black';\n\tmy $ary;\n\tmy $showvals;\n\tmy $ys;\n\tmy $t;\n\tmy $numPts = $#{$obj->{data}->[0]};\n\tmy @props;\n\tmy $stacked = undef;\n\tmy @barcolors = ();\n\tmy $svfont = 5;\n\tfor ($k = 0; $k < $numRanges; $k++) {\n\t\tpush @tops, [];\n\t\tpush @fronts, [];\n\t\tpush @sides, [];\n\t\t$t = $obj->{props}->[$k];\n\t\t$t=~s/\\s+/ /g;\n\t\t$t = lc $t;\n\t\t@props = split (' ', $t);\n\t\t$stacked = 0;\n\t\tforeach (@props) {\n\t\t\t$showvals = [ ], $svfont = $1, next if /^showvalues:(\\d+)/i;\n\t\t\t$stacked = 1, next if ($_ eq 'stack');\n\t\t\t$color = $_,\n\t\t\tpush(@barcolors, $_),\n\t\t\t$obj->{$color} = $img->colorAllocate(@{$colors{$_}}),\n\t\t\tpush(@{$tops[$k]}, $obj->{$color}),\n\t\t\tpush(@{$fronts[$k]}, $img->colorAllocate(int($colors{$_}->[0] * 0.8), \n\t\t\t\tint($colors{$_}->[1] * 0.8), int($colors{$_}->[2] * 0.8))),\n\t\t\tpush(@{$sides[$k]}, $img->colorAllocate(int($colors{$_}->[0] * 0.6), \n\t\t\t\tint($colors{$_}->[1] * 0.6), int($colors{$_}->[2] * 0.6))),\n\t\t\t\tif ($colors{$_});\n\t\t}\n\t\t\n\t\tif (($legend) && ($$legend[$k])) {\n\t\t\t$obj->addLegend($color, undef, $$legend[$k], undef), next\n\t\t\t\tunless $stacked;\n\n\t\t\t$obj->addLegend($barcolors[$_], undef, $$legend[$k]->[$_], undef)\n\t\t\t\tforeach (0..$#{$$legend[$k]});\n\t\t}\n\t}\n\tmy ($i, $j) = (0,0);\n\tunless (($numRanges > 1) || $stacked) {\n\t\t$ary = $obj->{data}->[0];\n\t\tfor (; $i <= $numPts; $i+=3) {\n\t\t\t$ys = $$ary[$i+1];\n\t\t\t$obj->drawCube($$ary[$i], $$ys[0], $$ys[1], $$ary[$i+2],\n\t\t\t\t0, $fronts[0]->[$j], $tops[0]->[$j], $sides[0]->[$j], \n\t\t\t\t$xoff, $xbarw, $zbarw, $$xvals[$$ary[$i]-1], \n\t\t\t\t$$zvals[$$ary[$i+2]-1], $showvals);\n\t\t\t$obj->renderCubeValues($showvals, $svfont) if $showvals;\n\t\t\t$j++;\n\t\t\t$j = 0 if ($j > $#{$fronts[0]});\n\t\t}\n\t\treturn 1;\n\t}\n\t$numRanges--;\n\tfor (; $i <= $numPts; $i+=3) {\n\t\tforeach $k (0..$numRanges) {\n\t\t\t$numPts = $#{$obj->{data}->[$k]};\n\t\t\t$ary = $obj->{data}->[$k];\n\t\t\t$ys = $$ary[$i+1];\n\t\t\t$obj->drawCube($$ary[$i], $$ys[$_-1], $$ys[$_], $$ary[$i+2],\n\t\t\t\t$k, $fronts[$k]->[$_-1], $tops[$k]->[$_-1], $sides[$k]->[$_-1], \n\t\t\t\t$xoff, $xbarw, $zbarw, $$xvals[$$ary[$i]-1], \n\t\t\t\t$$zvals[$$ary[$i+2]-1], $showvals, $stacked),\n\t\t\t\tforeach (1..$#$ys);\n\t\t\t$obj->renderCubeValues($showvals, $svfont) if $showvals;\n\t\t}\n\t}\n\treturn 1;\n}\n\nsub computeSides {\n\tmy ($x, $xoff, $barw, $k) = @_;\n\t\n\treturn ($x - ($xoff/2) + ($k * $barw), \n\t\t$x - ($xoff/2) + (($k+1) * $barw));\n}\n\nsub drawCube {\n\tmy ($obj, $x, $yl, $yh, $z, $k, $front, $top, $side, \n\t\t$xoff, $xbarw, $zbarw, $xval, $zval, $showvals, $stacked) = @_;\n\tmy ($xl, $xr) = computeSides($x, $xoff, $xbarw, $k);\n\tmy $ishisto = $obj->{plotTypes} & HISTO;\n\tmy @val_stack = ();\n\tmy ($mx, $px, $py);\n\n\t$z++;\n\tmy @v = $ishisto ?\n\t(\n\t\t$xl, $yl, $z - $zbarw,\t\n\t\t$xr, $yl, $z - $zbarw,\t\n\t\t$xr, $yl, $z + $zbarw,\t\n\t\t$xr, $yh, $z + $zbarw,\t\n\t\t$xr, $yh, $z - $zbarw,\t\n\t\t$xl, $yh, $z - $zbarw,\t\n\t\t$xl, $yh, $z + $zbarw\t\n\t) :\n\t(\n\t\t$xl, $yl, $z - $zbarw,\t\n\t\t$xl, $yh, $z - $zbarw,\t\n\t\t$xl, $yh, $z + $zbarw,\t\n\t\t$xr, $yh, $z + $zbarw,\t\n\t\t$xr, $yh, $z - $zbarw,\t\n\t\t$xr, $yl, $z - $zbarw,\t\n\t\t$xr, $yl, $z + $zbarw\t\n\t);\n\t\n\tmy @xlatverts = ();\n\tmy $img = $obj->{img};\n\tmy ($i, $j);\n\tfor ($i = 0; $i < 21; $i+=3) {\n\t\tpush(@xlatverts, $obj->pt2pxl($v[$i], $v[$i+1], $v[$i+2]));\n\t}\n\tmy $xwidth = $xlatverts[12] - $xlatverts[0];\n\n\tmy @faces = ($top, $front, $side);\n\tfor ($i = 0; $i < 3; $i++) {\n\t\tmy $poly = new GD::Polygon;\n\t\tmy $ary = $polyverts[$i];\n\t\t$poly->addPt($xlatverts[$$ary[$_]],$xlatverts[$$ary[$_]+1])\n\t\t\tforeach (0..3);\n\t\t$img->filledPolygon($poly, $faces[$i]);\n\t}\n\tfor ($i = 0; $i < 18; $i+=2) {\n\t\t$img->line($xlatverts[$vert2lines[$i]], \n\t\t\t$xlatverts[$vert2lines[$i]+1],\n\t\t\t$xlatverts[$vert2lines[$i+1]],\n\t\t\t$xlatverts[$vert2lines[$i+1]+1], $obj->{black});\n\t}\n\treturn 1 unless ($obj->{genMap} || $showvals);\n\tmy $y = ($yh > 0) ? $yh : $yl;\n\tif ($obj->{genMap}) {\n\t\tmy $text = ($obj->{zAxisLabel}) ? \"($xval, $y, $zval)\" : \"($xval, $y)\";\n\t\tmy $ary = $polyverts[($ishisto ? 2 : 0)];\n\t\tmy @ptsary = ();\n\t\tpush(@ptsary, $xlatverts[$$ary[$_]], $xlatverts[$$ary[$_]+1])\n\t\t\tforeach (0..3);\n\t\t$obj->updateImagemap('POLY', $text, 0, $xval, $y, $zval, @ptsary);\n\t}\n\treturn 1 unless $showvals;\n\t$mx = ($xr + $xl)/($ishisto ? 1.9 : 2);\n\t($px, $py) = $obj->pt2pxl($mx, $yh, $z - $zbarw);\n\tmy $valsz = (length($y) * $tfw);\n\tif ($stacked) {\n\t\t$px -= (15 + $valsz) if $ishisto;\n\t\t$py += (($xwidth > $obj->{yMaxlen}) ? 10 : 10 + $valsz) \n\t\t\tunless $ishisto;\n\t}\n\telse {\n\t\t$px += (($y < 0) ? -15 : 15) if $ishisto;\n\t\t$py += (($y < 0) ? (($xwidth < ($obj->{yMaxlen} * $tfw)) ? 10 + $valsz : 10) : -10) \n\t\t\tunless $ishisto;\n\t}\n\t$y = $yh - $yl if ($stacked && ($yh > 0) && ($yl > 0));\n\t$y = $yl - $yh if ($stacked && ($yh < 0) && ($yl < 0));\n\tpush(@$showvals, $px, $py, $y, ($xwidth > ($obj->{yMaxlen} * $tfw)));\n\treturn 1;\n}\n\nsub renderCubeValues {\n\tmy ($obj, $val_stack, $svfont) = @_;\n\tmy ($px, $py, $y, $xwidth, $ishisto);\n\t$ishisto = $obj->{plotTypes} & HISTO;\n\tmy $img = $obj->{img};\n\t\n\twhile (@$val_stack) {\n\t\t$px = shift @$val_stack;\n\t\t$py = shift @$val_stack;\n\t\t$y = shift @$val_stack;\n\t\t$xwidth = shift @$val_stack;\n\n\t\t$obj->string($svfont, 90, $px, $py, $y, $tfw), next\n\t\t\tunless ($ishisto || $xwidth);\n\t\t$obj->string($svfont,0, $px, $py, $y, $tfw);\n\t}\n\treturn 1;\n}\n\nsub abs { my $x = shift; return ($x < 0) ? -1*$x : $x; }\n\nsub plotPie {\n\tmy ($obj) = @_;\n\tmy $ary = $obj->{data}->[0];\n\tmy @colormap = ();\n\tmy $t = $obj->{props}->[0];\n\t$t=~s/\\s+/ /g;\n\t$t = lc $t;\n\tmy @props = split (' ', $t);\n\tmy $img = $obj->{img};\n\tmy $showvals = 6;\n\tforeach (@props) {\n\t\t$showvals = $1, next if /^showvalues:(\\d+)/;\n\t\tpush(@colormap, $img->colorAllocate(@{$colors{$_}}) )\n\t\t\tif $colors{$_};\n\t}\n\tmy $i = 0;\n\tmy $total = 0;\n\tmy $arc = 0;\n\tmy $maxlen = 0;\n\tmy $len = 0;\n\tfor ($i = 0; $i <= $#$ary; $i+=2) { \n\t\t$total += $$ary[$i+1]; \n\t\t$len = length($$ary[$i]);\n\t\t$len = 25 if ($len > 25);\n\t\t$maxlen = $len if ($len > $maxlen);\n\t}\n\t$maxlen++;\n\t$maxlen *= $tfw;\n\t$obj->{errmsg} = 'Insufficient image size for graph.',\n\treturn undef\n\t\tif ($maxlen * 2 > ($obj->{width} * 0.5));\n\tmy $xc = int($obj->{width}/2);\n\tmy $yc = int(($obj->{height}/2) - 30);\n\tmy $hr = $xc - $maxlen - 10;\n\tmy $vr = $obj->{threed} ? int($hr * tan(30 * (3.1415926/180))) : $hr;\n\tmy $piefactor = $obj->{threed} ? cotan(30 * (3.1415926/180)) : 1;\n\n\t$vr = $yc - 20, $hr = $vr\n\t\tunless ($obj->{threed} || ($yc - 20 > $vr));\n\t$vr = $yc - 20, $hr = int($vr/tan(30 * (3.1415926/180)))\n\t\tif ($obj->{threed} && ($vr > $yc - 20));\n\n\t$img->arc($xc, $yc, $hr*2, $vr*2, 0, 360, $obj->{black});\n\t$img->arc($xc, $yc+20, $hr*2, $vr*2, 0, 180, $obj->{black}),\n\t$img->line($xc-$hr, $yc, $xc-$hr, $yc+20, $obj->{black}),\n\t$img->line($xc+$hr, $yc, $xc+$hr, $yc+20, $obj->{black})\n\t\tif $obj->{threed};\n\n\tmy $w = 0;\n\tmy $j = 0;\n\tfor ($i = 0, $j = 0; $i <= $#$ary; $i+=2, $j++) { \n\t\t$w = $$ary[$i+1];\n\t\tmy $color = $colormap[$j%(scalar @colormap)];\n\t\t$arc = $obj->drawWedge($arc, $color, $xc, \n\t\t\t$yc, $vr, $hr, $w/$total, $$ary[$i], $w, $piefactor, $showvals);\n\t}\n\treturn 1;\n}\n\nsub drawWedge {\n\tmy ($obj, $arc, $color, $xc, $yc, $vr, $hr, $pct, $text, $val, $piefactor, $showvals) = @_;\n\tmy $img = $obj->{img};\n\tmy ($x, $y, $fx, $fy);\n\tif ($obj->{genMap}) {\n\t\tmy $tarc = 0;\n\n\t\tmy @ptsary = ($xc, $yc);\n\t\twhile ($tarc <= (2 * 3.1415926 * $pct)) {\n\t\t\t($x, $y) = computeCoords($xc, $yc, $vr, $hr, \n\t\t\t\t$arc + $tarc, $piefactor);\n\t\t\tpush(@ptsary, $x, $y);\n\t\t\tlast if ((2 * 3.1415926 * $pct) - $tarc < (2 * 3.1415926/36));\n\t\t\t$tarc += (2 * 3.1415926/36);\n\t\t}\n\t\tif ($tarc < (2 * 3.1415926 * $pct)) {\n\t\t\t($x, $y) = computeCoords($xc, $yc, $vr, $hr, \n\t\t\t\t$arc + (2 * 3.1415926 * $pct), $piefactor);\n\t\t\tpush(@ptsary, $x, $y);\n\t\t}\n\t\t$val = restore_temporal($val, $obj->{timeRange}) if $obj->{timeRange};\n\t\t$obj->updateImagemap('POLY', \n\t\t\t\"$val(\" . (int($pct * 1000)/10) . '%)', 0, $text, $val, \n\t\t\tint(10000*$pct)/100, @ptsary);\n\t}\n\tmy $start = $arc;\n\tmy $bisect = $arc + ($pct * 3.1415926);\n\t$arc += (2 * 3.1415926 * $pct); \n\tmy $visible = ($obj->{threed} &&\n\t\t(($start < 3.1415926/2) || ($start >= (1.5 * 3.1415926)) ||\n\t\t($arc < 3.1415926/2) || ($arc >= (1.5 * 3.1415926))));\n\t$start = (($arc < 3.1415926/2) || ($arc >= (1.5 * 3.1415926))) ?\n\t\t\t$arc : $start;\n\n\t($x, $y) = computeCoords($xc, $yc, $vr, $hr, $arc, $piefactor);\n\t($fx, $fy) = computeCoords($xc, $yc, $vr * 0.6, $hr* 0.6, $bisect, \n\t\t$piefactor);\n\t$img->line($xc, $yc, $x, $y, $obj->{black});\n\t$img->fill($fx, $fy, $color);\n\tif ($visible) {\n\t\t$img->line($x, $y, $x, $y+20, $obj->{black})\n\t\t\tif ($start == $arc);\n\t\t($fx, $fy) = computeCoords($xc, $yc+10, $vr, $hr, $start, $piefactor);\n\t\t$fx += ($start == $arc) ? 2 : -2;\n\t\t$img->fill($fx, $fy, $color);\n\t}\n\tif ($text) {\n\t\tmy ($gx, $gy) = computeCoords($xc, $yc, $vr, $hr, $bisect, $piefactor);\n\t\t$gy -= $sfh if (($bisect > 3.1415926/2) && ($bisect <= (1.5 * 3.1415926)));\n\n\t\t$gy += 20 if ($obj->{threed} && \n\t\t\t(($bisect < 3.1415926/2) || ($bisect >= (1.5 * 3.1415926))));\n\t\t$gx -= ((length($text)+1) * $sfw) \n\t\t\tif (($gx < $xc) && ($bisect > 3.1415926/4));\n\t\t$gx -= (length($text) * $sfw/2) \n\t\t\tif (($gx > $xc) && ($bisect > (1.75 * 3.1415926)));\n\t\t$gx += $sfw if ($gx > $xc);\n\t\t$gx -= (length($text) * $sfw/2) \n\t\t\tif (($gx == $xc) || ($bisect <= 3.1415926/4));\n\n\t\t$obj->string($showvals, 0,$gx, $gy, $text, $tfw);\n\t}\n\treturn $arc;\n}\n\nsub computeCoords {\n\tmy ($xc, $yc, $vr, $hr, $arc, $piefactor) = @_;\n\n\treturn (\n\t\tint($xc + $piefactor * $vr * cos($arc + (3.1415926/2))), \n\t\tint($yc + $piefactor * ($vr/$hr) * $vr * sin($arc+ (3.1415926/2)))\n\t);\n}\n\nsub tan {\n\tmy ($angle) = @_;\n\t\n\treturn (sin($angle)/cos($angle));\n}\n\nsub cotan {\n\tmy ($angle) = @_;\n\t\n\treturn (cos($angle)/sin($angle));\n}\n\nsub updateImagemap {\n\tmy ($obj, $shape, $alt, $plotNum, $x, $y, $z, @pts) = @_;\n\t$y = '' unless defined($y);\n\t$z = '' unless defined($z);\n\treturn $obj->updatePerlImagemap($plotNum, $x, $y, $z, $shape, @pts)\n\t\tif (uc $obj->{mapType} eq 'PERL');\n\n\tmy $imgURL = $obj->{mapURL};\n\tmy $imgScript = $obj->{mapScript};\n\tif ($obj->{mapModifier}) {\n\t\tmy $maphash = {\n\t\t\tURL => $imgURL,\n\t\t\tScript => $imgScript,\n\t\t\tName => $obj->{genMap},\n\t\t\tPLOTNUM => $plotNum,\n\t\t\tX => $x, Y => $y, Z => $z,\n\t\t\tAltText => $alt\n\t\t};\n\t\t&{$obj->{mapModifier}}($maphash);\n\t\t$imgURL = $maphash->{URL};\n\t\t$imgScript = $maphash->{Script};\n\t\t$alt = $maphash->{AltText};\n\t}\n\t$shape = uc $shape;\n\t$x =~ s/([^;\\/?:@&=+\\$,A-Za-z0-9\\-_.!~*'()])/$escapes{$1}/g;\n\t$y =~ s/([^;\\/?:@&=+\\$,A-Za-z0-9\\-_.!~*'()])/$escapes{$1}/g;\n\t$z =~ s/([^;\\/?:@&=+\\$,A-Za-z0-9\\-_.!~*'()])/$escapes{$1}/g;\n\t$plotNum =~ s/([^;\\/?:@&=+\\$,A-Za-z0-9\\-_.!~*'()])/$escapes{$1}/g;\n\tmy $imgmap = $obj->{imgMap};\n\t$imgURL=~s/:PLOTNUM\\b/$plotNum/g,\n\t$imgURL=~s/:X\\b/$x/g,\n\t$imgURL=~s/:Y\\b/$y/g,\n\t$imgURL=~s/:Z\\b/$z/g\n\t\tif ($imgURL);\n\t$imgScript=~s/:PLOTNUM\\b/$plotNum/g,\n\t$imgScript=~s/:X\\b/$x/g,\n\t$imgScript=~s/:Y\\b/$y/g,\n\t$imgScript=~s/:Z\\b/$z/g\n\t\tif ($imgScript);\n\n\t$imgmap .= \"\\n<AREA TITLE=\\\"$alt\\\" \" .\n\t\t(($obj->{mapURL}) ? \" HREF=\\\"$imgURL\\\" \" : ' NOHREF ');\n\t$imgmap .= \" $imgScript \"\n\t\tif ($imgScript);\n\n\t$imgmap .= \" SHAPE=$shape COORDS=\\\"\" . join(',', @pts) . '\">';\n\t$obj->{imgMap} = $imgmap;\n\treturn 1;\n}\n\nsub updatePerlImagemap {\n\tmy ($obj, $plotNum, $x, $y, $z, $shape, @pts) = @_;\n\tmy $imgmap = $obj->{imgMap};\n\t$imgmap .= \",\\n\" unless ($imgmap eq '');\n\t$imgmap .= \n\"\\{\n\tplotnum => $plotNum,\n\tX => '$x',\n\tY => '$y',\n\tZ => '$z',\n\tshape => '$shape',\n\tcoordinates => [ \" . join(',', @pts) . \"]\n}\";\n\t$obj->{imgMap} = $imgmap;\n\treturn 1;\n}\n\nsub addLogo {\n\tmy ($obj) = @_;\n\tmy $pat = GD::Image->can('newFromGif') ? 'png|jpe?g|gif' : 'png|jpe?g';\n\tmy ($logo, $imgw, $imgh) = ($obj->{logo}, $obj->{width}, $obj->{height});\n\tmy $img = $obj->{img};\n\n\t$obj->{errmsg} = \n\t'Unrecognized logo file format. File qualifier must be .png, .jpg, ' .\n\t\t(GD::Image->can('newFromGif') ? '.jpeg, or .gif.' :\t'or .jpeg.'),\n\treturn undef\n\t\tunless ($logo=~/\\.($pat)$/i);\n\n\t$obj->{errmsg} = 'Unable to open logo file.',\n\treturn undef\n\t\tunless open(LOGO, \"<$logo\");\n\n\tmy $logoimg = ($logo=~/\\.png$/i) ? GD::Image->newFromPng(*LOGO) :\n\t  ($logo=~/\\.gif$/i) ? GD::Image->newFromGif(*LOGO) :\n\t    GD::Image->newFromJpeg(*LOGO);\n\tclose(LOGO);\n\t\n\t$obj->{errmsg} = 'GD cannot read logo file.',\n\treturn undef\n\t\tunless $logoimg;\n\n\tmy ($logow, $logoh) = $logoimg->getBounds();\n\tmy $srcX = ($logow > $imgw) ? ($logow - $imgw)>>1 : 0;\n\tmy $srcY = ($logoh > $imgh) ? ($logoh - $imgh)>>1 : 0;\n\tmy $dstX = ($logow > $imgw) ? 0 : ($imgw - $logow)>>1;\n\tmy $dstY = ($logoh > $imgh) ? 0 : ($imgh - $logoh)>>1;\n\tmy $h = ($logoh > $imgh) ? $imgh : $logoh;\n\tmy $w = ($logow > $imgw) ? $imgw : $logow;\n\t$img->copy($logoimg, $dstX, $dstY, $srcX, $srcY, $w-1, $h-1);\n\treturn 1;\n}\n\n\nsub setGanttPoints {\n\tmy ($obj, $taskary, $starts, $ends, $assignees, $pcts, @depends) = @_;\n\tmy $props = pop @depends;\n\tmy @data = ();\n\tmy %taskhash = ();\n\tmy %starthash = ();\n\tmy $yh = -1E38;\n\tmy $xh = 0;\n\tmy $i;\n\tfor ($i = 0; $i <= $#$taskary; $i++) {\n\t\tnext unless (defined($$taskary[$i]) && \n\t\t\tdefined($$starts[$i]) && \n\t\t\tdefined($$ends[$i]));\n\t\t\n\t\t$obj->{errmsg} = 'Duplicate task name.',\n\t\treturn undef\n\t\t\tif $taskhash{uc $$taskary[$i]};\n\t\t\n\t\tmy $startdate = convert_temporal($$starts[$i], $obj->{timeRange});\n\t\tmy $enddate = convert_temporal($$ends[$i], $obj->{timeRange});\n\t\t$obj->{errmsg} = 'Invalid start date.',\n\t\treturn undef\n\t\t\tunless defined($startdate);\n\t\t$yh = $enddate if ($enddate > $yh);\n\t\t\n\t\t$obj->{errmsg} = 'Invalid end date.',\n\t\treturn undef\n\t\t\tunless (defined($enddate) && ($enddate >= $startdate));\n\t\t\n\t\t$obj->{errmsg} = 'Invalid completion percentage.',\n\t\treturn undef\n\t\t\tunless ((! $$pcts[$i]) || \n\t\t\t\t(($$pcts[$i]=~/^\\d+(\\.\\d+)?$/) &&\n\t\t\t\t($$pcts[$i] >= 0) && ($$pcts[$i] <= 100)));\n\n\t\tmy @deps = ();\n\t\tforeach (@depends) {\n\t\t\tnext unless $_->[$i];\n\n\t\t\t$obj->{errmsg} = \"Invalid dependency; $$taskary[$i] cannot be self-dependent.\",\n\t\t\treturn undef\n\t\t\t\tif (uc $_->[$i] eq uc $$taskary[$i]);\n\t\t\tpush(@deps, $_->[$i]);\n\t\t}\n\n\t\t$taskhash{uc $$taskary[$i]} = $startdate;\n\t\t$starthash{$startdate} = \n\t\t\t[ [ $$taskary[$i], $startdate, $enddate, $$assignees[$i], $$pcts[$i], \\@deps ] ], next\n\t\t\tunless $starthash{$startdate};\n\t\tpush @{$starthash{$startdate}}, \n\t\t\t[ $$taskary[$i], $startdate, $enddate, $$assignees[$i], $$pcts[$i], \\@deps ] ;\n\t}\t\t\n\tforeach my $d (@depends) {\n\t\tforeach (0..$#$d) {\n\t\t\tnext unless $$d[$_];\n\t\t\t$obj->{errmsg} = 'Unknown task ' . $$d[$_],\n\t\t\treturn undef\n\t\t\t\tunless $taskhash{uc $$d[$_]};\n\n\t\t\t$obj->{errmsg} = \"Invalid dependency; $$d[$_] precedes $$taskary[$_].\",\n\t\t\treturn undef\n\t\t\t\tif ($taskhash{uc $$d[$_]} < $taskhash{uc $$taskary[$_]});\n\t\t}\n\t}\n\tmy @started = sort numerically keys(%starthash);\n\tforeach my $startdate (@started) {\n\t\tpush(@data, @$_),\n\t\t$xh++\n\t\t\tforeach (@{$starthash{$startdate}});\n\t}\n\tpush(@{$obj->{data}}, \\@data);\n\tpush(@{$obj->{props}}, $props);\n\t$obj->{yl} = $started[0] unless (defined($obj->{yl}) && ($obj->{yl} < $started[0]));\n\t$obj->{yh} = $yh unless (defined($obj->{yh}) && ($obj->{yh} > $yh));\n\t$obj->{xl} = 1;\n\t$obj->{xh} = $xh;\n\t$obj->{plotTypes} |= GANTT;\n\treturn 1;\n}\n\nsub plotGantt {\n\tmy ($obj) = @_;\n\tmy $props = $obj->{props}->[0];\n\tmy $data = $obj->{data}->[0];\n\tmy ($xl, $xh, $yl, $yh) = ($obj->{xl}, $obj->{xh}, $obj->{yl}, $obj->{yh});\n\tmy ($s, $t, $i, $j, $deps, $depend, $srcx, $color);\n\tmy ($offset, $span, $pct, $compend, $prtT, $starts, $ends);\n\tmy $img = $obj->{img};\n\n\tmy $showvals = 6;\n\tforeach (split(' ', $props)) {\n\t\t$showvals = $1, next if /^showvalues:(\\d+)/;\n\t\t$color = $_ if $colors{$_};\n\t}\n\t$obj->{$color} = $img->colorAllocate(@{$colors{$color}})\n\t\tunless $obj->{$color};\n\t$obj->{compcolor} = $img->colorAllocate($colors{$color}->[0] * 0.6,\n\t\t$colors{$color}->[1] * 0.6,$colors{$color}->[2] * 0.6);\n\tmy @pts = ();\n\tmy %taskhash = ();\n\tfor ($i = 0, $j = ($#$data+1)/6; $i <= $#$data; $i+=6, $j--) {\n\t\t$taskhash{uc $$data[$i]} = $#pts + 1;\n\t\tpush (@pts, $obj->pt2pxl($j, $$data[$i + 1]),\n\t\t\t$obj->pt2pxl($j, $$data[$i + 2]));\n\t}\n\tmy $marker = $obj->make_marker('filldiamond', 'black');\n\tmy ($markw, $markh) = $marker->getBounds;\n\tfor ($i = 0; $i <= $#$data; $i+=6) {\n\t\t$s = $taskhash{uc $$data[$i]};\n\t\t$deps = $$data[$i+5];\n\t\tnext unless ($deps && ($#$deps >= 0));\n\t\tforeach (@$deps) {\n\t\t\t$t = $taskhash{uc $_};\n\t\t\t$img->line($pts[$s+2], $pts[$s+3], $pts[$t], $pts[$s+3], $obj->{black})\n\t\t\t\tif ($pts[$s+2] < $pts[$t]); \n\t\t\t$srcx = ($pts[$s+2] < $pts[$t]) ? $pts[$t] : \n\t\t\t\t($pts[$s+2] < $pts[$t+2]) ? $pts[$s+2] : $pts[$t];\n\t\t\t$img->line($srcx, $pts[$s+3], $srcx, $pts[$t+3]-$sfh, $obj->{black});\n\t\t\t$img->copy($marker, $srcx-($markw/2), $pts[$t+3]-$sfh, 0, 0, \n\t\t\t\t$markw-1, $markh-1);\n\t\t}\n\t}\n\t$offset = $sfh/2;\n\tfor ($i = 0; $i <= $#$data; $i+=6) {\n\t\t$s = $taskhash{uc $$data[$i]};\n\t\t$span = $pts[$s+2] - $pts[$s];\n\t\t$pct = $$data[$i+4]/100;\n\t\t$compend = $pts[$s] + int($span * $pct);\n\t\t$img->filledRectangle($pts[$s], $pts[$s+1] - $offset, \n\t\t\t$compend, $pts[$s+3] + $offset, $obj->{compcolor})\n\t\t\tif ($pct);\n\t\t$img->filledRectangle($compend, $pts[$s+1] - $offset, \n\t\t\t$pts[$s+2], $pts[$s+3] + $offset, $obj->{$color})\n\t\t\tif ($pct != 1);\n\t\t$prtT = $$data[$i];\n\t\t$prtT .= '(' . $$data[$i+3]. ')' if $$data[$i+3];\n\t\t$prtT .= ' : ' . $$data[$i+4] . '%';\n\t\t$obj->string($showvals, 0, $pts[$s], $pts[$s+1] - $offset - $sfh,\n\t\t\t\t$prtT, $tfw);\n\n\t\t$starts = restore_temporal($$data[$i+1], $obj->{timeRange}),\n\t\t$ends = restore_temporal($$data[$i+2], $obj->{timeRange}),\n\n\t\t$prtT = $starts . '->' . $ends,\n\t\t$obj->updateImagemap('RECT', $prtT, \n\t\t\t$$data[$i], $starts, $ends, $$data[$i+4] . ':' . $$data[$i+3],\n\t\t\t$pts[$s], $pts[$s+1] - $offset, $pts[$s+2], $pts[$s+3] + $offset)\n\t\t\tif $obj->{genMap};\n\t}\n\t1;\n}\n\nsub setQuadPoints {\n\tmy ($obj, @ranges) = @_;\n\tmy ($min, $max) = (1.0E+38, 1.0E-38);\n\tmy $props = pop @ranges;\n\t$obj->{errmsg} = 'Invalid dataset supplied for quadtree',\n\treturn undef\n\t\tunless ((ref $ranges[0]) && (ref $ranges[0] eq 'ARRAY') \n\t\t\t&& (@{$ranges[0]} > 2));\n\tmy $cells = @{$ranges[0]};\n\tmy @dataset = ();\n\tpush (@dataset, [ ])\n\t\tforeach (1..$cells);\n\n\tforeach my $x (@ranges) {\n\t\t$obj->{errmsg} = 'Invalid dataset supplied for quadtree',\n\t\treturn undef\n\t\t\tunless ((ref $x) && (ref $x eq 'ARRAY') && ($#$x > 1));\n\t\t$obj->{errmsg} = 'Unbalanced dataset supplied for quadtree',\n\t\treturn undef\n\t\t\tunless ($cells == @$x);\n\t\tpush @{$dataset[$_-1]}, $x->[$_-1]\n\t\t\tforeach (1..$cells);\n\t}\n\tforeach (@{$ranges[$#ranges]}) {\n\t\tnext unless defined($_);\n\t\t$min = $_ unless ($min < $_);\n\t\t$max = $_ unless ($max > $_);\n\t}\n\t$obj->{yl} = $min;\n\t$obj->{yh} = $max;\n\tmy %keyhash = ();\n\t$cells--;\n\t$obj->{data} = \\@dataset;\n\t$obj->clusterQuadPts([ 0..$cells ], 0, \\%keyhash, '');\n\t$obj->{data}->[0] = \\%keyhash;\n\t$obj->{props}->[0] = $props;\n\t$obj->{plotTypes} |= QUADTREE;\n\treturn 1;\n}\n\nsub clusterQuadPts {\n\tmy ($obj, $rowlist, $keycol, $keyhash, $category) = @_;\n\tmy $result = 0;\n\tmy $rows = $obj->{data};\n\tmy $ttlcols = @{$$rows[$$rowlist[0]]} - 1;\n\tif ($keycol == $ttlcols - 2) {\n\t\t$$keyhash{$$rows[$_]->[$keycol]} = \n\t\t\t[ ($category . ':' . $$rows[$_]->[$keycol]), \n\t\t\t\t$$rows[$_]->[$keycol+1], \n\t\t\t\t$$rows[$_]->[$keycol+2] ],\n\t\t$result += $$rows[$_]->[$keycol+1]\n\t\t\tforeach (@$rowlist);\n\t\treturn $result;\n\t}\n\tmy %idxhash = ();\n\tforeach (@$rowlist) {\n\t\t$idxhash{$$rows[$_]->[$keycol]} = [ ]\n\t\t\tunless $idxhash{$$rows[$_]->[$keycol]};\n\t\tpush @{$idxhash{$$rows[$_]->[$keycol]}}, $_;\n\t}\n\tforeach (keys(%idxhash)) {\n\t\tmy %lclhash = ();\t\n\t\t$$keyhash{$_} = \n\t\t\t[ \\%lclhash, $obj->clusterQuadPts($idxhash{$_}, $keycol+1, \\%lclhash, \n\t\t\t\t($category eq '') ? $_ : ($category . ':' . $_)) ];\n\t}\n\t$result += $$keyhash{$_}->[1]\n\t\tforeach (keys(%$keyhash));\n\treturn $result;\n}\n\nsub dumpQuadData {\n\tmy ($group, $tabcnt) = @_;\n\t\n\tprint ' ' x (4*$tabcnt), $group , \"\\n\" and return 1\n\t\tunless (ref $group);\n\t\n\tforeach (@$group) {\n\t\tif (ref $_ eq 'HASH') {\n\t\t\tforeach my $cat (keys(%{$_})) {\n\t\t\t\tdumpQuadData($cat, $tabcnt+1), next if (ref $cat);\n\t\t\t\tprint ' ' x (4*$tabcnt), $cat , ' => {', \"\\n\";\n\t\t\t\tdumpQuadData($_->{$cat}, $tabcnt+1);\n\t\t\t}\n\t\t}\n\t\telsif (ref $_ eq 'ARRAY') {\n\t\t\tforeach my $cat (0..$#$_) {\n\t\t\t\tprint ' ' x (4*$tabcnt), $cat , ' => [', \"\\n\";\n\t\t\t\tdumpQuadData($_->[$cat], $tabcnt+1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprint ' ' x (4*$tabcnt), $_ , \"\\n\";\n\t\t}\n\t}\n}\n\nsub plotQuadtree {\n\tmy ($obj) = @_;\n\t$obj->computeGradient;\n\t$obj->renderQuadTree([ $obj->{data}->[0] ], 40, 40, $obj->{width} - 80, \n\t\t$obj->{height} - 80, 'v', '');\n\treturn 1;\n}\nsub renderQuadTree {\n\tmy ($obj, $group, $xorig, $yorig, $w, $h, $splitdir) = @_;\n\t\n\t\n\tmy @cluster1 = ();\n\tmy @cluster2 = ();\n\tmy ($ttl, $half, $hash, $no_more_room, $w1, $w2, $h1, $h2);\n\twhile ((ref $$group[0] eq 'HASH') && (! $#$group)) {\n\t\tmy @newgroup = ();\n\t\t$hash = $$group[0];\n\t\tpush(@newgroup, (ref $$hash{$_}->[0]) ? $$hash{$_}->[0] : $$hash{$_})\n\t\t\tforeach (keys(%$hash));\n\t\t$group = \\@newgroup;\n\t}\n\tif (! ref $$group[0]) {\n\t\tmy $img = $obj->{img};\n\t\tmy $colormap = $obj->{colormap};\n\t\tmy $color;\n\t\tforeach (@$colormap) {\n\t\t\t$color = $_->[5], last\n\t\t\t\tif ($$group[2] >= $_->[3] && $$group[2] <= $_->[4]);\n\t\t}\n\t\t$img->filledRectangle($xorig, $yorig, $xorig+$w, $yorig+$h, $color);\n\t\t$img->rectangle($xorig, $yorig, $xorig+$w, $yorig+$h, $obj->{black});\n\t\tmy ($category, $item) = ($1,$2) if ($$group[0]=~/^(.*):(.+?)$/);\n\t\t$obj->updateImagemap('RECT', \n\t\t\t\"$$group[0]=$$group[1]($$group[2])\",\n\t\t\t$$group[2], $category, $item, $$group[1], \n\t\t\t$xorig, $yorig, $xorig+$w, $yorig+$h)\n\t\t\tif $obj->{genMap};\n\t\treturn 1;\n\t}\n\tif (ref $$group[0] eq 'ARRAY') {\n\t\treturn $obj->renderQuadTree($$group[0], $xorig, $yorig, $w, $h, $splitdir)\n\t\t\tif ($#$group == 0);\n\n\t\tmy $ttl = 0;\n\t\t$ttl += $_->[1]\n\t\t\tforeach (@$group);\n \t\t$half = $ttl/2;\n \t\tforeach (@$group) {\n\t\t\t$half -= $_->[1],\n\t\t\tpush(@cluster1, $_),\n\t\t\tnext\n\t\t\t\tif ($half >= $_->[1]);\n\t\t\tpush(@cluster2, $_);\n\t\t}\n\t\t$no_more_room = 0;\n\t\tif ($splitdir eq 'v') {\n\t\t\t$w1 = int($w * ((($ttl/2) - $half)/$ttl));\n\t\t\t$w2 = $w - $w1;\n\t\t\t$no_more_room = ($w2 <= 0);\n\t\t}\n\t\telse {\n\t\t\t$h1 = int($h * ((($ttl/2) - $half)/$ttl));\n\t\t\t$h2 = $h - $h1;\n\t\t\t$no_more_room = ($h2 <= 0);\n\t\t}\n\t\treturn undef\n\t\t\tunless (($splitdir eq 'v') ?\n\t\t\t\t$obj->renderQuadTree(((@cluster1 == 1) ? $cluster1[0] : \\@cluster1), \n\t\t\t\t\t$xorig, $yorig, $w1, $h, 'h') :\n\t\t\t\t$obj->renderQuadTree(((@cluster1 == 1) ? $cluster1[0] : \\@cluster1),\n\t\t\t\t\t$xorig, $yorig, $w, $h1, 'v'));\n\n\t\treturn ($no_more_room ? 1 : \n\t\t\t($splitdir eq 'v') ?\n\t\t\t$obj->renderQuadTree(((@cluster2 == 1) ? $cluster2[0] : \\@cluster2), \n\t\t\t\t$xorig+$w1, $yorig, $w2, $h, 'h') :\n\t\t\t$obj->renderQuadTree(((@cluster2 == 1) ? $cluster2[0] : \\@cluster2), \n\t\t\t\t$xorig, $yorig+$h1, $w, $h2, 'v'));\n\t}\n\tmy @ttlhash = ();\n\tmy $i = 0;\n\t$ttl = 0;\n\tforeach $hash (@$group) {\n\t\t$ttlhash[$i] = 0;\n\t\t$ttlhash[$i] += $$hash{$_}->[1]\n\t\t\tforeach (keys(%$hash));\n\t\t$ttl += $ttlhash[$i];\n\t\t$i++;\n\t}\n\t$i = 0;\n\t$half = $ttl/2;\n\tforeach $hash (@$group) {\n\t\t$half -= $ttlhash[$i++],\n\t\tpush(@cluster1, $hash),\n\t\tnext\n\t\t\tif (($half > 0) && ($i < $#ttlhash));\n\t\tpush(@cluster2, $hash);\n\t}\n\t$no_more_room = 0;\n\tif ($splitdir eq 'v') {\n\t\t$w1 = int($w * ((($ttl/2) - $half)/$ttl));\n\t\t$w2 = $w - $w1;\n\t\t$no_more_room = ($w2 <= 0);\n\t}\n\telse {\n\t\t$h1 = int($h * ((($ttl/2) - $half)/$ttl));\n\t\t$h2 = $h - $h1;\n\t\t$no_more_room = ($h2 <= 0);\n\t}\n\treturn undef\n\t\tunless (($splitdir eq 'v') ?\n\t\t\t$obj->renderQuadTree(\\@cluster1, $xorig, $yorig, $w1, $h, 'h') :\n\t\t\t$obj->renderQuadTree(\\@cluster1, $xorig, $yorig, $w, $h1, 'v'));\n\n\treturn ($no_more_room ? 1 : \n\t\t($splitdir eq 'v') ?\n\t\t$obj->renderQuadTree(\\@cluster2, $xorig+$w1, $yorig, $w2, $h, 'h') :\n\t\t$obj->renderQuadTree(\\@cluster2, $xorig, $yorig+$h1, $w, $h2, 'v'));\n}\n\nsub computeGradient {\n\tmy ($obj) = @_;\n\tmy @colormap = ();\n\tmy @t = split(' ', $obj->{props}->[0]);\n\tforeach (@t) {\n\t\tpush @colormap, $colors{$_}\n\t\t\tif defined($colors{$_});\n\t}\n\t$obj->{yh} *= 2, $obj->{yl} = 0\n\t\tif ($obj->{yh} == $obj->{yl});\n\tmy $incr = ($obj->{yh} - $obj->{yl})/24;\n\tmy $shadestep = ($obj->{yh} - $obj->{yl})/$#colormap;\n\tmy $min = $obj->{yl};\n\tmy $max;\n\t$_->[3] = $min,\n\t$_->[4] = $min + $shadestep, \n\t$min += $shadestep\n\t\tforeach (@colormap);\n\t\t\n\tmy @newmap = ();\n\tmy ($redincr, $greenincr, $blueincr) = (0,0,0);\n\tmy $img = $obj->{img};\n\tmy ($thiscolor, $nextcolor);\n\t$nextcolor = $colormap[0];\n\tmy ($redcomp, $greencomp, $bluecomp);\n\tmy $i;\n\tforeach (1..$#colormap) {\n\n\t\t$thiscolor = $nextcolor;\n\t\t$nextcolor= $colormap[$_];\n\t\t$min = $thiscolor->[3];\n\t\t$max = $thiscolor->[4];\n\n\t\t$i = int(($max - $min)/$incr);\n\t\t$redincr = ($nextcolor->[0] - $thiscolor->[0])/$i;\n\t\t$greenincr = ($nextcolor->[1] - $thiscolor->[1])/$i;\n\t\t$blueincr = ($nextcolor->[2] - $thiscolor->[2])/$i;\n\t\tmy ($redcomp, $greencomp, $bluecomp, $min, $max) = @$thiscolor;\n\t\tpush(@newmap, [ $redcomp, $greencomp, $bluecomp, $min, $min + $incr,\n\t\t\t$img->colorAllocate($redcomp, $greencomp, $bluecomp) ]),\n\t\t$min += $incr,\n\t\t$redcomp += $redincr, \n\t\t$greencomp += $greenincr, \n\t\t$bluecomp += $blueincr\n\t\t\twhile ($min < $max);\n\t}\n\t$obj->{colormap} = \\@newmap;\n\treturn 1;\n}\nsub loadFont {\n\tmy ($obj, $font) = @_;\n\t\n\tmy $gd_text;\n\tmy $ptsz;\n\tmy $rc;\n\tforeach (5,6,7) {\n\t\t$gd_text = GD::Text::Align->new($obj->{img},\n\t\t\tvalign => 'top', halign => 'center') or return undef;\n\t\t$ptsz = $_;\n\t\twhile ($ptsz < 12) {\n\t\t\t$rc = $gd_text->set_font($font, $ptsz);\n\t\t\tlast if $rc;\n\t\t\t$ptsz++;\n\t\t}\n\t\treturn undef unless ($ptsz < 13);\n\t\t$fontMap{$_} = $gd_text;\n\t}\n\treturn 1;\n}\nsub string {\n\tmy ($obj, $size, $angle, $x, $y, $val, $fontsz) = @_;\n\n\tmy $img = $obj->{img};\n\t$angle = 0 unless $angle;\n\t$angle = 3.1415926 * ($angle/360);\n\t\n\tmy $rc;\n\tmy $font = $obj->{font};\n\tunless ($font eq 'gd') {\n\t\tunless ($fontMap{$size}) {\n\t\t\tmy $gd_text = GD::Text::Align->new($img,\n\t\t\t\tvalign => 'top', halign => 'right') or return undef;\n\t\t\tmy $ptsz = $size;\n\t\t\twhile ($ptsz < $size + 4) {\n\t\t\t\tlast if $gd_text->set_font($font, $ptsz);\n\t\t\t\t$ptsz++;\n\t\t\t}\n\t\t\treturn undef unless ($ptsz < $size+4);\n\t\t\t$fontMap{$size} = $gd_text;\n\t\t}\n\t\t$fontsz = $sfw unless $fontsz;\n\t\t$x += (length($val) * ($fontsz>>1));\n\t\t$rc = $fontMap{$size}->set( color => $obj->{textColor} );\n\t\t$rc = $fontMap{$size}->set_text( $val );\n\t\t$rc = $fontMap{$size}->draw(int($x), int($y), $angle);\n\t\treturn 1 if $rc;\n\t}\n\t$font = $gdfontmap{$size};\n\t$img->string($font,$x,$y, $val, $obj->{textColor}),\n\treturn 1\n\t\tunless $angle;\n\t\n\t$img->stringUp($font,$x,$y, $val, $obj->{textColor});\n\treturn 1\n}\t\n\n1;\n}",
      "file" : "/var/tmp/arv_Gqz_Te/DBD-Chart-0.82/Chart/Plot.pm",
      "package" : "DBD::Chart::Plot"
   }
]
