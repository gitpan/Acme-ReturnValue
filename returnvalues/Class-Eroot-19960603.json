[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "DESTROY {\n\tmy $self = shift;\n\n\t$self->Store;\n}\n\n\nsub Keep {\n\tmy $self = shift;\n\tmy( $name, $ref ) = @_;\n\tmy $i = @{$self->refs};\n\tmy $id;\n\n\tif( @_ != 2 ){\n\t\tcroak \"usage - EROOT::Keep( self, name, ref )\";\n\t\treturn;\n\t}\n\tif( ! ref $ref ){\n\t\tcarp \"Not an object\";\n\t}\n\telse{\n\t\t$self->refs( $i, $ref );\n\t\t($id) = \"$ref\" =~ /\\((0x[a-f0-9]+)\\)$/o;\n\t\t$self->xrefs( $id, $i );\n\t\t$self->xnames( $name, $id );\n\t\t$self->id2name( $id, $name );\n\t}\n}\n\n\nsub Lose {\n\tmy( $self, $ref ) = @_;\n\tmy( $id, $i );\n\n\tif( ref $ref ){\n\t\t($id) = \"$ref\" =~ /\\((0x[a-f0-9]+)\\)$/o;\n\t\tif( defined $self->xrefs($id) ){\n\t\t\t$i = $self->xrefs($id);\n\t\t\t$self->refs( $i, undef );\n\t\t\t$self->xrefs( $id, undef );\n\t\t\t$self->id2name( $id, undef );\n\t\t}\n\t}\n\telsif( defined $self->xnames( $ref ) ){\n\t\t$id = $self->xnames( $ref );\n\t\t$i = $self->xrefs( $id );\n\t\t$self->refs( $i, undef );\n\t\t$self->xrefs( $id, undef );\n\t\t$self->id2name( $id, undef );\n\t}\n\telse{\n\t\tcarp \"Not an object\";\n\t}\n}\n\n\nsub Root {\n\tmy( $self, $name ) = @_;\n\tmy( $id, $i );\n\tmy $root = undef;\n\n\tif( defined $self->xnames( $name ) ){\n\t\t$id = $self->xnames( $name );\n\t\t$i = $self->xrefs( $id );\n\t\t$root = $self->refs( $i );\n\t}\n\telse{\n\t\tcarp \"No root named $name\";\n\t}\n\t$root;\n}\n\n\nsub List {\n\tmy $self = shift;\n\tmy @keys = keys %{$self->xrefs};\n\tmy( $id, $i );\n\n\twhile( @keys ){\n\t\t$id = shift @keys;\n\t\t$i = $self->xrefs( $id );\n\t\tprint $self->id2name($id),\" is \",$self->refs($i),\"\\n\";\n\t}\n}\n\n\n\nsub Resume {\n\teval qq{ bless \\$_[2], qq{$_[1]} };\n\tif( $@ ){\n\t\twarn \"While blessing ref $_[2] in class $_[1]: $@\";\n\t}\n\telse{\n\t\teval { $_[2]->resume };\n\t}\n}\n\n\n\nsub Store {\n\tmy $self = shift;\n\tmy $name = $self->{'fname'};\n\tmy( $n, $obj, @k );\n\tmy @s = ();\n\tmy @objs = @{$self->{'refs'}};\n\tmy $roots = $self->{'xrefs'};\n\tmy $id2name = $self->{'id2name'};\n\tmy $key = $self->{'key'};\n\tmy( $class, $type, $ident );\n\tmy %id = ();\n\n\twhile( @objs ){\n\t\t$obj = shift @objs;\n\t\tnext if( ! defined $obj );\n\t\t$class = \"\";\n\t\t\"$obj\" =~ /^([^=]+)=/o && do { $class = $1 };\n\t\tif( \"$obj\" =~ /([A-Z]+)\\((0x[a-f0-9]+)\\)$/o ){\n\t\t\t($type,$ident) = ($1,$2);\n\t\t\tnext if( defined $id{$ident} );\n\t\t\t$id{$ident}++;\n\t\t\tpush( @s, \"end $ident\" );\n\n\t\t\teval { $obj->suspend } if( $class ne '' );\n\n\t\t\tif( $type eq 'ARRAY' ){\n\t\t\t\tif( @$obj ){\n\t\t\t\t\t$self->StoreArray( $obj, $ident, \\@s, \\@objs );\n\t\t\t\t}\n\t\t\t}\n\t\t\telsif( $type eq 'HASH' ){\n\t\t\t\tif( keys %$obj ){\n\t\t\t\t\t$self->StoreHash( $obj, $ident, \\@s, \\@objs );\n\t\t\t\t}\n\t\t\t}\n\t\t\telsif( $type eq 'SCALAR' ){\n\t\t\t\t$self->StoreScalar( $obj, $ident, \\@s, \\@objs );\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdie \"Don't know how to handle $type $obj\";\n\t\t\t}\n\t\t\tif( defined $roots->{$ident} ){\n\t\t\t\t$n = $id2name->{$ident};\n\t\t\t\tpush( @s, \"root $ident $n\" );\n\t\t\t\t$roots->{$ident} = undef;\n\t\t\t}\n\t\t\tpush( @s, \"object $ident $type $class\" );\n\t\t}\n\t\telse{\n\t\t\twarn \"Eroot: Unable to recognize object $obj\";\n\t\t}\n\t}\n\t$self->DumpStack( \\@s )\t\t\tif $EROOT::DumpStack;\n\t$self->WriteStack( $key, $name, \\@s )\tif $EROOT::WriteStack;\n}\n\n\n\nsub WriteStack {\n\tmy $self = shift;\n\tmy( $key, $name, $s ) = @_;\n\tmy $fh = (caller)[0] . \"::$name\";\n\tmy $i = @$s;\n\tmy( $type, @v, $v );\n\tmy( $junk, $word, $ident, $stuff );\n\tmy @roots = ();\n\tmy @keep = ();\n\tmy @keepwake = ();\n\tmy @wake = ();\n\tmy %wake = ();\n\tmy( $e1, $e2, $elem, $whack );\n\tmy @delayed = ();\n\n\topen( $fh, \">$name\" ) || do{\n\t\twarn \"Eroot: Cannot save objects, unable to write to file $name\";\n\t\treturn;\n\t};\n\tprint $fh \"#KEY:$key\\n\";\n\tprint $fh \"# Persistent objects\\n\";\n\tprint $fh \"sub EROOT::Continue {\\n\";\n\tprint $fh \"  my \\$self = shift;\\n\";\n\tprint $fh \"  my \\%ref = ();\\n\";\n\tprint $fh \"  die \\\"These persistent objects (key=$key) do not belong to this application.\\\\n\\\"\\n\";\n\tprint $fh \"    if( \\$self->{\\'key\\'} ne \\'$key\\' );\\n\";\n\twhile( $i-- > 0 ){\n\t\t($junk, $word, $ident, $stuff) =\n\t\t\tsplit( /^(\\w+) ([^\\s]+) ?/o, $s->[$i], 2 );\n\t\tif( $word eq 'object' ){\n\t\t\t@v = split( ' ', $stuff );\n\t\t\t$e1 = $e2 = $type = $whack = '';\n\t\t\tif( $v[0] eq 'ARRAY' ){\n\t\t\t\t$e1 = \"[\";\n\t\t\t\t$e2 = \"]\";\n\t\t\t\t$type = \" = []\";\n\t\t\t}\n\t\t\telsif( $v[0] eq 'HASH' ){\n\t\t\t\t$e1 = \"{\\'\";\n\t\t\t\t$e2 = \"\\'}\";\n\t\t\t\t$type = \" = {}\";\n\t\t\t}\n\t\t\telsif( $v[0] eq 'SCALAR' ){\n\t\t\t\t$whack = \"\\\\\";\n\t\t\t}\n\t\t\tif( defined $v[1] ){\n\t\t\t\tpush( @wake, \"$ident!\\$self->Resume( \\'$v[1]\\', \\$ref{\\'$ident\\'} );\" );\n\t\t\t\t$wake{$ident} = $#wake;\n\t\t\t}\n\t\t\tprint $fh \"  {\\n    my \\$x$type;\\n\";\n\t\t}\n\t\telsif( $word eq 'root' ){\n\t\t\tpush( @keep, \"\\$self->Keep( \\'$stuff\\', \\$ref{\\'$ident\\'} );\" );\n\t\t\tif( $wake{$ident} ){\n\t\t\t\tpush( @keepwake, \"\\$self->Resume( \\'$v[1]\\', \\$ref{\\'$ident\\'} );\" );\n\t\t\t\tdelete $wake{$ident};\n\t\t\t}\n\t\t}\n\t\telsif( $word eq 'end' ){\n\t\t\tprint $fh \"    \\$ref{\\'$ident\\'} = $whack\\$x;\\n  }\\n\";\n\t\t}\n\t\telsif( $word eq 'ref' ){\n\t\t\t($junk, @v) = split( /^\\(([^)]*)\\) /o, $stuff, 0 );\n\t\t\t$elem = ($v[0] ne '') ? \"->$e1$v[0]$e2\" : \"\";\n\t\t\tpush( @delayed, \"  \\$ref{\\'$ident\\'}$elem = $whack\\$ref{\\'$v[1]\\'};\" );\n\t\t}\n\t\telsif( $word eq 'simple' ){\n\t\t\t($junk, @v) = split( /^\\(([^)]*)\\) /o, $stuff, 0 );\n\t\t\t$v[1] = '' unless defined $v[1];\n\t\t\t$elem = ($v[0] ne '') ? \"->$e1$v[0]$e2\" : \"\";\n\t\t\t$v[1] =~ s/\\'/\\\\\\'/og; \n\t\t\tprint $fh \"    \\$x$elem = \\'$v[1]\\';\\n\";\n\t\t}\n\t\telse{\n\t\t\twarn \"Eroot: Unknown code: $v\";\n\t\t}\n\t}\n\tprint $fh join(\"\\n\", @delayed),\"\\n\";\n\twhile( @wake ){\n\t\t$_ = shift @wake;\n\t\t@_ = split('!');\n\t\tnext unless defined $wake{$_[0]};\n\t\tprint $fh \"  $_[1]\\n\";\n\t}\n\tprint $fh \"  \", join(\"\\n  \", reverse @keepwake), \"\\n\";\n\tprint $fh \"  \", join(\"\\n  \", reverse @keep), \"\\n\";\n\tprint $fh \"  0;\\n}\\n1;\\n\";\n\tclose( $fh );\n}\n\nsub StoreScalar {\n\tmy $self = shift;\n\tmy( $obj, $ident, $s, $objs ) = @_;\n\tmy $v;\n\n\tif( ref $$obj ){\n\t\t($v) = \"$$obj\" =~ /\\((0x[a-f0-9]+)\\)$/o;\n\t\tpush( @$s, \"ref $ident () $v\" );\n\t\tpush( @$objs, $$obj );\n\t}\n\telse{\n\t\tpush( @$s, \"simple $ident () $$obj\" );\n\t}\n}\n\nsub StoreHash {\n\tmy $self = shift;\n\tmy( $obj, $ident, $s, $objs ) = @_;\n\tmy( $k, $v, @k );\n\n\t@k = keys %$obj;\n\twhile( @k ){\n\t\t$k = shift @k;\n\t\tif( defined $obj->{$k} ){\n\t\t\tif( ! ref $obj->{$k} ){\n\t\t\t\tpush( @$s, \"simple $ident ($k) $obj->{$k}\" );\n\t\t\t}\n\t\t\telse{\n\t\t\t\t($v) = \"$obj->{$k}\" =~ /\\((0x[a-f0-9]+)\\)$/o;\n\t\t\t\tpush( @$s, \"ref $ident ($k) $v\" );\n\t\t\t\tpush( @$objs, $obj->{$k} );\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nsub StoreArray {\n\tmy $self = shift;\n\tmy( $obj, $ident, $s, $objs ) = @_;\n\tmy $k = 0;\n\tmy $v;\n\n\twhile( $k < @$obj ){\n\t\tif( defined $obj->[$k] ){\n\t\t\tif( ! ref $obj->[$k] ){\n\t\t\t\tpush( @$s, \"simple $ident ($k) $obj->[$k]\" );\n\t\t\t}\n\t\t\telse{\n\t\t\t\t($v) = \"$obj->[$k]\" =~ /\\((0x[a-f0-9]+)\\)$/o;\n\t\t\t\tpush( @$s, \"ref $ident ($k) $v\" );\n\t\t\t\tpush( @$objs, $obj->[$k] );\n\t\t\t}\n\t\t}\n\t\t++$k;\n\t}\n\t$k;\n}\n\nsub DumpStack {\n\tmy $self = shift;\n\tmy $s = shift;\n\tmy $i = @$s;\n\n\twhile( $i-- > 0 ){\n\t\tprint \"$s->[$i]\\n\";\n\t}\n}\n1",
      "file" : "/var/tmp/arv_X7hmGZ/Class-Eroot/Eroot.pm",
      "package" : "EROOT"
   }
]
