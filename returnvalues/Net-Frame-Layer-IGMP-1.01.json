[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "sub v3report {\n   shift->SUPER::new(\n      type         => NF_IGMP_TYPE_REPORTv3,\n      maxResp      => 0,\n      checksum     => 0,\n      reserved     => 0,\n      numGroupRecs => 0,\n      @_,\n   );\n}\n\nsub getLength { 8 }\n\nsub pack {\n   my $self = shift;\n\n   my $raw;\n   if ($self->type == NF_IGMP_TYPE_REPORTv3) {\n      $raw = $self->SUPER::pack('CCnnn',\n         $self->type,\n         $self->maxResp,\n         $self->checksum,\n         $self->reserved,\n         $self->numGroupRecs\n      ) or return;\n   } else {\n      $raw = $self->SUPER::pack('CCna4',\n         $self->type,\n         $self->maxResp,\n         $self->checksum,\n         inetAton($self->groupAddress)\n      ) or return;\n   }\n\n   return $self->raw($raw);\n}\n\nsub unpack {\n   my $self = shift;\n\n   my ($type, $maxResp, $checksum, $groupAddress, $payload) =\n      $self->SUPER::unpack('CCna4 a*', $self->raw)\n         or return;\n\n   $self->type($type);\n   $self->maxResp($maxResp);\n   $self->checksum($checksum);\n   \n   if ($self->type == NF_IGMP_TYPE_REPORTv3) {\n      $self->reserved(unpack \"n\", (substr $groupAddress, 0, 2));\n      $self->numGroupRecs(unpack \"n\", (substr $groupAddress, 2, 2));\n   } else {\n      $self->groupAddress(inetNtoa($groupAddress))\n   }\n\n   $self->payload($payload);\n\n   return $self;\n}\n\nsub computeChecksums {\n   my $self = shift;\n   my ($layers) = @_;\n\n   my $phpkt;\n   if ($self->type == NF_IGMP_TYPE_REPORTv3) {\n      $phpkt .= $self->SUPER::pack('CCnnn',\n         $self->type, $self->maxResp, 0, $self->reserved, $self->numGroupRecs)\n            or return;\n   } else {\n      $phpkt .= $self->SUPER::pack('CCna4',\n         $self->type, $self->maxResp, 0, inetAton($self->groupAddress))\n            or return;\n   }\n\n   my $start   = 0;\n   my $last    = $self;\n   my $payload = '';\n   for my $l (@$layers) {\n      $last = $l;\n      if (! $start) {\n\t $start++ if $l->layer eq 'IGMP';\n         next;\n      }\n      $payload .= $l->pack;\n   }\n\n   if (defined($last->payload) && length($last->payload)) {\n      $payload .= $last->payload;\n   }\n\n   if (length($payload)) {\n      $phpkt .= $self->SUPER::pack('a*', $payload)\n         or return;\n   }\n\n   $self->checksum(inetChecksum($phpkt));\n\n   return 1;\n}\n\nsub encapsulate {\n   my $self = shift;\n\n   return $self->nextLayer if $self->nextLayer;\n\n   if ($self->payload) {\n      if ($self->type == 0x11) {\n         return 'IGMP::v3Query';\n      } elsif ($self->type == 0x22) {\n         return 'IGMP::v3Report';\n      } elsif ($self->type == 0x13) {\n         return 'DVMRP';\n      }\n   }\n\n   NF_LAYER_NONE;\n}\n\nsub print {\n   my $self = shift;\n\n   my $l = $self->layer;\n   my $buf = sprintf\n      \"$l: type:0x%02x  maxResp:%d  checksum:0x%04x\\n\",\n         $self->type, $self->maxResp, $self->checksum;\n\n   if ($self->type == NF_IGMP_TYPE_REPORTv3) {\n      $buf .= sprintf\n      \"$l: reserved:%d  numGroupRecs:%d\",\n         $self->reserved, $self->numGroupRecs;\n   } else {\n      $buf .= sprintf\n      \"$l: groupAddress:%s\",\n         $self->groupAddress;\n   }\n\n   return $buf;\n}\n\n1",
      "file" : "/var/tmp/arv_iAjlga/Net-Frame-Layer-IGMP-1.01/lib/Net/Frame/Layer/IGMP.pm",
      "package" : "Net::Frame::Layer::IGMP"
   }
]
