[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub _decompress {\n\t\n\tmy $compressed_file = shift;\n\t\n\tmy $null = $^O eq \"MSWin32\" ? \"NUL\" : \"/dev/null\";\n\teval(\"system('gzip --version > $null')\") == 0\n\t\tor croak \"ERROR: Cannot find 'gzip'\\n\";\n\n\tmy $basename = basename($compressed_file);\n\t\n\tprint \"decompress $compressed_file...\\n\";\n\tmy $command;\n\t\n\t$command = \"gzip -l \\\"$compressed_file\\\"\";\n\tmy $status = `$command`;\n\t\n\tmy @foo = split \"\\n\", $status;\n\t@foo = split \" \", $foo[1];\n\tmy $uncompressed_file = $foo[$#foo];\n\t\n\t$command = \"gzip -cd \\\"$compressed_file\\\" > \\\"$uncompressed_file\\\"\";\n\t\n\tsystem($command) == 0\n\t\tor croak \"ERROR: $!\\n\";\n\t\n\treturn \"$uncompressed_file\";\n}",
      "file" : "/var/tmp/arv_prHqie/Microarray-GEO-SOFT-0.20/lib/Microarray/GEO/SOFT.pm",
      "package" : "Microarray::GEO::SOFT"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub _parse_sample {\n\n\tmy $self = shift;\n\n\tmy $fh = shift;\n\t\n\tMicroarray::GEO::SOFT::_set_fh($self->{verbose});\n\t\n\tmy $accession;\n\tmy $title;\n\tmy $platform;\n\tmy $table_colnames = [];\n\tmy $table_rownames = [];\n\tmy $table_matrix = [];\n\n\twhile(my $line = <$fh>) {\n\t\t\n\t\tchomp $line;\n\t\tif($line =~/^!Sample_geo_accession = (GSM\\d+)$/) {\n\t\t\t$accession = $1;\n\t\t}\n\t\t\n\t\telsif($line =~/^!Sample_title = (.*?)$/) {\n\t\t\t$title = $1;\n\t\t}\n\t\t\n\t\telsif($line =~/^!Sample_platform_id = (GPL\\d+)$/) {\n\t\t\t$platform = $1;\n\t\t}\n\t\t\n\t\telsif($line =~/^!sample_table_begin$/) {\n\t\t\t\n\t\t\t$line = <$fh>;\n\t\t\tchomp $line;\n\t\t\t\n\t\t\t@$table_colnames = split \"\\t\", $line, -1;\n\t\t\tshift(@$table_colnames);\n\t\t\t\n\t\t\tmy $value_index = -1;\n\t\t\tfor(my $i = 0; $i < len($table_colnames); $i ++) {\n\t\t\t\tif($table_colnames->[$i] eq $self->{sample_value_column}) {\n\t\t\t\t\t$value_index = $i;\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif($value_index == -1) {\n\t\t\t\tcroak \"ERROR: Cannot find sample value column ($self->{sample_value_column}).\";\n\t\t\t}\n\t\t\t\n\t\t\twhile($line = <$fh>) {\n\t\t\t\n\t\t\t\tif($line =~/^!sample_table_end$/) {\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tchomp $line;\n\t\t\t\tmy @tmp = split \"\\t\", $line, -1;\n\t\t\t\t\n\t\t\t\tmy $uid = shift(@tmp);\n\t\t\t\t\n\t\t\t\tpush(@$table_rownames, $uid);\n\t\t\t\tpush(@$table_matrix, [$tmp[$value_index]]);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif($line =~/^!sample_table_end$/) {\n\t\t\tlast;\n\t\t}\n\t\t\n\t}\n\t\n\tmy $n_row = len($table_rownames);\n\tmy $n_col = len($table_colnames);\n\t\n\tprint \"Sample info:\\n\";\n\tprint \"  Accession: $accession\\n\";\n\tprint \"  Platform: $platform\\n\";\n\tprint \"  Title: $title\\n\";\n\tprint \"  Rows: $n_row\\n\";\n\tprint \"  Columns: $n_col\\n\";\n\tprint \"\\n\";\n\t\n\t\n\t$self->set_meta( accession => $accession,\n\t                 title     => $title,\n\t\t\t\t\t platform  => $platform );\n\t$self->set_table( rownames => $table_rownames,\n\t                  colnames => $table_colnames,\n\t\t\t\t\t  matrix   => $table_matrix );\n\t\n\tMicroarray::GEO::SOFT::_set_to_std_fh();\n\t\n\treturn $self;\n\n}",
      "file" : "/var/tmp/arv_prHqie/Microarray-GEO-SOFT-0.20/lib/Microarray/GEO/SOFT/GSM.pm",
      "package" : "Microarray::GEO::SOFT::GSM"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub _mapping {\n\n\tmy $self = shift;\n\tmy $to_id = shift;\n\tmy $from_list = shift;\n\t\n\tmy $mapping;\n\t\n\tmy $to_index;\n\tmy $colnames = $self->colnames;\n\tfor(my $i = 0; $i < len($colnames); $i ++) {\n\t\tif($colnames->[$i] eq $to_id) {\n\t\t\t$to_index = $i;\n\t\t\tlast;\n\t\t}\n\t}\n\t\n\tif(! defined($to_index)) {\n\t\tcroak \"ERROR: Cannot find ID ($to_id) in \".$self->platform.\"\\n\";\n\t}\n\t\n\tmy $mat = $self->matrix;\n\tmy $hash;\n\tmy $rownames = $self->rownames;\n\tfor(my $i = 0; $i < len($mat); $i ++) {\n\t\tif($mat->[$i]->[$to_index] =~/^(.*?)\\/\\/\\//) {\n\t\t\t$hash->{$rownames->[$i]} = $1;\n\t\t}\n\t\telse {\n\t\t\t$hash->{$rownames->[$i]} = $mat->[$i]->[$to_index];\n\t\t}\n\t}\n\t\n\tfor (@$from_list) {\n\t\tpush(@$mapping, $hash->{$_});\n\t}\n\n\treturn $mapping;\n\t\n}",
      "file" : "/var/tmp/arv_prHqie/Microarray-GEO-SOFT-0.20/lib/Microarray/GEO/SOFT/GPL.pm",
      "package" : "Microarray::GEO::SOFT::GPL"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub _merge_gsm {\n\n\tmy $self = shift;\n\t\n\tmy $gsm_list = shift;\n\t\n\tMicroarray::GEO::SOFT::_set_fh($self->{verbose});\n\t\n\tmy $gpl_list = sapply($gsm_list, sub {$_[0]->platform});\n\tif(len(unique($gpl_list)) != 1) {\n\t\tcroak \"ERROR: Platform should be same\\n\";\n\t}\n\t\n\t$GDS_MERGE ++;\n\tmy $accession = \"GDS_merge_$GDS_MERGE\".\"_from_\".$self->accession;\n\tmy $title = \"merged from \".$self->accession.\" under \".$gpl_list->[0];\n\tmy $platform = $gpl_list->[0];\n\tmy $table_colnames;\n\tmy $table_colnames_explain;\n\t\n\tfor(my $i = 0; $i < len($gsm_list); $i ++) {\n\n\t\t$table_colnames->[$i] = $gsm_list->[$i]->accession;\n\t\t$table_colnames_explain->[$i] = $gsm_list->[$i]->title;\n\t\t\n\t}\n\n\tmy $table_rownames = $gsm_list->[0]->rownames;\n\t\n\tmy $table_matrix = [[]];\n\tfor(my $i = 0; $i < len($gsm_list); $i ++) {\n\t\tfor(my $j = 0; $j < len($table_rownames); $j ++) {\n\t\t\t$table_matrix->[$j]->[$i] = $gsm_list->[$i]->matrix->[$j]->[0];\n\t\t}\n\t}\n\t\n\t\n\tmy $n_row = len($table_rownames);\n\tmy $n_col = len($table_colnames);\n\t\n\tprint \"Merge GSM into GDS:\\n\";\n\tprint \"  Accession: $accession\\n\";\n\tprint \"  Platform: $platform\\n\";\n\tprint \"  Title: $title\\n\";\n\tprint \"  Rows: $n_row\\n\";\n\tprint \"  Columns: $n_col\\n\";\n\tprint \"\\n\";\n\t\n\tmy $gds = Microarray::GEO::SOFT::GDS->new();\n\t$gds->set_meta( accession => $accession,\n\t                title     => $title,\n\t\t\t\t\tplatform  => $platform );\n\t$gds->set_table( rownames => $table_rownames,\n\t                 colnames => $table_colnames,\n\t\t\t\t\t colnames_explain => $table_colnames_explain,\n\t\t\t\t\t matrix   => $table_matrix );\n\t\n\tMicroarray::GEO::SOFT::_set_to_std_fh();\n\t\n\treturn $gds;\n}",
      "file" : "/var/tmp/arv_prHqie/Microarray-GEO-SOFT-0.20/lib/Microarray/GEO/SOFT/GSE.pm",
      "package" : "Microarray::GEO::SOFT::GSE"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub soft2exprset {\n\n\tmy $self = shift;\n\n\tmy $eset = Microarray::ExprSet->new;\n\t$eset->set_feature($self->rownames);\n\t$eset->set_phenotype($self->colnames_explain);\n\t$eset->set_matrix($self->matrix);\n\t\n\treturn $eset;\n\t\n}",
      "file" : "/var/tmp/arv_prHqie/Microarray-GEO-SOFT-0.20/lib/Microarray/GEO/SOFT/GDS.pm",
      "package" : "Microarray::GEO::SOFT::GDS"
   }
]
