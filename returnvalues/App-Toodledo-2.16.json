[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method get_session_token ( Str :$app_token?, Str :$user_id? ) {\n  my $app_id   = $self->app_id;\n  $user_id   ||= $self->user_id or $self->log->logdie(\"No user_id\");\n  $app_token ||= $self->app_token or $self->log->logdie(\"No app_token\");\n  $self->user_id( $user_id );\n  $self->app_token( $app_token );\n\n  my $session_token = $self->_session_token_from_cache( $user_id, $app_id,\n\t\t\t\t\t\t        $app_token);\n  $self->session_token( $session_token );\n  $session_token;\n}\n\n\nmethod _session_token_from_cache ( Str $user_id!, Str $app_id!, Str $app_token! ) {\n  my $token_cache = $self->_token_cache;\n  my $session_token;\n  if ( my $token_info = $token_cache->valid_token( user_id => $user_id,\n\t\t\t\t\t\t   app_id  => $app_id ) )\n  {\n    $self->log->debug( \"Have valid saved token\\n\" );\n    $session_token = $token_info->token;\n  }\n  else\n  {\n    $session_token = $self->new_session_token( $app_token );\n    $token_cache->add_token_info( user_id => $user_id,\n\t\t\t\t  app_id  => $app_id,\n\t\t\t\t  token   => $session_token );\n    $token_cache->save;\n  }\n  $session_token;\n}\n\n\nmethod get_session_token_from_rc ( Str $user_id? ) {\n  $user_id ||= $self->user_id || $self->default_user_id\n    or $self->log->logdie( \"No user_id and no default user_id\");\n  my $app_id = $self->app_id;\n  my $app_token = $self->app_token_of( $app_id )\n    or $self->log->logdie(\"Cannot get app_token for $app_id\");\n  $self->get_session_token( app_token => $app_token, user_id => $user_id );\n}\n\n\nmethod _make_session_key ( Str $password!, Str $app_token!, Str $session_token! ) {\n  md5_hex( md5_hex( $password ) . $app_token . $session_token );\n}\n\n\nmethod connect ( Str $password! ) {\n  my $session_token = $self->session_token\n    or $self->log->logdie(\"Need to get session token first\");\n  my $key = $self->_make_session_key( $password, $self->app_token,\n\t\t\t\t      $session_token );\n  $self->session_key( $key );\n  my $account_ref = $self->get( 'account' ) or $self->log->logdie( \"No account info\");\n  $self->account_info( $account_ref );\n  $key;\n}\n\n\nmethod login ( Str :$user_id, Str :$password!, Str :$app_token! ) {\n  $self->app_token( $app_token );\n  $self->get_session_token( user_id => $user_id, app_token => $app_token );\n  $self->connect( $password );\n}\n\n\nmethod login_from_rc ( Str $user_id? ) {\n  my @args = $user_id ? $user_id : ();\n  $self->get_session_token_from_rc( @args );\n  my $password = $self->password_of( $self->user_id )\n    or $self->log->logdie(\"Cannot get password\");\n  $self->log->debug( \"Loaded password from info cache\\n\" );\n  $self->connect( $password );\n}\n\n\nsub _token_cache\n{\n  my $file = _token_cache_name();\n\n  App::Toodledo::TokenCache->new_from_file( $file );\n}\n\n\nsub _token_cache_name\n{\n  File::Spec->catfile( home(), __PACKAGE__->Token_File_Name );\n}\n\n\nmethod app_token_of ( Str $app_id! ) {\n  my $cache = $self->_get_info_cache;\n  $cache->app_token_ref->{$app_id};\n}\n\n\nmethod password_of ( Str $user_id! ) {\n  my $cache = $self->_get_info_cache;\n  $cache->password_ref->{$user_id};\n}\n\n\nmethod default_user_id () {\n  my $cache = $self->_get_info_cache;\n  $cache->default_user_id;\n}\n\n\nmethod _get_info_cache () {\n  my $file = _info_cache_name();\n\n  $self->info_cache and return $self->info_cache;\n  $self->log->debug( \"Fetching info cache\\n\" );\n  my $cache = App::Toodledo::InfoCache->new_from_file( $file );\n  $self->info_cache( $cache );\n  $cache;\n}\n\n\nsub _info_cache_name\n{\n  File::Spec->catfile( home(), __PACKAGE__->Info_File_Name );\n}\n\n\nmethod new_session_token ( Str $app_token! ) {\n  my $sig    = $self->_signature( $self->user_id, $app_token );\n  my $argref = { appid  => $self->app_id,\n\t\t userid => $self->user_id,\n\t\t sig    => $sig };\n  $self->log->debug( \"Creating new session token\\n\" );\n  my $ref = $self->call_func( account => token => $argref );\n  $ref->{token};\n}\n\n\nmethod _signature( Str $user_id!, Str $app_token! ) {\n  md5_hex( \"$user_id$app_token\" );\n}\n\n\nmethod get ( Str $type!, %param ) {\n  my $class = __PACKAGE__ . '::' . ucfirst( $type );\n  $class =~ s/s\\z//;\n  eval \"require $class\";\n\n  if ( $type eq 'tasks' )\n  {\n    $param{fields} ||= join ',' => $class->optional_attributes;  \n    $param{start}  ||= 0;\n  }\n\n  my @things;\n  FETCH: {\n    my $ref = $self->call_func( $type => 'get', \\%param );\n    my @returned = ref $ref eq 'ARRAY' ? @$ref : $ref;\n\n    my $counter = $type eq 'tasks' ? shift @returned : ();\n    push @things, map { $class->new( %$_ ) } @returned;\n    if ( $type eq 'tasks' && @returned )  \n    {\n      if ( $param{start} + $counter->{num} != $counter->{total} )\n      {\n\t$self->log->debug( \"Start = $param{start}, Total = $counter->{total}, \"\n\n\t\t. \" Num = $counter->{num}\\n\" );\n\t$param{start} += $counter->{num};\n\tredo FETCH;\n      }\n    }\n  }  \n\n  @things = sort { $a->ord <=> $b->ord } @things\n    if @things && $things[0]->{ord};\n  wantarray ? @things : shift @things;\n}\n\n\nsub _make_user_agent  \n{\n  LWP::UserAgent->new;\n}\n\n\nmethod call_func ( Str $func!, Str $subfunc!, HashRef $argref? ) {\n  my $user_agent = $self->user_agent;\n  $argref ||= {};\n  $argref->{key} = $self->session_key if $self->session_key;\n  $self->log->debug( \"Calling function $func/$subfunc\\n\" );\n  my %encoded_args = map { $_,  arg_encode( $argref->{$_} ) }\n                         keys %$argref;\n  my $res = $user_agent->post( \"$ROOT_URL$func/$subfunc.php\",\n\t\t\t       \\%encoded_args );\n  $res->code != 200\n    and $self->log->logdie( \"Unable to contact Toodledo\\n\");\n  my $ref = decode_json( $res->content )\n    or $self->log->logdie( \"Content invalid\\n\");\n\n  $self->log->logdie( $ref->{errorCode} == 500 ? \"Toodledo offline\\n\"\n                                 : \"Error: \" . $ref->{errorDesc})\n    if ref $ref eq 'HASH' && $ref->{errorCode};\n  $ref;\n}\n\n\nmethod select ( ArrayRef[Object] $o_ref, Str $expr ) {\n  my $prototype = $o_ref->[0] or return;\n\n  if ( ref( $prototype ) =~ /task/i )\n  {\n    $expr =~ s/(.*)/($1) && completed == 0/ unless $expr =~ /completed/;\n  }\n\n  $expr =~ s/\\b$_\\b/\\$self->$_/g for $prototype->attribute_list;\n  $self->log->debug( \"Searching in \" . @$o_ref . \"objects for '$expr'\\n\" );\n  my $selector = sub { my $self = shift; eval $expr };\n  $self->grep_objects( $o_ref, $selector );\n}\n\n\nmethod grep_objects ( ArrayRef[Object] $o_ref, CodeRef $selector ) {\n  grep { $selector->( $_ ) } @$o_ref;\n}\n\n\nmethod foreach ( ArrayRef[Object] $o_ref, CodeRef $callback, @args ) {\n  for ( @$o_ref )\n  {\n    $callback->( $_, @args );\n    $App::Toodledo::Task::can_use_cache = 1;\n  }\n}\n\n\nmethod get_tasks_with_cache ( @args ) {\n  $self->task_cache_valid and return $self->task_cache->tasks;\n  my @tasks = $self->get( tasks => comp => -1, @args );\n  $self->store_tasks_in_cache( @tasks );\n  @tasks;\n}\n\n\nmethod task_cache_valid () {\n  my $ai = $self->account_info;\n  unless ( $self->task_cache )\n  {\n    $self->task_cache( App::Toodledo::TaskCache->new );\n    return unless $self->task_cache->exists;\n    $self->task_cache->fetch;\n  }\n\n  my $fetched = $self->task_cache->last_updated;\n  my $logstr = \"Edited: \" . localtime( $ai->lastedit_task )\n             . \", Deleted: \" . localtime( $ai->lastdelete_task )\n             . \" Fetched: \" . localtime( $fetched );\n  if ( $ai->lastedit_task >= $fetched || $ai->lastdelete_task >= $fetched )\n  {\n    $self->log->debug( \"Task cache invalid ($logstr)\\n\" );\n    return;\n  }\n  $self->log->debug( \"Task cache valid ($logstr)\\n\" );\n  return 1;\n}\n\n\nmethod store_tasks_in_cache ( App::Toodledo::Task @tasks ) {\n  $self->task_cache or $self->task_cache( App::Toodledo::TaskCache->new );\n  $self->task_cache->store( @tasks );\n}\n\n\nmethod add( Object $object! ) {\n  $object->add( $self );\n}\n\n\nmethod edit ( Object $object, @more ) {\n  $object->edit( $self, @more );\n}\n\n\nmethod delete( Object $object ) {\n  $object->delete( $self );\n}\n\n\nmethod readable ( Object $object, Str $attribute ) {\n  my $value = $object->$attribute;\n  if ( $attribute =~ /date\\z/ )\n  {\n    $value or return '';\n    return preferred_date_format( $self->account_info->dateformat, $value );\n  }\n  $value;\n}\n\n\n1",
      "file" : "/var/tmp/arv_K5r5c2/App-Toodledo-2.16/lib/App/Toodledo.pm",
      "package" : "App::Toodledo"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method add ( App::Toodledo $todo! ) {\n  my @args = ( name => $self->name );\n  $self->$_ and push @args, ( $_ => $self->$_ ) for qw(private archived ord);\n  my $added_ref = $todo->call_func( folder => add => { @args } );\n  $added_ref->[0]{id};\n}\n\n\n1",
      "file" : "/var/tmp/arv_K5r5c2/App-Toodledo-2.16/lib/App/Toodledo/Folder.pm",
      "package" : "App::Toodledo::Folder"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method exists () {\n  -s _cache_filename() or return;\n  $self->log->debug( \"Task cache exists\\n\" );\n}\n\n\nmethod fetch () {\n  $self->log->debug( \"Loading from task cache\\n\" );\n  %$self = LoadFile( _cache_filename() );\n  $self->log->debug( \"Fetched \" . @{ $self->tasks } . \" tasks from \"\n          . _cache_filename() . \"\\n\" );\n}\n\n\nmethod store ( App::Toodledo::Task @tasks ) {\n  $self->last_updated( time );\n  $self->tasks( [ @tasks ] );\n  $self->log->debug( \"Storing \" . @tasks .\" tasks in \" . _cache_filename() . \"\\n\" );\n  DumpFile( _cache_filename(), %$self );\n}\n\n\n1",
      "file" : "/var/tmp/arv_K5r5c2/App-Toodledo-2.16/lib/App/Toodledo/TaskCache.pm",
      "package" : "App::Toodledo::TaskCache"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method add ( App::Toodledo $todo! ) {\n  my $added_ref = $todo->call_func( context => add => { name => $self->name } );\n  $added_ref->[0]{id};\n}\n\n\n1",
      "file" : "/var/tmp/arv_K5r5c2/App-Toodledo-2.16/lib/App/Toodledo/Context.pm",
      "package" : "App::Toodledo::Context"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method add ( App::Toodledo $todo! ) {\n  my @args = ( name => $self->name );\n  $self->$_ and push @args, ( $_ => $self->$_ ) for qw(description lat lon);\n  my $added_ref = $todo->call_func( location => add => { @args } );\n  $added_ref->[0]{id};\n}\n\n\n1",
      "file" : "/var/tmp/arv_K5r5c2/App-Toodledo-2.16/lib/App/Toodledo/Location.pm",
      "package" : "App::Toodledo::Location"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method new_from_file ( $class: Str $file! ) {\n  if ( -r $file && -f $file)\n  {\n    my $ref = LoadFile( $file );\n    my ($password_ref, $app_token_ref, $default_user_id)\n      = @{$ref}{qw(passwords app_tokens default_user_id)};\n    my $log = Log::Log4perl->get_logger();\n    $log->debug(\"Loaded info cache from $file\");\n    return $class->new( filename        => $file,\n\t\t\tpassword_ref    => $password_ref,\n\t\t\tapp_token_ref   => $app_token_ref,\n\t\t\tdefault_user_id => $default_user_id );\n  }\n  else\n  {\n    return $class->new( filename => $file );\n  }\n}\n\n\nmethod save_to_file ( Str $filename! ) {\n  my %params = ( passwords       => $self->password_ref,\n\t         app_tokens      => $self->app_token_ref,\n\t         default_user_id => $self->default_user_id );\n  DumpFile( $filename, \\%params );\n}\n\n\nmethod save () {\n  $self->log->debug(\"test\");\n  $self->save_to_file( $self->filename );\n}\n\n\n1",
      "file" : "/var/tmp/arv_K5r5c2/App-Toodledo-2.16/lib/App/Toodledo/InfoCache.pm",
      "package" : "App::Toodledo::InfoCache"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method is_still_good () {\n  time - $self->creation_time < __PACKAGE__->Max_Token_Life;\n}\n\n\n1",
      "file" : "/var/tmp/arv_K5r5c2/App-Toodledo-2.16/lib/App/Toodledo/TokenCache.pm",
      "package" : "App::Toodledo::TokenCache"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method delete ( App::Toodledo $todo! ) {\n  my $id = $self->id;\n  (my $type = lc ref $self) =~ s/.*://;\n  my $deleted_ref = $todo->call_func( $type => delete => { id => $id } );\n  $deleted_ref->[0]{id} == $id or $self->log->logdie(\"Did not get ID back from delete\");\n}\n\n\n1",
      "file" : "/var/tmp/arv_K5r5c2/App-Toodledo-2.16/lib/App/Toodledo/InternalWrapper.pm",
      "package" : "App::Toodledo::InternalWrapper"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method add ( App::Toodledo $todo! ) {\n  my @args = ( name => $self->name );\n  $self->$_ and push @args, ( $_ => $self->$_ )\n    for qw(title folder private added text);\n  my $added_ref = $todo->call_func( notebook => add => { @args } );\n  $added_ref->[0]{id};\n\n}\n\n\nmethod delete ( App::Toodledo $todo! ) {\n  my $id = $self->id;\n  my $deleted_ref = $todo->call_func( notebook => delete =>\n\t\t\t\t      { notebooks => [$id] } );\n  $deleted_ref->[0]{id} == $id or $self->log->logdie(\"Did not get ID back from delete\");\n}\n\n\n1",
      "file" : "/var/tmp/arv_K5r5c2/App-Toodledo-2.16/lib/App/Toodledo/Notebook.pm",
      "package" : "App::Toodledo::Notebook"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method add ( App::Toodledo $todo! ) {\n  my @args = ( name => $self->name );\n  $self->$_ and push @args, ( $_ => $self->$_ ) for qw(contributes level);\n  my $added_ref = $todo->call_func( goal => add => { @args } );\n  $added_ref->[0]{id};\n}\n\n\n1",
      "file" : "/var/tmp/arv_K5r5c2/App-Toodledo-2.16/lib/App/Toodledo/Goal.pm",
      "package" : "App::Toodledo::Goal"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method set_name( App::Toodledo $todo!, Str $type!, Item $new_string? ) {\n  my @args;\n  my $class = \"App::Toodledo::\\u$type\";\n  eval \"require $class\";\n  my @objs;\n  if ( $can_use_cache )\n  {\n    @objs = @{ $cache{$type} };\n    $self->log->debug( \"Using cached ${type}s\\n\" );\n  }\n  else\n  {\n    $self->log->debug( \"Fetching ${type}s\\n\" );\n    @objs = $todo->get( $type.'s' );\n    $cache{$type} = \\@objs;\n    $can_use_cache = 0;\n  }\n  if ( defined $new_string )   \n  {\n    my $id;\n    if ( $new_string eq '' )\n    {\n      $id = 0;\n    }\n    else\n    {\n      my ($obj) = grep { $_->name eq $new_string } @objs\n\tor $self->log->logdie(\"Could not find a $type with name '$new_string'\");\n      $id = $obj->id;\n    }\n    $self->object->$type( $id );\n    return $new_string;\n  }\n\n  my $id = $self->$type or return '';\n  my ($obj) = grep { $_->id == $id } @objs\n    or $self->log->logdie( \"Could not find existing $type $id in global list!\");\n  $obj->name;\n}\n\n\nmethod tags ( Str @new_tags ) {\n  if ( @new_tags )\n  {\n    $self->tag( join ', ', @new_tags );\n    return @new_tags;\n  }\n  split /,/, $self->tag;\n}\n\n\nmethod has_tag ( Str $tag! ) {\n  grep { $_ eq $tag } $self->tags;\n}\n\n\nmethod add_tag ( Str $tag! ) {\n  my $new_tag = $self->tag ? $self->tag . \", $tag\" : $tag;\n  $self->tag( $new_tag ) unless $self->has_tag( $tag );\n}\n\n\nmethod remove_tag ( Str $tag! ) {\n  return unless $self->has_tag( $tag );\n  my @new_tags = grep { $_ ne $tag } $self->tags;\n  $self->tags( @new_tags );\n}\n\n\nmethod add ( App::Toodledo $todo! ) {\n  my %param = %{ $self->object };\n  $param{$_} = toodledo_encode( $param{$_} )\n    for grep { $param{$_} } qw(title tag note);\n  my $added_ref = $todo->call_func( tasks => add => { tasks => \\%param } );\n  $added_ref->[0]{id};\n}\n\n\nmethod optional_attributes ( $class: ) {\n  my @attrs = $class->attribute_list;\n  grep { ! /\\A(?:id|title|modified|completed)\\z/ } @attrs;\n}\n\n\nmethod edit ( App::Toodledo $todo!, App::Toodledo::Task @more ) {\n  if ( @more )\n  {\n    my @edited = map { +{ %{ $_->object } } } ( $self, @more );\n    my $edited_ref = $todo->call_func( tasks => edit => { tasks => \\@edited } );\n    return map { $_->{id} } @$edited_ref;\n  }\n  else\n  {\n    my %param = %{ $self->object };\n    my $edited_ref = $todo->call_func( tasks => edit => { tasks => \\%param } );\n    return $edited_ref->[0]{id};\n  }\n}\n\n\nmethod delete ( App::Toodledo $todo! ) {\n  my $id = $self->id;\n  my $deleted_ref = $todo->call_func( tasks => delete => { tasks => [$id] } );\n  $deleted_ref->[0]{id} == $id or $self->log->logdie(\"Did not get ID back from delete\");\n}\n\n\n1",
      "file" : "/var/tmp/arv_K5r5c2/App-Toodledo-2.16/lib/App/Toodledo/Task.pm",
      "package" : "App::Toodledo::Task"
   }
]
