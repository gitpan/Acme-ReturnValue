[
   {
      "PPI" : "PPI::Statement::Include",
      "bad" : "use constant {\n    autolexer => 1,\n    symtab => 2,\n    fixed_length => 4,\n    fates => 8,\n    longest_token_pattern_generation => 16,\n    EXPR => 32,\n    matchers => 64,\n    trace_call=> 128,\n    cursors => 256,\n    try_processing => 1024,\n    mixins => 2048,\n    callm_show_subnames => 16384,\n    use_color => 32768\n}",
      "file" : "/var/tmp/arv_diXJ1E/STD-20101111/lib/DEBUG.pm",
      "package" : "DEBUG"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub check_old_cclass { my $self = shift;\n    my $innards = shift;\n\n    my $prev = substr($::ORIG,$self->{_pos}-length($innards)-4,2);\n    return $self if $prev =~ /=\\s*$/;       \n\n    my $cclass = '';\n    my $single = '';\n    my $singleok = 1;\n    my $double = '';\n    my $doubleok = 1;\n\n    my $last = '';\n    my %seen;\n\n    my $i = $innards;\n    my $neg = '';\n    $neg = '-' if $i =~ s/^\\^//;\n    my $digits = 0;\n    $i =~ s/0-9/\\\\d/;\n    while ($i ne '') {\n        if ($i =~ s/^-(.)/$1/) {\n            $singleok = $doubleok = 0;\n            $cclass .= $last ? '..' : '\\\\-';\n            $last = '';\n        }\n        elsif ($i =~ /^\\|./ and $cclass ne '') {\n            return $self;       \n        }\n        elsif ($i =~ s/^\\|//) {\n            $last = '';\n            $singleok = $doubleok = 0;\n            $cclass .= '|';\n        }\n        elsif ($i =~ /^[*+?]/ and $cclass ne '') {\n            return $self;       \n        }\n        elsif ($i =~ s/^\\\\?'//) {\n            $last = \"'\";\n            $single .= '\\\\' . $last;\n            $double .= $last;\n            $cclass .= $last;\n        }\n        elsif ($i =~ s/^\\\\?\"//) {\n            $last = '\"';\n            $single .= $last;\n            $double .= '\\\\' . $last;\n            $cclass .= $last;\n        }\n        elsif ($i =~ s/^(\\\\[btnrf0])//) {\n            $last = eval '\"' . $1 . '\"';\n            $single .= $last;\n            $double .= $1;\n            $cclass .= $1;\n        }\n        elsif ($i =~ s/(\\\\x\\w\\w)//) {\n            $last = eval '\"' . $1 . '\"';\n            $single .= $last;\n            $double .= $1;\n            $cclass .= $1;\n        }\n        elsif ($i =~ s/(\\\\0[0-7]{1,3})//) {\n            $last = eval '\"' . $1 . '\"';\n            $single .= $last;\n            $double .= \"\\\\o\" . substr($1,1);\n            $cclass .= \"\\\\o\" . substr($1,1);\n        }\n        elsif ($i =~ s/^(\\\\[sSwWdD])//) {\n            $singleok = $doubleok = 0;\n            $last = '';\n            $cclass .= $1;\n        }\n        elsif ($i =~ s/^(\\\\?\\t)//) {\n            $last = \"\\t\";\n            $single .= $last;\n            $double .= '\\\\t';\n            $cclass .= '\\\\t';\n        }\n        elsif ($i =~ s/^(\\\\?\\x20)//) {\n            $last = ' ';\n            $single .= $last;\n            $double .= $last;\n            $cclass .= '\\\\x20';\n        }\n        elsif ($i =~ s/^\\.//) {\n            $last = '.';\n            $singleok = $doubleok = 0;\n            $cclass .= '.';\n        }\n        elsif ($i =~ s/^\\\\(.)//) {\n            $last = $1;\n            $single .= $last;\n            $double .= '\\\\' . $last;\n            $cclass .= '\\\\' . $last;\n        }\n        elsif ($i =~ s/^(.)//s) {\n            $last = $1;\n            $cclass .= $last;\n            $single .= $last;\n            $double .= $last;\n        }\n        else {\n            die \"can't happen\";\n        }\n\n        if ($last ne '' and $seen{$last}++) {\n            return $self;       \n        }\n    }\n\n    my $common = \"[$innards] appears to be an old-school character class;\";\n\n    if ($neg) {\n        return $self->worry(\"$common non-digits should be matched with \\\\D instead\") if $cclass eq '\\\\d';\n        return $self->worry(\"$common non-newlines should be matched with \\\\N instead\") if $cclass eq '\\\\n';\n        if ($singleok) {\n            return $self->worry(\"$common non-(horizontal whitespace) should be matched with \\\\H instead\") if $single =~ /\\A[ \\t\\b\\r]*\\z/;\n            return $self->worry(\"$common non-(vertical whitespace) should be matched with \\\\V instead\") if $single =~ /\\A[\\n\\f]*\\z/;\n            return $self->worry(\"$common non-whitespace should be matched with \\\\S instead\") if $single =~ /\\A[ \\t\\b\\r\\n\\f]*\\z/;\n            return $self->worry(\"$common please use <-[$cclass]> if you mean a character class\");\n        }\n        elsif ($doubleok) {\n            return $self->worry(\"$common please use <-[$cclass]> if you mean a character class\");\n        }\n    }\n    else {\n        return $self->worry(\"$common digits should be matched with \\\\d instead\") if $cclass eq '\\\\d';\n        if ($singleok) {\n            return $self->worry(\"$common horizontal whitespace should be matched with \\\\h instead\") if $single =~ /\\A[ \\t\\b\\r]*\\z/;\n            return $self->worry(\"$common vertical whitespace should be matched with \\\\v instead\") if $single =~ /\\A[\\n\\f]*\\z/;\n            return $self->worry(\"$common whitespace should be matched with \\\\s instead\") if $single =~ /\\A[ \\t\\b\\r\\n\\f]*\\z/;\n        }\n        if ($singleok and $single eq $double) {\n            return $self->worry(\"$common please use <[$cclass]> if you\\n    mean a character class, or quote it like '$single' to match\\n    string as a unit\");\n        }\n        elsif ($doubleok) {\n            return $self->worry(\"$common please use <[$cclass]> if you\\n    mean a character class, or quote it like \\\"$double\\\" to match\\n    string as a unit\");\n        }\n    }\n    if ($::FATALS) {\n        return $self->worry(\"$common please use <${neg}[$cclass]> if you mean a character class\");\n    }\n    else {\n        return $self->worry(\"$common please use <${neg}[$cclass]> if you\\n    mean a character class, or put whitespace inside like [ $innards ] to disable\\n    this warning\");\n    }\n    $self;\n}",
      "file" : "/var/tmp/arv_diXJ1E/STD-20101111/lib/CursorBase.pm",
      "package" : "CursorBase"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{ package STD::STD::P5;\nuse Moose ':all' => { -prefix => \"moose_\" };\nuse Encode;\nmoose_extends('STD');\nour $ALLROLES = { 'STD::STD::P5', 1 };\nour $REGEXES = {\nALL => [ qw/POST PRE arglist args babble backslash block blockoid capterm capture category charname charnames charspec comp_unit dec_number declarator def_module_name deflongname desigilname dottyop dottyopish eat_terminator endid escale escape fatarrow hexint hexints ident identifier infixish infixstopper integer label longname methodop modifier_expr morename name nibbler nofun nullterm nulltermish number numish octint octints p5circumfix p5comment p5dotty p5infix p5module_name p5multi_declarator p5number p5package_declarator p5postcircumfix p5postfix p5prefix p5quote p5regex_declarator p5routine_declarator p5rx_mods p5scope_declarator p5sigil p5special_variable p5statement_control p5statement_mod_cond p5statement_mod_loop p5statement_prefix p5term p5terminator p5tr_mods p5type_declarator p5value p5version package_def param_sep parensig pod_comment postop quasiquibble quibble quote radint regex_block routine_def scoped semiarglist semilist sibble signature spacey starter statement statementlist stdstopper stopper sublongname subshortname termish trait tribble type_constraint typename unitstopper unsp unspacey unv variable variable_declarator vnum vws ws xblock/ ],\ncategory => [ qw/category__S_000category__PEEK category__S_001p5sigil__PEEK category__S_002p5special_variable__PEEK category__S_003p5comment__PEEK category__S_004p5version__PEEK category__S_005p5module_name__PEEK category__S_006p5value__PEEK category__S_007p5term__PEEK category__S_008p5number__PEEK category__S_009p5quote__PEEK category__S_010p5prefix__PEEK category__S_011p5infix__PEEK category__S_012p5postfix__PEEK category__S_013p5dotty__PEEK category__S_014p5circumfix__PEEK category__S_015p5postcircumfix__PEEK category__S_016p5type_declarator__PEEK category__S_017p5scope_declarator__PEEK category__S_018p5package_declarator__PEEK category__S_019p5routine_declarator__PEEK category__S_020p5regex_declarator__PEEK category__S_021p5statement_prefix__PEEK category__S_022p5statement_control__PEEK category__S_023p5statement_mod_cond__PEEK category__S_024p5statement_mod_loop__PEEK category__S_025p5terminator__PEEK/ ],\nescape => [ qw/escape__S_117none__PEEK/ ],\nnumber => [ qw/number__S_116numish__PEEK/ ],\np5circumfix => [ qw/p5circumfix__S_120Lt_Gt__PEEK p5circumfix__S_132sigil__PEEK p5circumfix__S_133Paren_Thesis__PEEK p5circumfix__S_134Bra_Ket__PEEK p5circumfix__S_139Cur_Ly__PEEK/ ],\np5comment => [ qw/p5comment__S_026Sharp__PEEK/ ],\np5dotty => [ qw/p5dotty__S_135MinusGt__PEEK/ ],\np5infix => [ qw/p5infix__S_145StarStar__PEEK p5infix__S_150BangTilde__PEEK p5infix__S_151EqualTilde__PEEK p5infix__S_152Star__PEEK p5infix__S_153Slash__PEEK p5infix__S_154Percent__PEEK p5infix__S_155LtLt__PEEK p5infix__S_156GtGt__PEEK p5infix__S_157x__PEEK p5infix__S_158Dot__PEEK p5infix__S_159Plus__PEEK p5infix__S_160Minus__PEEK p5infix__S_161Amp__PEEK p5infix__S_162also__PEEK p5infix__S_163Vert__PEEK p5infix__S_164Caret__PEEK p5infix__S_169LtEqualGt__PEEK p5infix__S_170cmp__PEEK p5infix__S_171Lt__PEEK p5infix__S_172LtEqual__PEEK p5infix__S_173Gt__PEEK p5infix__S_174GtEqual__PEEK p5infix__S_175eq__PEEK p5infix__S_176ne__PEEK p5infix__S_177lt__PEEK p5infix__S_178le__PEEK p5infix__S_179gt__PEEK p5infix__S_180ge__PEEK p5infix__S_181EqualEqual__PEEK p5infix__S_182BangEqual__PEEK p5infix__S_183AmpAmp__PEEK p5infix__S_184VertVert__PEEK p5infix__S_185CaretCaret__PEEK p5infix__S_186SlashSlash__PEEK p5infix__S_187DotDot__PEEK p5infix__S_188DotDotDot__PEEK p5infix__S_189Question_Colon__PEEK p5infix__S_190Equal__PEEK p5infix__S_191Comma__PEEK p5infix__S_192EqualGt__PEEK p5infix__S_196and__PEEK p5infix__S_197andthen__PEEK p5infix__S_198or__PEEK p5infix__S_199orelse__PEEK p5infix__S_200xor__PEEK/ ],\np5module_name => [ qw/p5module_name__S_047normal__PEEK/ ],\np5multi_declarator => [ qw/p5multi_declarator__S_054null__PEEK/ ],\np5package_declarator => [ qw/p5package_declarator__S_052package__PEEK p5package_declarator__S_053require__PEEK/ ],\np5postcircumfix => [ qw/p5postcircumfix__S_136Paren_Thesis__PEEK p5postcircumfix__S_137Bra_Ket__PEEK p5postcircumfix__S_138Cur_Ly__PEEK/ ],\np5postfix => [ qw/p5postfix__S_140MinusGt__PEEK p5postfix__S_141PlusPlus__PEEK p5postfix__S_142MinusMinus__PEEK/ ],\np5prefix => [ qw/p5prefix__S_143PlusPlus__PEEK p5prefix__S_144MinusMinus__PEEK p5prefix__S_146Bang__PEEK p5prefix__S_147Plus__PEEK p5prefix__S_148Minus__PEEK p5prefix__S_149Tilde__PEEK p5prefix__S_165sleep__PEEK p5prefix__S_166abs__PEEK p5prefix__S_167let__PEEK p5prefix__S_168temp__PEEK/ ],\np5quote => [ qw/p5quote__S_118Single_Single__PEEK p5quote__S_119Double_Double__PEEK p5quote__S_121Slash_Slash__PEEK/ ],\np5routine_declarator => [ qw/p5routine_declarator__S_055sub__PEEK/ ],\np5scope_declarator => [ qw/p5scope_declarator__S_049my__PEEK p5scope_declarator__S_050our__PEEK p5scope_declarator__S_051state__PEEK/ ],\np5sigil => [ qw/p5sigil__S_109Dollar__PEEK p5sigil__S_110At__PEEK p5sigil__S_111Percent__PEEK p5sigil__S_112Amp__PEEK/ ],\np5special_variable => [ qw/p5special_variable__S_066DollarBang__PEEK p5special_variable__S_067DollarBangCur_Ly__PEEK p5special_variable__S_068DollarSlash__PEEK p5special_variable__S_069DollarTilde__PEEK p5special_variable__S_070DollarGrave__PEEK p5special_variable__S_071DollarAt__PEEK p5special_variable__S_072DollarSharp__PEEK p5special_variable__S_073DollarDollar__PEEK p5special_variable__S_074DollarPercent__PEEK p5special_variable__S_075DollarCaretX__PEEK p5special_variable__S_076DollarCaret__PEEK p5special_variable__S_077DollarAmp__PEEK p5special_variable__S_078DollarStar__PEEK p5special_variable__S_079DollarThesis__PEEK p5special_variable__S_080DollarMinus__PEEK p5special_variable__S_081DollarEqual__PEEK p5special_variable__S_082AtPlus__PEEK p5special_variable__S_083PercentPlus__PEEK p5special_variable__S_084DollarPlusBra_Ket__PEEK p5special_variable__S_085AtPlusBra_Ket__PEEK p5special_variable__S_086AtPlusCur_Ly__PEEK p5special_variable__S_087AtMinus__PEEK p5special_variable__S_088PercentMinus__PEEK p5special_variable__S_089DollarMinusBra_Ket__PEEK p5special_variable__S_090AtMinusBra_Ket__PEEK p5special_variable__S_091PercentMinusCur_Ly__PEEK p5special_variable__S_092DollarPlus__PEEK p5special_variable__S_093DollarCurCaret_Ly__PEEK p5special_variable__S_094ColonColonCur_Ly__PEEK p5special_variable__S_095DollarCur_Ly__PEEK p5special_variable__S_096DollarBra__PEEK p5special_variable__S_097DollarKet__PEEK p5special_variable__S_098DollarBack__PEEK p5special_variable__S_099DollarVert__PEEK p5special_variable__S_100DollarColon__PEEK p5special_variable__S_101DollarSemi__PEEK p5special_variable__S_102DollarSingle__PEEK p5special_variable__S_103DollarDouble__PEEK p5special_variable__S_104DollarComma__PEEK p5special_variable__S_105DollarLt__PEEK p5special_variable__S_106DollarGt__PEEK p5special_variable__S_107DollarDot__PEEK p5special_variable__S_108DollarQuestion__PEEK/ ],\np5statement_control => [ qw/p5statement_control__S_027use__PEEK p5statement_control__S_028no__PEEK p5statement_control__S_029if__PEEK p5statement_control__S_030while__PEEK p5statement_control__S_031until__PEEK p5statement_control__S_032for__PEEK p5statement_control__S_033given__PEEK p5statement_control__S_034when__PEEK p5statement_control__S_035default__PEEK p5statement_control__S_039END__PEEK/ ],\np5statement_mod_cond => [ qw/p5statement_mod_cond__S_040if__PEEK p5statement_mod_cond__S_041unless__PEEK p5statement_mod_cond__S_042when__PEEK/ ],\np5statement_mod_loop => [ qw/p5statement_mod_loop__S_043while__PEEK p5statement_mod_loop__S_044until__PEEK p5statement_mod_loop__S_045for__PEEK p5statement_mod_loop__S_046given__PEEK/ ],\np5statement_prefix => [ qw/p5statement_prefix__S_036BEGIN__PEEK p5statement_prefix__S_037CHECK__PEEK p5statement_prefix__S_038INIT__PEEK p5statement_prefix__S_128do__PEEK p5statement_prefix__S_129eval__PEEK/ ],\np5term => [ qw/p5term__S_056fatarrow__PEEK p5term__S_057variable__PEEK p5term__S_058package_declarator__PEEK p5term__S_059scope_declarator__PEEK p5term__S_060routine_declarator__PEEK p5term__S_061circumfix__PEEK p5term__S_062dotty__PEEK p5term__S_063value__PEEK p5term__S_064capterm__PEEK p5term__S_065statement_prefix__PEEK p5term__S_130undef__PEEK p5term__S_131continue__PEEK p5term__S_193identifier__PEEK p5term__S_194opfunc__PEEK p5term__S_195name__PEEK/ ],\np5terminator => [ qw/p5terminator__S_201Semi__PEEK p5terminator__S_202if__PEEK p5terminator__S_203unless__PEEK p5terminator__S_204while__PEEK p5terminator__S_205until__PEEK p5terminator__S_206for__PEEK p5terminator__S_207given__PEEK p5terminator__S_208when__PEEK p5terminator__S_209Thesis__PEEK p5terminator__S_210Ket__PEEK p5terminator__S_211Ly__PEEK p5terminator__S_212Colon__PEEK/ ],\np5value => [ qw/p5value__S_113quote__PEEK p5value__S_114number__PEEK p5value__S_115version__PEEK/ ],\np5version => [ qw/p5version__S_048v__PEEK/ ],\nquote => [ qw/quote__S_122qq__PEEK quote__S_123q__PEEK quote__S_124qr__PEEK quote__S_125m__PEEK quote__S_126s__PEEK quote__S_127tr__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\n;\nuse DEBUG;\nsub TOP {\nno warnings 'recursion';\nmy $self = shift;\nmy $STOP = @_ ? shift() : undef;\nif (defined $STOP) {\nlocal $::GOAL = $STOP;\n$self->unitstop($STOP)->comp_unit;\n}\nelse {\n$self->comp_unit}};\nour %term            = ('dba' => ('term')            , 'prec' => 'z=');\nour %methodcall      = ('dba' => ('methodcall')      , 'prec' => 'y=', 'assoc' => 'unary', 'uassoc' => 'left', 'fiddly' => 1);\nour %autoincrement   = ('dba' => ('autoincrement')   , 'prec' => 'x=', 'assoc' => 'unary', 'uassoc' => 'non');\nour %exponentiation  = ('dba' => ('exponentiation')  , 'prec' => 'w=', 'assoc' => 'right');\nour %symbolic_unary  = ('dba' => ('symbolic unary')  , 'prec' => 'v=', 'assoc' => 'unary', 'uassoc' => 'left');\nour %binding         = ('dba' => ('binding')         , 'prec' => 'u=', 'assoc' => 'unary', 'uassoc' => 'left');\nour %multiplicative  = ('dba' => ('multiplicative')  , 'prec' => 't=', 'assoc' => 'left');\nour %additive        = ('dba' => ('additive')        , 'prec' => 's=', 'assoc' => 'left');\nour %shift           = ('dba' => ('shift')           , 'prec' => 'r=', 'assoc' => 'left');\nour %named_unary     = ('dba' => ('named unary')     , 'prec' => 'q=', 'assoc' => 'unary', 'uassoc' => 'left');\nour %comparison      = ('dba' => ('comparison')      , 'prec' => 'p=', 'assoc' => 'non', 'diffy' => 1);\nour %equality        = ('dba' => ('equality')        , 'prec' => 'o=', 'assoc' => 'chain', 'diffy' => 1, 'iffy' => 1);\nour %bitwise_and     = ('dba' => ('bitwise and')     , 'prec' => 'n=', 'assoc' => 'left');\nour %bitwise_or      = ('dba' => ('bitwise or')      , 'prec' => 'm=', 'assoc' => 'left');\nour %tight_and       = ('dba' => ('tight and')       , 'prec' => 'l=', 'assoc' => 'left');\nour %tight_or        = ('dba' => ('tight or')        , 'prec' => 'k=', 'assoc' => 'left');\nour %range           = ('dba' => ('range')           , 'prec' => 'j=', 'assoc' => 'right', 'fiddly' => 1);\nour %conditional     = ('dba' => ('conditional')     , 'prec' => 'i=', 'assoc' => 'right', 'fiddly' => 1);\nour %assignment      = ('dba' => ('assignment')      , 'prec' => 'h=', 'assoc' => 'right');\nour %comma           = ('dba' => ('comma operator')  , 'prec' => 'g=', 'assoc' => 'left', 'nextterm' => 'nulltermish', 'fiddly' => 1);\nour %listop          = ('dba' => ('list operator')   , 'prec' => 'f=', 'assoc' => 'unary', 'uassoc' => 'left');\nour %loose_not       = ('dba' => ('not operator')    , 'prec' => 'e=', 'assoc' => 'unary', 'uassoc' => 'left');\nour %loose_and       = ('dba' => ('loose and')       , 'prec' => 'd=', 'assoc' => 'left');\nour %loose_or        = ('dba' => ('loose or')        , 'prec' => 'c=', 'assoc' => 'left');\nour %LOOSEST         = ('dba' => ('LOOSEST')         , 'prec' => 'a=!');\nour %terminator      = ('dba' => ('terminator')      , 'prec' => 'a=', 'assoc' => 'list');\nour $LOOSEST = \"a=!\";\nlocal $::endsym = \"null\";\nlocal $::endargs = -1;\nsub category__PEEK { $_[0]->_AUTOLEXpeek('category:*',$retree); }\nsub category {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE category');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'category') {\n$C->deb(\"Fate passed to category: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT category';\n}\nelse {\n$x = 'ALTLTM category';\n}\n}\nelse {\n$x = 'ALTLTM category';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'category:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"category trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"category\", @gather);\n};\n@result;\n}\n;\nsub category__S_000category__PEEK { $_[0]->_AUTOLEXpeek('category__S_000category', $retree) }\nsub category__S_000category {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_000category\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"category\";\n$self->_MATCHIFYr($S, \"category__S_000category\", $C->_EXACT(\"category\"));\n}\n;\nsub category__S_001p5sigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_001p5sigil', $retree) }\nsub category__S_001p5sigil {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_001p5sigil\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5sigil\";\n$self->_MATCHIFYr($S, \"category__S_001p5sigil\", $C->_EXACT(\"p5sigil\"));\n}\n;\nsub p5sigil__PEEK { $_[0]->_AUTOLEXpeek('p5sigil:*',$retree); }\nsub p5sigil {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5sigil');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5sigil') {\n$C->deb(\"Fate passed to p5sigil: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5sigil';\n}\nelse {\n$x = 'ALTLTM p5sigil';\n}\n}\nelse {\n$x = 'ALTLTM p5sigil';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5sigil:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5sigil trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5sigil\", @gather);\n};\n@result;\n}\n;\nsub category__S_002p5special_variable__PEEK { $_[0]->_AUTOLEXpeek('category__S_002p5special_variable', $retree) }\nsub category__S_002p5special_variable {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_002p5special_variable\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5special_variable\";\n$self->_MATCHIFYr($S, \"category__S_002p5special_variable\", $C->_EXACT(\"p5special_variable\"));\n}\n;\nsub p5special_variable__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable:*',$retree); }\nsub p5special_variable {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5special_variable');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5special_variable') {\n$C->deb(\"Fate passed to p5special_variable: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5special_variable';\n}\nelse {\n$x = 'ALTLTM p5special_variable';\n}\n}\nelse {\n$x = 'ALTLTM p5special_variable';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5special_variable:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5special_variable trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5special_variable\", @gather);\n};\n@result;\n}\n;\nsub category__S_003p5comment__PEEK { $_[0]->_AUTOLEXpeek('category__S_003p5comment', $retree) }\nsub category__S_003p5comment {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_003p5comment\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5comment\";\n$self->_MATCHIFYr($S, \"category__S_003p5comment\", $C->_EXACT(\"p5comment\"));\n}\n;\nsub p5comment__PEEK { $_[0]->_AUTOLEXpeek('p5comment:*',$retree); }\nsub p5comment {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5comment');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5comment') {\n$C->deb(\"Fate passed to p5comment: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5comment';\n}\nelse {\n$x = 'ALTLTM p5comment';\n}\n}\nelse {\n$x = 'ALTLTM p5comment';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5comment:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5comment trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5comment\", @gather);\n};\n@result;\n}\n;\nsub category__S_004p5version__PEEK { $_[0]->_AUTOLEXpeek('category__S_004p5version', $retree) }\nsub category__S_004p5version {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_004p5version\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5version\";\n$self->_MATCHIFYr($S, \"category__S_004p5version\", $C->_EXACT(\"p5version\"));\n}\n;\nsub p5version__PEEK { $_[0]->_AUTOLEXpeek('p5version:*',$retree); }\nsub p5version {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5version');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5version') {\n$C->deb(\"Fate passed to p5version: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5version';\n}\nelse {\n$x = 'ALTLTM p5version';\n}\n}\nelse {\n$x = 'ALTLTM p5version';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5version:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5version trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5version\", @gather);\n};\n@result;\n}\n;\nsub category__S_005p5module_name__PEEK { $_[0]->_AUTOLEXpeek('category__S_005p5module_name', $retree) }\nsub category__S_005p5module_name {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_005p5module_name\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5module_name\";\n$self->_MATCHIFYr($S, \"category__S_005p5module_name\", $C->_EXACT(\"p5module_name\"));\n}\n;\nsub p5module_name__PEEK { $_[0]->_AUTOLEXpeek('p5module_name:*',$retree); }\nsub p5module_name {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5module_name');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5module_name') {\n$C->deb(\"Fate passed to p5module_name: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5module_name';\n}\nelse {\n$x = 'ALTLTM p5module_name';\n}\n}\nelse {\n$x = 'ALTLTM p5module_name';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5module_name:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5module_name trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5module_name\", @gather);\n};\n@result;\n}\n;\nsub category__S_006p5value__PEEK { $_[0]->_AUTOLEXpeek('category__S_006p5value', $retree) }\nsub category__S_006p5value {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_006p5value\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5value\";\n$self->_MATCHIFYr($S, \"category__S_006p5value\", $C->_EXACT(\"p5value\"));\n}\n;\nsub p5value__PEEK { $_[0]->_AUTOLEXpeek('p5value:*',$retree); }\nsub p5value {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5value');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5value') {\n$C->deb(\"Fate passed to p5value: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5value';\n}\nelse {\n$x = 'ALTLTM p5value';\n}\n}\nelse {\n$x = 'ALTLTM p5value';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5value:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5value trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5value\", @gather);\n};\n@result;\n}\n;\nsub category__S_007p5term__PEEK { $_[0]->_AUTOLEXpeek('category__S_007p5term', $retree) }\nsub category__S_007p5term {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_007p5term\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5term\";\n$self->_MATCHIFYr($S, \"category__S_007p5term\", $C->_EXACT(\"p5term\"));\n}\n;\nsub p5term__PEEK { $_[0]->_AUTOLEXpeek('p5term:*',$retree); }\nsub p5term {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5term');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5term') {\n$C->deb(\"Fate passed to p5term: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5term';\n}\nelse {\n$x = 'ALTLTM p5term';\n}\n}\nelse {\n$x = 'ALTLTM p5term';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5term:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5term trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5term\", @gather);\n};\n@result;\n}\n;\nsub category__S_008p5number__PEEK { $_[0]->_AUTOLEXpeek('category__S_008p5number', $retree) }\nsub category__S_008p5number {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_008p5number\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5number\";\n$self->_MATCHIFYr($S, \"category__S_008p5number\", $C->_EXACT(\"p5number\"));\n}\n;\nsub p5number__PEEK { $_[0]->_AUTOLEXpeek('p5number:*',$retree); }\nsub p5number {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5number');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5number') {\n$C->deb(\"Fate passed to p5number: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5number';\n}\nelse {\n$x = 'ALTLTM p5number';\n}\n}\nelse {\n$x = 'ALTLTM p5number';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5number:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5number trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5number\", @gather);\n};\n@result;\n}\n;\nsub category__S_009p5quote__PEEK { $_[0]->_AUTOLEXpeek('category__S_009p5quote', $retree) }\nsub category__S_009p5quote {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_009p5quote\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5quote\";\n$self->_MATCHIFYr($S, \"category__S_009p5quote\", $C->_EXACT(\"p5quote\"));\n}\n;\nsub p5quote__PEEK { $_[0]->_AUTOLEXpeek('p5quote:*',$retree); }\nsub p5quote {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5quote');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5quote') {\n$C->deb(\"Fate passed to p5quote: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5quote';\n}\nelse {\n$x = 'ALTLTM p5quote';\n}\n}\nelse {\n$x = 'ALTLTM p5quote';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5quote:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5quote trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5quote\", @gather);\n};\n@result;\n}\n;\nsub category__S_010p5prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_010p5prefix', $retree) }\nsub category__S_010p5prefix {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_010p5prefix\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5prefix\";\n$self->_MATCHIFYr($S, \"category__S_010p5prefix\", $C->_EXACT(\"p5prefix\"));\n}\n;\nsub p5prefix__PEEK { $_[0]->_AUTOLEXpeek('p5prefix:*',$retree); }\nsub p5prefix {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5prefix');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5prefix') {\n$C->deb(\"Fate passed to p5prefix: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5prefix';\n}\nelse {\n$x = 'ALTLTM p5prefix';\n}\n}\nelse {\n$x = 'ALTLTM p5prefix';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5prefix:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5prefix trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5prefix\", @gather);\n};\n@result;\n}\n;\nsub category__S_011p5infix__PEEK { $_[0]->_AUTOLEXpeek('category__S_011p5infix', $retree) }\nsub category__S_011p5infix {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_011p5infix\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5infix\";\n$self->_MATCHIFYr($S, \"category__S_011p5infix\", $C->_EXACT(\"p5infix\"));\n}\n;\nsub p5infix__PEEK { $_[0]->_AUTOLEXpeek('p5infix:*',$retree); }\nsub p5infix {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5infix');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5infix') {\n$C->deb(\"Fate passed to p5infix: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5infix';\n}\nelse {\n$x = 'ALTLTM p5infix';\n}\n}\nelse {\n$x = 'ALTLTM p5infix';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5infix:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5infix trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5infix\", @gather);\n};\n@result;\n}\n;\nsub category__S_012p5postfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_012p5postfix', $retree) }\nsub category__S_012p5postfix {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_012p5postfix\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5postfix\";\n$self->_MATCHIFYr($S, \"category__S_012p5postfix\", $C->_EXACT(\"p5postfix\"));\n}\n;\nsub p5postfix__PEEK { $_[0]->_AUTOLEXpeek('p5postfix:*',$retree); }\nsub p5postfix {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5postfix');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5postfix') {\n$C->deb(\"Fate passed to p5postfix: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5postfix';\n}\nelse {\n$x = 'ALTLTM p5postfix';\n}\n}\nelse {\n$x = 'ALTLTM p5postfix';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5postfix:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5postfix trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5postfix\", @gather);\n};\n@result;\n}\n;\nsub category__S_013p5dotty__PEEK { $_[0]->_AUTOLEXpeek('category__S_013p5dotty', $retree) }\nsub category__S_013p5dotty {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_013p5dotty\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5dotty\";\n$self->_MATCHIFYr($S, \"category__S_013p5dotty\", $C->_EXACT(\"p5dotty\"));\n}\n;\nsub p5dotty__PEEK { $_[0]->_AUTOLEXpeek('p5dotty:*',$retree); }\nsub p5dotty {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5dotty');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5dotty') {\n$C->deb(\"Fate passed to p5dotty: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5dotty';\n}\nelse {\n$x = 'ALTLTM p5dotty';\n}\n}\nelse {\n$x = 'ALTLTM p5dotty';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5dotty:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5dotty trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5dotty\", @gather);\n};\n@result;\n}\n;\nsub category__S_014p5circumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_014p5circumfix', $retree) }\nsub category__S_014p5circumfix {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_014p5circumfix\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5circumfix\";\n$self->_MATCHIFYr($S, \"category__S_014p5circumfix\", $C->_EXACT(\"p5circumfix\"));\n}\n;\nsub p5circumfix__PEEK { $_[0]->_AUTOLEXpeek('p5circumfix:*',$retree); }\nsub p5circumfix {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5circumfix');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5circumfix') {\n$C->deb(\"Fate passed to p5circumfix: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5circumfix';\n}\nelse {\n$x = 'ALTLTM p5circumfix';\n}\n}\nelse {\n$x = 'ALTLTM p5circumfix';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5circumfix:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5circumfix trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5circumfix\", @gather);\n};\n@result;\n}\n;\nsub category__S_015p5postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_015p5postcircumfix', $retree) }\nsub category__S_015p5postcircumfix {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_015p5postcircumfix\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5postcircumfix\";\n$self->_MATCHIFYr($S, \"category__S_015p5postcircumfix\", $C->_EXACT(\"p5postcircumfix\"));\n}\n;\nsub p5postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('p5postcircumfix:*',$retree); }\nsub p5postcircumfix {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5postcircumfix');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5postcircumfix') {\n$C->deb(\"Fate passed to p5postcircumfix: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5postcircumfix';\n}\nelse {\n$x = 'ALTLTM p5postcircumfix';\n}\n}\nelse {\n$x = 'ALTLTM p5postcircumfix';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5postcircumfix:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5postcircumfix trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5postcircumfix\", @gather);\n};\n@result;\n}\n;\nsub category__S_016p5type_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_016p5type_declarator', $retree) }\nsub category__S_016p5type_declarator {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_016p5type_declarator\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5type_declarator\";\n$self->_MATCHIFYr($S, \"category__S_016p5type_declarator\", $C->_EXACT(\"p5type_declarator\"));\n}\n;\nsub p5type_declarator__PEEK { $_[0]->_AUTOLEXpeek('p5type_declarator:*',$retree); }\nsub p5type_declarator {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5type_declarator');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5type_declarator') {\n$C->deb(\"Fate passed to p5type_declarator: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5type_declarator';\n}\nelse {\n$x = 'ALTLTM p5type_declarator';\n}\n}\nelse {\n$x = 'ALTLTM p5type_declarator';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5type_declarator:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5type_declarator trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5type_declarator\", @gather);\n};\n@result;\n}\n;\nsub category__S_017p5scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_017p5scope_declarator', $retree) }\nsub category__S_017p5scope_declarator {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_017p5scope_declarator\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5scope_declarator\";\n$self->_MATCHIFYr($S, \"category__S_017p5scope_declarator\", $C->_EXACT(\"p5scope_declarator\"));\n}\n;\nsub p5scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('p5scope_declarator:*',$retree); }\nsub p5scope_declarator {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5scope_declarator');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5scope_declarator') {\n$C->deb(\"Fate passed to p5scope_declarator: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5scope_declarator';\n}\nelse {\n$x = 'ALTLTM p5scope_declarator';\n}\n}\nelse {\n$x = 'ALTLTM p5scope_declarator';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5scope_declarator:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5scope_declarator trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5scope_declarator\", @gather);\n};\n@result;\n}\n;\nsub category__S_018p5package_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_018p5package_declarator', $retree) }\nsub category__S_018p5package_declarator {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_018p5package_declarator\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5package_declarator\";\n$self->_MATCHIFYr($S, \"category__S_018p5package_declarator\", $C->_EXACT(\"p5package_declarator\"));\n}\n;\nsub p5package_declarator__PEEK { $_[0]->_AUTOLEXpeek('p5package_declarator:*',$retree); }\nsub p5package_declarator {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5package_declarator');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5package_declarator') {\n$C->deb(\"Fate passed to p5package_declarator: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5package_declarator';\n}\nelse {\n$x = 'ALTLTM p5package_declarator';\n}\n}\nelse {\n$x = 'ALTLTM p5package_declarator';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5package_declarator:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5package_declarator trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5package_declarator\", @gather);\n};\n@result;\n}\n;\nsub category__S_019p5routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_019p5routine_declarator', $retree) }\nsub category__S_019p5routine_declarator {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_019p5routine_declarator\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5routine_declarator\";\n$self->_MATCHIFYr($S, \"category__S_019p5routine_declarator\", $C->_EXACT(\"p5routine_declarator\"));\n}\n;\nsub p5routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('p5routine_declarator:*',$retree); }\nsub p5routine_declarator {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5routine_declarator');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5routine_declarator') {\n$C->deb(\"Fate passed to p5routine_declarator: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5routine_declarator';\n}\nelse {\n$x = 'ALTLTM p5routine_declarator';\n}\n}\nelse {\n$x = 'ALTLTM p5routine_declarator';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5routine_declarator:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5routine_declarator trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5routine_declarator\", @gather);\n};\n@result;\n}\n;\nsub category__S_020p5regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_020p5regex_declarator', $retree) }\nsub category__S_020p5regex_declarator {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_020p5regex_declarator\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5regex_declarator\";\n$self->_MATCHIFYr($S, \"category__S_020p5regex_declarator\", $C->_EXACT(\"p5regex_declarator\"));\n}\n;\nsub p5regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('p5regex_declarator:*',$retree); }\nsub p5regex_declarator {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5regex_declarator');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5regex_declarator') {\n$C->deb(\"Fate passed to p5regex_declarator: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5regex_declarator';\n}\nelse {\n$x = 'ALTLTM p5regex_declarator';\n}\n}\nelse {\n$x = 'ALTLTM p5regex_declarator';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5regex_declarator:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5regex_declarator trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5regex_declarator\", @gather);\n};\n@result;\n}\n;\nsub category__S_021p5statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_021p5statement_prefix', $retree) }\nsub category__S_021p5statement_prefix {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_021p5statement_prefix\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5statement_prefix\";\n$self->_MATCHIFYr($S, \"category__S_021p5statement_prefix\", $C->_EXACT(\"p5statement_prefix\"));\n}\n;\nsub p5statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('p5statement_prefix:*',$retree); }\nsub p5statement_prefix {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5statement_prefix');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5statement_prefix') {\n$C->deb(\"Fate passed to p5statement_prefix: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5statement_prefix';\n}\nelse {\n$x = 'ALTLTM p5statement_prefix';\n}\n}\nelse {\n$x = 'ALTLTM p5statement_prefix';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5statement_prefix:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5statement_prefix trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5statement_prefix\", @gather);\n};\n@result;\n}\n;\nsub category__S_022p5statement_control__PEEK { $_[0]->_AUTOLEXpeek('category__S_022p5statement_control', $retree) }\nsub category__S_022p5statement_control {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_022p5statement_control\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5statement_control\";\n$self->_MATCHIFYr($S, \"category__S_022p5statement_control\", $C->_EXACT(\"p5statement_control\"));\n}\n;\nsub p5statement_control__PEEK { $_[0]->_AUTOLEXpeek('p5statement_control:*',$retree); }\nsub p5statement_control {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5statement_control');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5statement_control') {\n$C->deb(\"Fate passed to p5statement_control: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5statement_control';\n}\nelse {\n$x = 'ALTLTM p5statement_control';\n}\n}\nelse {\n$x = 'ALTLTM p5statement_control';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5statement_control:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5statement_control trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5statement_control\", @gather);\n};\n@result;\n}\n;\nsub category__S_023p5statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('category__S_023p5statement_mod_cond', $retree) }\nsub category__S_023p5statement_mod_cond {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_023p5statement_mod_cond\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5statement_mod_cond\";\n$self->_MATCHIFYr($S, \"category__S_023p5statement_mod_cond\", $C->_EXACT(\"p5statement_mod_cond\"));\n}\n;\nsub p5statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('p5statement_mod_cond:*',$retree); }\nsub p5statement_mod_cond {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5statement_mod_cond');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5statement_mod_cond') {\n$C->deb(\"Fate passed to p5statement_mod_cond: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5statement_mod_cond';\n}\nelse {\n$x = 'ALTLTM p5statement_mod_cond';\n}\n}\nelse {\n$x = 'ALTLTM p5statement_mod_cond';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5statement_mod_cond:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5statement_mod_cond trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5statement_mod_cond\", @gather);\n};\n@result;\n}\n;\nsub category__S_024p5statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('category__S_024p5statement_mod_loop', $retree) }\nsub category__S_024p5statement_mod_loop {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_024p5statement_mod_loop\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5statement_mod_loop\";\n$self->_MATCHIFYr($S, \"category__S_024p5statement_mod_loop\", $C->_EXACT(\"p5statement_mod_loop\"));\n}\n;\nsub p5statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('p5statement_mod_loop:*',$retree); }\nsub p5statement_mod_loop {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5statement_mod_loop');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5statement_mod_loop') {\n$C->deb(\"Fate passed to p5statement_mod_loop: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5statement_mod_loop';\n}\nelse {\n$x = 'ALTLTM p5statement_mod_loop';\n}\n}\nelse {\n$x = 'ALTLTM p5statement_mod_loop';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5statement_mod_loop:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5statement_mod_loop trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5statement_mod_loop\", @gather);\n};\n@result;\n}\n;\nsub category__S_025p5terminator__PEEK { $_[0]->_AUTOLEXpeek('category__S_025p5terminator', $retree) }\nsub category__S_025p5terminator {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_025p5terminator\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5terminator\";\n$self->_MATCHIFYr($S, \"category__S_025p5terminator\", $C->_EXACT(\"p5terminator\"));\n}\n;\nsub p5terminator__PEEK { $_[0]->_AUTOLEXpeek('p5terminator:*',$retree); }\nsub p5terminator {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5terminator');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5terminator') {\n$C->deb(\"Fate passed to p5terminator: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5terminator';\n}\nelse {\n$x = 'ALTLTM p5terminator';\n}\n}\nelse {\n$x = 'ALTLTM p5terminator';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5terminator:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5terminator trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5terminator\", @gather);\n};\n@result;\n}\n;\nsub unspacey__PEEK { $_[0]->_AUTOLEXpeek('unspacey', $retree) }\nsub unspacey {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE unspacey\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"unspacey\", $C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->unsp)) { ($C) } else { () }\n}));\n}\n;\nsub endid__PEEK { $_[0]->_AUTOLEXpeek('endid', $retree) }\nsub endid {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE endid\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"endid\", $C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[^\\-\\'\\w]/)\n}))) { ($C) } else { () }\n}));\n}\n;\nsub spacey__PEEK { $_[0]->_AUTOLEXpeek('spacey', $retree) }\nsub spacey {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE spacey\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"spacey\", $C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[\\s\\#]/)\n}))) { ($C) } else { () }\n}));\n}\n;\nsub nofun__PEEK { $_[0]->_AUTOLEXpeek('nofun', $retree) }\nsub nofun {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE nofun\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"nofun\", $C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = (do {\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'nofun_0') {\n$C->deb(\"Fate passed to nofun_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT nofun_0';    \n}\nelse {\n$x = 'ALTLTM nofun_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'nofun_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"nofun_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\(\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\.\\(\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\\\\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\'\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\-\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\'\")\n},\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\w/)\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n\n})) { ($C) } else { () }\n}))) { ($C) } else { () }\n}));\n}\n;\nsub ws__PEEK { $_[0]->_AUTOLEXpeek('ws', $retree) }\nsub ws {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal @::STUB = @::STUB = return $self if exists $::MEMOS[$self->{'_pos'}]->{'ws'};my $startpos = $self->{'_pos'};\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE ws\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"ws\", do {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_0') {\n$C->deb(\"Fate passed to ws_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT ws_0';    \n}\nelse {\n$x = 'ALTLTM ws_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'ws_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"ws_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (($C) = ($C->_PATTERN(qr/\\G[\\x20\\t\\r]++/))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[\\#\\s\\\\]/)\n}))) {\nscalar(do {\n$::MEMOS[$C->{'_pos'}]->{'ws'} = $startpos}, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\w/)\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->after(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G(?<=\\w)/)\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_COMMITRULE())\nand ($C) = (scalar(do {\ndelete $::MEMOS[$startpos]->{'ws'}}, $C))\nand ($C) = ($C->panic(\"Whitespace is required between alphanumeric tokens\"))) {\n$C\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_1') {\n$C->deb(\"Fate passed to ws_1: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT ws_1';    \n}\nelse {\n$x = 'ALTLTM ws_1'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'ws_1', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"ws_1 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->unsp)) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->vws)\nand ($C) = ($C->heredoc)) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->unv)) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_PATTERN(qr/\\G\\z/))) {\nscalar(do {\n$C->moreinput }, $C)\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) { ($C) } else { () }\n}))) {\nscalar(do {\n{\nif (($C->{'_pos'} == $startpos)) {\ndelete $::MEMOS[$C->{'_pos'}]->{'ws'}}\nelse {\ndelete $::MEMOS[$C->{'_pos'}]->{'ws'};\n$::MEMOS[$C->{'_pos'}]->{'endstmt'} = $::MEMOS[$startpos]->{'endstmt'}\nif exists $::MEMOS[$startpos]->{'endstmt'};\n}}}, $C)\n} else { () }\n\n}\n};\n@gather;\n});\n}\n;\nsub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp', $retree) }\nsub unsp {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE unsp\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"unsp\", $C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}));\n}\n;\nsub vws__PEEK { $_[0]->_AUTOLEXpeek('vws', $retree) }\nsub vws {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE vws\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"vws\", do {\nif (my ($C) = ($C->_PATTERN(qr/\\G\\n/))) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_EXACT(\"\\#DEBUG\\ \\-1\"))) {\nscalar(do {\nsay \"DEBUG\";\n$STD::DEBUG = $::DEBUG = -1;\n}, $C)\n} else { () }\n}))) { ($C) } else { () }\n})\n} else { () }\n\n});\n}\n;\nsub moreinput {\nno warnings 'recursion';\nmy $self = shift;\n$::moreinput->() if $::moreinput};\nsub unv__PEEK { $_[0]->_AUTOLEXpeek('unv', $retree) }\nsub unv {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE unv\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"unv\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_0') {\n$C->deb(\"Fate passed to unv_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT unv_0';    \n}\nelse {\n$x = 'ALTLTM unv_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'unv_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"unv_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[\\x20\\t\\r]++/)\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\ndo {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\G[\\x20\\t\\r]*+\\=/))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_1') {\n$C->deb(\"Fate passed to unv_1: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT unv_1';    \n}\nelse {\n$x = 'ALTLTM unv_1'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'unv_1', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"unv_1 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\w/)\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\\\\")\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n};\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_PATTERN(qr/\\G(?m:^)/))\nand ($C) = ($C->pod_comment)) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_PATTERN(qr/\\G[\\x20\\t\\r]*+/))) {\n$C->_SUBSUMEr(['comment','p5comment'], sub {\nmy $C = shift;\n$C->p5comment\n})\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub p5comment__S_026Sharp__PEEK { $_[0]->_AUTOLEXpeek('p5comment__S_026Sharp', $retree) }\nsub p5comment__S_026Sharp {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5comment__S_026Sharp\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\#\";\n$self->_MATCHIFYr($S, \"p5comment__S_026Sharp\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\#\"))\nand ($C) = (scalar(do {\n}, $C))) {\n$C->_STARr(sub {\nmy $C=shift;\n$C->_NOTCHAR( sub { my $C=shift;\n$C->_EXACT(\"\\n\")\n})\n})\n} else { () }\n\n});\n}\n;\nsub ident__PEEK { $_[0]->_AUTOLEXpeek('ident', $retree) }\nsub ident {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE ident\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"ident\", $C->_PATTERN(qr/\\G[_[:alpha:]]\\w*+/));\n}\n;\nsub identifier__PEEK { $_[0]->_AUTOLEXpeek('identifier', $retree) }\nsub identifier {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE identifier\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"identifier\", $C->_PATTERN(qr/\\G[_[:alpha:]]\\w*+/));\n}\n;\nsub pod_comment__PEEK { $_[0]->_AUTOLEXpeek('pod_comment', $retree) }\nsub pod_comment {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE pod_comment\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"pod_comment\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\G(?m:^)[\\x20\\t\\r]*+\\=/))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->unsp)) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'pod_comment_0') {\n$C->deb(\"Fate passed to pod_comment_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT pod_comment_0';    \n}\nelse {\n$x = 'ALTLTM pod_comment_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'pod_comment_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"pod_comment_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (($C) = ($C->_PATTERN(qr/\\Gbegin[\\x20\\t\\r]++/))\nand ($C) = ($C->_SUBSUMEr(['identifier'], sub {\nmy $C = shift;\n$C->identifier\n}))\nand ($C) = ($C->_COMMITLTM())\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = (STD::LazyMap::lazymap(sub {\nmy $C=shift;\nif (($C) = ($C->_EXACT(\"\\n\"))\nand ($C) = ($C->_PATTERN(qr/\\G[\\x20\\t\\r]*+\\=/))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->unsp)) { ($C) } else { () }\n}))\nand ($C) = ($C->_PATTERN(qr/\\Gend[\\x20\\t\\r]++/))\nand ($C) = ($C->_BACKREFn('identifier'))\nand ($C) = ($C->_PATTERN(qr/\\G\\b/))) {\n$C->_STARr(sub {\nmy $C=shift;\n$C->_NOTCHAR( sub { my $C=shift;\n$C->_EXACT(\"\\n\")\n})\n})\n} else { () }\n},\n$C->_SCANf()))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\nmy $M = $C;\n$M->{'identifier'}->Str eq 'END'})\n}))) {\n$C->_STARr(sub {\nmy $C=shift;\n$C->cursor_incr()\n})\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, scalar(do {\nmy $M = $C;\nmy $id = $M->{'identifier'}->Str;\n$self->panic(\"=begin $id without matching =end $id\");\n}, $C)\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_PATTERN(qr/\\Gbegin\\b/))\nand ($C) = ($C->_COMMITLTM())\nand ($C) = ($C->_PATTERN(qr/\\G[\\x20\\t\\r]*+/))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_PATTERN(qr/\\G(?m:$)/)\n}\nor $xact->[-2] or\ndo {\npush @gather, $C->_EXACT(\"\\#\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Unrecognized token after =begin\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = (STD::LazyMap::lazymap(sub {\nmy $C=shift;\nif (($C) = ($C->_EXACT(\"\\n\"))\nand ($C) = ($C->_PATTERN(qr/\\G[\\x20\\t\\r]*+\\=/))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->unsp)) { ($C) } else { () }\n}))\nand ($C) = ($C->_PATTERN(qr/\\Gend\\b/))) {\n$C->_STARr(sub {\nmy $C=shift;\n$C->_NOTCHAR( sub { my $C=shift;\n$C->_EXACT(\"\\n\")\n})\n})\n} else { () }\n},\n$C->_SCANf()))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, scalar(do {\n$self->panic(\"=begin without matching =end\")}, $C)\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_PATTERN(qr/\\Gfor\\b/))\nand ($C) = ($C->_COMMITLTM())\nand ($C) = ($C->_PATTERN(qr/\\G[\\x20\\t\\r]*+/))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_SUBSUMEr(['identifier'], sub {\nmy $C = shift;\n$C->identifier\n})\n}\nor $xact->[-2] or\ndo {\npush @gather, $C->_PATTERN(qr/\\G(?m:$)/)\n}\nor $xact->[-2] or\ndo {\npush @gather, $C->_EXACT(\"\\#\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Unrecognized token after =for\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = (STD::LazyMap::lazymap(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G(?m:^)[\\x20\\t\\r]*+(?m:$)/)\n},\n$C->_SCANf()))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, $C->_STARr(sub {\nmy $C=shift;\n$C->cursor_incr()\n})\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_COMMITLTM())\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = (STD::LazyMap::lazymap(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G(?m:^)\\=cut\\b/)\n},\n$C->_SCANf()))) { ($C) } else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->panic(\"Obsolete pod format, please use =begin/=end instead\"))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_PATTERN(qr/\\G[_[:alpha:]]/)\n}\nor $xact->[-2] or\ndo {\npush @gather, $C->_PATTERN(qr/\\G\\s/)\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Illegal pod directive\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C->_STARr(sub {\nmy $C=shift;\n$C->_NOTCHAR( sub { my $C=shift;\n$C->_EXACT(\"\\n\")\n})\n})\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub comp_unit__PEEK { $_[0]->_AUTOLEXpeek('comp_unit', $retree) }\nsub comp_unit {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::begin_compunit = 1;local $::endargs = -1;local %::LANG;local $::PKGDECL = \"\";local $::IN_DECL;local $::DECLARAND;local $::NEWPKG;local $::NEWLEX;local $::QSIGIL = '';local $::IN_META = 0;local $::QUASIMODO;local $::SCOPE = \"\";local $::LEFTSIGIL;local %::MYSTERY = ();local $::INVOCANT_OK;local $::INVOCANT_IS;local $::CURLEX;local $::MULTINESS = '';local $::CURPKG;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE comp_unit\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"comp_unit\", do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = (scalar(do {\n{\n$::LANG{'MAIN'}    = 'STD' ;\n$::LANG{'Q'}       = 'STD::Q' ;\n$::LANG{'Regex'}   = 'STD::Regex' ;\n$::LANG{'Trans'}   = 'STD::Trans' ;\n$::LANG{'P5'}      = 'STD::STD::P5' ;\n$::LANG{'P5Regex'} = 'STD::P5::Regex' ;\n@::WORRIES = ();\n$self->load_setting($::SETTINGNAME);\nmy $oid = $::SETTING->id;\nmy $id = 'MY:file<' . $::FILE->{'name'} . '>';\n$::CURLEX = Stash->new(\n'OUTER::' => [$oid],\n'!file' => $::FILE, '!line' => 0,\n'!id' => [$id],\n);\n$STD::ALL->{$id} = $::CURLEX;\n$::UNIT = $::CURLEX;\n$STD::ALL->{'UNIT'} = $::UNIT;\n$self->finishlex;\n}}, $C))\nand ($C) = ($C->_SUBSUMEr(['statementlist'], sub {\nmy $C = shift;\n$C->statementlist\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->unitstopper)) { ($C) } else { () }\n}))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->panic(\"Confused\"))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n}\n};\n@gather;\n}\n}))) {\nscalar(do {\n{\nif (@::WORRIES) {\nwarn \"Potential difficulties:\\n  \" . join( \"\\n  \", @::WORRIES) . \"\\n\"};\nmy $m = $C->explain_mystery();\nwarn $m if $m;\n}}, $C)\n} else { () }\n\n});\n}\n;\nsub explain_mystery {\nno warnings 'recursion';\nmy $self = shift;\nmy %post_types;\nmy %unk_types;\nmy %unk_routines;\nmy $m = '';\nfor (keys(%::MYSTERY)) {\nmy $p = $::MYSTERY{$_}->{'lex'};\nif ($self->is_name($_, $p)) {\n$post_types{$_} = $::MYSTERY{$_};\nnext;\n};\nnext if $self->is_known($_, $p) or $self->is_known('&' . $_, $p);\nif ($_ lt 'a') {\n$unk_types{$_} = $::MYSTERY{$_}}\nelse {\n$unk_routines{$_} = $::MYSTERY{$_}};\n}\n;\nif (%post_types) {\nmy @tmp = sort keys(%post_types);\n$m .= \"Illegally post-declared type\" . ('s' x (@tmp != 1)) . \":\\n\";\nfor (@tmp) {\n$m .= \"\\t$_ used at line \" . $post_types{$_}->{'line'} . \"\\n\"}\n;\n};\nif (%unk_types) {\nmy @tmp = sort keys(%unk_types);\n$m .= \"Undeclared name\" . ('s' x (@tmp != 1)) . \":\\n\";\nfor (@tmp) {\n$m .= \"\\t$_ used at line \" . $unk_types{$_}->{'line'} . \"\\n\"}\n;\n};\nif (%unk_routines) {\nmy @tmp = sort keys(%unk_routines);\n$m .= \"Undeclared routine\" . ('s' x (@tmp != 1)) . \":\\n\";\nfor (@tmp) {\n$m .= \"\\t$_ used at line \" . $unk_routines{$_}->{'line'} . \"\\n\"}\n;\n};\n$m;\n};\nsub xblock__PEEK { $_[0]->_AUTOLEXpeek('xblock', $retree) }\nsub xblock {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::GOAL = '{';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE xblock\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"xblock\", do {\nmy $C = $C;\nif (($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\)\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\)\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'block expression', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))\nand ($C) = ($C->ws)) {\n$C->_SUBSUMEr(['block'], sub {\nmy $C = shift;\n$C->block\n})\n} else { () }\n\n});\n}\n;\nsub block__PEEK { $_[0]->_AUTOLEXpeek('block', $retree) }\nsub block {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::CURLEX = $::CURLEX;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE block\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"block\", do {\nmy $C = $C;\nif (($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\{\")\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Missing block\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))\nand ($C) = ($C->newlex)) {\n$C->_SUBSUMEr(['blockoid'], sub {\nmy $C = shift;\n$C->blockoid\n})\n} else { () }\n\n});\n}\n;\nsub blockoid__PEEK { $_[0]->_AUTOLEXpeek('blockoid', $retree) }\nsub blockoid {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal %::LANG = %::LANG;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE blockoid\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"blockoid\", do {\nmy $C = $C;\nif (($C) = ($C->finishlex)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'blockoid_0') {\n$C->deb(\"Fate passed to blockoid_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT blockoid_0';    \n}\nelse {\n$x = 'ALTLTM blockoid_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'blockoid_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"blockoid_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\}\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\{\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['statementlist'], sub {\nmy $C = shift;\n$C->statementlist\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\}\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'block', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->terminator)) { ($C) } else { () }\n}))\nand ($C) = ($C->panic('Missing block'))) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\n$C\n}))\nand ($C) = ($C->panic(\"Malformed block\"))) {\n$C\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'blockoid_1') {\n$C->deb(\"Fate passed to blockoid_1: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT blockoid_1';    \n}\nelse {\n$x = 'ALTLTM blockoid_1'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'blockoid_1', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"blockoid_1 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[\\x20\\t\\r]*+(?m:$)/)\n}))) { ($C) } else { () }\n}))) {\nscalar(do {\n$::MEMOS[$C->{'_pos'}]->{'endstmt'} = 2}, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_PATTERN(qr/\\G[\\x20\\t\\r]*+/))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[\\\\,:]/)\n}))) { ($C) } else { () }\n}))) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->unv)) { ($C) } else { () }\n}))\nand ($C) = ($C->_PATTERN(qr/\\G(?m:$)/))) {\nscalar(do {\n$::MEMOS[$C->{'_pos'}]->{'endstmt'} = 2}, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->unsp)) { ($C) } else { () }\n}))) {\nscalar(do {\n$::MEMOS[$C->{'_pos'}]->{'endargs'} = 1}, $C)\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub regex_block__PEEK { $_[0]->_AUTOLEXpeek('regex_block', $retree) }\nsub regex_block {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal %::LANG = %::LANG;my $lang = $::LANG{'Regex'};local $::GOAL = '}';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE regex_block\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'quotepair'} = [];\n$self->_MATCHIFYr($S, \"regex_block\", do {\nmy $C = $C;\nif (($C) = ($C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['quotepair'], sub {\nmy $C = shift;\n$C->quotepair\n}))\nand ($C) = ($C->ws)) {\nscalar(do {\nmy $M = $C;\nmy $kv = $M->{'quotepair'}->[-1];\n$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})\nor $self->sorry(\"Unrecognized adverb :\" . $kv->{'k'} . '(' . $kv->{'v'} . ')');\n}, $C)\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_EXACT(\"\\{\"))\nand ($C) = ($C->_SUBSUMEr(['nibble'], sub {\nmy $C = shift;\n$C->nibble( $C->cursor_fresh($lang)->unbalanced('}') )\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\}\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Unable to parse regex; couldn't find right brace\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_block_0') {\n$C->deb(\"Fate passed to regex_block_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT regex_block_0';    \n}\nelse {\n$x = 'ALTLTM regex_block_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'regex_block_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"regex_block_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[\\x20\\t\\r]*+(?m:$)/)\n}))) { ($C) } else { () }\n}))) {\nscalar(do {\n$::MEMOS[$C->{'_pos'}]->{'endstmt'} = 2}, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_PATTERN(qr/\\G[\\x20\\t\\r]*+/))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[\\\\,:]/)\n}))) { ($C) } else { () }\n}))) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->unv)) { ($C) } else { () }\n}))\nand ($C) = ($C->_PATTERN(qr/\\G(?m:$)/))) {\nscalar(do {\n$::MEMOS[$C->{'_pos'}]->{'endstmt'} = 2}, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->unsp)) { ($C) } else { () }\n}))) {\nscalar(do {\n$::MEMOS[$C->{'_pos'}]->{'endargs'} = 1}, $C)\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub statementlist__PEEK { $_[0]->_AUTOLEXpeek('statementlist', $retree) }\nsub statementlist {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::INVOCANT_OK = 0;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE statementlist\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'eat_terminator'} = [];\n$C->{'statement'} = [];\n$self->_MATCHIFYr($S, \"statementlist\", do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'statementlist_0') {\n$C->deb(\"Fate passed to statementlist_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT statementlist_0';    \n}\nelse {\n$x = 'ALTLTM statementlist_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'statementlist_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"statementlist_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (($C) = ($C->_PATTERN(qr/\\G\\z/))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\ndo {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_PATTERN(qr/\\G[\\)\\]\\}]/))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n};\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['statement'], sub {\nmy $C = shift;\n$C->statement\n}))\nand ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {\nmy $C = shift;\n$C->eat_terminator\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub semilist__PEEK { $_[0]->_AUTOLEXpeek('semilist', $retree) }\nsub semilist {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::INVOCANT_OK = 0;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE semilist\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'eat_terminator'} = [];\n$C->{'statement'} = [];\n$self->_MATCHIFYr($S, \"semilist\", do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'semilist_0') {\n$C->deb(\"Fate passed to semilist_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT semilist_0';    \n}\nelse {\n$x = 'ALTLTM semilist_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'semilist_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"semilist_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\ndo {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_PATTERN(qr/\\G[\\)\\]\\}]/))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n};\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['statement'], sub {\nmy $C = shift;\n$C->statement\n}))\nand ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {\nmy $C = shift;\n$C->eat_terminator\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub label__PEEK { $_[0]->_AUTOLEXpeek('label', $retree) }\nsub label {\nno warnings 'recursion';\nmy $self = shift;\n\nmy $label;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE label\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"label\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['identifier'], sub {\nmy $C = shift;\n$C->identifier\n}))\nand ($C) = ($C->_EXACT(\"\\:\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\s/)\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\nmy $M = $C;\n$C->is_name($label = $M->{'identifier'}->Str) })\n}))\nand ($C) = ($C->sorry(\"Illegal redeclaration of '$label'\"))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}))) {\nscalar(do {\n{\n$C->add_my_name($label)}}, $C)\n} else { () }\n\n});\n}\n;\nsub statement__PEEK { $_[0]->_AUTOLEXpeek('statement', $retree) }\nsub statement {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::endargs = -1;local $::QSIGIL = 0;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE statement\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'p5statement_mod_cond'} = [];\n$C->{'p5statement_mod_loop'} = [];\n$C->{'statement_mod_cond'} = [];\n$C->{'statement_mod_loop'} = [];\n$self->_MATCHIFYr($S, \"statement\", do {\nmy $C = $C;\nif (($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[\\)\\]\\}]/)\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n(($C) x !!do {\n$C = $::LANG{'MAIN'}->bless($C)})\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_0') {\n$C->deb(\"Fate passed to statement_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT statement_0';    \n}\nelse {\n$x = 'ALTLTM statement_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'statement_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"statement_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['label'], sub {\nmy $C = shift;\n$C->label\n}))) {\n$C->_SUBSUMEr(['statement'], sub {\nmy $C = shift;\n$C->statement\n})\n} else { () }\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['statement_control','p5statement_control'], sub {\nmy $C = shift;\n$C->p5statement_control\n})\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR\n}))\nand ($C) = ($C->ws)) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_1') {\n$C->deb(\"Fate passed to statement_1: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT statement_1';    \n}\nelse {\n$x = 'ALTLTM statement_1'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'statement_1', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"statement_1 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['statement_mod_loop','p5statement_mod_loop'], sub {\nmy $C = shift;\n$C->p5statement_mod_loop\n})\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['statement_mod_cond','p5statement_mod_cond'], sub {\nmy $C = shift;\n$C->p5statement_mod_cond\n})\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) { ($C) } else { () }\n})\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\;\")\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub eat_terminator__PEEK { $_[0]->_AUTOLEXpeek('eat_terminator', $retree) }\nsub eat_terminator {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE eat_terminator\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"eat_terminator\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->_EXACT(\"\\;\"))) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\z/)\n}))) { ($C) } else { () }\n}))) {\nscalar(do {\n$::ORIG =~ s/\\;$/ /}, $C)\n} else { () }\n}))) { ($C) } else { () }\n})\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n$::MEMOS[$C->{'_pos'}]->{'endstmt'} })\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->terminator)) { ($C) } else { () }\n}))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, $C->_PATTERN(qr/\\G\\z/)\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = (scalar(do {\n{\nif ($::MEMOS[$C->{'_pos'}]->{'ws'}) {\n$C->{'_pos'} = $::MEMOS[$C->{'_pos'}]->{'ws'}}}}, $C))\nand ($C) = ($C->panic(\"Confused\"))) {\n$C\n} else { () }\n\n}\n};\n@gather;\n}\n}));\n}\n;\nsub p5statement_control__S_027use__PEEK { $_[0]->_AUTOLEXpeek('p5statement_control__S_027use', $retree) }\nsub p5statement_control__S_027use {\nno warnings 'recursion';\nmy $self = shift;\n\n;\nmy $longname;local $::SCOPE = 'use';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_control__S_027use\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"use\";\n$self->_MATCHIFYr($S, \"p5statement_control__S_027use\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"use\"))\nand ($C) = ($C->spacey)\nand ($C) = ($C->ws)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5statement_control__S_027use_0') {\n$C->deb(\"Fate passed to p5statement_control__S_027use_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5statement_control__S_027use_0';    \n}\nelse {\n$x = 'ALTLTM p5statement_control__S_027use_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5statement_control__S_027use_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5statement_control__S_027use_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['version','p5version'], sub {\nmy $C = shift;\n$C->p5version\n})\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['module_name','p5module_name'], sub {\nmy $C = shift;\n$C->p5module_name\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\n{\n$longname = $M->{'module_name'}->{'longname'}}}, $C))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->spacey)\nand ($C) = ($C->_SUBSUMEr(['arglist'], sub {\nmy $C = shift;\n$C->arglist\n}))) {\nscalar(do {\nmy $M = $C;\n{\n$C->do_use($longname, $M->{'arglist'})}}, $C)\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, scalar(do {\n{\n$C->do_use($longname, '')}}, $C)\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_control__S_028no__PEEK { $_[0]->_AUTOLEXpeek('p5statement_control__S_028no', $retree) }\nsub p5statement_control__S_028no {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_control__S_028no\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'arglist'} = [];\n$C->{sym} = \"no\";\n$self->_MATCHIFYr($S, \"p5statement_control__S_028no\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"no\"))\nand ($C) = ($C->spacey)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['module_name','p5module_name'], sub {\nmy $C = shift;\n$C->p5module_name\n}))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->spacey)) {\n$C->_SUBSUMEr(['arglist'], sub {\nmy $C = shift;\n$C->arglist\n})\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_control__S_029if__PEEK { $_[0]->_AUTOLEXpeek('p5statement_control__S_029if', $retree) }\nsub p5statement_control__S_029if {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_control__S_029if\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'else'} = [];\n$C->{'elsif'} = [];\n$C->{'pblock'} = [];\n$C->{'xblock'} = [];\n$C->{sym} = \"if\";\n$self->_MATCHIFYr($S, \"p5statement_control__S_029if\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['sym'], sub {\nmy $C = shift;\n$C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5statement_control__S_029if_0') {\n$C->deb(\"Fate passed to p5statement_control__S_029if_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5statement_control__S_029if_0';    \n}\nelse {\n$x = 'ALTLTM p5statement_control__S_029if_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5statement_control__S_029if_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5statement_control__S_029if_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_EXACT(\"if\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"unless\")\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n})\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['xblock'], sub {\nmy $C = shift;\n$C->xblock\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->ws)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->ws)) {\n$C->_PATTERN(qr/\\Gelse\\s*+if/)\n} else { () }\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->panic(\"Please use 'elsif'\"))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n}\n};\n@gather;\n}\n}))\nand ($C) = ($C->_EXACT(\"elsif\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->spacey)) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['elsif','xblock'], sub {\nmy $C = shift;\n$C->xblock\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->ws)\nand ($C) = ($C->_EXACT(\"else\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->spacey)) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['else','pblock'], sub {\nmy $C = shift;\n$C->pblock\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_control__S_030while__PEEK { $_[0]->_AUTOLEXpeek('p5statement_control__S_030while', $retree) }\nsub p5statement_control__S_030while {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_control__S_030while\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"while\";\n$self->_MATCHIFYr($S, \"p5statement_control__S_030while\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"while\"))\nand ($C) = ($C->spacey)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['xblock'], sub {\nmy $C = shift;\n$C->xblock\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_control__S_031until__PEEK { $_[0]->_AUTOLEXpeek('p5statement_control__S_031until', $retree) }\nsub p5statement_control__S_031until {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_control__S_031until\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"until\";\n$self->_MATCHIFYr($S, \"p5statement_control__S_031until\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"until\"))\nand ($C) = ($C->spacey)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['xblock'], sub {\nmy $C = shift;\n$C->xblock\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_control__S_032for__PEEK { $_[0]->_AUTOLEXpeek('p5statement_control__S_032for', $retree) }\nsub p5statement_control__S_032for {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_control__S_032for\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"for\";\n$self->_MATCHIFYr($S, \"p5statement_control__S_032for\", do {\nmy $C = $C;\nif (($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5statement_control__S_032for_0') {\n$C->deb(\"Fate passed to p5statement_control__S_032for_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5statement_control__S_032for_0';    \n}\nelse {\n$x = 'ALTLTM p5statement_control__S_032for_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5statement_control__S_032for_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5statement_control__S_032for_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_EXACT(\"for\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"foreach\")\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['eee'], sub {\nmy $C = shift;\n$C->_PAREN( sub {\nmy $C=shift;\ndo {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['e1','EXPR'], sub {\nmy $C = shift;\n$C->EXPR\n})\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_EXACT(\"\\;\"))\nand ($C) = ($C->ws)\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['e2','EXPR'], sub {\nmy $C = shift;\n$C->EXPR\n})\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_EXACT(\"\\;\"))\nand ($C) = ($C->ws)\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['e3','EXPR'], sub {\nmy $C = shift;\n$C->EXPR\n})\n}))\nand ($C) = ($C->ws)) {\n$C->_EXACT(\"\\)\")\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Malformed loop spec\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n};\n\n})\n})\n}))\nand ($C) = ($C->ws)) {\n$C->_SUBSUMEr(['block'], sub {\nmy $C = shift;\n$C->block\n})\n} else { () }\n\n});\n}\n;\nsub p5statement_control__S_033given__PEEK { $_[0]->_AUTOLEXpeek('p5statement_control__S_033given', $retree) }\nsub p5statement_control__S_033given {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_control__S_033given\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"given\";\n$self->_MATCHIFYr($S, \"p5statement_control__S_033given\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"given\"))\nand ($C) = ($C->spacey)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['xblock'], sub {\nmy $C = shift;\n$C->xblock\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_control__S_034when__PEEK { $_[0]->_AUTOLEXpeek('p5statement_control__S_034when', $retree) }\nsub p5statement_control__S_034when {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_control__S_034when\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"when\";\n$self->_MATCHIFYr($S, \"p5statement_control__S_034when\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"when\"))\nand ($C) = ($C->spacey)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['xblock'], sub {\nmy $C = shift;\n$C->xblock\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_control__S_035default__PEEK { $_[0]->_AUTOLEXpeek('p5statement_control__S_035default', $retree) }\nsub p5statement_control__S_035default {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_control__S_035default\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"default\";\n$self->_MATCHIFYr($S, \"p5statement_control__S_035default\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"default\"))\nand ($C) = ($C->spacey)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['block'], sub {\nmy $C = shift;\n$C->block\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_prefix__S_036BEGIN__PEEK { $_[0]->_AUTOLEXpeek('p5statement_prefix__S_036BEGIN', $retree) }\nsub p5statement_prefix__S_036BEGIN {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_prefix__S_036BEGIN\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"BEGIN\";\n$self->_MATCHIFYr($S, \"p5statement_prefix__S_036BEGIN\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"BEGIN\"))\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['block'], sub {\nmy $C = shift;\n$C->block\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_prefix__S_037CHECK__PEEK { $_[0]->_AUTOLEXpeek('p5statement_prefix__S_037CHECK', $retree) }\nsub p5statement_prefix__S_037CHECK {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_prefix__S_037CHECK\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"CHECK\";\n$self->_MATCHIFYr($S, \"p5statement_prefix__S_037CHECK\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"CHECK\"))\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['block'], sub {\nmy $C = shift;\n$C->block\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_prefix__S_038INIT__PEEK { $_[0]->_AUTOLEXpeek('p5statement_prefix__S_038INIT', $retree) }\nsub p5statement_prefix__S_038INIT {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_prefix__S_038INIT\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"INIT\";\n$self->_MATCHIFYr($S, \"p5statement_prefix__S_038INIT\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"INIT\"))\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['block'], sub {\nmy $C = shift;\n$C->block\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_control__S_039END__PEEK { $_[0]->_AUTOLEXpeek('p5statement_control__S_039END', $retree) }\nsub p5statement_control__S_039END {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_control__S_039END\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"END\";\n$self->_MATCHIFYr($S, \"p5statement_control__S_039END\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"END\"))\nand ($C) = ($C->spacey)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['block'], sub {\nmy $C = shift;\n$C->block\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub modifier_expr__PEEK { $_[0]->_AUTOLEXpeek('modifier_expr', $retree) }\nsub modifier_expr {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE modifier_expr\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"modifier_expr\", do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_mod_cond__S_040if__PEEK { $_[0]->_AUTOLEXpeek('p5statement_mod_cond__S_040if', $retree) }\nsub p5statement_mod_cond__S_040if {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_mod_cond__S_040if\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"if\";\n$self->_MATCHIFYr($S, \"p5statement_mod_cond__S_040if\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"if\"))\nand ($C) = ($C->nofun)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {\nmy $C = shift;\n$C->modifier_expr\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_mod_cond__S_041unless__PEEK { $_[0]->_AUTOLEXpeek('p5statement_mod_cond__S_041unless', $retree) }\nsub p5statement_mod_cond__S_041unless {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_mod_cond__S_041unless\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"unless\";\n$self->_MATCHIFYr($S, \"p5statement_mod_cond__S_041unless\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"unless\"))\nand ($C) = ($C->nofun)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {\nmy $C = shift;\n$C->modifier_expr\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_mod_cond__S_042when__PEEK { $_[0]->_AUTOLEXpeek('p5statement_mod_cond__S_042when', $retree) }\nsub p5statement_mod_cond__S_042when {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_mod_cond__S_042when\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"when\";\n$self->_MATCHIFYr($S, \"p5statement_mod_cond__S_042when\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"when\"))\nand ($C) = ($C->nofun)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {\nmy $C = shift;\n$C->modifier_expr\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_mod_loop__S_043while__PEEK { $_[0]->_AUTOLEXpeek('p5statement_mod_loop__S_043while', $retree) }\nsub p5statement_mod_loop__S_043while {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_mod_loop__S_043while\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"while\";\n$self->_MATCHIFYr($S, \"p5statement_mod_loop__S_043while\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"while\"))\nand ($C) = ($C->nofun)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {\nmy $C = shift;\n$C->modifier_expr\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_mod_loop__S_044until__PEEK { $_[0]->_AUTOLEXpeek('p5statement_mod_loop__S_044until', $retree) }\nsub p5statement_mod_loop__S_044until {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_mod_loop__S_044until\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"until\";\n$self->_MATCHIFYr($S, \"p5statement_mod_loop__S_044until\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"until\"))\nand ($C) = ($C->nofun)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {\nmy $C = shift;\n$C->modifier_expr\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_mod_loop__S_045for__PEEK { $_[0]->_AUTOLEXpeek('p5statement_mod_loop__S_045for', $retree) }\nsub p5statement_mod_loop__S_045for {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_mod_loop__S_045for\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"for\";\n$self->_MATCHIFYr($S, \"p5statement_mod_loop__S_045for\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"for\"))\nand ($C) = ($C->nofun)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {\nmy $C = shift;\n$C->modifier_expr\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_mod_loop__S_046given__PEEK { $_[0]->_AUTOLEXpeek('p5statement_mod_loop__S_046given', $retree) }\nsub p5statement_mod_loop__S_046given {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_mod_loop__S_046given\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"given\";\n$self->_MATCHIFYr($S, \"p5statement_mod_loop__S_046given\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"given\"))\nand ($C) = ($C->nofun)\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {\nmy $C = shift;\n$C->modifier_expr\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub def_module_name__PEEK { $_[0]->_AUTOLEXpeek('def_module_name', $retree) }\nsub def_module_name {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE def_module_name\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'signature'} = [];\n$self->_MATCHIFYr($S, \"def_module_name\", do {\nif (my ($C) = ($C->_SUBSUMEr(['longname'], sub {\nmy $C = shift;\n$C->longname\n}))) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\[\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n($::PKGDECL//'') eq 'role' })\n}))\nand ($C) = ($C->newlex)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\]\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\[\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['signature'], sub {\nmy $C = shift;\n$C->signature\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\]\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'generic role', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))\nand ($C) = (scalar(do {\n$::IN_DECL = 0}, $C))\nand ($C) = ($C->finishlex)) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n})\n} else { () }\n\n});\n}\n;\nsub p5module_name__S_047normal__PEEK { $_[0]->_AUTOLEXpeek('p5module_name__S_047normal', $retree) }\nsub p5module_name__S_047normal {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5module_name__S_047normal\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'arglist'} = [];\n$C->{sym} = \"normal\";\n$self->_MATCHIFYr($S, \"p5module_name__S_047normal\", do {\nif (my ($C) = ($C->_SUBSUMEr(['longname'], sub {\nmy $C = shift;\n$C->longname\n}))) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\[\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\]\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\[\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['arglist'], sub {\nmy $C = shift;\n$C->arglist\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\]\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'generic role', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n})\n} else { () }\n\n});\n}\n;\nsub vnum__PEEK { $_[0]->_AUTOLEXpeek('vnum', $retree) }\nsub vnum {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE vnum\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"vnum\", do {\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'vnum_0') {\n$C->deb(\"Fate passed to vnum_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT vnum_0';    \n}\nelse {\n$x = 'ALTLTM vnum_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'vnum_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"vnum_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\d++/)\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\*\")\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n\n});\n}\n;\nsub p5version__S_048v__PEEK { $_[0]->_AUTOLEXpeek('p5version__S_048v', $retree) }\nsub p5version__S_048v {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5version__S_048v\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'vnum'} = [];\n$C->{sym} = \"v\";\n$self->_MATCHIFYr($S, \"p5version__S_048v\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"v\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\d++/)\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_COMMITLTM())\nand ($C) = ($C->_REPSEPr( sub {\nmy $C=shift;\n$C->_EXACT(\"\\.\")\n}, sub {\nmy $C=shift;\n$C->_SUBSUMEr(['vnum'], sub {\nmy $C = shift;\n$C->vnum\n})\n}))) {\n$C->_PATTERN(qr/\\G\\+?+/)\n} else { () }\n\n});\n}\n;\nsub variable_declarator__PEEK { $_[0]->_AUTOLEXpeek('variable_declarator', $retree) }\nsub variable_declarator {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::IN_DECL = 1;local $::DECLARAND;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE variable_declarator\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'p5postcircumfix'} = [];\n$C->{'postcircumfix'} = [];\n$C->{'semilist'} = [];\n$C->{'shape'} = [];\n$C->{'signature'} = [];\n$C->{'trait'} = [];\n$self->_MATCHIFYr($S, \"variable_declarator\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['variable'], sub {\nmy $C = shift;\n$C->variable\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\n$::IN_DECL = 0;\n$C->add_variable($M->{'variable'}->Str) ;\n}, $C))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->unsp)) { ($C) } else { () }\n}))) {\n$C->_STARr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['shape'], sub {\nmy $C = shift;\n$C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_declarator_0') {\n$C->deb(\"Fate passed to variable_declarator_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT variable_declarator_0';    \n}\nelse {\n$x = 'ALTLTM variable_declarator_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'variable_declarator_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"variable_declarator_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\)\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['signature'], sub {\nmy $C = shift;\n$C->signature\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\)\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'variable_declarator', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\]\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\[\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['semilist'], sub {\nmy $C = shift;\n$C->semilist\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\]\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'shape definition', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\}\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\{\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['semilist'], sub {\nmy $C = shift;\n$C->semilist\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\}\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'shape definition', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\<\")\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['postcircumfix','p5postcircumfix'], sub {\nmy $C = shift;\n$C->p5postcircumfix\n})\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n})\n})\n})\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)) {\n$C->_STARr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['trait'], sub {\nmy $C = shift;\n$C->trait\n})\n})\n} else { () }\n\n});\n}\n;\nsub scoped__PEEK { $_[0]->_AUTOLEXpeek('scoped', $retree) }\nsub scoped {\nno warnings 'recursion';\nmy $self = shift;\n\ndie 'Required argument SCOPE omitted' unless @_;\nlocal $::SCOPE = @_ ? shift() : undef;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE scoped\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"scoped\", do {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'scoped_0') {\n$C->deb(\"Fate passed to scoped_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT scoped_0';    \n}\nelse {\n$x = 'ALTLTM scoped_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'scoped_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"scoped_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['declarator'], sub {\nmy $C = shift;\n$C->declarator\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['regex_declarator','p5regex_declarator'], sub {\nmy $C = shift;\n$C->p5regex_declarator\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['package_declarator','p5package_declarator'], sub {\nmy $C = shift;\n$C->p5package_declarator\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->ws)) {\n$C->_PATTERN(qr/\\G[A-Z]/)\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_SUBSUMEr(['longname'], sub {\nmy $C = shift;\n$C->longname\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\n{\nmy $t = $M->{'longname'}->Str;\nif (not $C->is_known($t)) {\n$C->sorry(\"In \\\"$::SCOPE\\\" declaration, typename $t must be predeclared (or marked as declarative with :: prefix)\")};\n}}, $C))\nand ($C) = ($C->ws)\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}))) {\n$C\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->panic(\"Malformed $::SCOPE\"))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n}\n};\n@gather;\n});\n}\n;\nsub p5scope_declarator__S_049my__PEEK { $_[0]->_AUTOLEXpeek('p5scope_declarator__S_049my', $retree) }\nsub p5scope_declarator__S_049my {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5scope_declarator__S_049my\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"my\";\n$self->_MATCHIFYr($S, \"p5scope_declarator__S_049my\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"my\"))\nand ($C) = ($C->nofun)) {\n$C->_SUBSUMEr(['scoped'], sub {\nmy $C = shift;\n$C->scoped('my')\n})\n} else { () }\n\n});\n}\n;\nsub p5scope_declarator__S_050our__PEEK { $_[0]->_AUTOLEXpeek('p5scope_declarator__S_050our', $retree) }\nsub p5scope_declarator__S_050our {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5scope_declarator__S_050our\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"our\";\n$self->_MATCHIFYr($S, \"p5scope_declarator__S_050our\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"our\"))\nand ($C) = ($C->nofun)) {\n$C->_SUBSUMEr(['scoped'], sub {\nmy $C = shift;\n$C->scoped('our')\n})\n} else { () }\n\n});\n}\n;\nsub p5scope_declarator__S_051state__PEEK { $_[0]->_AUTOLEXpeek('p5scope_declarator__S_051state', $retree) }\nsub p5scope_declarator__S_051state {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5scope_declarator__S_051state\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"state\";\n$self->_MATCHIFYr($S, \"p5scope_declarator__S_051state\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"state\"))\nand ($C) = ($C->nofun)) {\n$C->_SUBSUMEr(['scoped'], sub {\nmy $C = shift;\n$C->scoped('state')\n})\n} else { () }\n\n});\n}\n;\nsub p5package_declarator__S_052package__PEEK { $_[0]->_AUTOLEXpeek('p5package_declarator__S_052package', $retree) }\nsub p5package_declarator__S_052package {\nno warnings 'recursion';\nmy $self = shift;\n\n;\nlocal $::PKGDECL = 'package';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5package_declarator__S_052package\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"package\";\n$self->_MATCHIFYr($S, \"p5package_declarator__S_052package\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"package\"))\nand ($C) = ($C->spacey)) {\n$C->_SUBSUMEr(['package_def'], sub {\nmy $C = shift;\n$C->package_def\n})\n} else { () }\n\n});\n}\n;\nsub p5package_declarator__S_053require__PEEK { $_[0]->_AUTOLEXpeek('p5package_declarator__S_053require', $retree) }\nsub p5package_declarator__S_053require {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5package_declarator__S_053require\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'EXPR'} = [];\n$C->{sym} = \"require\";\n$self->_MATCHIFYr($S, \"p5package_declarator__S_053require\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"require\"))\nand ($C) = ($C->spacey)\nand ($C) = ($C->ws)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->_SUBSUMEr(['module_name','p5module_name'], sub {\nmy $C = shift;\n$C->p5module_name\n}))) {\n$C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR\n})\n})\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, $C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR\n})\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub package_def__PEEK { $_[0]->_AUTOLEXpeek('package_def', $retree) }\nsub package_def {\nno warnings 'recursion';\nmy $self = shift;\n\nmy $longname;local $::IN_DECL = 1;local $::DECLARAND;local $::NEWPKG;local $::NEWLEX;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE package_def\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'def_module_name'} = [];\n$self->_MATCHIFYr($S, \"package_def\", do {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = (scalar(do {\n$::SCOPE ||= 'our'}, $C))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['def_module_name'], sub {\nmy $C = shift;\n$C->def_module_name\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\n$longname = $M->{'def_module_name'}->[0]->{'longname'};\n$C->add_name($longname->Str);\n}, $C))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->ws)) {\n$C->_EXACT(\"\\;\")\n} else { () }\n}))) { ($C) } else { () }\n}))) {\nscalar(do {\n{\n$longname  or  $C->panic(\"Package cannot be anonymous\");\nmy $shortname = $longname->{'name'}->Str;\n$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};\n}}, $C)\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->panic(\"Unable to parse \" . $::PKGDECL . \" definition\"))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) {\n$C\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->panic(\"Malformed $::PKGDECL\"))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n}\n};\n@gather;\n});\n}\n;\nsub declarator__PEEK { $_[0]->_AUTOLEXpeek('declarator', $retree) }\nsub declarator {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE declarator\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'trait'} = [];\n$self->_MATCHIFYr($S, \"declarator\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'declarator_0') {\n$C->deb(\"Fate passed to declarator_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT declarator_0';    \n}\nelse {\n$x = 'ALTLTM declarator_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'declarator_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"declarator_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['constant_declarator'], sub {\nmy $C = shift;\n$C->constant_declarator\n})\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['variable_declarator'], sub {\nmy $C = shift;\n$C->variable_declarator\n})\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\)\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['signature'], sub {\nmy $C = shift;\n$C->signature\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\)\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'declarator', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) {\n$C->_STARr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['trait'], sub {\nmy $C = shift;\n$C->trait\n})\n})\n} else { () }\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['routine_declarator','p5routine_declarator'], sub {\nmy $C = shift;\n$C->p5routine_declarator\n})\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['regex_declarator','p5regex_declarator'], sub {\nmy $C = shift;\n$C->p5regex_declarator\n})\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['type_declarator','p5type_declarator'], sub {\nmy $C = shift;\n$C->p5type_declarator\n})\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub p5multi_declarator__S_054null__PEEK { $_[0]->_AUTOLEXpeek('p5multi_declarator__S_054null', $retree) }\nsub p5multi_declarator__S_054null {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::MULTINESS = '';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5multi_declarator__S_054null\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"null\";\n$self->_MATCHIFYr($S, \"p5multi_declarator__S_054null\", $C->_SUBSUMEr(['declarator'], sub {\nmy $C = shift;\n$C->declarator\n}));\n}\n;\nsub p5routine_declarator__S_055sub__PEEK { $_[0]->_AUTOLEXpeek('p5routine_declarator__S_055sub', $retree) }\nsub p5routine_declarator__S_055sub {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5routine_declarator__S_055sub\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"sub\";\n$self->_MATCHIFYr($S, \"p5routine_declarator__S_055sub\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"sub\"))\nand ($C) = ($C->nofun)) {\n$C->_SUBSUMEr(['routine_def'], sub {\nmy $C = shift;\n$C->routine_def\n})\n} else { () }\n\n});\n}\n;\nsub parensig__PEEK { $_[0]->_AUTOLEXpeek('parensig', $retree) }\nsub parensig {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE parensig\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"parensig\", do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\)\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['signature'], sub {\nmy $C = shift;\n$C->signature(1)\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\)\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'signature', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub checkyada {\nno warnings 'recursion';\nmy $self = shift;\neval {\nmy $startsym = $self->{'blockoid'}->{'statementlist'}->{'statement'}->[0]->{'EXPR'}->{'term'}->{'sym'} // '';\nif ($startsym eq '...' or $startsym eq '!!!' or $startsym eq '???') {\n$::DECLARAND->{'stub'} = 1};\n};\nreturn $self;\n};\nsub routine_def__PEEK { $_[0]->_AUTOLEXpeek('routine_def', $retree) }\nsub routine_def {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::CURLEX = $::CURLEX;local $::IN_DECL = 1;local $::DECLARAND;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE routine_def\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'deflongname'} = [];\n$C->{'parensig'} = [];\n$C->{'trait'} = [];\n$self->_MATCHIFYr($S, \"routine_def\", do {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_0') {\n$C->deb(\"Fate passed to routine_def_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT routine_def_0';    \n}\nelse {\n$x = 'ALTLTM routine_def_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'routine_def_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"routine_def_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (($C) = ($C->ws)\nand ($C) = ($C->_EXACT(\"\\&\"))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['deflongname'], sub {\nmy $C = shift;\n$C->deflongname\n})\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['deflongname'], sub {\nmy $C = shift;\n$C->deflongname\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->newlex(1))\nand ($C) = ($C->ws)\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['parensig'], sub {\nmy $C = shift;\n$C->parensig\n})\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_STARr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['trait'], sub {\nmy $C = shift;\n$C->trait\n})\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n(($C) x !!do {\n$::IN_DECL = 0})\n}))\nand ($C) = ($C->_SUBSUMEr(['blockoid'], sub {\nmy $C = shift;\n$C->blockoid\n}))\nand ($C) = ($C->checkyada)\nand ($C) = ($C->getsig)) {\n$C\n} else { () }\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->panic(\"Malformed routine\"))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n}\n};\n@gather;\n});\n}\n;\nsub trait__PEEK { $_[0]->_AUTOLEXpeek('trait', $retree) }\nsub trait {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::IN_DECL = 0;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE trait\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"trait\", do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_EXACT(\"\\:\"))\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR(\\%comma)\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub nullterm__PEEK { $_[0]->_AUTOLEXpeek('nullterm', $retree) }\nsub nullterm {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE nullterm\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"nullterm\", $C->before(sub {\nmy $C=shift;\n$C\n}));\n}\n;\nsub nulltermish__PEEK { $_[0]->_AUTOLEXpeek('nulltermish', $retree) }\nsub nulltermish {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE nulltermish\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"nulltermish\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'nulltermish_0') {\n$C->deb(\"Fate passed to nulltermish_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT nulltermish_0';    \n}\nelse {\n$x = 'ALTLTM nulltermish_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'nulltermish_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"nulltermish_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->stdstopper)) { ($C) } else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['term','termish'], sub {\nmy $C = shift;\n$C->termish\n}))) {\nscalar(do {\nmy $M = $C;\n$C->{'PRE'}  = delete $M->{'term'}->{'PRE'};\n$C->{'POST'} = delete $M->{'term'}->{'POST'};\n$C->{'~CAPS'} = $M->{'term'}->{'~CAPS'};\n}, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub termish__PEEK { $_[0]->_AUTOLEXpeek('termish', $retree) }\nsub termish {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::SCOPE = \"\";local $::VAR;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE termish\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'POST'} = [];\n$C->{'PRE'} = [];\n$self->_MATCHIFYr($S, \"termish\", do {\nmy $C = $C;\nif (($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'termish_0') {\n$C->deb(\"Fate passed to termish_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT termish_0';    \n}\nelse {\n$x = 'ALTLTM termish_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'termish_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"termish_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['PRE'], sub {\nmy $C = shift;\n$C->PRE\n}))\nand ($C) = ($C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n(($C) x !!do {\nmy $M = $C;\nmy $p = $M->{'PRE'};\nmy @p = @$p;\n$p[-1]->{'O'}->{'term'} and $M->{'term'} = pop @$p ;\n})\n}))) {\n$C->_SUBSUMEr(['PRE'], sub {\nmy $C = shift;\n$C->PRE\n})\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\nmy $M = $C;\n$M->{'term'} })\n}))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, $C->_SUBSUMEr(['term'], sub {\nmy $C = shift;\n$C->term\n})\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['term','p5term'], sub {\nmy $C = shift;\n$C->p5term\n})\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n$::QSIGIL })\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n$::QSIGIL eq '$' })\n}))) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nSTD::LazyMap::lazymap(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->after(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G(?<=[\\]}>)])/)\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n},\n$C->_PLUSg(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['POST'], sub {\nmy $C = shift;\n$C->POST\n})\n}))\n}))) { ($C) } else { () }\n})\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = (STD::LazyMap::lazymap(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->after(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G(?<=[\\]}>)])/)\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n},\n$C->_PLUSg(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['POST'], sub {\nmy $C = shift;\n$C->POST\n})\n})))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, scalar(do {\n$::VAR = 0}, $C)\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n(($C) x !!do {\n$::QSIGIL })\n}))) {\n$C->_STARr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['POST'], sub {\nmy $C = shift;\n$C->POST\n})\n})\n} else { () }\n\n}\n};\n@gather;\n}\n}))) {\nscalar(do {\nmy $M = $C;\n$self->check_variable($::VAR) if $::VAR;\n$C->{'~CAPS'} = $M->{'term'}->{'~CAPS'};\n}, $C)\n} else { () }\n\n});\n}\n;\nsub p5term__S_056fatarrow__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_056fatarrow', $retree) }\nsub p5term__S_056fatarrow {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_056fatarrow\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"fatarrow\";\n$self->_MATCHIFYr($S, \"p5term__S_056fatarrow\", $C->_SUBSUMEr(['fatarrow'], sub {\nmy $C = shift;\n$C->fatarrow\n}));\n}\n;\nsub p5term__S_057variable__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_057variable', $retree) }\nsub p5term__S_057variable {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_057variable\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"variable\";\n$self->_MATCHIFYr($S, \"p5term__S_057variable\", do {\nif (my ($C) = ($C->_SUBSUMEr(['variable'], sub {\nmy $C = shift;\n$C->variable\n}))) {\nscalar(do {\nmy $M = $C;\n$::VAR = $M->{'variable'} }, $C)\n} else { () }\n\n});\n}\n;\nsub p5term__S_058package_declarator__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_058package_declarator', $retree) }\nsub p5term__S_058package_declarator {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_058package_declarator\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"package_declarator\";\n$self->_MATCHIFYr($S, \"p5term__S_058package_declarator\", $C->_SUBSUMEr(['package_declarator','p5package_declarator'], sub {\nmy $C = shift;\n$C->p5package_declarator\n}));\n}\n;\nsub p5term__S_059scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_059scope_declarator', $retree) }\nsub p5term__S_059scope_declarator {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_059scope_declarator\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"scope_declarator\";\n$self->_MATCHIFYr($S, \"p5term__S_059scope_declarator\", $C->_SUBSUMEr(['scope_declarator','p5scope_declarator'], sub {\nmy $C = shift;\n$C->p5scope_declarator\n}));\n}\n;\nsub p5term__S_060routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_060routine_declarator', $retree) }\nsub p5term__S_060routine_declarator {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_060routine_declarator\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"routine_declarator\";\n$self->_MATCHIFYr($S, \"p5term__S_060routine_declarator\", $C->_SUBSUMEr(['routine_declarator','p5routine_declarator'], sub {\nmy $C = shift;\n$C->p5routine_declarator\n}));\n}\n;\nsub p5term__S_061circumfix__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_061circumfix', $retree) }\nsub p5term__S_061circumfix {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_061circumfix\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"circumfix\";\n$self->_MATCHIFYr($S, \"p5term__S_061circumfix\", $C->_SUBSUMEr(['circumfix','p5circumfix'], sub {\nmy $C = shift;\n$C->p5circumfix\n}));\n}\n;\nsub p5term__S_062dotty__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_062dotty', $retree) }\nsub p5term__S_062dotty {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_062dotty\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"dotty\";\n$self->_MATCHIFYr($S, \"p5term__S_062dotty\", $C->_SUBSUMEr(['dotty','p5dotty'], sub {\nmy $C = shift;\n$C->p5dotty\n}));\n}\n;\nsub p5term__S_063value__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_063value', $retree) }\nsub p5term__S_063value {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_063value\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"value\";\n$self->_MATCHIFYr($S, \"p5term__S_063value\", $C->_SUBSUMEr(['value','p5value'], sub {\nmy $C = shift;\n$C->p5value\n}));\n}\n;\nsub p5term__S_064capterm__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_064capterm', $retree) }\nsub p5term__S_064capterm {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_064capterm\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"capterm\";\n$self->_MATCHIFYr($S, \"p5term__S_064capterm\", $C->_SUBSUMEr(['capterm'], sub {\nmy $C = shift;\n$C->capterm\n}));\n}\n;\nsub p5term__S_065statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_065statement_prefix', $retree) }\nsub p5term__S_065statement_prefix {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_065statement_prefix\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"statement_prefix\";\n$self->_MATCHIFYr($S, \"p5term__S_065statement_prefix\", $C->_SUBSUMEr(['statement_prefix','p5statement_prefix'], sub {\nmy $C = shift;\n$C->p5statement_prefix\n}));\n}\n;\nsub fatarrow__PEEK { $_[0]->_AUTOLEXpeek('fatarrow', $retree) }\nsub fatarrow {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE fatarrow\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"fatarrow\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['key','identifier'], sub {\nmy $C = shift;\n$C->identifier\n}))\nand ($C) = ($C->_PATTERN(qr/\\G[\\x20\\t\\r]*+\\=\\>/))\nand ($C) = ($C->ws)) {\n$C->_SUBSUMEr(['val','EXPR'], sub {\nmy $C = shift;\n$C->EXPR(\\%assignment)\n})\n} else { () }\n\n});\n}\n;\nsub p5special_variable__S_066DollarBang__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_066DollarBang', $retree) }\nsub p5special_variable__S_066DollarBang {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_066DollarBang\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\!\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_066DollarBang\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\$\\!\"))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\w/)\n}))) { ($C) } else { () }\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5special_variable__S_067DollarBangCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_067DollarBangCur_Ly', $retree) }\nsub p5special_variable__S_067DollarBangCur_Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_067DollarBangCur_Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\!\\{\\ \\}\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_067DollarBangCur_Ly\", $C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\}\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\$\\!\\{\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\}\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'p5special_variable', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}));\n}\n;\nsub p5special_variable__S_068DollarSlash__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_068DollarSlash', $retree) }\nsub p5special_variable__S_068DollarSlash {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_068DollarSlash\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\/\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_068DollarSlash\", $C->_EXACT(\"\\$\\/\"));\n}\n;\nsub p5special_variable__S_069DollarTilde__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_069DollarTilde', $retree) }\nsub p5special_variable__S_069DollarTilde {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_069DollarTilde\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\~\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_069DollarTilde\", $C->_EXACT(\"\\$\\~\"));\n}\n;\nsub p5special_variable__S_070DollarGrave__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_070DollarGrave', $retree) }\nsub p5special_variable__S_070DollarGrave {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_070DollarGrave\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\`\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_070DollarGrave\", $C->_EXACT(\"\\$\\`\"));\n}\n;\nsub p5special_variable__S_071DollarAt__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_071DollarAt', $retree) }\nsub p5special_variable__S_071DollarAt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_071DollarAt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\@\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_071DollarAt\", $C->_EXACT(\"\\$\\@\"));\n}\n;\nsub p5special_variable__S_072DollarSharp__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_072DollarSharp', $retree) }\nsub p5special_variable__S_072DollarSharp {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_072DollarSharp\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\#\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_072DollarSharp\", $C->_EXACT(\"\\$\\#\"));\n}\n;\nsub p5special_variable__S_073DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_073DollarDollar', $retree) }\nsub p5special_variable__S_073DollarDollar {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_073DollarDollar\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\$\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_073DollarDollar\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\$\\$\"))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[_[:alpha:]]/)\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5special_variable__S_074DollarPercent__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_074DollarPercent', $retree) }\nsub p5special_variable__S_074DollarPercent {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_074DollarPercent\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\%\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_074DollarPercent\", $C->_EXACT(\"\\$\\%\"));\n}\n;\nsub p5special_variable__S_075DollarCaretX__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_075DollarCaretX', $retree) }\nsub p5special_variable__S_075DollarCaretX {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_075DollarCaretX\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\^X\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_075DollarCaretX\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['sigil','p5sigil'], sub {\nmy $C = shift;\n$C->p5sigil\n}))\nand ($C) = ($C->_EXACT(\"\\^\"))\nand ($C) = ($C->_SUBSUMEr(['letter'], sub {\nmy $C = shift;\n$C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[A-Z]/)\n})\n}))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\W/)\n}))) { ($C) } else { () }\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5special_variable__S_076DollarCaret__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_076DollarCaret', $retree) }\nsub p5special_variable__S_076DollarCaret {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_076DollarCaret\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\^\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_076DollarCaret\", $C->_EXACT(\"\\$\\^\"));\n}\n;\nsub p5special_variable__S_077DollarAmp__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_077DollarAmp', $retree) }\nsub p5special_variable__S_077DollarAmp {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_077DollarAmp\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\&\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_077DollarAmp\", $C->_EXACT(\"\\$\\&\"));\n}\n;\nsub p5special_variable__S_078DollarStar__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_078DollarStar', $retree) }\nsub p5special_variable__S_078DollarStar {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_078DollarStar\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\*\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_078DollarStar\", $C->_EXACT(\"\\$\\*\"));\n}\n;\nsub p5special_variable__S_079DollarThesis__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_079DollarThesis', $retree) }\nsub p5special_variable__S_079DollarThesis {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_079DollarThesis\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\)\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_079DollarThesis\", $C->_EXACT(\"\\$\\)\"));\n}\n;\nsub p5special_variable__S_080DollarMinus__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_080DollarMinus', $retree) }\nsub p5special_variable__S_080DollarMinus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_080DollarMinus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\-\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_080DollarMinus\", $C->_EXACT(\"\\$\\-\"));\n}\n;\nsub p5special_variable__S_081DollarEqual__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_081DollarEqual', $retree) }\nsub p5special_variable__S_081DollarEqual {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_081DollarEqual\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\=\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_081DollarEqual\", $C->_EXACT(\"\\$\\=\"));\n}\n;\nsub p5special_variable__S_082AtPlus__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_082AtPlus', $retree) }\nsub p5special_variable__S_082AtPlus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_082AtPlus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\@\\+\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_082AtPlus\", $C->_EXACT(\"\\@\\+\"));\n}\n;\nsub p5special_variable__S_083PercentPlus__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_083PercentPlus', $retree) }\nsub p5special_variable__S_083PercentPlus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_083PercentPlus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\%\\+\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_083PercentPlus\", $C->_EXACT(\"\\%\\+\"));\n}\n;\nsub p5special_variable__S_084DollarPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_084DollarPlusBra_Ket', $retree) }\nsub p5special_variable__S_084DollarPlusBra_Ket {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_084DollarPlusBra_Ket\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\+\\[\\ \\]\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_084DollarPlusBra_Ket\", $C->_EXACT(\"\\$\\+\\[\"));\n}\n;\nsub p5special_variable__S_085AtPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_085AtPlusBra_Ket', $retree) }\nsub p5special_variable__S_085AtPlusBra_Ket {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_085AtPlusBra_Ket\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\@\\+\\[\\ \\]\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_085AtPlusBra_Ket\", $C->_EXACT(\"\\@\\+\\[\"));\n}\n;\nsub p5special_variable__S_086AtPlusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_086AtPlusCur_Ly', $retree) }\nsub p5special_variable__S_086AtPlusCur_Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_086AtPlusCur_Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\@\\+\\{\\ \\}\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_086AtPlusCur_Ly\", $C->_EXACT(\"\\@\\+\\{\"));\n}\n;\nsub p5special_variable__S_087AtMinus__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_087AtMinus', $retree) }\nsub p5special_variable__S_087AtMinus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_087AtMinus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\@\\-\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_087AtMinus\", $C->_EXACT(\"\\@\\-\"));\n}\n;\nsub p5special_variable__S_088PercentMinus__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_088PercentMinus', $retree) }\nsub p5special_variable__S_088PercentMinus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_088PercentMinus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\%\\-\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_088PercentMinus\", $C->_EXACT(\"\\%\\-\"));\n}\n;\nsub p5special_variable__S_089DollarMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_089DollarMinusBra_Ket', $retree) }\nsub p5special_variable__S_089DollarMinusBra_Ket {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_089DollarMinusBra_Ket\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\-\\[\\ \\]\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_089DollarMinusBra_Ket\", $C->_EXACT(\"\\$\\-\\[\"));\n}\n;\nsub p5special_variable__S_090AtMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_090AtMinusBra_Ket', $retree) }\nsub p5special_variable__S_090AtMinusBra_Ket {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_090AtMinusBra_Ket\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\@\\-\\[\\ \\]\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_090AtMinusBra_Ket\", $C->_EXACT(\"\\@\\-\\[\"));\n}\n;\nsub p5special_variable__S_091PercentMinusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_091PercentMinusCur_Ly', $retree) }\nsub p5special_variable__S_091PercentMinusCur_Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_091PercentMinusCur_Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\%\\-\\{\\ \\}\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_091PercentMinusCur_Ly\", $C->_EXACT(\"\\@\\-\\{\"));\n}\n;\nsub p5special_variable__S_092DollarPlus__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_092DollarPlus', $retree) }\nsub p5special_variable__S_092DollarPlus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_092DollarPlus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\+\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_092DollarPlus\", $C->_EXACT(\"\\$\\+\"));\n}\n;\nsub p5special_variable__S_093DollarCurCaret_Ly__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_093DollarCurCaret_Ly', $retree) }\nsub p5special_variable__S_093DollarCurCaret_Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_093DollarCurCaret_Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\{\\^\\ \\}\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_093DollarCurCaret_Ly\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['sigil','p5sigil'], sub {\nmy $C = shift;\n$C->p5sigil\n}))\nand ($C) = ($C->_EXACT(\"\\{\\^\"))\nand ($C) = ($C->_COMMITLTM())\nand ($C) = ($C->_SUBSUMEr(['text'], sub {\nmy $C = shift;\n$C->_BRACKET(sub {\nmy $C=shift;\n$C->_SCANf()\n})\n}))) {\n$C->_EXACT(\"\\}\")\n} else { () }\n\n});\n}\n;\nsub p5special_variable__S_094ColonColonCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_094ColonColonCur_Ly', $retree) }\nsub p5special_variable__S_094ColonColonCur_Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_094ColonColonCur_Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\:\\:\\{\\ \\}\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_094ColonColonCur_Ly\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\:\\:\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\{\")\n}))) { ($C) } else { () }\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5special_variable__S_095DollarCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_095DollarCur_Ly', $retree) }\nsub p5special_variable__S_095DollarCur_Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_095DollarCur_Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\{\\ \\}\";\n$self->_MATCHIFY($S, \"p5special_variable__S_095DollarCur_Ly\", STD::LazyMap::lazymap(sub {\nmy $C=shift;\nif (($C) = ($C->_EXACT(\"\\{\"))\nand ($C) = (scalar(do {\n}, $C))) {\nSTD::LazyMap::lazymap(sub {\nmy $C=shift;\n$C->_EXACT(\"\\}\")\n},\n$C->_SUBSUME(['text'], sub {\nmy $C = shift;\n$C->_BRACKET(sub {\nmy $C=shift;\n$C->_SCANf()\n})\n}))\n} else { () }\n},\n$C->_SUBSUME(['sigil','p5sigil'], sub {\nmy $C = shift;\n$C->p5sigil\n})));\n}\n;\nsub p5special_variable__S_096DollarBra__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_096DollarBra', $retree) }\nsub p5special_variable__S_096DollarBra {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_096DollarBra\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\[\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_096DollarBra\", $C->_EXACT(\"\\$\\[\"));\n}\n;\nsub p5special_variable__S_097DollarKet__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_097DollarKet', $retree) }\nsub p5special_variable__S_097DollarKet {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_097DollarKet\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\]\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_097DollarKet\", $C->_EXACT(\"\\$\\]\"));\n}\n;\nsub p5special_variable__S_098DollarBack__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_098DollarBack', $retree) }\nsub p5special_variable__S_098DollarBack {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_098DollarBack\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\\\\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_098DollarBack\", $C->_EXACT(\"\\$\\\\\"));\n}\n;\nsub p5special_variable__S_099DollarVert__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_099DollarVert', $retree) }\nsub p5special_variable__S_099DollarVert {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_099DollarVert\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\|\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_099DollarVert\", $C->_EXACT(\"\\$\\|\"));\n}\n;\nsub p5special_variable__S_100DollarColon__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_100DollarColon', $retree) }\nsub p5special_variable__S_100DollarColon {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_100DollarColon\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\:\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_100DollarColon\", $C->_EXACT(\"\\$\\:\"));\n}\n;\nsub p5special_variable__S_101DollarSemi__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_101DollarSemi', $retree) }\nsub p5special_variable__S_101DollarSemi {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_101DollarSemi\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\;\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_101DollarSemi\", $C->_EXACT(\"\\$\\;\"));\n}\n;\nsub p5special_variable__S_102DollarSingle__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_102DollarSingle', $retree) }\nsub p5special_variable__S_102DollarSingle {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_102DollarSingle\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\'\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_102DollarSingle\", $C->_EXACT(\"\\$\\'\"));\n}\n;\nsub p5special_variable__S_103DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_103DollarDouble', $retree) }\nsub p5special_variable__S_103DollarDouble {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_103DollarDouble\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\\"\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_103DollarDouble\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\$\\\"\"))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n(($C) x !!do {\n$::QSIGIL })\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5special_variable__S_104DollarComma__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_104DollarComma', $retree) }\nsub p5special_variable__S_104DollarComma {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_104DollarComma\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\,\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_104DollarComma\", $C->_EXACT(\"\\$\\,\"));\n}\n;\nsub p5special_variable__S_105DollarLt__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_105DollarLt', $retree) }\nsub p5special_variable__S_105DollarLt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_105DollarLt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\<\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_105DollarLt\", $C->_EXACT(\"\\$\\<\"));\n}\n;\nsub p5special_variable__S_106DollarGt__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_106DollarGt', $retree) }\nsub p5special_variable__S_106DollarGt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_106DollarGt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\>\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_106DollarGt\", $C->_EXACT(\"\\$\\>\"));\n}\n;\nsub p5special_variable__S_107DollarDot__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_107DollarDot', $retree) }\nsub p5special_variable__S_107DollarDot {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_107DollarDot\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\.\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_107DollarDot\", $C->_EXACT(\"\\$\\.\"));\n}\n;\nsub p5special_variable__S_108DollarQuestion__PEEK { $_[0]->_AUTOLEXpeek('p5special_variable__S_108DollarQuestion', $retree) }\nsub p5special_variable__S_108DollarQuestion {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5special_variable__S_108DollarQuestion\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\\?\";\n$self->_MATCHIFYr($S, \"p5special_variable__S_108DollarQuestion\", $C->_EXACT(\"\\$\\?\"));\n}\n;\nsub desigilname__PEEK { $_[0]->_AUTOLEXpeek('desigilname', $retree) }\nsub desigilname {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE desigilname\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"desigilname\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'desigilname_0') {\n$C->deb(\"Fate passed to desigilname_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT desigilname_0';    \n}\nelse {\n$x = 'ALTLTM desigilname_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'desigilname_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"desigilname_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\$\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_SUBSUMEr(['variable'], sub {\nmy $C = shift;\n$C->variable\n}))) {\nscalar(do {\nmy $M = $C;\n$::VAR = $M->{'variable'} }, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['longname'], sub {\nmy $C = shift;\n$C->longname\n})\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub variable__PEEK { $_[0]->_AUTOLEXpeek('variable', $retree) }\nsub variable {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::IN_META = 0;my $sigil = '';my $name;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE variable\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"variable\", do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['sigil','p5sigil'], sub {\nmy $C = shift;\n$C->p5sigil\n}))) {\nscalar(do {\nmy $M = $C;\n$sigil = $M->{'sigil'}->Str}, $C)\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\&\"))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_0') {\n$C->deb(\"Fate passed to variable_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT variable_0';    \n}\nelse {\n$x = 'ALTLTM variable_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'variable_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"variable_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['sublongname'], sub {\nmy $C = shift;\n$C->sublongname\n}))) {\nscalar(do {\nmy $M = $C;\n$name = $M->{'sublongname'}->Str }, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\]\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\[\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['infixish'], sub {\nmy $C = shift;\n$C->infixish(1)\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\]\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'infix noun', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_1') {\n$C->deb(\"Fate passed to variable_1: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT variable_1';    \n}\nelse {\n$x = 'ALTLTM variable_1'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'variable_1', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"variable_1 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['sigil','p5sigil'], sub {\nmy $C = shift;\n$C->p5sigil\n}))\nand ($C) = ($C->_SUBSUMEr(['desigilname'], sub {\nmy $C = shift;\n$C->desigilname\n}))) {\nscalar(do {\nmy $M = $C;\n$name = $M->{'desigilname'}->Str }, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['special_variable','p5special_variable'], sub {\nmy $C = shift;\n$C->p5special_variable\n})\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['sigil','p5sigil'], sub {\nmy $C = shift;\n$C->p5sigil\n}))) {\n$C->_SUBSUMEr(['index'], sub {\nmy $C = shift;\n$C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\d++/)\n})\n})\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['sigil','p5sigil'], sub {\nmy $C = shift;\n$C->p5sigil\n}))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = (do {\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_2') {\n$C->deb(\"Fate passed to variable_2: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT variable_2';    \n}\nelse {\n$x = 'ALTLTM variable_2'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'variable_2', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"variable_2 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\<\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\(\")\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n\n})) { ($C) } else { () }\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['postcircumfix','p5postcircumfix'], sub {\nmy $C = shift;\n$C->p5postcircumfix\n})\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['sigil','p5sigil'], sub {\nmy $C = shift;\n$C->p5sigil\n}))\nand ($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n$::IN_DECL })\n}))) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C\n}))) {\nscalar(do {\n{\nif ($::QSIGIL) {\nreturn ()}\nelse {\n$C->panic(\"Anonymous variable requires declarator\")}}}, $C)\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5sigil__S_109Dollar__PEEK { $_[0]->_AUTOLEXpeek('p5sigil__S_109Dollar', $retree) }\nsub p5sigil__S_109Dollar {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5sigil__S_109Dollar\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\";\n$self->_MATCHIFYr($S, \"p5sigil__S_109Dollar\", $C->_EXACT(\"\\$\"));\n}\n;\nsub p5sigil__S_110At__PEEK { $_[0]->_AUTOLEXpeek('p5sigil__S_110At', $retree) }\nsub p5sigil__S_110At {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5sigil__S_110At\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\@\";\n$self->_MATCHIFYr($S, \"p5sigil__S_110At\", $C->_EXACT(\"\\@\"));\n}\n;\nsub p5sigil__S_111Percent__PEEK { $_[0]->_AUTOLEXpeek('p5sigil__S_111Percent', $retree) }\nsub p5sigil__S_111Percent {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5sigil__S_111Percent\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\%\";\n$self->_MATCHIFYr($S, \"p5sigil__S_111Percent\", $C->_EXACT(\"\\%\"));\n}\n;\nsub p5sigil__S_112Amp__PEEK { $_[0]->_AUTOLEXpeek('p5sigil__S_112Amp', $retree) }\nsub p5sigil__S_112Amp {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5sigil__S_112Amp\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\&\";\n$self->_MATCHIFYr($S, \"p5sigil__S_112Amp\", $C->_EXACT(\"\\&\"));\n}\n;\nsub deflongname__PEEK { $_[0]->_AUTOLEXpeek('deflongname', $retree) }\nsub deflongname {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE deflongname\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'colonpair'} = [];\n$self->_MATCHIFYr($S, \"deflongname\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['name'], sub {\nmy $C = shift;\n$C->name\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'deflongname_0') {\n$C->deb(\"Fate passed to deflongname_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT deflongname_0';    \n}\nelse {\n$x = 'ALTLTM deflongname_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'deflongname_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"deflongname_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_PLUSr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['colonpair'], sub {\nmy $C = shift;\n$C->colonpair\n})\n}))) {\nscalar(do {\nmy $M = $C;\n$C->add_macro($M->{'name'}) if $::IN_DECL}, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\nscalar(do {\nmy $M = $C;\n$C->add_routine($M->{'name'}->Str) if $::IN_DECL}, $C)\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub longname__PEEK { $_[0]->_AUTOLEXpeek('longname', $retree) }\nsub longname {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE longname\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'colonpair'} = [];\n$self->_MATCHIFYr($S, \"longname\", do {\nif (my ($C) = ($C->_SUBSUMEr(['name'], sub {\nmy $C = shift;\n$C->name\n}))) {\n$C->_STARr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['colonpair'], sub {\nmy $C = shift;\n$C->colonpair\n})\n})\n} else { () }\n\n});\n}\n;\nsub name__PEEK { $_[0]->_AUTOLEXpeek('name', $retree) }\nsub name {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE name\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'morename'} = [];\n$self->_MATCHIFYr($S, \"name\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'name_0') {\n$C->deb(\"Fate passed to name_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT name_0';    \n}\nelse {\n$x = 'ALTLTM name_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'name_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"name_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {\nmy $C = shift;\n$C->identifier\n}))) {\n$C->_STARr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['morename'], sub {\nmy $C = shift;\n$C->morename\n})\n})\n} else { () }\n},\nsub {\nmy $C=shift;\n$C->_PLUSr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['morename'], sub {\nmy $C = shift;\n$C->morename\n})\n})\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub morename__PEEK { $_[0]->_AUTOLEXpeek('morename', $retree) }\nsub morename {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::QSIGIL = '';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE morename\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'EXPR'} = [];\n$C->{'identifier'} = [];\n$self->_MATCHIFYr($S, \"morename\", do {\nif (my ($C) = ($C->_EXACT(\"\\:\\:\"))) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = (do {\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_0') {\n$C->deb(\"Fate passed to morename_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT morename_0';    \n}\nelse {\n$x = 'ALTLTM morename_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'morename_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"morename_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\(\")\n},\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[_[:alpha:]]/)\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n\n})) { ($C) } else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_1') {\n$C->deb(\"Fate passed to morename_1: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT morename_1';    \n}\nelse {\n$x = 'ALTLTM morename_1'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'morename_1', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"morename_1 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['identifier'], sub {\nmy $C = shift;\n$C->identifier\n})\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\)\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\)\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'indirect name', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n})\n} else { () }\n\n});\n}\n;\nsub subshortname__PEEK { $_[0]->_AUTOLEXpeek('subshortname', $retree) }\nsub subshortname {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE subshortname\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'colonpair'} = [];\n$self->_MATCHIFYr($S, \"subshortname\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'subshortname_0') {\n$C->deb(\"Fate passed to subshortname_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT subshortname_0';    \n}\nelse {\n$x = 'ALTLTM subshortname_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'subshortname_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"subshortname_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['category'], sub {\nmy $C = shift;\n$C->category\n}))) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_PLUSr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['colonpair'], sub {\nmy $C = shift;\n$C->colonpair\n})\n}))) {\nscalar(do {\nmy $M = $C;\n$C->add_macro($M->{'category'}) if $::IN_DECL}, $C)\n} else { () }\n}))) { ($C) } else { () }\n})\n} else { () }\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['desigilname'], sub {\nmy $C = shift;\n$C->desigilname\n})\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub sublongname__PEEK { $_[0]->_AUTOLEXpeek('sublongname', $retree) }\nsub sublongname {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE sublongname\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'sigterm'} = [];\n$self->_MATCHIFYr($S, \"sublongname\", do {\nif (my ($C) = ($C->_SUBSUMEr(['subshortname'], sub {\nmy $C = shift;\n$C->subshortname\n}))) {\n$C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['sigterm'], sub {\nmy $C = shift;\n$C->sigterm\n})\n})\n} else { () }\n\n});\n}\n;\nsub p5value__S_113quote__PEEK { $_[0]->_AUTOLEXpeek('p5value__S_113quote', $retree) }\nsub p5value__S_113quote {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5value__S_113quote\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"quote\";\n$self->_MATCHIFYr($S, \"p5value__S_113quote\", $C->_SUBSUMEr(['quote','p5quote'], sub {\nmy $C = shift;\n$C->p5quote\n}));\n}\n;\nsub p5value__S_114number__PEEK { $_[0]->_AUTOLEXpeek('p5value__S_114number', $retree) }\nsub p5value__S_114number {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5value__S_114number\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"number\";\n$self->_MATCHIFYr($S, \"p5value__S_114number\", $C->_SUBSUMEr(['number','p5number'], sub {\nmy $C = shift;\n$C->p5number\n}));\n}\n;\nsub p5value__S_115version__PEEK { $_[0]->_AUTOLEXpeek('p5value__S_115version', $retree) }\nsub p5value__S_115version {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5value__S_115version\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"version\";\n$self->_MATCHIFYr($S, \"p5value__S_115version\", $C->_SUBSUMEr(['version','p5version'], sub {\nmy $C = shift;\n$C->p5version\n}));\n}\n;\nsub typename__PEEK { $_[0]->_AUTOLEXpeek('typename', $retree) }\nsub typename {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE typename\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'p5postcircumfix'} = [];\n$C->{'postcircumfix'} = [];\n$C->{'typename'} = [];\n$self->_MATCHIFYr($S, \"typename\", do {\nmy $C = $C;\nif (($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'typename_0') {\n$C->deb(\"Fate passed to typename_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT typename_0';    \n}\nelse {\n$x = 'ALTLTM typename_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'typename_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"typename_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_EXACT(\"\\:\\:\\?\"))) {\n$C->_SUBSUMEr(['identifier'], sub {\nmy $C = shift;\n$C->identifier\n})\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['longname'], sub {\nmy $C = shift;\n$C->longname\n}))\nand ($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\nmy $M = $C;\n{\nmy $longname = $M->{'longname'}->Str;\nif (substr($longname, 0, 2) eq '::') {\n$C->add_my_name(substr($longname, 2))}\nelse {\n$C->is_name($longname)\n};\n}})\n}))) {\n$C\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->unsp)) { ($C) } else { () }\n}))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\[\")\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['postcircumfix','p5postcircumfix'], sub {\nmy $C = shift;\n$C->p5postcircumfix\n})\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_EXACT(\"of\"))\nand ($C) = ($C->ws)) {\n$C->_SUBSUMEr(['typename'], sub {\nmy $C = shift;\n$C->typename\n})\n} else { () }\n}))) { ($C) } else { () }\n})\n} else { () }\n\n});\n}\n;\nsub numish__PEEK { $_[0]->_AUTOLEXpeek('numish', $retree) }\nsub numish {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE numish\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"numish\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'numish_0') {\n$C->deb(\"Fate passed to numish_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT numish_0';    \n}\nelse {\n$x = 'ALTLTM numish_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'numish_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"numish_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['integer'], sub {\nmy $C = shift;\n$C->integer\n})\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['dec_number'], sub {\nmy $C = shift;\n$C->dec_number\n})\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['rad_number'], sub {\nmy $C = shift;\n$C->rad_number\n})\n},\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\GNaN\\b/)\n},\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\GInf\\b/)\n},\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\+Inf\\b/)\n},\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\-Inf\\b/)\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub number__S_116numish__PEEK { $_[0]->_AUTOLEXpeek('number__S_116numish', $retree) }\nsub number__S_116numish {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE number__S_116numish\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"numish\";\n$self->_MATCHIFYr($S, \"number__S_116numish\", $C->_SUBSUMEr(['numish'], sub {\nmy $C = shift;\n$C->numish\n}));\n}\n;\nsub integer__PEEK { $_[0]->_AUTOLEXpeek('integer', $retree) }\nsub integer {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE integer\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"integer\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_0') {\n$C->deb(\"Fate passed to integer_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT integer_0';    \n}\nelse {\n$x = 'ALTLTM integer_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'integer_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"integer_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (($C) = ($C->_EXACT(\"0\"))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_1') {\n$C->deb(\"Fate passed to integer_1: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT integer_1';    \n}\nelse {\n$x = 'ALTLTM integer_1'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'integer_1', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"integer_1 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_PATTERN(qr/\\Gb(?:[01])++/))) {\n$C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_(?:[01])++/)\n}))) { ($C) } else { () }\n})\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_PATTERN(qr/\\Go(?:[0-7])++/))) {\n$C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_(?:[0-7])++/)\n}))) { ($C) } else { () }\n})\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_PATTERN(qr/\\Gx(?:[0-9a-fA-F])++/))) {\n$C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_(?:[0-9a-fA-F])++/)\n}))) { ($C) } else { () }\n})\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_PATTERN(qr/\\Gd\\d++/))) {\n$C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_\\d++/)\n}))) { ($C) } else { () }\n})\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_PATTERN(qr/\\G\\d++/))\nand ($C) = ($C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_\\d++/)\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n(($C) x !!do {\n$C->worry(\"Leading 0 does not indicate octal in Perl 6\") })\n}))) { ($C) } else { () }\n}))) {\n$C\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_PATTERN(qr/\\G\\d++/))) {\n$C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_\\d++/)\n}))) { ($C) } else { () }\n})\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub radint__PEEK { $_[0]->_AUTOLEXpeek('radint', $retree) }\nsub radint {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE radint\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"radint\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'radint_0') {\n$C->deb(\"Fate passed to radint_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT radint_0';    \n}\nelse {\n$x = 'ALTLTM radint_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'radint_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"radint_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['integer'], sub {\nmy $C = shift;\n$C->integer\n})\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\:\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_SUBSUMEr(['rad_number'], sub {\nmy $C = shift;\n$C->rad_number\n}))\nand ($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\nmy $M = $C;\ndefined $M->{'rad_number'}->{'intpart'}\nand\nnot defined $M->{'rad_number'}->{'fracpart'}\n})\n}))) {\n$C\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub escale__PEEK { $_[0]->_AUTOLEXpeek('escale', $retree) }\nsub escale {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE escale\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"escale\", do {\nif (my ($C) = ($C->_PATTERN(qr/\\G[Ee](?:[+\\-])?+\\d++/))) {\n$C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_\\d++/)\n}))) { ($C) } else { () }\n})\n} else { () }\n\n});\n}\n;\nsub dec_number__PEEK { $_[0]->_AUTOLEXpeek('dec_number', $retree) }\nsub dec_number {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE dec_number\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'escale'} = [];\n$self->_MATCHIFYr($S, \"dec_number\", do {\nmy $C = $C;\nif (($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'dec_number_0') {\n$C->deb(\"Fate passed to dec_number_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT dec_number_0';    \n}\nelse {\n$x = 'ALTLTM dec_number_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'dec_number_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"dec_number_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['coeff'], sub {\nmy $C = shift;\n$C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_PATTERN(qr/\\G\\.\\d++/))) {\n$C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_\\d++/)\n}))) { ($C) } else { () }\n})\n} else { () }\n})\n}))) {\n$C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['escale'], sub {\nmy $C = shift;\n$C->escale\n})\n})\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['coeff'], sub {\nmy $C = shift;\n$C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_PATTERN(qr/\\G\\d++/))\nand ($C) = ($C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_\\d++/)\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_PATTERN(qr/\\G\\.\\d++/))) {\n$C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_\\d++/)\n}))) { ($C) } else { () }\n})\n} else { () }\n})\n}))) {\n$C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['escale'], sub {\nmy $C = shift;\n$C->escale\n})\n})\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['coeff'], sub {\nmy $C = shift;\n$C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_PATTERN(qr/\\G\\d++/))) {\n$C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_\\d++/)\n}))) { ($C) } else { () }\n})\n} else { () }\n})\n}))) {\n$C->_SUBSUMEr(['escale'], sub {\nmy $C = shift;\n$C->escale\n})\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_EXACT(\"\\.\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\d/)\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->panic(\"Number contains two decimal points (missing 'v' for version number?)\"))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n})\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub octints__PEEK { $_[0]->_AUTOLEXpeek('octints', $retree) }\nsub octints {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE octints\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'octint'} = [];\n$self->_MATCHIFYr($S, \"octints\", $C->_REPSEPr( sub {\nmy $C=shift;\n$C->_EXACT(\"\\,\")\n}, sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['octint'], sub {\nmy $C = shift;\n$C->octint\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}));\n}\n;\nsub octint__PEEK { $_[0]->_AUTOLEXpeek('octint', $retree) }\nsub octint {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE octint\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"octint\", do {\nif (my ($C) = ($C->_PATTERN(qr/\\G(?:[0-7])++/))) {\n$C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_(?:[0-7])++/)\n}))) { ($C) } else { () }\n})\n} else { () }\n\n});\n}\n;\nsub hexints__PEEK { $_[0]->_AUTOLEXpeek('hexints', $retree) }\nsub hexints {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE hexints\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'hexint'} = [];\n$self->_MATCHIFYr($S, \"hexints\", $C->_REPSEPr( sub {\nmy $C=shift;\n$C->_EXACT(\"\\,\")\n}, sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['hexint'], sub {\nmy $C = shift;\n$C->hexint\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}));\n}\n;\nsub hexint__PEEK { $_[0]->_AUTOLEXpeek('hexint', $retree) }\nsub hexint {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE hexint\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"hexint\", do {\nif (my ($C) = ($C->_PATTERN(qr/\\G(?:[0-9a-fA-F])++/))) {\n$C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G_(?:[0-9a-fA-F])++/)\n}))) { ($C) } else { () }\n})\n} else { () }\n\n});\n}\n;\nour @herestub_queue;\n{ package STD::P5::Herestub;\nuse Moose ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Herestub', 1 };\nour $REGEXES = {\nALL => [ qw// ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\nmoose_has 'delim' => (isa => 'Str', is => 'rw');\nmoose_has 'orignode' => (is => 'rw');\nmoose_has 'lang' => (is => 'rw');\n1; };\n{ package STD::P5::herestop;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::herestop', 1 };\nour $REGEXES = {\nALL => [ qw/stopper/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }\nsub stopper {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE stopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"stopper\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\G(?m:^)/))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['ws'], sub {\nmy $C = shift;\n$C->_PAREN( sub {\nmy $C=shift;\n$C->_STARf(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[\\x20\\t\\r]/)\n})\n\n})\n}))\nand ($C) = ($C->_EXACT($::DELIM))\nand ($C) = ($C->_PATTERN(qr/\\G[\\x20\\t\\r]*+/))) {\nSTD::LazyMap::lazymap(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G(?m:$)\\n?+/)\n},\n$C->_OPTf(sub {\nmy $C=shift;\nif (my ($C) = ($C->unv)) { ($C) } else { () }\n}))\n} else { () }\n\n});\n}\n1; };\nsub heredoc {\nno warnings 'recursion';\nmy $self = shift;\nlocal $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;\nreturn if $self->peek;\nmy $here = $self;\nwhile (my $herestub = shift @herestub_queue) {\nlocal $::DELIM = $herestub->delim;\nmy $lang = $herestub->lang->mixin( 'STD::P5::herestop' );\nmy $doc;\nif (($doc) = $here->nibble($lang)) {\n$here = $doc->trim_heredoc();\n$herestub->orignode->{'doc'} = $doc;\n}\nelse {\n$self->panic(\"Ending delimiter $::DELIM not found\")};\n}\n;\nreturn $self->cursor($here->{'_pos'});\n};\nsub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }\nsub backslash {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE backslash');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'backslash') {\n$C->deb(\"Fate passed to backslash: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT backslash';\n}\nelse {\n$x = 'ALTLTM backslash';\n}\n}\nelse {\n$x = 'ALTLTM backslash';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'backslash:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"backslash trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"backslash\", @gather);\n};\n@result;\n}\n;\nsub escape__PEEK { $_[0]->_AUTOLEXpeek('escape:*',$retree); }\nsub escape {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE escape');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'escape') {\n$C->deb(\"Fate passed to escape: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT escape';\n}\nelse {\n$x = 'ALTLTM escape';\n}\n}\nelse {\n$x = 'ALTLTM escape';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'escape:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"escape trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"escape\", @gather);\n};\n@result;\n}\n;\nsub starter__PEEK { $_[0]->_AUTOLEXpeek('starter', $retree) }\nsub starter {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE starter\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"starter\", $C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}));\n}\n;\nsub escape__S_117none__PEEK { $_[0]->_AUTOLEXpeek('escape__S_117none', $retree) }\nsub escape__S_117none {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE escape__S_117none\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"none\";\n$self->_MATCHIFYr($S, \"escape__S_117none\", $C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}));\n}\n;\nsub babble__PEEK { $_[0]->_AUTOLEXpeek('babble', $retree) }\nsub babble {\nno warnings 'recursion';\nmy $self = shift;\n\ndie 'Required argument l omitted' unless @_;\nmy $l = @_ ? shift() : undef;\nmy $lang = $l;my $start;my $stop;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE babble\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'quotepair'} = [];\n$self->_MATCHIFYr($S, \"babble\", do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['quotepair'], sub {\nmy $C = shift;\n$C->quotepair\n}))\nand ($C) = ($C->ws)) {\nscalar(do {\nmy $M = $C;\nmy $kv = $M->{'quotepair'}->[-1];\n$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})\nor $self->sorry(\"Unrecognized adverb :\" . $kv->{'k'} . '(' . $kv->{'v'} . ')');\n}, $C)\n} else { () }\n}))) { ($C) } else { () }\n}))) {\nscalar(do {\nmy $M = $C;\n($start,$stop) = $C->peek_delimiters();\n$lang = $start ne $stop ? $lang->balanced($start,$stop)\n: $lang->unbalanced($stop);\n$M->{'B'} = [$lang,$start,$stop];\n}, $C)\n} else { () }\n\n});\n}\n;\nsub quibble__PEEK { $_[0]->_AUTOLEXpeek('quibble', $retree) }\nsub quibble {\nno warnings 'recursion';\nmy $self = shift;\n\ndie 'Required argument l omitted' unless @_;\nmy $l = @_ ? shift() : undef;\nmy ($lang, $start, $stop);\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE quibble\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"quibble\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['babble'], sub {\nmy $C = shift;\n$C->babble($l)\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\nmy $B = $M->{'babble'}->{'B'};\n($lang,$start,$stop) = @$B;\n}, $C))\nand ($C) = ($C->_EXACT($start))\nand ($C) = ($C->_SUBSUMEr(['nibble'], sub {\nmy $C = shift;\n$C->nibble($lang)\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Couldn't find terminator $stop\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\nscalar(do {\nmy $M = $C;\n{\nif ($lang->{'_herelang'}) {\npush @herestub_queue,\n'STD::P5::Herestub'->new(\ndelim => $M->{'nibble'}->{'nibbles'}->[0]->{'TEXT'},\norignode => $C,\nlang => $lang->{'_herelang'},\n)}}}, $C)\n} else { () }\n\n});\n}\n;\nsub sibble__PEEK { $_[0]->_AUTOLEXpeek('sibble', $retree) }\nsub sibble {\nno warnings 'recursion';\nmy $self = shift;\n\ndie 'Required argument l omitted' unless @_;\nmy $l = @_ ? shift() : undef;\ndie 'Required argument lang2 omitted' unless @_;\nmy $lang2 = @_ ? shift() : undef;\nmy ($lang, $start, $stop);\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE sibble\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'nibble'} = [];\n$self->_MATCHIFYr($S, \"sibble\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['babble'], sub {\nmy $C = shift;\n$C->babble($l)\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\nmy $B = $M->{'babble'}->{'B'};\n($lang,$start,$stop) = @$B;\n}, $C))\nand ($C) = ($C->_EXACT($start))\nand ($C) = ($C->_SUBSUMEr(['left','nibble'], sub {\nmy $C = shift;\n$C->nibble($lang)\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Couldn't find terminator $stop\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n$start ne $stop })\n}))\nand ($C) = ($C->ws)) {\n$C->_SUBSUMEr(['quibble'], sub {\nmy $C = shift;\n$C->quibble($lang2)\n})\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = (scalar(do {\n$lang = $lang2->unbalanced($stop)}, $C))\nand ($C) = ($C->_SUBSUMEr(['right','nibble'], sub {\nmy $C = shift;\n$C->nibble($lang)\n}))\nand ($C) = ($C->_EXACT($stop))) {\n$C\n} else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub tribble__PEEK { $_[0]->_AUTOLEXpeek('tribble', $retree) }\nsub tribble {\nno warnings 'recursion';\nmy $self = shift;\n\ndie 'Required argument l omitted' unless @_;\nmy $l = @_ ? shift() : undef;\nmy $lang2 = @_ ? shift() : $l;\nmy ($lang, $start, $stop);\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE tribble\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'nibble'} = [];\n$self->_MATCHIFYr($S, \"tribble\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['babble'], sub {\nmy $C = shift;\n$C->babble($l)\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\nmy $B = $M->{'babble'}->{'B'};\n($lang,$start,$stop) = @$B;\n}, $C))\nand ($C) = ($C->_EXACT($start))\nand ($C) = ($C->_SUBSUMEr(['left','nibble'], sub {\nmy $C = shift;\n$C->nibble($lang)\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Couldn't find terminator $stop\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n$start ne $stop })\n}))\nand ($C) = ($C->ws)) {\n$C->_SUBSUMEr(['quibble'], sub {\nmy $C = shift;\n$C->quibble($lang2)\n})\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = (scalar(do {\n$lang = $lang2->unbalanced($stop)}, $C))\nand ($C) = ($C->_SUBSUMEr(['right','nibble'], sub {\nmy $C = shift;\n$C->nibble($lang)\n}))\nand ($C) = ($C->_EXACT($stop))) {\n$C\n} else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub quasiquibble__PEEK { $_[0]->_AUTOLEXpeek('quasiquibble', $retree) }\nsub quasiquibble {\nno warnings 'recursion';\nmy $self = shift;\n\ndie 'Required argument l omitted' unless @_;\nmy $l = @_ ? shift() : undef;\nmy ($lang, $start, $stop);local $::QUASIMODO = 0;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE quasiquibble\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"quasiquibble\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['babble'], sub {\nmy $C = shift;\n$C->babble($l)\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\nmy $B = $M->{'babble'}->{'B'};\n($lang,$start,$stop) = @$B;\n}, $C))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n$start eq '{' })\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nmy $newlang = ($lang);\n$C = bless($C, (ref($newlang) || $newlang));\n$C->_SUBSUMEr(['block'], sub {\nmy $C = shift;\n$C->block\n})\n}))) {\n$C\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->_EXACT($start))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nmy $newlang = ($lang);\n$C = bless($C, (ref($newlang) || $newlang));\n$C->_SUBSUMEr(['statementlist'], sub {\nmy $C = shift;\n$C->statementlist\n})\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Couldn't find terminator $stop\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler', $retree) }\nsub nibbler {\nno warnings 'recursion';\nmy $self = shift;\n\nmy $text = '';my $from = $self->{'_pos'};my $to = $from;my @nibbles = ();my $multiline = 0;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE nibbler\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'escape'} = [];\n$C->{'nibbler'} = [];\n$C->{'starter'} = [];\n$C->{'stopper'} = [];\n$self->_MATCHIFYr($S, \"nibbler\", do {\nmy $C = $C;\nif (($C) = (scalar(do {\nmy $M = $C;\n$M->{'_from'} = $self->{'_pos'}}, $C))\nand ($C) = ($C->_STARr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->{'stopper'} = [];\n$C->_SUBSUMEr(['stopper'], sub {\nmy $C = shift;\n$C->stopper\n})\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['starter'], sub {\nmy $C = shift;\n$C->starter\n}))\nand ($C) = ($C->_SUBSUMEr(['nibbler'], sub {\nmy $C = shift;\n$C->nibbler\n}))\nand ($C) = ($C->_SUBSUMEr(['stopper'], sub {\nmy $C = shift;\n$C->stopper\n}))) {\nscalar(do {\nmy $M = $C;\n{\npush @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to;\nmy $n = $M->{'nibbler'}->[-1]->{'nibbles'};\nmy @n = @$n;\npush @nibbles, $M->{'starter'};\npush @nibbles, @n;\npush @nibbles, $M->{'stopper'};\n$text = '';\n$to = $from = $C->{'_pos'};\n}}, $C)\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->_SUBSUMEr(['escape'], sub {\nmy $C = shift;\n$C->escape\n}))) {\nscalar(do {\nmy $M = $C;\n{\npush @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to;\npush @nibbles, $M->{'escape'}->[-1];\n$text = '';\n$to = $from = $C->{'_pos'};\n}}, $C)\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->cursor_incr())) {\nscalar(do {\n{\nmy $ch = substr($::ORIG, $C->{'_pos'}-1, 1);\n$text .= $ch;\n$to = $C->{'_pos'};\nif ($ch =~ \"\\n\") {\n$multiline++};\n}}, $C)\n} else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}))) {\nscalar(do {\nmy $M = $C;\n{\npush @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to or !@nibbles;\n$M->{'nibbles'} = \\@nibbles;\n$M->{'_pos'} = $C->{'_pos'};\ndelete $M->{'nibbler'};\ndelete $M->{'escape'};\ndelete $M->{'starter'};\ndelete $M->{'stopper'};\n$::LAST_NIBBLE = $C;\n$::LAST_NIBBLE_MULTILINE = $C if $multiline;\n}}, $C)\n} else { () }\n\n});\n}\n;\nsub nibble {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument lang omitted' unless @_;\nmy $lang = @_ ? shift() : undef;\n$self->cursor_fresh($lang)->nibbler};\nsub p5quote__S_118Single_Single__PEEK { $_[0]->_AUTOLEXpeek('p5quote__S_118Single_Single', $retree) }\nsub p5quote__S_118Single_Single {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5quote__S_118Single_Single\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\'\\ \\'\";\n$self->_MATCHIFYr($S, \"p5quote__S_118Single_Single\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\'\"))\nand ($C) = ($C->_SUBSUMEr(['nibble'], sub {\nmy $C = shift;\n$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->unbalanced(\"'\"))\n}))) {\n$C->_EXACT(\"\\'\")\n} else { () }\n\n});\n}\n;\nsub p5quote__S_119Double_Double__PEEK { $_[0]->_AUTOLEXpeek('p5quote__S_119Double_Double', $retree) }\nsub p5quote__S_119Double_Double {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5quote__S_119Double_Double\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\\"\\ \\\"\";\n$self->_MATCHIFYr($S, \"p5quote__S_119Double_Double\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\\"\"))\nand ($C) = ($C->_SUBSUMEr(['nibble'], sub {\nmy $C = shift;\n$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->unbalanced('\"'))\n}))) {\n$C->_EXACT(\"\\\"\")\n} else { () }\n\n});\n}\n;\nsub p5circumfix__S_120Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('p5circumfix__S_120Lt_Gt', $retree) }\nsub p5circumfix__S_120Lt_Gt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5circumfix__S_120Lt_Gt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\<\\ \\>\";\n$self->_MATCHIFYr($S, \"p5circumfix__S_120Lt_Gt\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\<\"))\nand ($C) = ($C->_SUBSUMEr(['nibble'], sub {\nmy $C = shift;\n$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('w' => 1)->balanced('<','>'))\n}))) {\n$C->_EXACT(\"\\>\")\n} else { () }\n\n});\n}\n;\nsub p5quote__S_121Slash_Slash__PEEK { $_[0]->_AUTOLEXpeek('p5quote__S_121Slash_Slash', $retree) }\nsub p5quote__S_121Slash_Slash {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5quote__S_121Slash_Slash\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'p5rx_mods'} = [];\n$C->{sym} = \"\\/\\ \\/\";\n$self->_MATCHIFYr($S, \"p5quote__S_121Slash_Slash\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\/\"))\nand ($C) = ($C->_SUBSUMEr(['nibble'], sub {\nmy $C = shift;\n$C->nibble( $C->cursor_fresh( $::LANG{'Regex'} )->unbalanced(\"/\") )\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\/\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Unable to parse regex; couldn't find final '/'\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['p5rx_mods'], sub {\nmy $C = shift;\n$C->p5rx_mods\n})\n})\n} else { () }\n\n});\n}\n;\nsub quote__S_122qq__PEEK { $_[0]->_AUTOLEXpeek('quote__S_122qq', $retree) }\nsub quote__S_122qq {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE quote__S_122qq\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"qq\";\n$self->_MATCHIFYr($S, \"quote__S_122qq\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"qq\"))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_PATTERN(qr/\\G\\b/))\nand ($C) = ($C->ws)) {\n$C->_SUBSUMEr(['quibble'], sub {\nmy $C = shift;\n$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))\n})\n} else { () }\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub quote__S_123q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_123q', $retree) }\nsub quote__S_123q {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE quote__S_123q\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"q\";\n$self->_MATCHIFYr($S, \"quote__S_123q\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"q\"))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_PATTERN(qr/\\G\\b/))\nand ($C) = ($C->ws)) {\n$C->_SUBSUMEr(['quibble'], sub {\nmy $C = shift;\n$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))\n})\n} else { () }\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub quote__S_124qr__PEEK { $_[0]->_AUTOLEXpeek('quote__S_124qr', $retree) }\nsub quote__S_124qr {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE quote__S_124qr\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"qr\";\n$self->_MATCHIFYr($S, \"quote__S_124qr\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Gqr\\b/))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\(\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_SUBSUMEr(['quibble'], sub {\nmy $C = shift;\n$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )\n}))) {\n$C->_SUBSUMEr(['p5rx_mods'], sub {\nmy $C = shift;\n$C->p5rx_mods\n})\n} else { () }\n\n});\n}\n;\nsub quote__S_125m__PEEK { $_[0]->_AUTOLEXpeek('quote__S_125m', $retree) }\nsub quote__S_125m {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE quote__S_125m\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"m\";\n$self->_MATCHIFYr($S, \"quote__S_125m\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Gm\\b/))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\(\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_SUBSUMEr(['quibble'], sub {\nmy $C = shift;\n$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )\n}))) {\n$C->_SUBSUMEr(['p5rx_mods'], sub {\nmy $C = shift;\n$C->p5rx_mods\n})\n} else { () }\n\n});\n}\n;\nsub quote__S_126s__PEEK { $_[0]->_AUTOLEXpeek('quote__S_126s', $retree) }\nsub quote__S_126s {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE quote__S_126s\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"s\";\n$self->_MATCHIFYr($S, \"quote__S_126s\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Gs\\b/))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\(\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_SUBSUMEr(['pat','sibble'], sub {\nmy $C = shift;\n$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} ), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))\n}))) {\n$C->_SUBSUMEr(['p5rx_mods'], sub {\nmy $C = shift;\n$C->p5rx_mods\n})\n} else { () }\n\n});\n}\n;\nsub quote__S_127tr__PEEK { $_[0]->_AUTOLEXpeek('quote__S_127tr', $retree) }\nsub quote__S_127tr {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE quote__S_127tr\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"tr\";\n$self->_MATCHIFYr($S, \"quote__S_127tr\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Gtr\\b/))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\(\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_SUBSUMEr(['pat','tribble'], sub {\nmy $C = shift;\n$C->tribble( $C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))\n}))) {\n$C->_SUBSUMEr(['p5tr_mods'], sub {\nmy $C = shift;\n$C->p5tr_mods\n})\n} else { () }\n\n});\n}\n;\nsub p5rx_mods__PEEK { $_[0]->_AUTOLEXpeek('p5rx_mods', $retree) }\nsub p5rx_mods {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5rx_mods\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"p5rx_mods\", do {\nif (my ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->after(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G(?<=\\w)/)\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['0'], sub {\nmy $C = shift;\n$C->_PAREN( sub {\nmy $C=shift;\n$C->_PLUSr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_ARRAY( qw< i g s m x c e > ))) { ($C) } else { () }\n})\n\n})\n})\n} else { () }\n\n});\n}\n;\nsub p5tr_mods__PEEK { $_[0]->_AUTOLEXpeek('p5tr_mods', $retree) }\nsub p5tr_mods {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5tr_mods\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"p5tr_mods\", $C->_SUBSUMEr(['0'], sub {\nmy $C = shift;\n$C->_PAREN( sub {\nmy $C=shift;\n$C->_PLUSr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_ARRAY( qw< c d s ] > ))) { ($C) } else { () }\n})\n\n})\n}));\n}\n;\nsub peek_delimiters {\nno warnings 'recursion';\nmy $self = shift;\nmy $pos = $self->{'_pos'};\nmy $startpos = $pos;\nmy $char = substr($::ORIG,$pos++,1);\nif ($char =~ /^\\s$/) {\n$self->panic(\"Whitespace character is not allowed as delimiter\")}\nelsif ($char =~ /^\\w$/) {\n$self->panic(\"Alphanumeric character is not allowed as delimiter\")}\nelsif ($STD::close2open{$char}) {\n$self->panic(\"Use of a closing delimiter for an opener is reserved\")};\nmy $rightbrack = $STD::open2close{$char};\nif (not defined $rightbrack) {\nreturn $char, $char};\nwhile (substr($::ORIG,$pos,1) eq $char) {\n$pos++}\n;\nmy $len = $pos - $startpos;\nmy $start = $char x $len;\nmy $stop = $rightbrack x $len;\nreturn $start, $stop;\n};\n{     package STD::P5::startstop;\nrequire \"mangle.pl\";\nour %INSTANTIATED;\nsub __instantiate__ { my $self = shift;\nmy ($start, $stop) = @_;\nmy $mangle = ::mangle($start, $stop);\nmy $mixin = \"STD::P5::startstop::\" . $mangle;\nreturn $mixin if $INSTANTIATED{$mixin}++;\n::deb(\"         instantiating $mixin\") if $::DEBUG & DEBUG::mixins;\nmy $eval = \"package $mixin\" . q{;\n\t    sub _PARAMS { { '$start' => $start, '$stop' => $stop } }\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::startstop', 1 };\nour $REGEXES = {\nALL => [ qw/starter stopper/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; # suppress used-once warning\n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\n---\nstarter: !!perl/hash:RE_ast\n  dba: starter\n  dic: STD::P5::startstop\n  re: !!perl/hash:RE_var\n    var: $start\nstopper: !!perl/hash:RE_ast\n  dba: stopper\n  dic: STD::P5::startstop\n  re: !!perl/hash:RE_var\n    var: $stop\nRETREE_END\n## token starter { $start }\nsub starter__PEEK { $_[0]->_AUTOLEXpeek('starter', $retree) }\nsub starter {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE starter\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"starter\", $C->_EXACT($start));\n}\n;\n## token stopper { $stop }\nsub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }\nsub stopper {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE stopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"stopper\", $C->_EXACT($stop));\n}\n;\n\t};\n\teval $eval;\n\tdie $@ if $@;\n\treturn $mixin;\n}\n1; };\n{     package STD::P5::stop;\nrequire \"mangle.pl\";\nour %INSTANTIATED;\nsub __instantiate__ { my $self = shift;\nmy ($stop) = @_;\nmy $mangle = ::mangle($stop);\nmy $mixin = \"STD::P5::stop::\" . $mangle;\nreturn $mixin if $INSTANTIATED{$mixin}++;\n::deb(\"         instantiating $mixin\") if $::DEBUG & DEBUG::mixins;\nmy $eval = \"package $mixin\" . q{;\n\t    sub _PARAMS { { '$stop' => $stop } }\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::stop', 1 };\nour $REGEXES = {\nALL => [ qw/starter stopper/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; # suppress used-once warning\n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\n---\nstarter: !!perl/hash:RE_ast\n  dba: starter\n  dic: STD::P5::stop\n  re: !!perl/hash:RE_assertion\n    assert: '!'\n    re: !!perl/hash:RE_noop\n      nobind: 1\nstopper: !!perl/hash:RE_ast\n  dba: stopper\n  dic: STD::P5::stop\n  re: !!perl/hash:RE_var\n    var: $stop\nRETREE_END\n## token starter { <!> }\nsub starter__PEEK { $_[0]->_AUTOLEXpeek('starter', $retree) }\nsub starter {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE starter\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"starter\", $C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}));\n}\n;\n## token stopper { $stop }\nsub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }\nsub stopper {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE stopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"stopper\", $C->_EXACT($stop));\n}\n;\n\t};\n\teval $eval;\n\tdie $@ if $@;\n\treturn $mixin;\n}\n1; };\n{     package STD::P5::unitstop;\nrequire \"mangle.pl\";\nour %INSTANTIATED;\nsub __instantiate__ { my $self = shift;\nmy ($stop) = @_;\nmy $mangle = ::mangle($stop);\nmy $mixin = \"STD::P5::unitstop::\" . $mangle;\nreturn $mixin if $INSTANTIATED{$mixin}++;\n::deb(\"         instantiating $mixin\") if $::DEBUG & DEBUG::mixins;\nmy $eval = \"package $mixin\" . q{;\n\t    sub _PARAMS { { '$stop' => $stop } }\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::unitstop', 1 };\nour $REGEXES = {\nALL => [ qw/unitstopper/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; # suppress used-once warning\n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\n---\nunitstopper: !!perl/hash:RE_ast\n  dba: unitstopper\n  dic: STD::P5::unitstop\n  re: !!perl/hash:RE_var\n    var: $stop\nRETREE_END\n## token unitstopper { $stop }\nsub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper', $retree) }\nsub unitstopper {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE unitstopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"unitstopper\", $C->_EXACT($stop));\n}\n\t};\n\teval $eval;\n\tdie $@ if $@;\n\treturn $mixin;\n}\n1; };\nsub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper', $retree) }\nsub unitstopper {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE unitstopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"unitstopper\", $C->_PATTERN(qr/\\G\\z/));\n}\n;\nsub balanced {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument start omitted' unless @_;\nmy $start = @_ ? shift() : undef;\ndie 'Required argument stop omitted' unless @_;\nmy $stop = @_ ? shift() : undef;\n$self->mixin( STD::P5::startstop->__instantiate__($start,$stop) )};\nsub unbalanced {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument stop omitted' unless @_;\nmy $stop = @_ ? shift() : undef;\n$self->mixin( STD::P5::stop->__instantiate__($stop) )};\nsub unitstop {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument stop omitted' unless @_;\nmy $stop = @_ ? shift() : undef;\n$self->mixin( STD::P5::unitstop->__instantiate__($stop) )};\nsub charname__PEEK { $_[0]->_AUTOLEXpeek('charname', $retree) }\nsub charname {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE charname\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"charname\", do {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'charname_0') {\n$C->deb(\"Fate passed to charname_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT charname_0';    \n}\nelse {\n$x = 'ALTLTM charname_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'charname_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"charname_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['radint'], sub {\nmy $C = shift;\n$C->radint\n})\n},\nsub {\nmy $C=shift;\nif (my ($C) = (do {\nif (my ($C) = ($C->_PATTERN(qr/\\G[a-zA-Z]/))) {\nSTD::LazyMap::lazymap(sub {\nmy $C=shift;\nif (($C) = ($C->_PATTERN(qr/\\G[a-zA-Z)]/))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\s*+[\\],\\#]/)\n}))) { ($C) } else { () }\n}))) {\n$C\n} else { () }\n},\n$C->_STARf(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[^\\],\\#]/)\n}))\n} else { () }\n\n})) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Unrecognized character name\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n});\n}\n;\nsub charnames__PEEK { $_[0]->_AUTOLEXpeek('charnames', $retree) }\nsub charnames {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE charnames\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'charname'} = [];\n$self->_MATCHIFYr($S, \"charnames\", $C->_REPSEPr( sub {\nmy $C=shift;\n$C->_EXACT(\"\\,\")\n}, sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['charname'], sub {\nmy $C = shift;\n$C->charname\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}));\n}\n;\nsub charspec__PEEK { $_[0]->_AUTOLEXpeek('charspec', $retree) }\nsub charspec {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE charspec\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"charspec\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'charspec_0') {\n$C->deb(\"Fate passed to charspec_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT charspec_0';    \n}\nelse {\n$x = 'ALTLTM charspec_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'charspec_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"charspec_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\]\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\[\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['charnames'], sub {\nmy $C = shift;\n$C->charnames\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\]\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'character name', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\d++/)\n},\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[?-Z\\\\-_]/)\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\n$C\n}))\nand ($C) = ($C->panic(\"Unrecognized \\\\c character\"))) {\n$C\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub truly {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument bool omitted' unless @_;\nmy $bool = @_ ? shift() : undef;\ndie 'Required argument opt omitted' unless @_;\nmy $opt = @_ ? shift() : undef;\nreturn $self if $bool;\n$self->panic(\"Can't negate $opt adverb\");\n};\n{ package STD::P5::Q;\nuse Moose ':all' => { -prefix => \"moose_\" };\nuse Encode;\nmoose_extends('STD');\nour $ALLROLES = { 'STD::P5::Q', 1 };\nour $REGEXES = {\nALL => [ qw// ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n{ package STD::P5::Q::b1;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::b1', 1 };\nour $REGEXES = {\nALL => [ qw/p5backslash p5escape/ ],\np5backslash => [ qw/p5backslash__S_001qq__PEEK p5backslash__S_002Back__PEEK p5backslash__S_003stopper__PEEK p5backslash__S_004a__PEEK p5backslash__S_005b__PEEK p5backslash__S_006c__PEEK p5backslash__S_007e__PEEK p5backslash__S_008f__PEEK p5backslash__S_009n__PEEK p5backslash__S_010o__PEEK p5backslash__S_011r__PEEK p5backslash__S_012t__PEEK p5backslash__S_013x__PEEK p5backslash__S_0140__PEEK/ ],\np5escape => [ qw/p5escape__S_000Back__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub p5escape__S_000Back__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000Back', $retree) }\nsub p5escape__S_000Back {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000Back\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\\\\";\n$self->_MATCHIFYr($S, \"p5escape__S_000Back\", do {\nif (my ($C) = ($C->_EXACT(\"\\\\\"))) {\n$C->_SUBSUMEr(['item','p5backslash'], sub {\nmy $C = shift;\n$C->p5backslash\n})\n} else { () }\n\n});\n}\n;\nsub p5backslash__S_001qq__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_001qq', $retree) }\nsub p5backslash__S_001qq {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_001qq\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"qq\";\n$self->_MATCHIFYr($S, \"p5backslash__S_001qq\", do {\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"q\")\n}))) { ($C) } else { () }\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote()}, $C)\n} else { () }\n\n});\n}\n;\nsub p5backslash__S_002Back__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_002Back', $retree) }\nsub p5backslash__S_002Back {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_002Back\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\\\\";\n$self->_MATCHIFYr($S, \"p5backslash__S_002Back\", $C->_SUBSUMEr(['text'], sub {\nmy $C = shift;\n$C->_EXACT(\"\\\\\")\n}));\n}\n;\nsub p5backslash__S_003stopper__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_003stopper', $retree) }\nsub p5backslash__S_003stopper {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_003stopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"stopper\";\n$self->_MATCHIFYr($S, \"p5backslash__S_003stopper\", $C->_SUBSUMEr(['text','stopper'], sub {\nmy $C = shift;\n$C->stopper\n}));\n}\n;\nsub p5backslash__S_004a__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_004a', $retree) }\nsub p5backslash__S_004a {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_004a\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"a\";\n$self->_MATCHIFYr($S, \"p5backslash__S_004a\", $C->_EXACT(\"a\"));\n}\n;\nsub p5backslash__S_005b__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_005b', $retree) }\nsub p5backslash__S_005b {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_005b\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"b\";\n$self->_MATCHIFYr($S, \"p5backslash__S_005b\", $C->_EXACT(\"b\"));\n}\n;\nsub p5backslash__S_006c__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_006c', $retree) }\nsub p5backslash__S_006c {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_006c\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"c\";\n$self->_MATCHIFYr($S, \"p5backslash__S_006c\", do {\nif (my ($C) = ($C->_EXACT(\"c\"))) {\n$C->_SUBSUMEr(['charspec'], sub {\nmy $C = shift;\n$C->charspec\n})\n} else { () }\n\n});\n}\n;\nsub p5backslash__S_007e__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_007e', $retree) }\nsub p5backslash__S_007e {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_007e\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"e\";\n$self->_MATCHIFYr($S, \"p5backslash__S_007e\", $C->_EXACT(\"e\"));\n}\n;\nsub p5backslash__S_008f__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_008f', $retree) }\nsub p5backslash__S_008f {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_008f\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"f\";\n$self->_MATCHIFYr($S, \"p5backslash__S_008f\", $C->_EXACT(\"f\"));\n}\n;\nsub p5backslash__S_009n__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_009n', $retree) }\nsub p5backslash__S_009n {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_009n\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"n\";\n$self->_MATCHIFYr($S, \"p5backslash__S_009n\", $C->_EXACT(\"n\"));\n}\n;\nsub p5backslash__S_010o__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_010o', $retree) }\nsub p5backslash__S_010o {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_010o\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"o\";\n$self->_MATCHIFYr($S, \"p5backslash__S_010o\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"o\"))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5backslash__S_010o_0') {\n$C->deb(\"Fate passed to p5backslash__S_010o_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5backslash__S_010o_0';    \n}\nelse {\n$x = 'ALTLTM p5backslash__S_010o_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Q::b1', 'p5backslash__S_010o_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5backslash__S_010o_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['octint'], sub {\nmy $C = shift;\n$C->octint\n})\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\]\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\[\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['octints'], sub {\nmy $C = shift;\n$C->octints\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\]\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'octal character', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5backslash__S_011r__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_011r', $retree) }\nsub p5backslash__S_011r {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_011r\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"r\";\n$self->_MATCHIFYr($S, \"p5backslash__S_011r\", $C->_EXACT(\"r\"));\n}\n;\nsub p5backslash__S_012t__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_012t', $retree) }\nsub p5backslash__S_012t {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_012t\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"t\";\n$self->_MATCHIFYr($S, \"p5backslash__S_012t\", $C->_EXACT(\"t\"));\n}\n;\nsub p5backslash__S_013x__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_013x', $retree) }\nsub p5backslash__S_013x {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_013x\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"x\";\n$self->_MATCHIFYr($S, \"p5backslash__S_013x\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"x\"))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5backslash__S_013x_0') {\n$C->deb(\"Fate passed to p5backslash__S_013x_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5backslash__S_013x_0';    \n}\nelse {\n$x = 'ALTLTM p5backslash__S_013x_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Q::b1', 'p5backslash__S_013x_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5backslash__S_013x_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['hexint'], sub {\nmy $C = shift;\n$C->hexint\n})\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\]\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\[\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['hexints'], sub {\nmy $C = shift;\n$C->hexints\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\]\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'hex character', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5backslash__S_0140__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_0140', $retree) }\nsub p5backslash__S_0140 {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_0140\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"p5backslash__S_0140\", $C->_EXACT(\"0\"));\n}\n;\n1; };\n{ package STD::P5::Q::b0;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::b0', 1 };\nour $REGEXES = {\nALL => [ qw/p5escape/ ],\np5escape => [ qw/p5escape__S_000Back__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub p5escape__S_000Back__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000Back', $retree) }\nsub p5escape__S_000Back {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000Back\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\\\\";\n$self->_MATCHIFYr($S, \"p5escape__S_000Back\", $C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}));\n}\n1; };\n{ package STD::P5::Q::c1;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::c1', 1 };\nour $REGEXES = {\nALL => [ qw/p5escape/ ],\np5escape => [ qw/p5escape__S_000Cur_Ly__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub p5escape__S_000Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000Cur_Ly', $retree) }\nsub p5escape__S_000Cur_Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000Cur_Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\{\\ \\}\";\n$self->_MATCHIFYr($S, \"p5escape__S_000Cur_Ly\", do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\{\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nmy $newlang = ($::LANG{'MAIN'});\n$C = bless($C, (ref($newlang) || $newlang));\n$C->_SUBSUMEr(['block'], sub {\nmy $C = shift;\n$C->block\n})\n}))) {\n$C\n} else { () }\n\n});\n}\n1; };\n{ package STD::P5::Q::c0;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::c0', 1 };\nour $REGEXES = {\nALL => [ qw/p5escape/ ],\np5escape => [ qw/p5escape__S_000Cur_Ly__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub p5escape__S_000Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000Cur_Ly', $retree) }\nsub p5escape__S_000Cur_Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000Cur_Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\{\\ \\}\";\n$self->_MATCHIFYr($S, \"p5escape__S_000Cur_Ly\", $C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}));\n}\n1; };\n{ package STD::P5::Q::s1;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::s1', 1 };\nour $REGEXES = {\nALL => [ qw/p5escape/ ],\np5escape => [ qw/p5escape__S_000Dollar__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub p5escape__S_000Dollar__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000Dollar', $retree) }\nsub p5escape__S_000Dollar {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::QSIGIL = '$';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000Dollar\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\";\n$self->_MATCHIFYr($S, \"p5escape__S_000Dollar\", do {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\$\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nmy $newlang = ($::LANG{'MAIN'});\n$C = bless($C, (ref($newlang) || $newlang));\n$C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR(\\%methodcall)\n})\n}))) {\n$C\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Non-variable \\$ must be backslashed\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n});\n}\n1; };\n{ package STD::P5::Q::s0;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::s0', 1 };\nour $REGEXES = {\nALL => [ qw/p5escape/ ],\np5escape => [ qw/p5escape__S_000Dollar__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub p5escape__S_000Dollar__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000Dollar', $retree) }\nsub p5escape__S_000Dollar {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000Dollar\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\";\n$self->_MATCHIFYr($S, \"p5escape__S_000Dollar\", $C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}));\n}\n1; };\n{ package STD::P5::Q::a1;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::a1', 1 };\nour $REGEXES = {\nALL => [ qw/p5escape/ ],\np5escape => [ qw/p5escape__S_000At__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub p5escape__S_000At__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000At', $retree) }\nsub p5escape__S_000At {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::QSIGIL = '@';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000At\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\@\";\n$self->_MATCHIFYr($S, \"p5escape__S_000At\", do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\@\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5escape__S_000At_0') {\n$C->deb(\"Fate passed to p5escape__S_000At_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5escape__S_000At_0';    \n}\nelse {\n$x = 'ALTLTM p5escape__S_000At_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Q::a1', 'p5escape__S_000At_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5escape__S_000At_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = (do {\nmy $newlang = ($::LANG{'MAIN'});\n$C = bless($C, (ref($newlang) || $newlang));\n$C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR(\\%methodcall)\n})\n\n})) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n1; };\n{ package STD::P5::Q::a0;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::a0', 1 };\nour $REGEXES = {\nALL => [ qw/p5escape/ ],\np5escape => [ qw/p5escape__S_000At__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub p5escape__S_000At__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000At', $retree) }\nsub p5escape__S_000At {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000At\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\@\";\n$self->_MATCHIFYr($S, \"p5escape__S_000At\", $C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}));\n}\n1; };\n{ package STD::P5::Q::h1;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::h1', 1 };\nour $REGEXES = {\nALL => [ qw/p5escape/ ],\np5escape => [ qw/p5escape__S_000Percent__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub p5escape__S_000Percent__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000Percent', $retree) }\nsub p5escape__S_000Percent {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::QSIGIL = '%';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000Percent\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\%\";\n$self->_MATCHIFYr($S, \"p5escape__S_000Percent\", do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\%\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5escape__S_000Percent_0') {\n$C->deb(\"Fate passed to p5escape__S_000Percent_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5escape__S_000Percent_0';    \n}\nelse {\n$x = 'ALTLTM p5escape__S_000Percent_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Q::h1', 'p5escape__S_000Percent_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5escape__S_000Percent_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = (do {\nmy $newlang = ($::LANG{'MAIN'});\n$C = bless($C, (ref($newlang) || $newlang));\n$C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR(\\%methodcall)\n})\n\n})) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n1; };\n{ package STD::P5::Q::h0;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::h0', 1 };\nour $REGEXES = {\nALL => [ qw/p5escape/ ],\np5escape => [ qw/p5escape__S_000Percent__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub p5escape__S_000Percent__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000Percent', $retree) }\nsub p5escape__S_000Percent {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000Percent\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\%\";\n$self->_MATCHIFYr($S, \"p5escape__S_000Percent\", $C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}));\n}\n1; };\n{ package STD::P5::Q::f1;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::f1', 1 };\nour $REGEXES = {\nALL => [ qw/p5escape/ ],\np5escape => [ qw/p5escape__S_000Amp__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub p5escape__S_000Amp__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000Amp', $retree) }\nsub p5escape__S_000Amp {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::QSIGIL = '&';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000Amp\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\&\";\n$self->_MATCHIFYr($S, \"p5escape__S_000Amp\", do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\&\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5escape__S_000Amp_0') {\n$C->deb(\"Fate passed to p5escape__S_000Amp_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5escape__S_000Amp_0';    \n}\nelse {\n$x = 'ALTLTM p5escape__S_000Amp_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Q::f1', 'p5escape__S_000Amp_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5escape__S_000Amp_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = (do {\nmy $newlang = ($::LANG{'MAIN'});\n$C = bless($C, (ref($newlang) || $newlang));\n$C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR(\\%methodcall)\n})\n\n})) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n1; };\n{ package STD::P5::Q::f0;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::f0', 1 };\nour $REGEXES = {\nALL => [ qw/p5escape/ ],\np5escape => [ qw/p5escape__S_000Amp__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub p5escape__S_000Amp__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000Amp', $retree) }\nsub p5escape__S_000Amp {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000Amp\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\&\";\n$self->_MATCHIFYr($S, \"p5escape__S_000Amp\", $C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}));\n}\n1; };\n{ package STD::P5::Q::w1;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::w1', 1 };\nour $REGEXES = {\nALL => [ qw// ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\nsub postprocess {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument s omitted' unless @_;\nmy $s = @_ ? shift() : undef;\n$s->words }  1; };\n{ package STD::P5::Q::w0;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::w0', 1 };\nour $REGEXES = {\nALL => [ qw// ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\nsub postprocess {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument s omitted' unless @_;\nmy $s = @_ ? shift() : undef;\n$s }  1; };\n{ package STD::P5::Q::ww1;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::ww1', 1 };\nour $REGEXES = {\nALL => [ qw// ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\nsub postprocess {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument s omitted' unless @_;\nmy $s = @_ ? shift() : undef;\n$s->words }  1; };\n{ package STD::P5::Q::ww0;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::ww0', 1 };\nour $REGEXES = {\nALL => [ qw// ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\nsub postprocess {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument s omitted' unless @_;\nmy $s = @_ ? shift() : undef;\n$s }  1; };\n{ package STD::P5::Q::x1;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::x1', 1 };\nour $REGEXES = {\nALL => [ qw// ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\nsub postprocess {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument s omitted' unless @_;\nmy $s = @_ ? shift() : undef;\n$s->run }  1; };\n{ package STD::P5::Q::x0;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::x0', 1 };\nour $REGEXES = {\nALL => [ qw// ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\nsub postprocess {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument s omitted' unless @_;\nmy $s = @_ ? shift() : undef;\n$s }  1; };\n{ package STD::P5::Q::q;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::q', 1 };\nour $REGEXES = {\nALL => [ qw/p5backslash p5escape stopper/ ],\np5backslash => [ qw/p5backslash__S_001qq__PEEK p5backslash__S_002Back__PEEK p5backslash__S_003stopper__PEEK p5backslash__S_004misc__PEEK/ ],\np5escape => [ qw/p5escape__S_000Back__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }\nsub stopper {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE stopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"stopper\", $C->_EXACT(\"\\'\"));\n}\n;\nsub p5escape__S_000Back__PEEK { $_[0]->_AUTOLEXpeek('p5escape__S_000Back', $retree) }\nsub p5escape__S_000Back {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5escape__S_000Back\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\\\\";\n$self->_MATCHIFYr($S, \"p5escape__S_000Back\", do {\nif (my ($C) = ($C->_EXACT(\"\\\\\"))) {\n$C->_SUBSUMEr(['item','p5backslash'], sub {\nmy $C = shift;\n$C->p5backslash\n})\n} else { () }\n\n});\n}\n;\nsub p5backslash__S_001qq__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_001qq', $retree) }\nsub p5backslash__S_001qq {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_001qq\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"qq\";\n$self->_MATCHIFYr($S, \"p5backslash__S_001qq\", do {\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"q\")\n}))) { ($C) } else { () }\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote()}, $C)\n} else { () }\n\n});\n}\n;\nsub p5backslash__S_002Back__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_002Back', $retree) }\nsub p5backslash__S_002Back {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_002Back\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\\\\";\n$self->_MATCHIFYr($S, \"p5backslash__S_002Back\", $C->_SUBSUMEr(['text'], sub {\nmy $C = shift;\n$C->_EXACT(\"\\\\\")\n}));\n}\n;\nsub p5backslash__S_003stopper__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_003stopper', $retree) }\nsub p5backslash__S_003stopper {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_003stopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"stopper\";\n$self->_MATCHIFYr($S, \"p5backslash__S_003stopper\", $C->_SUBSUMEr(['text','stopper'], sub {\nmy $C = shift;\n$C->stopper\n}));\n}\n;\nsub p5backslash__S_004misc__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_004misc', $retree) }\nsub p5backslash__S_004misc {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_004misc\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"misc\";\n$self->_MATCHIFYr($S, \"p5backslash__S_004misc\", do {\nmy $C = $C;\nif (($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['0'], sub {\nmy $C = shift;\n$C->_PAREN( sub {\nmy $C=shift;\n$C->cursor_incr()\n\n})\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'text'} = \"\\\\\" . $M->{0}->Str}, $C)\n} else { () }\n\n});\n}\n;\n;\n;\nmoose_around tweak  => sub {\nmy $orig = shift;\nno warnings 'recursion';\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{single} || exists $args{q};\nmy $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;\n$self->panic(\"Too late for :q\")     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{double} || exists $args{qq};\nmy $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;\n$self->panic(\"Too late for :qq\")     };\n}\n$orig->(@_);\n};\n\n1; };\n{ package STD::P5::Q::qq;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nmoose_with('STD::P5::Q::b1');\nmoose_with('STD::P5::Q::c1');\nmoose_with('STD::P5::Q::s1');\nmoose_with('STD::P5::Q::a1');\nmoose_with('STD::P5::Q::h1');\nmoose_with('STD::P5::Q::f1');\nour $REGEXES = {\nALL => [ qw/p5backslash stopper/ ],\np5backslash => [ qw/p5backslash__S_000misc__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\nsub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }\nsub stopper {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE stopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"stopper\", $C->_EXACT(\"\\\"\"));\n}\n;\nsub p5backslash__S_000misc__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_000misc', $retree) }\nsub p5backslash__S_000misc {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_000misc\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"misc\";\n$self->_MATCHIFYr($S, \"p5backslash__S_000misc\", do {\nmy $C = $C;\nif (($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5backslash__S_000misc_0') {\n$C->deb(\"Fate passed to p5backslash__S_000misc_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5backslash__S_000misc_0';    \n}\nelse {\n$x = 'ALTLTM p5backslash__S_000misc_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Q::qq', 'p5backslash__S_000misc_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5backslash__S_000misc_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['0'], sub {\nmy $C = shift;\n$C->_PAREN( sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\W/)\n\n})\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'text'} = $M->{0}->Str}, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_SUBSUMEr(['x'], sub {\nmy $C = shift;\n$C->_PAREN( sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\w/)\n\n})\n}))\nand ($C) = (do {\nmy $M = $C;\n$C->panic(\"Unrecognized backslash sequence: '\\\\\" . $M->{'x'}->Str . \"'\")\n})) {\n$C\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\n;\n;\nmoose_around tweak  => sub {\nmy $orig = shift;\nno warnings 'recursion';\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{single} || exists $args{q};\nmy $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;\n$self->panic(\"Too late for :q\")     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{double} || exists $args{qq};\nmy $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;\n$self->panic(\"Too late for :qq\")     };\n}\n$orig->(@_);\n};\n\n1; };\n{ package STD::P5::Q::p5;\nuse Moose::Role ':all' => { -prefix => \"moose_\" };\nuse Encode;\nour $ALLROLES = { 'STD::P5::Q::p5', 1 };\nour $REGEXES = {\nALL => [ qw// ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n;\n;\n;\n;\n;\n;\n;\nmoose_around tweak  => sub {\nmy $orig = shift;\nno warnings 'recursion';\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{g};\nmy $g = exists $args{g} ? delete $args{g} : undef;\n$self     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{i};\nmy $i = exists $args{i} ? delete $args{i} : undef;\n$self     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{m};\nmy $m = exists $args{m} ? delete $args{m} : undef;\n$self     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{s};\nmy $s = exists $args{s} ? delete $args{s} : undef;\n$self     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{x};\nmy $x = exists $args{x} ? delete $args{x} : undef;\n$self     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{p};\nmy $p = exists $args{p} ? delete $args{p} : undef;\n$self     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{c};\nmy $c = exists $args{c} ? delete $args{c} : undef;\n$self     };\n}\n$orig->(@_);\n};\n\n1; };\n;\n;\n;\n;\n;\n;\n;\n;\n;\n;\n;\n;\n;\n;\n;\nmoose_around tweak  => sub {\nmy $orig = shift;\nno warnings 'recursion';\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{single} || exists $args{q};\nmy $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;\n$self->truly($q,':q');\n$self->mixin( 'STD::P5::Q::q' );\n};\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{double} || exists $args{qq};\nmy $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;\n$self->truly($qq, ':qq');\n$self->mixin( 'STD::P5::Q::qq' );\n};\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{backslash} || exists $args{b};\nmy $b = exists $args{backslash} ? delete $args{backslash} : exists $args{b} ? delete $args{b} : undef;\n$self->mixin($b ? 'STD::P5::Q::b1' : 'STD::P5::Q::b0')     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{scalar} || exists $args{s};\nmy $s = exists $args{scalar} ? delete $args{scalar} : exists $args{s} ? delete $args{s} : undef;\n$self->mixin($s ? 'STD::P5::Q::s1' : 'STD::P5::Q::s0')     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{array} || exists $args{a};\nmy $a = exists $args{array} ? delete $args{array} : exists $args{a} ? delete $args{a} : undef;\n$self->mixin($a ? 'STD::P5::Q::a1' : 'STD::P5::Q::a0')     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{hash} || exists $args{h};\nmy $h = exists $args{hash} ? delete $args{hash} : exists $args{h} ? delete $args{h} : undef;\n$self->mixin($h ? 'STD::P5::Q::h1' : 'STD::P5::Q::h0')     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{function} || exists $args{f};\nmy $f = exists $args{function} ? delete $args{function} : exists $args{f} ? delete $args{f} : undef;\n$self->mixin($f ? 'STD::P5::Q::f1' : 'STD::P5::Q::f0')     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{closure} || exists $args{c};\nmy $c = exists $args{closure} ? delete $args{closure} : exists $args{c} ? delete $args{c} : undef;\n$self->mixin($c ? 'STD::P5::Q::c1' : 'STD::P5::Q::c0')     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{exec} || exists $args{x};\nmy $x = exists $args{exec} ? delete $args{exec} : exists $args{x} ? delete $args{x} : undef;\n$self->mixin($x ? 'STD::P5::Q::x1' : 'STD::P5::Q::x0')     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{words} || exists $args{w};\nmy $w = exists $args{words} ? delete $args{words} : exists $args{w} ? delete $args{w} : undef;\n$self->mixin($w ? 'STD::P5::Q::w1' : 'STD::P5::Q::w0')     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{quotewords} || exists $args{ww};\nmy $ww = exists $args{quotewords} ? delete $args{quotewords} : exists $args{ww} ? delete $args{ww} : undef;\n$self->mixin($ww ? 'STD::P5::Q::ww1' : 'STD::P5::Q::ww0')     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{heredoc} || exists $args{to};\nmy $to = exists $args{heredoc} ? delete $args{heredoc} : exists $args{to} ? delete $args{to} : undef;\n$self->truly($to, ':to');\n$self->cursor_herelang;\n};\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{regex};\nmy $regex = exists $args{regex} ? delete $args{regex} : undef;\nreturn $::LANG{'Regex'}    };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{trans};\nmy $trans = exists $args{trans} ? delete $args{trans} : undef;\nreturn $::LANG{'Trans'}    };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nmy %x = %args;\nmy @k = keys(%x);\n$self->panic(\"Unrecognized quote modifier: \" . join('',@k));\n};\n}\n$orig->(@_);\n};\n\n1; };\nsub capterm__PEEK { $_[0]->_AUTOLEXpeek('capterm', $retree) }\nsub capterm {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE capterm\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'capture'} = [];\n$self->_MATCHIFYr($S, \"capterm\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\\\\"))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'capterm_0') {\n$C->deb(\"Fate passed to capterm_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT capterm_0';    \n}\nelse {\n$x = 'ALTLTM capterm_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'capterm_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"capterm_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['capture'], sub {\nmy $C = shift;\n$C->capture\n})\n}))) {\n$C->_EXACT(\"\\)\")\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\S/)\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['termish'], sub {\nmy $C = shift;\n$C->termish\n})\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub capture__PEEK { $_[0]->_AUTOLEXpeek('capture', $retree) }\nsub capture {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::INVOCANT_OK = 1;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE capture\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"capture\", do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub param_sep__PEEK { $_[0]->_AUTOLEXpeek('param_sep', $retree) }\nsub param_sep {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE param_sep\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"param_sep\", do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'param_sep_0') {\n$C->deb(\"Fate passed to param_sep_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT param_sep_0';    \n}\nelse {\n$x = 'ALTLTM param_sep_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'param_sep_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"param_sep_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\,\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\:\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\;\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\;\\;\")\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub signature__PEEK { $_[0]->_AUTOLEXpeek('signature', $retree) }\nsub signature {\nno warnings 'recursion';\nmy $self = shift;\n\nmy $lexsig = @_ ? shift() : 0;\nlocal $::IN_DECL = 1;local $::zone = 'posreq';my $startpos = $self->{'_pos'};\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE signature\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'param_sep'} = [];\n$C->{'parameter'} = [];\n$C->{'typename'} = [];\n$self->_MATCHIFYr($S, \"signature\", do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_REPSEPr( sub {\nmy $C=shift;\n$C->_SUBSUMEr(['param_sep'], sub {\nmy $C = shift;\n$C->param_sep\n})\n}, sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_0') {\n$C->deb(\"Fate passed to signature_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT signature_0';    \n}\nelse {\n$x = 'ALTLTM signature_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'signature_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"signature_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = (do {\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_1') {\n$C->deb(\"Fate passed to signature_1: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT signature_1';    \n}\nelse {\n$x = 'ALTLTM signature_1'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'signature_1', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"signature_1 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\-\\-\\>\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\)\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\]\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\{\")\n},\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\:\\s/)\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n\n})) { ($C) } else { () }\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_SUBSUMEr(['parameter'], sub {\nmy $C = shift;\n$C->parameter\n})\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Malformed parameter\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)\nand ($C) = (scalar(do {\n$::IN_DECL = 0}, $C))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_EXACT(\"\\-\\-\\>\"))\nand ($C) = ($C->ws)) {\n$C->_SUBSUMEr(['typename'], sub {\nmy $C = shift;\n$C->typename\n})\n} else { () }\n}))) { ($C) } else { () }\n}))) {\nscalar(do {\n{\n$::LEFTSIGIL = '@';\nif ($lexsig) {\n$::CURLEX->{'$?SIGNATURE'} .= '(' . substr($::ORIG, $startpos, $C->{'_pos'} - $startpos) . ')';\ndelete $::CURLEX->{'!NEEDSIG'};\n};\n}}, $C)\n} else { () }\n\n});\n}\n;\nsub type_constraint__PEEK { $_[0]->_AUTOLEXpeek('type_constraint', $retree) }\nsub type_constraint {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE type_constraint\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"type_constraint\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['typename'], sub {\nmy $C = shift;\n$C->typename\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_prefix__S_128do__PEEK { $_[0]->_AUTOLEXpeek('p5statement_prefix__S_128do', $retree) }\nsub p5statement_prefix__S_128do {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_prefix__S_128do\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"do\";\n$self->_MATCHIFYr($S, \"p5statement_prefix__S_128do\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"do\"))\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['block'], sub {\nmy $C = shift;\n$C->block\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5statement_prefix__S_129eval__PEEK { $_[0]->_AUTOLEXpeek('p5statement_prefix__S_129eval', $retree) }\nsub p5statement_prefix__S_129eval {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5statement_prefix__S_129eval\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"eval\";\n$self->_MATCHIFYr($S, \"p5statement_prefix__S_129eval\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"eval\"))\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['block'], sub {\nmy $C = shift;\n$C->block\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5term__S_130undef__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_130undef', $retree) }\nsub p5term__S_130undef {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_130undef\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"undef\";\n$self->_MATCHIFYr($S, \"p5term__S_130undef\", do {\nif (my ($C) = ($C->_PATTERN(qr/\\Gundef\\b/))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%term)\n})\n} else { () }\n\n});\n}\n;\nsub p5term__S_131continue__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_131continue', $retree) }\nsub p5term__S_131continue {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_131continue\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"continue\";\n$self->_MATCHIFYr($S, \"p5term__S_131continue\", do {\nif (my ($C) = ($C->_PATTERN(qr/\\Gcontinue\\b/))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%term)\n})\n} else { () }\n\n});\n}\n;\nsub p5circumfix__S_132sigil__PEEK { $_[0]->_AUTOLEXpeek('p5circumfix__S_132sigil', $retree) }\nsub p5circumfix__S_132sigil {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5circumfix__S_132sigil\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"sigil\";\n$self->_MATCHIFYr($S, \"p5circumfix__S_132sigil\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['sigil','p5sigil'], sub {\nmy $C = shift;\n$C->p5sigil\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\)\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['semilist'], sub {\nmy $C = shift;\n$C->semilist\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\)\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'contextualizer', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\n$::LEFTSIGIL ||= $M->{'sigil'}->Str }, $C))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%term)\n})\n} else { () }\n\n});\n}\n;\nsub p5circumfix__S_133Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('p5circumfix__S_133Paren_Thesis', $retree) }\nsub p5circumfix__S_133Paren_Thesis {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5circumfix__S_133Paren_Thesis\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\(\\ \\)\";\n$self->_MATCHIFYr($S, \"p5circumfix__S_133Paren_Thesis\", do {\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\)\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['semilist'], sub {\nmy $C = shift;\n$C->semilist\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\)\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'parenthesized expression', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%term)\n})\n} else { () }\n\n});\n}\n;\nsub p5circumfix__S_134Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('p5circumfix__S_134Bra_Ket', $retree) }\nsub p5circumfix__S_134Bra_Ket {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5circumfix__S_134Bra_Ket\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\[\\ \\]\";\n$self->_MATCHIFYr($S, \"p5circumfix__S_134Bra_Ket\", do {\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\]\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\[\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['semilist'], sub {\nmy $C = shift;\n$C->semilist\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\]\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'array composer', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%term)\n})\n} else { () }\n\n});\n}\n;\nsub PRE__PEEK { $_[0]->_AUTOLEXpeek('PRE', $retree) }\nsub PRE {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE PRE\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"PRE\", do {\nmy $C = $C;\nif (($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['prefix','p5prefix'], sub {\nmy $C = shift;\n$C->p5prefix\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'O'} = $M->{'prefix'}->{'O'};\n$M->{'sym'} = $M->{'prefix'}->{'sym'} ;\n}, $C)\n} else { () }\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish', $retree) }\nsub infixish {\nno warnings 'recursion';\nmy $self = shift;\n\nmy $in_meta = @_ ? shift() : $::IN_META;\nlocal $::IN_META = $in_meta;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE infixish\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"infixish\", do {\nmy $C = $C;\nif (($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->stdstopper)) { ($C) } else { () }\n}))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->infixstopper)) { ($C) } else { () }\n}))\nand ($C) = ($C->_SUBSUMEr(['infix','p5infix'], sub {\nmy $C = shift;\n$C->p5infix\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'O'} = $M->{'infix'}->{'O'};\n$M->{'sym'} = $M->{'infix'}->{'sym'};\n}, $C)\n} else { () }\n\n});\n}\n;\nsub p5dotty__S_135MinusGt__PEEK { $_[0]->_AUTOLEXpeek('p5dotty__S_135MinusGt', $retree) }\nsub p5dotty__S_135MinusGt {\nno warnings 'recursion';\nmy $self = shift;\n\n;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5dotty__S_135MinusGt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\-\\>\";\n$self->_MATCHIFYr($S, \"p5dotty__S_135MinusGt\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\-\\>\"))\nand ($C) = ($C->unspacey)\nand ($C) = ($C->_SUBSUMEr(['dottyop'], sub {\nmy $C = shift;\n$C->dottyop\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%methodcall)\n})\n} else { () }\n\n});\n}\n;\nsub dottyopish__PEEK { $_[0]->_AUTOLEXpeek('dottyopish', $retree) }\nsub dottyopish {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE dottyopish\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"dottyopish\", $C->_SUBSUMEr(['term','dottyop'], sub {\nmy $C = shift;\n$C->dottyop\n}));\n}\n;\nsub dottyop__PEEK { $_[0]->_AUTOLEXpeek('dottyop', $retree) }\nsub dottyop {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE dottyop\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"dottyop\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'dottyop_0') {\n$C->deb(\"Fate passed to dottyop_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT dottyop_0';    \n}\nelse {\n$x = 'ALTLTM dottyop_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'dottyop_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"dottyop_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['methodop'], sub {\nmy $C = shift;\n$C->methodop\n})\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[_[:alpha:]]/)\n}))\nand ($C) = ($C->_SUBSUMEr(['postcircumfix','p5postcircumfix'], sub {\nmy $C = shift;\n$C->p5postcircumfix\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'O'} = $M->{'postcircumfix'}->{'O'};\n$M->{'sym'} = $M->{'postcircumfix'}->{'sym'};\n}, $C)\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub POST__PEEK { $_[0]->_AUTOLEXpeek('POST', $retree) }\nsub POST {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE POST\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"POST\", do {\nmy $C = $C;\nif (($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->stdstopper)) { ($C) } else { () }\n}))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n(($C) x !!do {\n$::MEMOS[$C->{'_pos'}]->{'ws'} })\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_0') {\n$C->deb(\"Fate passed to POST_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT POST_0';    \n}\nelse {\n$x = 'ALTLTM POST_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'POST_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"POST_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['dotty','p5dotty'], sub {\nmy $C = shift;\n$C->p5dotty\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'O'} = $M->{'dotty'}->{'O'};\n$M->{'sym'} = $M->{'dotty'}->{'sym'};\n$M->{'~CAPS'} = $M->{'dotty'}->{'~CAPS'};\n}, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['postop'], sub {\nmy $C = shift;\n$C->postop\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'O'} = $M->{'postop'}->{'O'};\n$M->{'sym'} = $M->{'postop'}->{'sym'};\n$M->{'~CAPS'} = $M->{'postop'}->{'~CAPS'};\n}, $C)\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5postcircumfix__S_136Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('p5postcircumfix__S_136Paren_Thesis', $retree) }\nsub p5postcircumfix__S_136Paren_Thesis {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5postcircumfix__S_136Paren_Thesis\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\(\\ \\)\";\n$self->_MATCHIFYr($S, \"p5postcircumfix__S_136Paren_Thesis\", do {\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\)\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {\nmy $C = shift;\n$C->semiarglist\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\)\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'argument list', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%methodcall)\n})\n} else { () }\n\n});\n}\n;\nsub p5postcircumfix__S_137Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('p5postcircumfix__S_137Bra_Ket', $retree) }\nsub p5postcircumfix__S_137Bra_Ket {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5postcircumfix__S_137Bra_Ket\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\[\\ \\]\";\n$self->_MATCHIFYr($S, \"p5postcircumfix__S_137Bra_Ket\", do {\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\]\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\[\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['semilist'], sub {\nmy $C = shift;\n$C->semilist\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\]\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%methodcall)\n})\n} else { () }\n\n});\n}\n;\nsub p5postcircumfix__S_138Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('p5postcircumfix__S_138Cur_Ly', $retree) }\nsub p5postcircumfix__S_138Cur_Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5postcircumfix__S_138Cur_Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\{\\ \\}\";\n$self->_MATCHIFYr($S, \"p5postcircumfix__S_138Cur_Ly\", do {\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\}\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\{\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['semilist'], sub {\nmy $C = shift;\n$C->semilist\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\}\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%methodcall)\n})\n} else { () }\n\n});\n}\n;\nsub postop__PEEK { $_[0]->_AUTOLEXpeek('postop', $retree) }\nsub postop {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE postop\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"postop\", do {\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'postop_0') {\n$C->deb(\"Fate passed to postop_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT postop_0';    \n}\nelse {\n$x = 'ALTLTM postop_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'postop_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"postop_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['postfix','p5postfix'], sub {\nmy $C = shift;\n$C->p5postfix\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'O'} = $M->{'postfix'}->{'O'};\n$M->{'sym'} = $M->{'postfix'}->{'sym'};\n}, $C)\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['postcircumfix','p5postcircumfix'], sub {\nmy $C = shift;\n$C->p5postcircumfix\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'O'} = $M->{'postcircumfix'}->{'O'};\n$M->{'sym'} = $M->{'postcircumfix'}->{'sym'};\n}, $C)\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n\n});\n}\n;\nsub methodop__PEEK { $_[0]->_AUTOLEXpeek('methodop', $retree) }\nsub methodop {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE methodop\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'args'} = [];\n$self->_MATCHIFYr($S, \"methodop\", do {\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_0') {\n$C->deb(\"Fate passed to methodop_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT methodop_0';    \n}\nelse {\n$x = 'ALTLTM methodop_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'methodop_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"methodop_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['longname'], sub {\nmy $C = shift;\n$C->longname\n})\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = (do {\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_1') {\n$C->deb(\"Fate passed to methodop_1: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT methodop_1';    \n}\nelse {\n$x = 'ALTLTM methodop_1'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'methodop_1', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"methodop_1 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\$\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\@\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\&\")\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n\n})) { ($C) } else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_SUBSUMEr(['variable'], sub {\nmy $C = shift;\n$C->variable\n}))) {\nscalar(do {\nmy $M = $C;\n$::VAR = $M->{'variable'} }, $C)\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G[\\\\(]/)\n}))) {\n$C->_SUBSUMEr(['args'], sub {\nmy $C = shift;\n$C->args\n})\n} else { () }\n}))) { ($C) } else { () }\n})\n} else { () }\n\n});\n}\n;\nsub semiarglist__PEEK { $_[0]->_AUTOLEXpeek('semiarglist', $retree) }\nsub semiarglist {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE semiarglist\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'arglist'} = [];\n$self->_MATCHIFYr($S, \"semiarglist\", do {\nmy $C = $C;\nif (($C) = ($C->_REPSEPr( sub {\nmy $C=shift;\n$C->_EXACT(\"\\;\")\n}, sub {\nmy $C=shift;\n$C->_SUBSUMEr(['arglist'], sub {\nmy $C = shift;\n$C->arglist\n})\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub arglist__PEEK { $_[0]->_AUTOLEXpeek('arglist', $retree) }\nsub arglist {\nno warnings 'recursion';\nmy $self = shift;\n\nmy $inv_ok = $::INVOCANT_OK;local $::endargs = 0;local $::GOAL = 'endargs';local $::QSIGIL = '';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE arglist\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"arglist\", do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'arglist_0') {\n$C->deb(\"Fate passed to arglist_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT arglist_0';    \n}\nelse {\n$x = 'ALTLTM arglist_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'arglist_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"arglist_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->stdstopper)) { ($C) } else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR(\\%listop)\n}))) {\nscalar(do {\nmy $M = $C;\n{\nmy $delims = $M->{'EXPR'}->{'delims'};\nfor (@$delims) {\nif (($_->{'sym'} // '') eq ':') {\nif ($inv_ok) {\n$::INVOCANT_IS = $M->{'EXPR'}->{'list'}->[0]}}}\n;\n}}, $C)\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5circumfix__S_139Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('p5circumfix__S_139Cur_Ly', $retree) }\nsub p5circumfix__S_139Cur_Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5circumfix__S_139Cur_Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\{\\ \\}\";\n$self->_MATCHIFYr($S, \"p5circumfix__S_139Cur_Ly\", do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\{\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_SUBSUMEr(['pblock'], sub {\nmy $C = shift;\n$C->pblock\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%term)\n})\n} else { () }\n\n});\n}\n;\nsub p5postfix__S_140MinusGt__PEEK { $_[0]->_AUTOLEXpeek('p5postfix__S_140MinusGt', $retree) }\nsub p5postfix__S_140MinusGt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5postfix__S_140MinusGt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\-\\>\";\n$self->_MATCHIFYr($S, \"p5postfix__S_140MinusGt\", $C->_EXACT(\"\\-\\>\"));\n}\n;\nsub p5postfix__S_141PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('p5postfix__S_141PlusPlus', $retree) }\nsub p5postfix__S_141PlusPlus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5postfix__S_141PlusPlus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\+\\+\";\n$self->_MATCHIFYr($S, \"p5postfix__S_141PlusPlus\", do {\nif (my ($C) = ($C->_EXACT(\"\\+\\+\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%autoincrement)\n})\n} else { () }\n\n});\n}\n;\nsub p5postfix__S_142MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('p5postfix__S_142MinusMinus', $retree) }\nsub p5postfix__S_142MinusMinus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5postfix__S_142MinusMinus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\-\\-\";\n$self->_MATCHIFYr($S, \"p5postfix__S_142MinusMinus\", do {\nif (my ($C) = ($C->_EXACT(\"\\-\\-\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%autoincrement)\n})\n} else { () }\n\n});\n}\n;\nsub p5prefix__S_143PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('p5prefix__S_143PlusPlus', $retree) }\nsub p5prefix__S_143PlusPlus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5prefix__S_143PlusPlus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\+\\+\";\n$self->_MATCHIFYr($S, \"p5prefix__S_143PlusPlus\", do {\nif (my ($C) = ($C->_EXACT(\"\\+\\+\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%autoincrement)\n})\n} else { () }\n\n});\n}\n;\nsub p5prefix__S_144MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('p5prefix__S_144MinusMinus', $retree) }\nsub p5prefix__S_144MinusMinus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5prefix__S_144MinusMinus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\-\\-\";\n$self->_MATCHIFYr($S, \"p5prefix__S_144MinusMinus\", do {\nif (my ($C) = ($C->_EXACT(\"\\-\\-\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%autoincrement)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_145StarStar__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_145StarStar', $retree) }\nsub p5infix__S_145StarStar {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_145StarStar\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\*\\*\";\n$self->_MATCHIFYr($S, \"p5infix__S_145StarStar\", do {\nif (my ($C) = ($C->_EXACT(\"\\*\\*\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%exponentiation)\n})\n} else { () }\n\n});\n}\n;\nsub p5prefix__S_146Bang__PEEK { $_[0]->_AUTOLEXpeek('p5prefix__S_146Bang', $retree) }\nsub p5prefix__S_146Bang {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5prefix__S_146Bang\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\!\";\n$self->_MATCHIFYr($S, \"p5prefix__S_146Bang\", do {\nif (my ($C) = ($C->_EXACT(\"\\!\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%symbolic_unary)\n})\n} else { () }\n\n});\n}\n;\nsub p5prefix__S_147Plus__PEEK { $_[0]->_AUTOLEXpeek('p5prefix__S_147Plus', $retree) }\nsub p5prefix__S_147Plus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5prefix__S_147Plus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\+\";\n$self->_MATCHIFYr($S, \"p5prefix__S_147Plus\", do {\nif (my ($C) = ($C->_EXACT(\"\\+\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%symbolic_unary)\n})\n} else { () }\n\n});\n}\n;\nsub p5prefix__S_148Minus__PEEK { $_[0]->_AUTOLEXpeek('p5prefix__S_148Minus', $retree) }\nsub p5prefix__S_148Minus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5prefix__S_148Minus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\-\";\n$self->_MATCHIFYr($S, \"p5prefix__S_148Minus\", do {\nif (my ($C) = ($C->_EXACT(\"\\-\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%symbolic_unary)\n})\n} else { () }\n\n});\n}\n;\nsub p5prefix__S_149Tilde__PEEK { $_[0]->_AUTOLEXpeek('p5prefix__S_149Tilde', $retree) }\nsub p5prefix__S_149Tilde {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5prefix__S_149Tilde\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\~\";\n$self->_MATCHIFYr($S, \"p5prefix__S_149Tilde\", do {\nif (my ($C) = ($C->_EXACT(\"\\~\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%symbolic_unary)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_150BangTilde__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_150BangTilde', $retree) }\nsub p5infix__S_150BangTilde {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_150BangTilde\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\!\\~\";\n$self->_MATCHIFYr($S, \"p5infix__S_150BangTilde\", do {\nif (my ($C) = ($C->_EXACT(\"\\!\\~\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%binding)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_151EqualTilde__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_151EqualTilde', $retree) }\nsub p5infix__S_151EqualTilde {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_151EqualTilde\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\=\\~\";\n$self->_MATCHIFYr($S, \"p5infix__S_151EqualTilde\", do {\nif (my ($C) = ($C->_EXACT(\"\\=\\~\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%binding)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_152Star__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_152Star', $retree) }\nsub p5infix__S_152Star {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_152Star\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\*\";\n$self->_MATCHIFYr($S, \"p5infix__S_152Star\", do {\nif (my ($C) = ($C->_EXACT(\"\\*\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%multiplicative)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_153Slash__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_153Slash', $retree) }\nsub p5infix__S_153Slash {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_153Slash\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\/\";\n$self->_MATCHIFYr($S, \"p5infix__S_153Slash\", do {\nif (my ($C) = ($C->_EXACT(\"\\/\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%multiplicative)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_154Percent__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_154Percent', $retree) }\nsub p5infix__S_154Percent {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_154Percent\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\%\";\n$self->_MATCHIFYr($S, \"p5infix__S_154Percent\", do {\nif (my ($C) = ($C->_EXACT(\"\\%\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%multiplicative)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_155LtLt__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_155LtLt', $retree) }\nsub p5infix__S_155LtLt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_155LtLt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\<\\<\";\n$self->_MATCHIFYr($S, \"p5infix__S_155LtLt\", do {\nif (my ($C) = ($C->_EXACT(\"\\<\\<\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%multiplicative)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_156GtGt__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_156GtGt', $retree) }\nsub p5infix__S_156GtGt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_156GtGt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\>\\>\";\n$self->_MATCHIFYr($S, \"p5infix__S_156GtGt\", do {\nif (my ($C) = ($C->_EXACT(\"\\>\\>\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%multiplicative)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_157x__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_157x', $retree) }\nsub p5infix__S_157x {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_157x\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"x\";\n$self->_MATCHIFYr($S, \"p5infix__S_157x\", do {\nif (my ($C) = ($C->_EXACT(\"x\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%multiplicative)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_158Dot__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_158Dot', $retree) }\nsub p5infix__S_158Dot {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_158Dot\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\.\";\n$self->_MATCHIFYr($S, \"p5infix__S_158Dot\", do {\nif (my ($C) = ($C->_EXACT(\"\\.\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%additive)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_159Plus__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_159Plus', $retree) }\nsub p5infix__S_159Plus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_159Plus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\+\";\n$self->_MATCHIFYr($S, \"p5infix__S_159Plus\", do {\nif (my ($C) = ($C->_EXACT(\"\\+\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%additive)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_160Minus__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_160Minus', $retree) }\nsub p5infix__S_160Minus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_160Minus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\-\";\n$self->_MATCHIFYr($S, \"p5infix__S_160Minus\", do {\nif (my ($C) = ($C->_EXACT(\"\\-\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%additive)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_161Amp__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_161Amp', $retree) }\nsub p5infix__S_161Amp {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_161Amp\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\&\";\n$self->_MATCHIFYr($S, \"p5infix__S_161Amp\", do {\nif (my ($C) = ($C->_EXACT(\"\\&\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%bitwise_and)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_162also__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_162also', $retree) }\nsub p5infix__S_162also {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_162also\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"also\";\n$self->_MATCHIFYr($S, \"p5infix__S_162also\", do {\nif (my ($C) = ($C->_EXACT(\"also\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%bitwise_and)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_163Vert__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_163Vert', $retree) }\nsub p5infix__S_163Vert {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_163Vert\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\|\";\n$self->_MATCHIFYr($S, \"p5infix__S_163Vert\", do {\nif (my ($C) = ($C->_EXACT(\"\\|\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%bitwise_or)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_164Caret__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_164Caret', $retree) }\nsub p5infix__S_164Caret {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_164Caret\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\^\";\n$self->_MATCHIFYr($S, \"p5infix__S_164Caret\", do {\nif (my ($C) = ($C->_EXACT(\"\\^\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%bitwise_or)\n})\n} else { () }\n\n});\n}\n;\nsub p5prefix__S_165sleep__PEEK { $_[0]->_AUTOLEXpeek('p5prefix__S_165sleep', $retree) }\nsub p5prefix__S_165sleep {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5prefix__S_165sleep\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"sleep\";\n$self->_MATCHIFYr($S, \"p5prefix__S_165sleep\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Gsleep\\b/))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\s*+/)\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%named_unary)\n})\n} else { () }\n\n});\n}\n;\nsub p5prefix__S_166abs__PEEK { $_[0]->_AUTOLEXpeek('p5prefix__S_166abs', $retree) }\nsub p5prefix__S_166abs {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5prefix__S_166abs\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"abs\";\n$self->_MATCHIFYr($S, \"p5prefix__S_166abs\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Gabs\\b/))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\s*+/)\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%named_unary)\n})\n} else { () }\n\n});\n}\n;\nsub p5prefix__S_167let__PEEK { $_[0]->_AUTOLEXpeek('p5prefix__S_167let', $retree) }\nsub p5prefix__S_167let {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5prefix__S_167let\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"let\";\n$self->_MATCHIFYr($S, \"p5prefix__S_167let\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Glet\\b/))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\s*+/)\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%named_unary)\n})\n} else { () }\n\n});\n}\n;\nsub p5prefix__S_168temp__PEEK { $_[0]->_AUTOLEXpeek('p5prefix__S_168temp', $retree) }\nsub p5prefix__S_168temp {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5prefix__S_168temp\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"temp\";\n$self->_MATCHIFYr($S, \"p5prefix__S_168temp\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Gtemp\\b/))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\s*+/)\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%named_unary)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_169LtEqualGt__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_169LtEqualGt', $retree) }\nsub p5infix__S_169LtEqualGt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_169LtEqualGt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\<\\=\\>\";\n$self->_MATCHIFYr($S, \"p5infix__S_169LtEqualGt\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\<\\=\\>\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\nmy $M = $C;\n$M->{'O'}->{'returns'} = \"Order\"})\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%comparison)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_170cmp__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_170cmp', $retree) }\nsub p5infix__S_170cmp {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_170cmp\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"cmp\";\n$self->_MATCHIFYr($S, \"p5infix__S_170cmp\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"cmp\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\nmy $M = $C;\n$M->{'O'}->{'returns'} = \"Order\"})\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%comparison)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_171Lt__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_171Lt', $retree) }\nsub p5infix__S_171Lt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_171Lt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\<\";\n$self->_MATCHIFYr($S, \"p5infix__S_171Lt\", do {\nif (my ($C) = ($C->_EXACT(\"\\<\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%comparison)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_172LtEqual__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_172LtEqual', $retree) }\nsub p5infix__S_172LtEqual {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_172LtEqual\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\<\\=\";\n$self->_MATCHIFYr($S, \"p5infix__S_172LtEqual\", do {\nif (my ($C) = ($C->_EXACT(\"\\<\\=\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%comparison)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_173Gt__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_173Gt', $retree) }\nsub p5infix__S_173Gt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_173Gt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\>\";\n$self->_MATCHIFYr($S, \"p5infix__S_173Gt\", do {\nif (my ($C) = ($C->_EXACT(\"\\>\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%comparison)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_174GtEqual__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_174GtEqual', $retree) }\nsub p5infix__S_174GtEqual {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_174GtEqual\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\>\\=\";\n$self->_MATCHIFYr($S, \"p5infix__S_174GtEqual\", do {\nif (my ($C) = ($C->_EXACT(\"\\>\\=\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%comparison)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_175eq__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_175eq', $retree) }\nsub p5infix__S_175eq {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_175eq\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"eq\";\n$self->_MATCHIFYr($S, \"p5infix__S_175eq\", do {\nif (my ($C) = ($C->_EXACT(\"eq\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%equality)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_176ne__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_176ne', $retree) }\nsub p5infix__S_176ne {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_176ne\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"ne\";\n$self->_MATCHIFYr($S, \"p5infix__S_176ne\", do {\nif (my ($C) = ($C->_EXACT(\"ne\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%equality)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_177lt__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_177lt', $retree) }\nsub p5infix__S_177lt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_177lt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"lt\";\n$self->_MATCHIFYr($S, \"p5infix__S_177lt\", do {\nif (my ($C) = ($C->_EXACT(\"lt\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%comparison)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_178le__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_178le', $retree) }\nsub p5infix__S_178le {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_178le\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"le\";\n$self->_MATCHIFYr($S, \"p5infix__S_178le\", do {\nif (my ($C) = ($C->_EXACT(\"le\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%comparison)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_179gt__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_179gt', $retree) }\nsub p5infix__S_179gt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_179gt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"gt\";\n$self->_MATCHIFYr($S, \"p5infix__S_179gt\", do {\nif (my ($C) = ($C->_EXACT(\"gt\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%comparison)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_180ge__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_180ge', $retree) }\nsub p5infix__S_180ge {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_180ge\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"ge\";\n$self->_MATCHIFYr($S, \"p5infix__S_180ge\", do {\nif (my ($C) = ($C->_EXACT(\"ge\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%comparison)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_181EqualEqual__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_181EqualEqual', $retree) }\nsub p5infix__S_181EqualEqual {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_181EqualEqual\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\=\\=\";\n$self->_MATCHIFYr($S, \"p5infix__S_181EqualEqual\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\=\\=\"))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\=\")\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%equality)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_182BangEqual__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_182BangEqual', $retree) }\nsub p5infix__S_182BangEqual {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_182BangEqual\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\!\\=\";\n$self->_MATCHIFYr($S, \"p5infix__S_182BangEqual\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\!\\=\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\s/)\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%equality)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_183AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_183AmpAmp', $retree) }\nsub p5infix__S_183AmpAmp {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_183AmpAmp\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\&\\&\";\n$self->_MATCHIFYr($S, \"p5infix__S_183AmpAmp\", do {\nif (my ($C) = ($C->_EXACT(\"\\&\\&\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%tight_and)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_184VertVert__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_184VertVert', $retree) }\nsub p5infix__S_184VertVert {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_184VertVert\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\|\\|\";\n$self->_MATCHIFYr($S, \"p5infix__S_184VertVert\", do {\nif (my ($C) = ($C->_EXACT(\"\\|\\|\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%tight_or)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_185CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_185CaretCaret', $retree) }\nsub p5infix__S_185CaretCaret {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_185CaretCaret\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\^\\^\";\n$self->_MATCHIFYr($S, \"p5infix__S_185CaretCaret\", do {\nif (my ($C) = ($C->_EXACT(\"\\^\\^\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%tight_or)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_186SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_186SlashSlash', $retree) }\nsub p5infix__S_186SlashSlash {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_186SlashSlash\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\/\\/\";\n$self->_MATCHIFYr($S, \"p5infix__S_186SlashSlash\", do {\nif (my ($C) = ($C->_EXACT(\"\\/\\/\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%tight_or)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_187DotDot__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_187DotDot', $retree) }\nsub p5infix__S_187DotDot {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_187DotDot\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\.\\.\";\n$self->_MATCHIFYr($S, \"p5infix__S_187DotDot\", do {\nif (my ($C) = ($C->_EXACT(\"\\.\\.\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%range)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_188DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_188DotDotDot', $retree) }\nsub p5infix__S_188DotDotDot {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_188DotDotDot\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\.\\.\\.\";\n$self->_MATCHIFYr($S, \"p5infix__S_188DotDotDot\", do {\nif (my ($C) = ($C->_EXACT(\"\\.\\.\\.\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%range)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_189Question_Colon__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_189Question_Colon', $retree) }\nsub p5infix__S_189Question_Colon {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::GOAL = ':';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_189Question_Colon\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\?\\ \\:\";\n$self->_MATCHIFYr($S, \"p5infix__S_189Question_Colon\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\?\"))\nand ($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR(\\%assignment)\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\:\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\=\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->panic(\"Assignment not allowed within ?:\"))) {\n$C\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\!\\!\")\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->panic(\"Please use : rather than !!\"))) {\n$C\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['infixish'], sub {\nmy $C = shift;\n$C->infixish\n})\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->panic(\"Precedence too loose within ?:; use ?(): instead \"))) {\n$C\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Found ? but no :; possible precedence problem\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\n$M->{'O'}->{'_reducecheck'} = 'raise_middle'}, $C))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%conditional)\n})\n} else { () }\n\n});\n}\n;\nsub raise_middle {\nno warnings 'recursion';\nmy $self = shift;\n$self->{'middle'} = $self->{'infix'}->{'EXPR'};\n$self;\n};\nsub p5infix__S_190Equal__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_190Equal', $retree) }\nsub p5infix__S_190Equal {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_190Equal\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\=\";\n$self->_MATCHIFYr($S, \"p5infix__S_190Equal\", do {\nif (my ($C) = ($C->_EXACT(\"\\=\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%assignment)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_191Comma__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_191Comma', $retree) }\nsub p5infix__S_191Comma {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_191Comma\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\,\";\n$self->_MATCHIFYr($S, \"p5infix__S_191Comma\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\,\"))\nand ($C) = (scalar(do {\nmy $M = $C;\n$M->{'O'}->{'fiddly'} = 0}, $C))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%comma)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_192EqualGt__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_192EqualGt', $retree) }\nsub p5infix__S_192EqualGt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_192EqualGt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\=\\>\";\n$self->_MATCHIFYr($S, \"p5infix__S_192EqualGt\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\=\\>\"))\nand ($C) = (scalar(do {\nmy $M = $C;\n$M->{'O'}->{'fiddly'} = 0}, $C))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%comma)\n})\n} else { () }\n\n});\n}\n;\nsub p5term__S_193identifier__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_193identifier', $retree) }\nsub p5term__S_193identifier {\nno warnings 'recursion';\nmy $self = shift;\n\nmy $name;my $pos;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_193identifier\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"identifier\";\n$self->_MATCHIFYr($S, \"p5term__S_193identifier\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['identifier'], sub {\nmy $C = shift;\n$C->identifier\n}))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->{'unsp'} = [];\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5term__S_193identifier_0') {\n$C->deb(\"Fate passed to p5term__S_193identifier_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5term__S_193identifier_0';    \n}\nelse {\n$x = 'ALTLTM p5term__S_193identifier_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5term__S_193identifier_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5term__S_193identifier_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['unsp'], sub {\nmy $C = shift;\n$C->unsp\n})\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\(\")\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) { ($C) } else { () }\n})\n}))) { ($C) } else { () }\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\n$name = $M->{'identifier'}->Str;\n$pos = $C->{'_pos'};\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['args'], sub {\nmy $C = shift;\n$C->args( $C->is_name($name) )\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\n$self->add_mystery($name,$pos,substr($::ORIG,$pos,1)) unless $M->{'args'}->{'invocant'}}, $C))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%term)\n})\n} else { () }\n\n});\n}\n;\nsub p5term__S_194opfunc__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_194opfunc', $retree) }\nsub p5term__S_194opfunc {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_194opfunc\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'colonpair'} = [];\n$C->{sym} = \"opfunc\";\n$self->_MATCHIFYr($S, \"p5term__S_194opfunc\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['category'], sub {\nmy $C = shift;\n$C->category\n}))\nand ($C) = ($C->_PLUSr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['colonpair'], sub {\nmy $C = shift;\n$C->colonpair\n})\n}))\nand ($C) = ($C->_SUBSUMEr(['args'], sub {\nmy $C = shift;\n$C->args\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%term)\n})\n} else { () }\n\n});\n}\n;\nsub args__PEEK { $_[0]->_AUTOLEXpeek('args', $retree) }\nsub args {\nno warnings 'recursion';\nmy $self = shift;\n\nmy $istype = @_ ? shift() : 0;\nmy $listopish = 0;local $::GOAL = '';local $::INVOCANT_OK = 1;local $::INVOCANT_IS;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE args\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'arglist'} = [];\n$self->_MATCHIFYr($S, \"args\", do {\nmy $C = $C;\nif (($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'args_0') {\n$C->deb(\"Fate passed to args_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT args_0';    \n}\nelse {\n$x = 'ALTLTM args_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'args_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"args_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\)\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {\nmy $C = shift;\n$C->semiarglist\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\)\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'argument list', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->unsp)\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\)\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {\nmy $C = shift;\n$C->semiarglist\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\)\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'argument list', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) {\n$C\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = (scalar(do {\n$listopish = 1 }, $C))) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\s/)\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\n(($C) x !!do {\n$istype })\n}))\nand ($C) = ($C->ws)\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->infixstopper)) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['arglist'], sub {\nmy $C = shift;\n$C->arglist\n})\n} else { () }\n}))) { ($C) } else { () }\n})\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\n$M->{'invocant'} = $::INVOCANT_IS}, $C))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n$listopish })\n}))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\:\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\s/)\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['moreargs','arglist'], sub {\nmy $C = shift;\n$C->arglist\n})\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, scalar(do {\nmy $M = $C;\n{\n$M->{'O'} = {\n}}}, $C)\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5term__S_195name__PEEK { $_[0]->_AUTOLEXpeek('p5term__S_195name', $retree) }\nsub p5term__S_195name {\nno warnings 'recursion';\nmy $self = shift;\n\nmy $name;my $pos;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5term__S_195name\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'p5postcircumfix'} = [];\n$C->{'postcircumfix'} = [];\n$C->{sym} = \"name\";\n$self->_MATCHIFYr($S, \"p5term__S_195name\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['longname'], sub {\nmy $C = shift;\n$C->longname\n}))\nand ($C) = (scalar(do {\nmy $M = $C;\n$name = $M->{'longname'}->Str;\n$pos = $C->{'_pos'};\n}, $C))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\nmy $M = $C;\n$C->is_name($M->{'longname'}->Str) or substr($M->{'longname'}->Str,0,2) eq '::'\n})\n}))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->unsp)) { ($C) } else { () }\n}))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\[\")\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['postcircumfix','p5postcircumfix'], sub {\nmy $C = shift;\n$C->p5postcircumfix\n})\n} else { () }\n}))) { ($C) } else { () }\n}))) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->_EXACT(\"\\:\\:\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5term__S_195name_0') {\n$C->deb(\"Fate passed to p5term__S_195name_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5term__S_195name_0';    \n}\nelse {\n$x = 'ALTLTM p5term__S_195name_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'p5term__S_195name_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5term__S_195name_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_EXACT(\"\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\<\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\{\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\<\\<\")\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['postcircumfix','p5postcircumfix'], sub {\nmy $C = shift;\n$C->p5postcircumfix\n})\n} else { () }\n}))) { ($C) } else { () }\n})\n} else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->_SUBSUMEr(['args'], sub {\nmy $C = shift;\n$C->args\n}))) {\nscalar(do {\nmy $M = $C;\n$self->add_mystery($name,$pos,'termish') unless $M->{'args'}->{'invocant'}}, $C)\n} else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%term)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_196and__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_196and', $retree) }\nsub p5infix__S_196and {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_196and\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"and\";\n$self->_MATCHIFYr($S, \"p5infix__S_196and\", do {\nif (my ($C) = ($C->_EXACT(\"and\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%loose_and)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_197andthen__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_197andthen', $retree) }\nsub p5infix__S_197andthen {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_197andthen\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"andthen\";\n$self->_MATCHIFYr($S, \"p5infix__S_197andthen\", do {\nif (my ($C) = ($C->_EXACT(\"andthen\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%loose_and)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_198or__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_198or', $retree) }\nsub p5infix__S_198or {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_198or\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"or\";\n$self->_MATCHIFYr($S, \"p5infix__S_198or\", do {\nif (my ($C) = ($C->_EXACT(\"or\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%loose_or)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_199orelse__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_199orelse', $retree) }\nsub p5infix__S_199orelse {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_199orelse\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"orelse\";\n$self->_MATCHIFYr($S, \"p5infix__S_199orelse\", do {\nif (my ($C) = ($C->_EXACT(\"orelse\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%loose_or)\n})\n} else { () }\n\n});\n}\n;\nsub p5infix__S_200xor__PEEK { $_[0]->_AUTOLEXpeek('p5infix__S_200xor', $retree) }\nsub p5infix__S_200xor {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5infix__S_200xor\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"xor\";\n$self->_MATCHIFYr($S, \"p5infix__S_200xor\", do {\nif (my ($C) = ($C->_EXACT(\"xor\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%loose_or)\n})\n} else { () }\n\n});\n}\n;\nsub p5terminator__S_201Semi__PEEK { $_[0]->_AUTOLEXpeek('p5terminator__S_201Semi', $retree) }\nsub p5terminator__S_201Semi {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5terminator__S_201Semi\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\;\";\n$self->_MATCHIFYr($S, \"p5terminator__S_201Semi\", do {\nif (my ($C) = ($C->_EXACT(\"\\;\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%terminator)\n})\n} else { () }\n\n});\n}\n;\nsub p5terminator__S_202if__PEEK { $_[0]->_AUTOLEXpeek('p5terminator__S_202if', $retree) }\nsub p5terminator__S_202if {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5terminator__S_202if\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"if\";\n$self->_MATCHIFYr($S, \"p5terminator__S_202if\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Gif\\b/))\nand ($C) = ($C->nofun)) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%terminator)\n})\n} else { () }\n\n});\n}\n;\nsub p5terminator__S_203unless__PEEK { $_[0]->_AUTOLEXpeek('p5terminator__S_203unless', $retree) }\nsub p5terminator__S_203unless {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5terminator__S_203unless\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"unless\";\n$self->_MATCHIFYr($S, \"p5terminator__S_203unless\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Gunless\\b/))\nand ($C) = ($C->nofun)) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%terminator)\n})\n} else { () }\n\n});\n}\n;\nsub p5terminator__S_204while__PEEK { $_[0]->_AUTOLEXpeek('p5terminator__S_204while', $retree) }\nsub p5terminator__S_204while {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5terminator__S_204while\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"while\";\n$self->_MATCHIFYr($S, \"p5terminator__S_204while\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Gwhile\\b/))\nand ($C) = ($C->nofun)) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%terminator)\n})\n} else { () }\n\n});\n}\n;\nsub p5terminator__S_205until__PEEK { $_[0]->_AUTOLEXpeek('p5terminator__S_205until', $retree) }\nsub p5terminator__S_205until {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5terminator__S_205until\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"until\";\n$self->_MATCHIFYr($S, \"p5terminator__S_205until\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Guntil\\b/))\nand ($C) = ($C->nofun)) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%terminator)\n})\n} else { () }\n\n});\n}\n;\nsub p5terminator__S_206for__PEEK { $_[0]->_AUTOLEXpeek('p5terminator__S_206for', $retree) }\nsub p5terminator__S_206for {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5terminator__S_206for\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"for\";\n$self->_MATCHIFYr($S, \"p5terminator__S_206for\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Gfor\\b/))\nand ($C) = ($C->nofun)) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%terminator)\n})\n} else { () }\n\n});\n}\n;\nsub p5terminator__S_207given__PEEK { $_[0]->_AUTOLEXpeek('p5terminator__S_207given', $retree) }\nsub p5terminator__S_207given {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5terminator__S_207given\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"given\";\n$self->_MATCHIFYr($S, \"p5terminator__S_207given\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Ggiven\\b/))\nand ($C) = ($C->nofun)) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%terminator)\n})\n} else { () }\n\n});\n}\n;\nsub p5terminator__S_208when__PEEK { $_[0]->_AUTOLEXpeek('p5terminator__S_208when', $retree) }\nsub p5terminator__S_208when {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5terminator__S_208when\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"when\";\n$self->_MATCHIFYr($S, \"p5terminator__S_208when\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\Gwhen\\b/))\nand ($C) = ($C->nofun)) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%terminator)\n})\n} else { () }\n\n});\n}\n;\nsub p5terminator__S_209Thesis__PEEK { $_[0]->_AUTOLEXpeek('p5terminator__S_209Thesis', $retree) }\nsub p5terminator__S_209Thesis {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5terminator__S_209Thesis\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\)\";\n$self->_MATCHIFYr($S, \"p5terminator__S_209Thesis\", do {\nif (my ($C) = ($C->_EXACT(\"\\)\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%terminator)\n})\n} else { () }\n\n});\n}\n;\nsub p5terminator__S_210Ket__PEEK { $_[0]->_AUTOLEXpeek('p5terminator__S_210Ket', $retree) }\nsub p5terminator__S_210Ket {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5terminator__S_210Ket\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\]\";\n$self->_MATCHIFYr($S, \"p5terminator__S_210Ket\", do {\nif (my ($C) = ($C->_EXACT(\"\\]\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%terminator)\n})\n} else { () }\n\n});\n}\n;\nsub p5terminator__S_211Ly__PEEK { $_[0]->_AUTOLEXpeek('p5terminator__S_211Ly', $retree) }\nsub p5terminator__S_211Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5terminator__S_211Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\}\";\n$self->_MATCHIFYr($S, \"p5terminator__S_211Ly\", do {\nif (my ($C) = ($C->_EXACT(\"\\}\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%terminator)\n})\n} else { () }\n\n});\n}\n;\nsub p5terminator__S_212Colon__PEEK { $_[0]->_AUTOLEXpeek('p5terminator__S_212Colon', $retree) }\nsub p5terminator__S_212Colon {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5terminator__S_212Colon\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\:\";\n$self->_MATCHIFYr($S, \"p5terminator__S_212Colon\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\:\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n$::GOAL eq ':' })\n}))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%terminator)\n})\n} else { () }\n\n});\n}\n;\nsub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper', $retree) }\nsub infixstopper {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE infixstopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFY($S, \"infixstopper\", $C->_BRACKET(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_0') {\n$C->deb(\"Fate passed to infixstopper_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT infixstopper_0';    \n}\nelse {\n$x = 'ALTLTM infixstopper_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'infixstopper_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"infixstopper_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->before(sub {\nmy $C=shift;\n$C->_SUBSUME(['stopper'], sub {\nmy $C = shift;\n$C->stopper\n})\n})\n},\nsub {\nmy $C=shift;\nSTD::LazyMap::lazymap(sub {\nmy $C=shift;\n$C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n$::GOAL eq ':' })\n})\n},\n$C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\:\")\n}))\n},\nsub {\nmy $C=shift;\n$C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n$::GOAL eq 'endargs' and $::MEMOS[$C->{'_pos'}]->{'endargs'} })\n})\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }\nsub stopper {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE stopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"stopper\", $C->_NOTBEFORE(sub {\nmy $C=shift;\n$C\n}));\n}\n;\nsub stdstopper__PEEK { $_[0]->_AUTOLEXpeek('stdstopper', $retree) }\nsub stdstopper {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal @::STUB = @::STUB = return $self if exists $::MEMOS[$self->{'_pos'}]->{'endstmt'};\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE stdstopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFY($S, \"stdstopper\", STD::LazyMap::lazymap(sub {\nmy $C=shift;\nscalar(do {\n$::MEMOS[$C->{'_pos'}]->{'endstmt'} ||= 1}, $C)\n},\n$C->_BRACKET(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'stdstopper_0') {\n$C->deb(\"Fate passed to stdstopper_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT stdstopper_0';    \n}\nelse {\n$x = 'ALTLTM stdstopper_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::STD::P5', 'stdstopper_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"stdstopper_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->before(sub {\nmy $C=shift;\n$C->terminator\n})\n},\nsub {\nmy $C=shift;\n$C->before(sub {\nmy $C=shift;\n$C->unitstopper\n})\n},\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\z/)\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n})));\n}\n;\n{ package STD::P5::Regex;\nuse Moose ':all' => { -prefix => \"moose_\" };\nuse Encode;\nmoose_extends('STD');\nour $ALLROLES = { 'STD::P5::Regex', 1 };\nour $REGEXES = {\nALL => [ qw/atom category codeblock infixish infixstopper nibbler p5assertion p5backslash p5metachar p5mod p5mod_internal p5mods p5quantifier p5regex_infix quant_atom_list quantified_atom quantmod rx termish ws/ ],\ncategory => [ qw/category__S_000p5metachar__PEEK category__S_001p5backslash__PEEK category__S_002p5assertion__PEEK category__S_003p5quantifier__PEEK category__S_004p5mod_internal__PEEK/ ],\np5assertion => [ qw/p5assertion__S_040Question__PEEK p5assertion__S_041Cur_Ly__PEEK p5assertion__S_042Lt__PEEK p5assertion__S_043Equal__PEEK p5assertion__S_044Bang__PEEK p5assertion__S_045Gt__PEEK p5assertion__S_046mod__PEEK p5assertion__S_047bogus__PEEK/ ],\np5backslash => [ qw/p5backslash__S_017A__PEEK p5backslash__S_018a__PEEK p5backslash__S_019b__PEEK p5backslash__S_020c__PEEK p5backslash__S_021d__PEEK p5backslash__S_022e__PEEK p5backslash__S_023f__PEEK p5backslash__S_024h__PEEK p5backslash__S_025l__PEEK p5backslash__S_026n__PEEK p5backslash__S_027o__PEEK p5backslash__S_028p__PEEK p5backslash__S_029Q__PEEK p5backslash__S_030r__PEEK p5backslash__S_031s__PEEK p5backslash__S_032t__PEEK p5backslash__S_033u__PEEK p5backslash__S_034v__PEEK p5backslash__S_035w__PEEK p5backslash__S_036x__PEEK p5backslash__S_037z__PEEK p5backslash__S_038misc__PEEK p5backslash__S_039oops__PEEK/ ],\np5metachar => [ qw/p5metachar__S_006Vert__PEEK p5metachar__S_007Thesis__PEEK p5metachar__S_008quant__PEEK p5metachar__S_009Bra_Ket__PEEK p5metachar__S_010ParenQuestion_Thesis__PEEK p5metachar__S_011Paren_Thesis__PEEK p5metachar__S_012Back__PEEK p5metachar__S_013Dot__PEEK p5metachar__S_014Caret__PEEK p5metachar__S_015Dollar__PEEK p5metachar__S_016var__PEEK/ ],\np5quantifier => [ qw/p5quantifier__S_048Star__PEEK p5quantifier__S_049Plus__PEEK p5quantifier__S_050Question__PEEK p5quantifier__S_051Cur_Ly__PEEK/ ],\np5regex_infix => [ qw/p5regex_infix__S_005Vert__PEEK/ ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));\n;\n;\nsub category__S_000p5metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_000p5metachar', $retree) }\nsub category__S_000p5metachar {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_000p5metachar\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5metachar\";\n$self->_MATCHIFYr($S, \"category__S_000p5metachar\", $C->_EXACT(\"p5metachar\"));\n}\n;\nsub p5metachar__PEEK { $_[0]->_AUTOLEXpeek('p5metachar:*',$retree); }\nsub p5metachar {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5metachar');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5metachar') {\n$C->deb(\"Fate passed to p5metachar: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5metachar';\n}\nelse {\n$x = 'ALTLTM p5metachar';\n}\n}\nelse {\n$x = 'ALTLTM p5metachar';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5metachar:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5metachar trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5metachar\", @gather);\n};\n@result;\n}\n;\nsub category__S_001p5backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_001p5backslash', $retree) }\nsub category__S_001p5backslash {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_001p5backslash\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5backslash\";\n$self->_MATCHIFYr($S, \"category__S_001p5backslash\", $C->_EXACT(\"p5backslash\"));\n}\n;\nsub p5backslash__PEEK { $_[0]->_AUTOLEXpeek('p5backslash:*',$retree); }\nsub p5backslash {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5backslash');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5backslash') {\n$C->deb(\"Fate passed to p5backslash: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5backslash';\n}\nelse {\n$x = 'ALTLTM p5backslash';\n}\n}\nelse {\n$x = 'ALTLTM p5backslash';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5backslash:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5backslash trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5backslash\", @gather);\n};\n@result;\n}\n;\nsub category__S_002p5assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_002p5assertion', $retree) }\nsub category__S_002p5assertion {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_002p5assertion\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5assertion\";\n$self->_MATCHIFYr($S, \"category__S_002p5assertion\", $C->_EXACT(\"p5assertion\"));\n}\n;\nsub p5assertion__PEEK { $_[0]->_AUTOLEXpeek('p5assertion:*',$retree); }\nsub p5assertion {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5assertion');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5assertion') {\n$C->deb(\"Fate passed to p5assertion: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5assertion';\n}\nelse {\n$x = 'ALTLTM p5assertion';\n}\n}\nelse {\n$x = 'ALTLTM p5assertion';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5assertion:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5assertion trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5assertion\", @gather);\n};\n@result;\n}\n;\nsub category__S_003p5quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_003p5quantifier', $retree) }\nsub category__S_003p5quantifier {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_003p5quantifier\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5quantifier\";\n$self->_MATCHIFYr($S, \"category__S_003p5quantifier\", $C->_EXACT(\"p5quantifier\"));\n}\n;\nsub p5quantifier__PEEK { $_[0]->_AUTOLEXpeek('p5quantifier:*',$retree); }\nsub p5quantifier {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5quantifier');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5quantifier') {\n$C->deb(\"Fate passed to p5quantifier: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5quantifier';\n}\nelse {\n$x = 'ALTLTM p5quantifier';\n}\n}\nelse {\n$x = 'ALTLTM p5quantifier';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5quantifier:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5quantifier trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5quantifier\", @gather);\n};\n@result;\n}\n;\nsub category__S_004p5mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_004p5mod_internal', $retree) }\nsub category__S_004p5mod_internal {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE category__S_004p5mod_internal\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p5mod_internal\";\n$self->_MATCHIFYr($S, \"category__S_004p5mod_internal\", $C->_EXACT(\"p5mod_internal\"));\n}\n;\nsub p5mod_internal__PEEK { $_[0]->_AUTOLEXpeek('p5mod_internal:*',$retree); }\nsub p5mod_internal {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5mod_internal');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5mod_internal') {\n$C->deb(\"Fate passed to p5mod_internal: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5mod_internal';\n}\nelse {\n$x = 'ALTLTM p5mod_internal';\n}\n}\nelse {\n$x = 'ALTLTM p5mod_internal';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5mod_internal:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5mod_internal trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5mod_internal\", @gather);\n};\n@result;\n}\n;\nsub p5regex_infix__PEEK { $_[0]->_AUTOLEXpeek('p5regex_infix:*',$retree); }\nsub p5regex_infix {\nmy $self = shift;\nmy $subs;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact('RULE p5regex_infix');\nmy $S = $C->{'_pos'};\n\nmy @result = do {\nmy ($tag, $try);\nmy @try;\nmy $relex;\nmy $x;\nif (my $fate = $C->{'_fate'}) {\nif ($fate->[1] eq 'p5regex_infix') {\n$C->deb(\"Fate passed to p5regex_infix: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5regex_infix';\n}\nelse {\n$x = 'ALTLTM p5regex_infix';\n}\n}\nelse {\n$x = 'ALTLTM p5regex_infix';\n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5regex_infix:*', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;       \n}\n\n$C->deb(\"p5regex_infix trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, $C->$try(@_);\nlast if @gather;\nlast if $xact->[-2];  \n}\n$self->_MATCHIFYr($S, \"p5regex_infix\", @gather);\n};\n@result;\n}\n;\nsub codeblock__PEEK { $_[0]->_AUTOLEXpeek('codeblock', $retree) }\nsub codeblock {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::GOAL = '}';\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE codeblock\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"codeblock\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\{\"))\nand ($C) = ($C->_COMMITLTM())\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nmy $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));\n$C = bless($C, (ref($newlang) || $newlang));\n$C->_SUBSUMEr(['statementlist'], sub {\nmy $C = shift;\n$C->statementlist\n})\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\}\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Unable to parse statement list; couldn't find right brace\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub ws__PEEK { $_[0]->_AUTOLEXpeek('ws', $retree) }\nsub ws {\nno warnings 'recursion';\nmy $self = shift;\n\nmy @origargs = @_;\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE ws\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"ws\", do {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n(($C) x !!do {\n$::RX->{'s'} })\n}))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, $C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = (do {\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_0') {\n$C->deb(\"Fate passed to ws_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT ws_0';    \n}\nelse {\n$x = 'ALTLTM ws_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'ws_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"ws_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\s/)\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\#\")\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n\n})) { ($C) } else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($self->SUPER::ws(@origargs))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n})\n};\n@gather;\n});\n}\n;\nsub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler', $retree) }\nsub nibbler {\nno warnings 'recursion';\nmy $self = shift;\n\nlocal $::ignorecase = $::ignorecase;\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE nibbler\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"nibbler\", do {\nmy $C = $C;\nif (($C) = ($C->ws)\nand ($C) = ($C->_SUBSUMEr(['EXPR'], sub {\nmy $C = shift;\n$C->EXPR\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub termish__PEEK { $_[0]->_AUTOLEXpeek('termish', $retree) }\nsub termish {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE termish\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"termish\", do {\nif (my ($C) = ($C->ws)) {\n$C->_SUBSUMEr(['term','quant_atom_list'], sub {\nmy $C = shift;\n$C->quant_atom_list\n})\n} else { () }\n\n});\n}\n;\nsub quant_atom_list__PEEK { $_[0]->_AUTOLEXpeek('quant_atom_list', $retree) }\nsub quant_atom_list {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE quant_atom_list\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'quantified_atom'} = [];\n$self->_MATCHIFYr($S, \"quant_atom_list\", $C->_PLUSr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['quantified_atom'], sub {\nmy $C = shift;\n$C->quantified_atom\n})\n}));\n}\n;\nsub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish', $retree) }\nsub infixish {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE infixish\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"infixish\", do {\nmy $C = $C;\nif (($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->infixstopper)) { ($C) } else { () }\n}))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->stdstopper)) { ($C) } else { () }\n}))\nand ($C) = ($C->_SUBSUMEr(['regex_infix','p5regex_infix'], sub {\nmy $C = shift;\n$C->p5regex_infix\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'O'} = $M->{'regex_infix'}->{'O'};\n$M->{'sym'} = $M->{'regex_infix'}->{'sym'};\n}, $C)\n} else { () }\n\n});\n}\n;\nsub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper', $retree) }\nsub infixstopper {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE infixstopper\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFY($S, \"infixstopper\", $C->before(sub {\nmy $C=shift;\n$C->_SUBSUME(['stopper'], sub {\nmy $C = shift;\n$C->stopper\n})\n}));\n}\n;\nsub p5regex_infix__S_005Vert__PEEK { $_[0]->_AUTOLEXpeek('p5regex_infix__S_005Vert', $retree) }\nsub p5regex_infix__S_005Vert {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5regex_infix__S_005Vert\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\|\";\n$self->_MATCHIFYr($S, \"p5regex_infix__S_005Vert\", do {\nif (my ($C) = ($C->_EXACT(\"\\|\"))) {\n$C->_SUBSUMEr(['O'], sub {\nmy $C = shift;\n$C->O(%tight_or)\n})\n} else { () }\n\n});\n}\n;\nsub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom', $retree) }\nsub quantified_atom {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE quantified_atom\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'p5quantifier'} = [];\n$C->{'quantifier'} = [];\n$self->_MATCHIFYr($S, \"quantified_atom\", do {\nmy $C = $C;\nif (($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->stopper)) { ($C) } else { () }\n}))\nand ($C) = ($C->_NOTBEFORE(sub {\nmy $C=shift;\nif (my ($C) = ($C->p5regex_infix)) { ($C) } else { () }\n}))\nand ($C) = ($C->_SUBSUMEr(['atom'], sub {\nmy $C = shift;\n$C->atom\n}))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->ws)) {\n$C->_SUBSUMEr(['quantifier','p5quantifier'], sub {\nmy $C = shift;\n$C->p5quantifier\n})\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->ws)) {\n$C\n} else { () }\n\n});\n}\n;\nsub atom__PEEK { $_[0]->_AUTOLEXpeek('atom', $retree) }\nsub atom {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE atom\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"atom\", $C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'atom_0') {\n$C->deb(\"Fate passed to atom_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT atom_0';    \n}\nelse {\n$x = 'ALTLTM atom_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'atom_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"atom_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\w/)\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['metachar','p5metachar'], sub {\nmy $C = shift;\n$C->p5metachar\n})\n},\nsub {\nmy $C=shift;\nif (($C) = ($C->_EXACT(\"\\\\\"))\nand ($C) = ($C->_COMMITLTM())) {\n$C->cursor_incr()\n} else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}));\n}\n;\nsub p5metachar__S_006Vert__PEEK { $_[0]->_AUTOLEXpeek('p5metachar__S_006Vert', $retree) }\nsub p5metachar__S_006Vert {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5metachar__S_006Vert\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\|\";\n$self->_MATCHIFYr($S, \"p5metachar__S_006Vert\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\|\"))\nand ($C) = ($C->_COMMITLTM())) {\n$C->_SUBSUMEr(['fail'], sub {\nmy $C = shift;\n$C->fail\n})\n} else { () }\n\n});\n}\n;\nsub p5metachar__S_007Thesis__PEEK { $_[0]->_AUTOLEXpeek('p5metachar__S_007Thesis', $retree) }\nsub p5metachar__S_007Thesis {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5metachar__S_007Thesis\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\)\";\n$self->_MATCHIFYr($S, \"p5metachar__S_007Thesis\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\)\"))\nand ($C) = ($C->_COMMITLTM())) {\n$C->_SUBSUMEr(['fail'], sub {\nmy $C = shift;\n$C->fail\n})\n} else { () }\n\n});\n}\n;\nsub p5metachar__S_008quant__PEEK { $_[0]->_AUTOLEXpeek('p5metachar__S_008quant', $retree) }\nsub p5metachar__S_008quant {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5metachar__S_008quant\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"quant\";\n$self->_MATCHIFYr($S, \"p5metachar__S_008quant\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['quantifier','p5quantifier'], sub {\nmy $C = shift;\n$C->p5quantifier\n}))\nand ($C) = ($C->panic(\"quantifier quantifies nothing\"))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5metachar__S_009Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('p5metachar__S_009Bra_Ket', $retree) }\nsub p5metachar__S_009Bra_Ket {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5metachar__S_009Bra_Ket\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\[\\ \\]\";\n$self->_MATCHIFYr($S, \"p5metachar__S_009Bra_Ket\", do {\nif (my ($C) = ($C->_SUBSUMEr(['before'], sub {\nmy $C = shift;\n$C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\[\")\n})\n}))) {\n$C->_SUBSUMEr(['quibble'], sub {\nmy $C = shift;\n$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))\n})\n} else { () }\n\n});\n}\n;\nsub p5metachar__S_010ParenQuestion_Thesis__PEEK { $_[0]->_AUTOLEXpeek('p5metachar__S_010ParenQuestion_Thesis', $retree) }\nsub p5metachar__S_010ParenQuestion_Thesis {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5metachar__S_010ParenQuestion_Thesis\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\(\\?\\ \\)\";\n$self->_MATCHIFYr($S, \"p5metachar__S_010ParenQuestion_Thesis\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\(\\?\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['assertion','p5assertion'], sub {\nmy $C = shift;\n$C->p5assertion\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\)\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Perl 5 regex assertion not terminated by parenthesis\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5metachar__S_011Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('p5metachar__S_011Paren_Thesis', $retree) }\nsub p5metachar__S_011Paren_Thesis {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5metachar__S_011Paren_Thesis\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'nibbler'} = [];\n$C->{sym} = \"\\(\\ \\)\";\n$self->_MATCHIFYr($S, \"p5metachar__S_011Paren_Thesis\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\(\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nmy $newlang = ($self->unbalanced(')'));\n$C = bless($C, (ref($newlang) || $newlang));\n$C->_SUBSUMEr(['nibbler'], sub {\nmy $C = shift;\n$C->nibbler\n})\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\)\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Unable to parse Perl 5 regex; couldn't find right parenthesis\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\nscalar(do {\nmy $M = $C;\n$M->{'sym'} = <( )> }, $C)\n} else { () }\n\n});\n}\n;\nsub p5metachar__S_012Back__PEEK { $_[0]->_AUTOLEXpeek('p5metachar__S_012Back', $retree) }\nsub p5metachar__S_012Back {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5metachar__S_012Back\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\\\\";\n$self->_MATCHIFYr($S, \"p5metachar__S_012Back\", do {\nif (my ($C) = ($C->_EXACT(\"\\\\\"))) {\n$C->_SUBSUMEr(['backslash','p5backslash'], sub {\nmy $C = shift;\n$C->p5backslash\n})\n} else { () }\n\n});\n}\n;\nsub p5metachar__S_013Dot__PEEK { $_[0]->_AUTOLEXpeek('p5metachar__S_013Dot', $retree) }\nsub p5metachar__S_013Dot {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5metachar__S_013Dot\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\.\";\n$self->_MATCHIFYr($S, \"p5metachar__S_013Dot\", $C->_EXACT(\"\\.\"));\n}\n;\nsub p5metachar__S_014Caret__PEEK { $_[0]->_AUTOLEXpeek('p5metachar__S_014Caret', $retree) }\nsub p5metachar__S_014Caret {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5metachar__S_014Caret\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\^\";\n$self->_MATCHIFYr($S, \"p5metachar__S_014Caret\", $C->_EXACT(\"\\^\"));\n}\n;\nsub p5metachar__S_015Dollar__PEEK { $_[0]->_AUTOLEXpeek('p5metachar__S_015Dollar', $retree) }\nsub p5metachar__S_015Dollar {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5metachar__S_015Dollar\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\$\";\n$self->_MATCHIFYr($S, \"p5metachar__S_015Dollar\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\$\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = (do {\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5metachar__S_015Dollar_0') {\n$C->deb(\"Fate passed to p5metachar__S_015Dollar_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5metachar__S_015Dollar_0';    \n}\nelse {\n$x = 'ALTLTM p5metachar__S_015Dollar_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5metachar__S_015Dollar_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5metachar__S_015Dollar_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\W/)\n},\nsub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\z/)\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n\n})) { ($C) } else { () }\n}))) { ($C) } else { () }\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5metachar__S_016var__PEEK { $_[0]->_AUTOLEXpeek('p5metachar__S_016var', $retree) }\nsub p5metachar__S_016var {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5metachar__S_016var\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"var\";\n$self->_MATCHIFYr($S, \"p5metachar__S_016var\", do {\nmy $C = $C;\nif (($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->_SUBSUMEr(['sigil','p5sigil'], sub {\nmy $C = shift;\n$C->p5sigil\n}))) {\n$C->_PATTERN(qr/\\G\\w/)\n} else { () }\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->panic(\"Can't interpolate variable in Perl 5 regex\"))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5backslash__S_017A__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_017A', $retree) }\nsub p5backslash__S_017A {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_017A\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"A\";\n$self->_MATCHIFYr($S, \"p5backslash__S_017A\", $C->_EXACT(\"A\"));\n}\n;\nsub p5backslash__S_018a__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_018a', $retree) }\nsub p5backslash__S_018a {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_018a\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"a\";\n$self->_MATCHIFYr($S, \"p5backslash__S_018a\", $C->_EXACT(\"a\"));\n}\n;\nsub p5backslash__S_019b__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_019b', $retree) }\nsub p5backslash__S_019b {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_019b\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"b\";\n$self->_MATCHIFYr($S, \"p5backslash__S_019b\", $C->_PATTERN(qr/\\G(?i:b)/));\n}\n;\nsub p5backslash__S_020c__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_020c', $retree) }\nsub p5backslash__S_020c {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_020c\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"c\";\n$self->_MATCHIFYr($S, \"p5backslash__S_020c\", do {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_PATTERN(qr/\\G(?i:c)(?i:[?-_])/)\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Unrecognized \\\\c character\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n});\n}\n;\nsub p5backslash__S_021d__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_021d', $retree) }\nsub p5backslash__S_021d {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_021d\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"d\";\n$self->_MATCHIFYr($S, \"p5backslash__S_021d\", $C->_PATTERN(qr/\\G(?i:d)/));\n}\n;\nsub p5backslash__S_022e__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_022e', $retree) }\nsub p5backslash__S_022e {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_022e\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"e\";\n$self->_MATCHIFYr($S, \"p5backslash__S_022e\", $C->_PATTERN(qr/\\G(?i:e)/));\n}\n;\nsub p5backslash__S_023f__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_023f', $retree) }\nsub p5backslash__S_023f {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_023f\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"f\";\n$self->_MATCHIFYr($S, \"p5backslash__S_023f\", $C->_PATTERN(qr/\\G(?i:f)/));\n}\n;\nsub p5backslash__S_024h__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_024h', $retree) }\nsub p5backslash__S_024h {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_024h\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"h\";\n$self->_MATCHIFYr($S, \"p5backslash__S_024h\", $C->_PATTERN(qr/\\G(?i:h)/));\n}\n;\nsub p5backslash__S_025l__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_025l', $retree) }\nsub p5backslash__S_025l {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_025l\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"l\";\n$self->_MATCHIFYr($S, \"p5backslash__S_025l\", $C->_PATTERN(qr/\\G(?i:l)/));\n}\n;\nsub p5backslash__S_026n__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_026n', $retree) }\nsub p5backslash__S_026n {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_026n\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"n\";\n$self->_MATCHIFYr($S, \"p5backslash__S_026n\", $C->_PATTERN(qr/\\G(?i:n)/));\n}\n;\nsub p5backslash__S_027o__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_027o', $retree) }\nsub p5backslash__S_027o {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_027o\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"o\";\n$self->_MATCHIFYr($S, \"p5backslash__S_027o\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"0\"))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5backslash__S_027o_0') {\n$C->deb(\"Fate passed to p5backslash__S_027o_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5backslash__S_027o_0';    \n}\nelse {\n$x = 'ALTLTM p5backslash__S_027o_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5backslash__S_027o_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5backslash__S_027o_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['octint'], sub {\nmy $C = shift;\n$C->octint\n})\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\}\";\nmy $goalpos = $C;\nif (($C) = ($C->_EXACT(\"\\{\"))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['octints'], sub {\nmy $C = shift;\n$C->octints\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_EXACT(\"\\}\")\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'octal character', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5backslash__S_028p__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_028p', $retree) }\nsub p5backslash__S_028p {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_028p\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"p\";\n$self->_MATCHIFYr($S, \"p5backslash__S_028p\", $C->_PATTERN(qr/\\G(?i:p)(?i:\\{)(?i:[\\w:])++(?i:\\})/));\n}\n;\nsub p5backslash__S_029Q__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_029Q', $retree) }\nsub p5backslash__S_029Q {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_029Q\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"Q\";\n$self->_MATCHIFYr($S, \"p5backslash__S_029Q\", $C->_EXACT(\"Q\"));\n}\n;\nsub p5backslash__S_030r__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_030r', $retree) }\nsub p5backslash__S_030r {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_030r\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"r\";\n$self->_MATCHIFYr($S, \"p5backslash__S_030r\", $C->_PATTERN(qr/\\G(?i:r)/));\n}\n;\nsub p5backslash__S_031s__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_031s', $retree) }\nsub p5backslash__S_031s {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_031s\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"s\";\n$self->_MATCHIFYr($S, \"p5backslash__S_031s\", $C->_PATTERN(qr/\\G(?i:s)/));\n}\n;\nsub p5backslash__S_032t__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_032t', $retree) }\nsub p5backslash__S_032t {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_032t\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"t\";\n$self->_MATCHIFYr($S, \"p5backslash__S_032t\", $C->_PATTERN(qr/\\G(?i:t)/));\n}\n;\nsub p5backslash__S_033u__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_033u', $retree) }\nsub p5backslash__S_033u {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_033u\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"u\";\n$self->_MATCHIFYr($S, \"p5backslash__S_033u\", $C->_PATTERN(qr/\\G(?i:u)/));\n}\n;\nsub p5backslash__S_034v__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_034v', $retree) }\nsub p5backslash__S_034v {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_034v\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"v\";\n$self->_MATCHIFYr($S, \"p5backslash__S_034v\", $C->_PATTERN(qr/\\G(?i:v)/));\n}\n;\nsub p5backslash__S_035w__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_035w', $retree) }\nsub p5backslash__S_035w {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_035w\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"w\";\n$self->_MATCHIFYr($S, \"p5backslash__S_035w\", $C->_PATTERN(qr/\\G(?i:w)/));\n}\n;\nsub p5backslash__S_036x__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_036x', $retree) }\nsub p5backslash__S_036x {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_036x\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"x\";\n$self->_MATCHIFYr($S, \"p5backslash__S_036x\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\G(?i:x)/))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5backslash__S_036x_0') {\n$C->deb(\"Fate passed to p5backslash__S_036x_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5backslash__S_036x_0';    \n}\nelse {\n$x = 'ALTLTM p5backslash__S_036x_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5backslash__S_036x_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5backslash__S_036x_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['hexint'], sub {\nmy $C = shift;\n$C->hexint\n})\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nlocal $::GOAL = \"\\}\";\nmy $goalpos = $C;\nif (($C) = ($C->_PATTERN(qr/\\G(?i:\\{)/))\nand ($C) = (scalar(do {\n}, $C))\nand ($C) = ($C->_SUBSUMEr(['hexints'], sub {\nmy $C = shift;\n$C->hexints\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, $C->_PATTERN(qr/\\G(?i:\\})/)\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->FAILGOAL($::GOAL, 'hex character', $goalpos))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5backslash__S_037z__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_037z', $retree) }\nsub p5backslash__S_037z {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_037z\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"z\";\n$self->_MATCHIFYr($S, \"p5backslash__S_037z\", $C->_PATTERN(qr/\\G(?i:z)/));\n}\n;\nsub p5backslash__S_038misc__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_038misc', $retree) }\nsub p5backslash__S_038misc {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_038misc\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"misc\";\n$self->_MATCHIFYr($S, \"p5backslash__S_038misc\", do {\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5backslash__S_038misc_0') {\n$C->deb(\"Fate passed to p5backslash__S_038misc_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5backslash__S_038misc_0';    \n}\nelse {\n$x = 'ALTLTM p5backslash__S_038misc_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5backslash__S_038misc_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5backslash__S_038misc_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['litchar'], sub {\nmy $C = shift;\n$C->_PAREN( sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\W/)\n\n})\n})\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['number'], sub {\nmy $C = shift;\n$C->_PAREN( sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\d++/)\n\n})\n})\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n\n});\n}\n;\nsub p5backslash__S_039oops__PEEK { $_[0]->_AUTOLEXpeek('p5backslash__S_039oops', $retree) }\nsub p5backslash__S_039oops {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5backslash__S_039oops\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"oops\";\n$self->_MATCHIFYr($S, \"p5backslash__S_039oops\", $C->panic(\"Unrecognized Perl 5 regex backslash sequence\"));\n}\n;\nsub p5assertion__S_040Question__PEEK { $_[0]->_AUTOLEXpeek('p5assertion__S_040Question', $retree) }\nsub p5assertion__S_040Question {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5assertion__S_040Question\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\?\";\n$self->_MATCHIFYr($S, \"p5assertion__S_040Question\", do {\nif (my ($C) = ($C->_EXACT(\"\\?\"))) {\n$C->_SUBSUMEr(['codeblock'], sub {\nmy $C = shift;\n$C->codeblock\n})\n} else { () }\n\n});\n}\n;\nsub p5assertion__S_041Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('p5assertion__S_041Cur_Ly', $retree) }\nsub p5assertion__S_041Cur_Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5assertion__S_041Cur_Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\{\\ \\}\";\n$self->_MATCHIFYr($S, \"p5assertion__S_041Cur_Ly\", $C->_SUBSUMEr(['codeblock'], sub {\nmy $C = shift;\n$C->codeblock\n}));\n}\n;\nsub p5assertion__S_042Lt__PEEK { $_[0]->_AUTOLEXpeek('p5assertion__S_042Lt', $retree) }\nsub p5assertion__S_042Lt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5assertion__S_042Lt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\<\";\n$self->_MATCHIFYr($S, \"p5assertion__S_042Lt\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\<\"))\nand ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = (do {\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5assertion__S_042Lt_0') {\n$C->deb(\"Fate passed to p5assertion__S_042Lt_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5assertion__S_042Lt_0';    \n}\nelse {\n$x = 'ALTLTM p5assertion__S_042Lt_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5assertion__S_042Lt_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5assertion__S_042Lt_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\=\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\!\")\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n\n})) { ($C) } else { () }\n}))) { ($C) } else { () }\n}))) {\n$C->_SUBSUMEr(['assertion','p5assertion'], sub {\nmy $C = shift;\n$C->p5assertion\n})\n} else { () }\n\n});\n}\n;\nsub p5assertion__S_043Equal__PEEK { $_[0]->_AUTOLEXpeek('p5assertion__S_043Equal', $retree) }\nsub p5assertion__S_043Equal {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5assertion__S_043Equal\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\=\";\n$self->_MATCHIFYr($S, \"p5assertion__S_043Equal\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\=\"))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5assertion__S_043Equal_0') {\n$C->deb(\"Fate passed to p5assertion__S_043Equal_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5assertion__S_043Equal_0';    \n}\nelse {\n$x = 'ALTLTM p5assertion__S_043Equal_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5assertion__S_043Equal_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5assertion__S_043Equal_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\)\")\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['rx'], sub {\nmy $C = shift;\n$C->rx\n})\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5assertion__S_044Bang__PEEK { $_[0]->_AUTOLEXpeek('p5assertion__S_044Bang', $retree) }\nsub p5assertion__S_044Bang {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5assertion__S_044Bang\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\!\";\n$self->_MATCHIFYr($S, \"p5assertion__S_044Bang\", do {\nmy $C = $C;\nif (($C) = ($C->_EXACT(\"\\!\"))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5assertion__S_044Bang_0') {\n$C->deb(\"Fate passed to p5assertion__S_044Bang_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5assertion__S_044Bang_0';    \n}\nelse {\n$x = 'ALTLTM p5assertion__S_044Bang_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5assertion__S_044Bang_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5assertion__S_044Bang_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\)\")\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n},\nsub {\nmy $C=shift;\n$C->_SUBSUMEr(['rx'], sub {\nmy $C = shift;\n$C->rx\n})\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5assertion__S_045Gt__PEEK { $_[0]->_AUTOLEXpeek('p5assertion__S_045Gt', $retree) }\nsub p5assertion__S_045Gt {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5assertion__S_045Gt\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\>\";\n$self->_MATCHIFYr($S, \"p5assertion__S_045Gt\", do {\nif (my ($C) = ($C->_EXACT(\"\\>\"))) {\n$C->_SUBSUMEr(['rx'], sub {\nmy $C = shift;\n$C->rx\n})\n} else { () }\n\n});\n}\n;\nsub rx__PEEK { $_[0]->_AUTOLEXpeek('rx', $retree) }\nsub rx {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE rx\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"rx\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['nibbler'], sub {\nmy $C = shift;\n$C->nibbler\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {    my $C = $C->cursor_xact('ALT ||');\nmy $xact = $C->xact;\nmy @gather;\ndo {\npush @gather, do {\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\)\")\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n\n}\n}\nor $xact->[-2] or\ndo {\npush @gather, do {\nif (my ($C) = ($C->panic(\"Unable to parse Perl 5 regex; couldn't find right parenthesis\"))) { ($C) } else { () }\n\n}\n};\n@gather;\n}\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5mod__PEEK { $_[0]->_AUTOLEXpeek('p5mod', $retree) }\nsub p5mod {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5mod\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"p5mod\", $C->_PATTERN(qr/\\G(?:[imox])*+/));\n}\n;\nsub p5mods__PEEK { $_[0]->_AUTOLEXpeek('p5mods', $retree) }\nsub p5mods {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5mods\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'off'} = [];\n$C->{'p5mod'} = [];\n$self->_MATCHIFYr($S, \"p5mods\", do {\nif (my ($C) = ($C->_SUBSUMEr(['on','p5mod'], sub {\nmy $C = shift;\n$C->p5mod\n}))) {\n$C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_EXACT(\"\\-\"))) {\n$C->_SUBSUMEr(['off','p5mod'], sub {\nmy $C = shift;\n$C->p5mod\n})\n} else { () }\n}))) { ($C) } else { () }\n})\n} else { () }\n\n});\n}\n;\nsub p5assertion__S_046mod__PEEK { $_[0]->_AUTOLEXpeek('p5assertion__S_046mod', $retree) }\nsub p5assertion__S_046mod {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5assertion__S_046mod\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{'rx'} = [];\n$C->{sym} = \"mod\";\n$self->_MATCHIFYr($S, \"p5assertion__S_046mod\", do {\nmy $C = $C;\nif (($C) = ($C->_SUBSUMEr(['mods','p5mods'], sub {\nmy $C = shift;\n$C->p5mods\n}))\nand ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'p5assertion__S_046mod_0') {\n$C->deb(\"Fate passed to p5assertion__S_046mod_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT p5assertion__S_046mod_0';    \n}\nelse {\n$x = 'ALTLTM p5assertion__S_046mod_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'p5assertion__S_046mod_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"p5assertion__S_046mod_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\nif (my ($C) = ($C->_EXACT(\"\\:\"))) {\n$C->_OPTr(sub {\nmy $C=shift;\n$C->_SUBSUMEr(['rx'], sub {\nmy $C = shift;\n$C->rx\n})\n})\n} else { () }\n},\nsub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\nif (my ($C) = ($C->before(sub {\nmy $C=shift;\n$C->_EXACT(\"\\)\")\n}))) { ($C) } else { () }\n}))) { ($C) } else { () }\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) {\n$C\n} else { () }\n\n});\n}\n;\nsub p5assertion__S_047bogus__PEEK { $_[0]->_AUTOLEXpeek('p5assertion__S_047bogus', $retree) }\nsub p5assertion__S_047bogus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5assertion__S_047bogus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"bogus\";\n$self->_MATCHIFYr($S, \"p5assertion__S_047bogus\", $C->panic(\"Unrecognized Perl 5 regex assertion\"));\n}\n;\nsub p5quantifier__S_048Star__PEEK { $_[0]->_AUTOLEXpeek('p5quantifier__S_048Star', $retree) }\nsub p5quantifier__S_048Star {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5quantifier__S_048Star\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\*\";\n$self->_MATCHIFYr($S, \"p5quantifier__S_048Star\", do {\nif (my ($C) = ($C->_EXACT(\"\\*\"))) {\n$C->_SUBSUMEr(['quantmod'], sub {\nmy $C = shift;\n$C->quantmod\n})\n} else { () }\n\n});\n}\n;\nsub p5quantifier__S_049Plus__PEEK { $_[0]->_AUTOLEXpeek('p5quantifier__S_049Plus', $retree) }\nsub p5quantifier__S_049Plus {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5quantifier__S_049Plus\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\+\";\n$self->_MATCHIFYr($S, \"p5quantifier__S_049Plus\", do {\nif (my ($C) = ($C->_EXACT(\"\\+\"))) {\n$C->_SUBSUMEr(['quantmod'], sub {\nmy $C = shift;\n$C->quantmod\n})\n} else { () }\n\n});\n}\n;\nsub p5quantifier__S_050Question__PEEK { $_[0]->_AUTOLEXpeek('p5quantifier__S_050Question', $retree) }\nsub p5quantifier__S_050Question {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5quantifier__S_050Question\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\?\";\n$self->_MATCHIFYr($S, \"p5quantifier__S_050Question\", do {\nif (my ($C) = ($C->_EXACT(\"\\?\"))) {\n$C->_SUBSUMEr(['quantmod'], sub {\nmy $C = shift;\n$C->quantmod\n})\n} else { () }\n\n});\n}\n;\nsub p5quantifier__S_051Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('p5quantifier__S_051Cur_Ly', $retree) }\nsub p5quantifier__S_051Cur_Ly {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE p5quantifier__S_051Cur_Ly\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$C->{sym} = \"\\{\\ \\}\";\n$self->_MATCHIFYr($S, \"p5quantifier__S_051Cur_Ly\", do {\nmy $C = $C;\nif (($C) = ($C->_PATTERN(qr/\\G\\{\\d++/))\nand ($C) = ($C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\n$C->_PATTERN(qr/\\G\\,\\d*+/)\n}))) { ($C) } else { () }\n}))\nand ($C) = ($C->_EXACT(\"\\}\"))) {\n$C->_SUBSUMEr(['quantmod'], sub {\nmy $C = shift;\n$C->quantmod\n})\n} else { () }\n\n});\n}\n;\nsub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod', $retree) }\nsub quantmod {\nno warnings 'recursion';\nmy $self = shift;\n\n\nlocal $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;\n\nmy $C = $self->cursor_xact(\"RULE quantmod\");\nmy $xact = $C->xact;\nmy $S = $C->{'_pos'};\n$self->_MATCHIFYr($S, \"quantmod\", $C->_OPTr(sub {\nmy $C=shift;\nif (my ($C) = ($C->_BRACKETr(sub {\nmy $C=shift;\ndo {\nmy ($tag, $try);\nmy @try;\nmy $relex;\n\nmy $fate;\nmy $x;\nif ($fate = $C->{'_fate'} and $fate->[1] eq 'quantmod_0') {\n$C->deb(\"Fate passed to quantmod_0: \", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;\n($C->{'_fate'}, $tag, $try) = @$fate;\n@try = ($try);\n$x = 'ALT quantmod_0';    \n}\nelse {\n$x = 'ALTLTM quantmod_0'; \n}\nmy $C = $C->cursor_xact($x);\nmy $xact = $C->{_xact};\n\nmy @gather = ();\nfor (;;) {\nunless (@try) {\n$relex //= $C->cursor_fate('STD::P5::Regex', 'quantmod_0', $retree);\n@try = $relex->($C) or last;\n}\n$try = shift(@try) // next;\n\nif (ref $try) {\n($C->{'_fate'}, $tag, $try) = @$try;   \n}\n\n$C->deb(\"quantmod_0 trying $tag $try\") if $::DEBUG & DEBUG::try_processing;\npush @gather, ((\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\?\")\n},\nsub {\nmy $C=shift;\n$C->_EXACT(\"\\+\")\n}\n)[$try])->($C);\nlast if @gather;\nlast if $xact->[-2];  \n}\n@gather;\n};\n}))) { ($C) } else { () }\n}));\n}\n;\nmoose_around tweak  => sub {\nmy $orig = shift;\nno warnings 'recursion';\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{global} || exists $args{g};\nmy $g = exists $args{global} ? delete $args{global} : exists $args{g} ? delete $args{g} : undef;\n$self     };\n}\n{\nlocal @_ = @_;\nreturn scalar do { \nmy $self = shift;\nmy %args = @_;\nlast unless exists $args{ignorecase} || exists $args{i};\nmy $i = exists $args{ignorecase} ? delete $args{ignorecase} : exists $args{i} ? delete $args{i} : undef;\n$self     };\n}\n$orig->(@_);\n};\n\n1; };\n1; }",
      "file" : "/var/tmp/arv_diXJ1E/STD-20101111/lib/STD_P5.pm",
      "package" : "STD::STD::P5"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{ package STD::Cursor;\nuse Moose ':all' => { -prefix => \"moose_\" };\nuse Encode;\nmoose_extends('CursorBase');\nour $ALLROLES = { 'STD::Cursor', 1 };\nour $REGEXES = {\nALL => [ qw// ],\n};\n\n\nno warnings 'qw', 'recursion';\nmy $retree;\n\n$DB::deep = $DB::deep = 1000; \n\nuse YAML::XS;\n\n$SIG{__WARN__} = sub { die @_,\"   statement started at line \", 'STD::Cursor'->lineof($::LASTSTATE), \"\n\" } if $::DEBUG;\n\n;\nour $BLUE    = $CursorBase::BLUE;\nour $GREEN   = $CursorBase::GREEN;\nour $CYAN    = $CursorBase::CYAN;\nour $MAGENTA = $CursorBase::MAGENTA;\nour $YELLOW  = $CursorBase::YELLOW;\nour $RED     = $CursorBase::RED;\nour $CLEAR   = $CursorBase::CLEAR;\nsub panic {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument s omitted' unless @_;\nmy $s = @_ ? shift() : undef;\n$self->deb(\"panic $s\") if $::DEBUG;\nmy $m;\nmy $here = $self;\n$m .= $s;\n$m .= $here->locmess;\n$m .= \"\\n\" unless $m =~ /\\n$/;\nprint STDERR $STD::Cursor::RED, '===', $STD::Cursor::CLEAR, 'SORRY!', $STD::Cursor::RED, '===', $STD::Cursor::CLEAR, \"\\n\";\nprint STDERR $m;\ndie \"Parse failed\\n\";\n};\nsub worry {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument s omitted' unless @_;\nmy $s = @_ ? shift() : undef;\nmy $m = $s . $self->locmess;\npush @::WORRIES, $m unless $::WORRIES{$s}++;\n$self;\n};\nsub sorry {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument s omitted' unless @_;\nmy $s = @_ ? shift() : undef;\n$self->deb(\"sorry $s\") if $::DEBUG;\nprint STDERR $STD::Cursor::RED, '===', $STD::Cursor::CLEAR, 'SORRY!', $STD::Cursor::RED, '===', $STD::Cursor::CLEAR, \"\\n\"\nunless $::IN_SUPPOSE or $::FATALS++;\nif ($s) {\nmy $m = $s;\n$m .= $self->locmess . \"\\n\" unless $m =~ /\\n$/;\nif ($::FATALS > 10 or $::IN_SUPPOSE) {\ndie $m}\nelse {\nprint STDERR $m unless $::WORRIES{$m}++};\n};\n$self;\n};\nsub locmess {\nno warnings 'recursion';\nmy $self = shift;\nmy $pos = $self->{'_pos'};\nmy $line = $self->lineof($pos);\nif ($pos >= @::MEMOS - 1) {\n$pos = $pos - 1;\n$line = $line . \" (EOF)\";\n};\nmy $pre = substr($::ORIG, 0, $pos);\n$pre = substr($pre, -40, 40);\n1 while $pre =~ s!.*\\n!!;\n$pre = '<BOL>' if $pre eq '';\nmy $post = substr($::ORIG, $pos, 40);\n1 while $post =~ s!(\\n.*)!!;\n$post = '<EOL>' if $post eq '';\n\" at \" . $::FILE->{'name'} . \" line $line:\\n------> \" . $STD::Cursor::GREEN . $pre . $STD::Cursor::YELLOW . $::PERL6HERE . $STD::Cursor::RED . \n\"$post$STD::Cursor::CLEAR\";\n};\nsub line {\nno warnings 'recursion';\nmy $self = shift;\n$self->lineof($self->{'_pos'})};\nsub lineof {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument p omitted' unless @_;\nmy $p = @_ ? shift() : undef;\nreturn 1 unless defined $p;\nmy $line = $::MEMOS[$p]->{'L'};\nreturn $line if $line;\n$line = 0;\nmy $pos = 0;\nmy @text = split(/^/,$::ORIG);\nfor (@text) {\n$line++;\n$::MEMOS[$pos++]->{'L'} = $line\nfor 1 .. length($_);\n}\n;\n$::MEMOS[$pos++]->{'L'} = $line;\nreturn $::MEMOS[$p]->{'L'} // 0;\n};\nsub SETGOAL {\nno warnings 'recursion';\nmy $self = shift;\n};\nsub FAILGOAL {\nno warnings 'recursion';\nmy $self = shift;\ndie 'Required argument stop omitted' unless @_;\nmy $stop = @_ ? shift() : undef;\ndie 'Required argument name omitted' unless @_;\nmy $name = @_ ? shift() : undef;\ndie 'Required argument startpos omitted' unless @_;\nmy $startpos = @_ ? shift() : undef;\nmy $s = \"'$stop'\";\n$s = '\"\\'\"' if $s eq \"'''\";\n$self->panic(\"Unable to parse $name\" . $startpos->locmess . \"\\nCouldn't find final $s; gave up\");\n};\n1; }",
      "file" : "/var/tmp/arv_diXJ1E/STD-20101111/lib/STD/Cursor.pm",
      "package" : "STD::Cursor"
   }
]
