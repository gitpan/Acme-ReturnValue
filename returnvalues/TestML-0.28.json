[
   {
      "PPI" : "PPI::Statement::Variable",
      "bad" : "our $DumpModule = 'YAML'",
      "file" : "/var/tmp/arv_ij6KZc/TestML-0.28/lib/TestML/Mo.pm",
      "package" : "TestML::Mo"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub make_tree {\n  {\n    '+toprule' => 'testml_document',\n    'assertion_call' => {\n      '.any' => [\n        {\n          '-wrap' => 1,\n          '.ref' => 'assertion_eq'\n        },\n        {\n          '-wrap' => 1,\n          '.ref' => 'assertion_ok'\n        },\n        {\n          '-wrap' => 1,\n          '.ref' => 'assertion_has'\n        }\n      ]\n    },\n    'assertion_call_test' => {\n      '.rgx' => qr/\\G(?:\\.(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*|(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*\\.)(?:EQ|OK|HAS)/\n    },\n    'assertion_eq' => {\n      '.any' => [\n        {\n          '-wrap' => 1,\n          '.ref' => 'assertion_operator_eq'\n        },\n        {\n          '-wrap' => 1,\n          '.ref' => 'assertion_function_eq'\n        }\n      ]\n    },\n    'assertion_function_eq' => {\n      '.all' => [\n        {\n          '.rgx' => qr/\\G(?:\\.(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*|(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*\\.)EQ\\(/\n        },\n        {\n          '.ref' => 'code_expression'\n        },\n        {\n          '.rgx' => qr/\\G\\)/\n        }\n      ]\n    },\n    'assertion_function_has' => {\n      '.all' => [\n        {\n          '.rgx' => qr/\\G(?:\\.(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*|(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*\\.)HAS\\(/\n        },\n        {\n          '.ref' => 'code_expression'\n        },\n        {\n          '.rgx' => qr/\\G\\)/\n        }\n      ]\n    },\n    'assertion_function_ok' => {\n      '.rgx' => qr/\\G(?:\\.(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*|(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*\\.)(OK)(?:\\((?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*\\))?/\n    },\n    'assertion_has' => {\n      '.any' => [\n        {\n          '-wrap' => 1,\n          '.ref' => 'assertion_operator_has'\n        },\n        {\n          '-wrap' => 1,\n          '.ref' => 'assertion_function_has'\n        }\n      ]\n    },\n    'assertion_ok' => {\n      '.ref' => 'assertion_function_ok'\n    },\n    'assertion_operator_eq' => {\n      '.all' => [\n        {\n          '.rgx' => qr/\\G(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)+==(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)+/\n        },\n        {\n          '.ref' => 'code_expression'\n        }\n      ]\n    },\n    'assertion_operator_has' => {\n      '.all' => [\n        {\n          '.rgx' => qr/\\G(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)+\\~\\~(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)+/\n        },\n        {\n          '.ref' => 'code_expression'\n        }\n      ]\n    },\n    'assignment_statement' => {\n      '.all' => [\n        {\n          '.ref' => 'variable_name'\n        },\n        {\n          '.rgx' => qr/\\G\\s+=\\s+/\n        },\n        {\n          '.ref' => 'code_expression'\n        },\n        {\n          '.ref' => 'semicolon'\n        }\n      ]\n    },\n    'blank_line' => {\n      '.rgx' => qr/\\G[\\ \\t]*\\r?\\n/\n    },\n    'block_header' => {\n      '.all' => [\n        {\n          '.ref' => 'block_marker'\n        },\n        {\n          '+max' => 1,\n          '.all' => [\n            {\n              '.rgx' => qr/\\G[\\ \\t]+/\n            },\n            {\n              '.ref' => 'block_label'\n            }\n          ]\n        },\n        {\n          '.rgx' => qr/\\G[\\ \\t]*\\r?\\n/\n        }\n      ]\n    },\n    'block_label' => {\n      '.ref' => 'unquoted_string'\n    },\n    'block_marker' => {\n      '.rgx' => qr/\\G===/\n    },\n    'block_point' => {\n      '.any' => [\n        {\n          '.ref' => 'lines_point'\n        },\n        {\n          '.ref' => 'phrase_point'\n        }\n      ]\n    },\n    'call_indicator' => {\n      '.rgx' => qr/\\G(?:\\.(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*|(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*\\.)/\n    },\n    'code_expression' => {\n      '.all' => [\n        {\n          '.ref' => 'code_object'\n        },\n        {\n          '+min' => 0,\n          '.ref' => 'unit_call'\n        }\n      ]\n    },\n    'code_object' => {\n      '.any' => [\n        {\n          '.ref' => 'function_object'\n        },\n        {\n          '.ref' => 'point_object'\n        },\n        {\n          '.ref' => 'string_object'\n        },\n        {\n          '.ref' => 'number_object'\n        },\n        {\n          '.ref' => 'transform_object'\n        }\n      ]\n    },\n    'code_section' => {\n      '+min' => 0,\n      '.any' => [\n        {\n          '.rgx' => qr/\\G(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)+/\n        },\n        {\n          '.ref' => 'assignment_statement'\n        },\n        {\n          '.ref' => 'code_statement'\n        }\n      ]\n    },\n    'code_statement' => {\n      '.all' => [\n        {\n          '.ref' => 'code_expression'\n        },\n        {\n          '+max' => 1,\n          '.ref' => 'assertion_call'\n        },\n        {\n          '.ref' => 'semicolon'\n        }\n      ]\n    },\n    'comment' => {\n      '.rgx' => qr/\\G\\#.*\\r?\\n/\n    },\n    'core_transform' => {\n      '.rgx' => qr/\\G([A-Z]\\w*)/\n    },\n    'data_block' => {\n      '.all' => [\n        {\n          '.ref' => 'block_header'\n        },\n        {\n          '+min' => 0,\n          '-skip' => 1,\n          '.any' => [\n            {\n              '.ref' => 'blank_line'\n            },\n            {\n              '.ref' => 'comment'\n            }\n          ]\n        },\n        {\n          '+min' => 0,\n          '.ref' => 'block_point'\n        }\n      ]\n    },\n    'data_section' => {\n      '+min' => 0,\n      '.ref' => 'data_block'\n    },\n    'double_quoted_string' => {\n      '.rgx' => qr/\\G(?:\"((?:[^\\n\\\\\"]|\\\\\"|\\\\\\\\|\\\\[0nt])*?)\")/\n    },\n    'function_object' => {\n      '.all' => [\n        {\n          '+max' => 1,\n          '.ref' => 'function_signature'\n        },\n        {\n          '.ref' => 'function_start'\n        },\n        {\n          '+min' => 0,\n          '.any' => [\n            {\n              '.rgx' => qr/\\G(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)+/\n            },\n            {\n              '.ref' => 'assignment_statement'\n            },\n            {\n              '.ref' => 'code_statement'\n            }\n          ]\n        },\n        {\n          '.rgx' => qr/\\G(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*\\}/\n        }\n      ]\n    },\n    'function_signature' => {\n      '.all' => [\n        {\n          '.rgx' => qr/\\G\\((?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*/\n        },\n        {\n          '+max' => 1,\n          '.ref' => 'function_variables'\n        },\n        {\n          '.rgx' => qr/\\G(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*\\)/\n        }\n      ]\n    },\n    'function_start' => {\n      '.rgx' => qr/\\G(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*(\\{)(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*/\n    },\n    'function_variable' => {\n      '.rgx' => qr/\\G([a-zA-Z]\\w*)/\n    },\n    'function_variables' => {\n      '+min' => 1,\n      '.ref' => 'function_variable',\n      '.sep' => {\n        '.rgx' => qr/\\G(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*,(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*/\n      }\n    },\n    'lines_point' => {\n      '.all' => [\n        {\n          '.ref' => 'point_marker'\n        },\n        {\n          '.rgx' => qr/\\G[\\ \\t]+/\n        },\n        {\n          '.ref' => 'point_name'\n        },\n        {\n          '.rgx' => qr/\\G[\\ \\t]*\\r?\\n/\n        },\n        {\n          '.ref' => 'point_lines'\n        }\n      ]\n    },\n    'number' => {\n      '.rgx' => qr/\\G([0-9]+)/\n    },\n    'number_object' => {\n      '.ref' => 'number'\n    },\n    'phrase_point' => {\n      '.all' => [\n        {\n          '.ref' => 'point_marker'\n        },\n        {\n          '.rgx' => qr/\\G[\\ \\t]+/\n        },\n        {\n          '.ref' => 'point_name'\n        },\n        {\n          '.rgx' => qr/\\G:[\\ \\t]/\n        },\n        {\n          '.ref' => 'point_phrase'\n        },\n        {\n          '.rgx' => qr/\\G\\r?\\n/\n        },\n        {\n          '.rgx' => qr/\\G(?:\\#.*\\r?\\n|[\\ \\t]*\\r?\\n)*/\n        }\n      ]\n    },\n    'point_lines' => {\n      '.rgx' => qr/\\G((?:(?!===|\\-\\-\\-).*\\r?\\n)*)/\n    },\n    'point_marker' => {\n      '.rgx' => qr/\\G\\-\\-\\-/\n    },\n    'point_name' => {\n      '.rgx' => qr/\\G([a-z]\\w*|[A-Z]\\w*)/\n    },\n    'point_object' => {\n      '.rgx' => qr/\\G(\\*[a-z]\\w*)/\n    },\n    'point_phrase' => {\n      '.ref' => 'unquoted_string'\n    },\n    'quoted_string' => {\n      '.any' => [\n        {\n          '.ref' => 'single_quoted_string'\n        },\n        {\n          '.ref' => 'double_quoted_string'\n        }\n      ]\n    },\n    'semicolon' => {\n      '.any' => [\n        {\n          '.rgx' => qr/\\G;/\n        },\n        {\n          '.err' => 'You seem to be missing a semicolon'\n        }\n      ]\n    },\n    'single_quoted_string' => {\n      '.rgx' => qr/\\G(?:'((?:[^\\n\\\\']|\\\\'|\\\\\\\\)*?)')/\n    },\n    'string_object' => {\n      '.ref' => 'quoted_string'\n    },\n    'testml_document' => {\n      '.all' => [\n        {\n          '.ref' => 'code_section'\n        },\n        {\n          '+max' => 1,\n          '.ref' => 'data_section'\n        }\n      ]\n    },\n    'transform_argument' => {\n      '.ref' => 'code_expression'\n    },\n    'transform_argument_list' => {\n      '.all' => [\n        {\n          '.rgx' => qr/\\G\\((?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*/\n        },\n        {\n          '+min' => 0,\n          '.ref' => 'transform_argument',\n          '.sep' => {\n            '.rgx' => qr/\\G(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*,(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*/\n          }\n        },\n        {\n          '.rgx' => qr/\\G(?:[\\ \\t]|\\r?\\n|\\#.*\\r?\\n)*\\)/\n        }\n      ]\n    },\n    'transform_name' => {\n      '.any' => [\n        {\n          '.ref' => 'user_transform'\n        },\n        {\n          '.ref' => 'core_transform'\n        }\n      ]\n    },\n    'transform_object' => {\n      '.all' => [\n        {\n          '.ref' => 'transform_name'\n        },\n        {\n          '+max' => 1,\n          '.ref' => 'transform_argument_list'\n        }\n      ]\n    },\n    'unit_call' => {\n      '.all' => [\n        {\n          '+asr' => -1,\n          '.ref' => 'assertion_call_test'\n        },\n        {\n          '.ref' => 'call_indicator'\n        },\n        {\n          '.ref' => 'code_object'\n        }\n      ]\n    },\n    'unquoted_string' => {\n      '.rgx' => qr/\\G([^\\ \\t\\n\\#](?:[^\\n\\#]*[^\\ \\t\\n\\#])?)/\n    },\n    'user_transform' => {\n      '.rgx' => qr/\\G([a-z]\\w*)/\n    },\n    'variable_name' => {\n      '.rgx' => qr/\\G([a-zA-Z]\\w*)/\n    }\n  }\n}",
      "file" : "/var/tmp/arv_ij6KZc/TestML-0.28/lib/TestML/Grammar.pm",
      "package" : "TestML::Grammar"
   },
   {
      "PPI" : "PPI::Statement::Variable",
      "bad" : "our $None = TestML::None->new",
      "file" : "/var/tmp/arv_ij6KZc/TestML-0.28/lib/TestML/Runtime.pm",
      "package" : "TestML::Runtime"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub assert_OK {\n    my $self = shift;\n    my $context = shift;\n    $self->test_builder->ok(\n        $context->bool->value,\n        $self->get_label,\n    );\n}",
      "file" : "/var/tmp/arv_ij6KZc/TestML-0.28/lib/TestML/Runtime/TAP.pm",
      "package" : "TestML::Runtime::TAP"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub Sort {\n    my $context = shift;\n    my $value = $context->list->value;\n    return list([ sort { $a->value cmp $b->value } @$value ]);\n}",
      "file" : "/var/tmp/arv_ij6KZc/TestML-0.28/lib/TestML/Library/Standard.pm",
      "package" : "TestML::Library::Standard"
   }
]
