[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method input_event( Str $data? ) {\n\t$self->log_trace(\n\t\t\"input event: \"\n\t\t\t.(defined($data)?length($data).\" byte(s)\":\"will read\")\n\t\t       );\n\tif ( defined $data and $data ne \"\") {\n\t\tpush @{ $self->input_buffer }, $data;\n\n\t}\n\n\tmy $ready = $self->input_buffer_size;\n\tmy $expected = $self->input_expect;\n\n\tif ( !defined $data ) {\n\t\t$data = $self->read_input($expected - $ready);\n\t\t$self->log_trace(\n\t\t\t\"input_event read \".length($data).\" byte(s)\"\n\t\t       );\n\t\tif ( length($data) == 0 ) {\n\t\t\t$self->empty_read;\n\t\t}\n\t\telse {\n\t\t\tpush @{ $self->input_buffer }, $data;\n\t\t}\n\t}\n\n\tmy $got_chunk;\n\n\twhile ( $self->input_buffer_size >= $expected ) {\n\t\tmy $data = $expected\n\t\t\t? $self->input_buffer_read($expected)\n\t\t\t: \"\";\n\t\tif ( $self->input_state eq \"expect_length\" ) {\n\t\t\t$self->input_state(\"expect_data\");\n\t\t\t$self->input_expect(unpack(\"N\", $data)-4);\n\t\t\t$self->log_trace(\n\t\t\t\t\"expecting \".$self->input_expect.\" byte(s)\"\n\t\t\t       );\n\t\t}\n\t\telse {\n\t\t\t$self->log_trace(\n\t\t\t\t\"got complete packet, calling input_packet\"\n\t\t\t       );\n\t\t\t$self->input_state(\"expect_length\");\n\t\t\t$self->input_packet($data);\n\t\t\t$self->input_expect(4);\n\t\t\t$self->log_trace(\n\t\t\t\t\"now expecting length packet\"\n\t\t\t       );\n\t\t}\n\t\t$expected = $self->input_expect;\n\t\t$got_chunk = 1;\n\t}\n\n\tif ( $self->input_ready ) {\n\t\t$self->log_trace(\n\t\t\t\"done input_event, but more input ready - yielding input_event\"\n\t\t       );\n\t\t$self->yield(\"input_event\");\n\t}\n\n\treturn $got_chunk;\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Packets.pm",
      "package" : "SRS::EPP::Packets"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method verify_detached(Str $data, Str $signature, :$cert, :$key_text) {\n\tif ( $key_text ) {\n\t\t$cert ||= $self->get_cert_from_key_text($key_text);\n\t}\n\tmy $pgp = $self->pgp;\n\tmy $res = $pgp->verify(\n\t\tData => byte_string($data),\n\t\tSignature => $signature,\n\t\t( $cert ? (Key => $cert) : () ),\n\t       );\n\tif ( $res ) {\n\t\tmy $res_neg = $pgp->verify(\n\t\t\tData => \"xx.$$.\".rand(3),\n\t\t\tSignature => $signature,\n\t\t\t( $cert ? (Key => $cert) : () ),\n\t\t       );\n\t\tif ( $res and $res_neg ) {\n\t\t\t$res = 0;\n\t\t}\n\t}\n\twarn $pgp->errstr if !$res && $pgp->errstr;\n\treturn $res;\n}\n\nmethod detached_sign(Str $data, $key?, $passphrase?) {\n\t$key ||= $self->default_signing_key;\n\tmy $pgp = $self->pgp;\n\tmy $signature = $pgp->sign(\n\t\tData => byte_string($data),\n\t\tDetach => 1,\n\t\tArmour => 1,\n\t\tDigest => \"SHA1\",\n\t\tPassphrase => $passphrase//\"\",\n\t\tKey => $key,\n\t       );\n\n\tcarp \"Signing attempt failed: \", $pgp->errstr() unless $signature;\n\treturn $signature;\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/OpenPGP.pm",
      "package" : "SRS::EPP::OpenPGP"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method shutdown() {\n\t$self->log_info( \"shutting down session\" );\n\t$self->state(\"Shutting down\");\n\t$self->stalled(1);\n\t$self->shutting_down(1);\n\t$self->yield(\"output_event\");\n}\n\nmethod input_timeout() {\n\t$self->shutdown;\n}\n\nmethod do_close() {\n\t$self->log_debug( \"shutting down Socket\" );\n\t$self->socket->shutdown(1);\n\t$self->log_debug( \"shutting down user agent\" );\n\t$self->user_agent(undef);\n\t$self->input_event_watcher->cancel;\n\t$self->event->unloop_all;\n}\n\nmethod empty_read() {\n\t$self->log_info( \"detected EOF on input\" );\n\t$self->do_close;\n}\n\nmethod output_event() {\n\tmy $oq = $self->output_queue;\n\tmy $written = 0;\n\tmy $io = $self->io;\n\twhile ( @$oq ) {\n\t\tmy $datum = shift @$oq;\n\t\tmy $wrote = $io->write( $datum );\n\t\tif ( $wrote <= 0 ) {\n\t\t\t$self->log_debug(\"error on write? \\$! = $!\");\n\t\t\tunshift @$oq, $datum;\n\t\t\tlast;\n\t\t}\n\t\telse {\n\t\t\t$written += $wrote;  \n\t\t\tif ( $wrote < bytes::length $datum ) {\n\t\t\t\tunshift @$oq, bytes::substr $datum, $wrote;\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t}\n\t$self->log_trace(\n\t\"output_event wrote $written bytes, \".@$oq.\" chunk(s) remaining\"\n\t\t);\n\tif ( @$oq ) {\n\t\t$self->output_event_watcher->start;\n\t}\n\telse {\n\t\t$self->output_event_watcher->stop;\n\t\t$self->log_info(\"flushed output to client\");\n\t\tif ( $self->shutting_down ) {\n\t\t\t$self->check_queues;\n\t\t\tif ( !keys %{$self->yielding} ) {\n\t\t\t\t$self->do_close;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$self->log_debug(\n\t\t\t\"shutdown still pending: @{[keys %{$self->yielding}]}\"\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\treturn $written;\n}\n\nmethod log_packet(Str $label, Str $data) {\n\t$data =~ s{([\\0-\\037])}{chr(ord($1)+0x2400)}eg;\n\t$data =~ s{([,\\|])}{chr(ord($1)+0xff00-0x20)}eg;\n\tmy @data;\n\twhile ( length $data ) {\n\t\tpush @data, substr $data, 0, 1024, \"\";\n\t}\n\tfor (my $i = 0; $i <= $#data; $i++ ) {\n\t\tmy $n_of_n = (@data > 1 ? \" [\".($i+1).\" of \".@data.\"]\" : \"\");\n\t\t$self->log_info(\n\t\t\t\"$label message$n_of_n: \"\n\t\t\t\t.encode(\"utf8\", $data[$i]),\n\t\t\t);\n\t}\n}\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Session.pm",
      "package" : "SRS::EPP::Session"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method init() {\n\n\tmy @sockets;\n\tfor my $addr ( @{ $self->listen } ) {\n\n\t\tmy ($hostname, $port) = $addr =~\n\t\t\tm{^(?|\\[([^]]+)\\]|([^:]+))(?::(\\d+))?$}\n\t\t\t\tor die \"bad listen address: $addr\";\n\t\t$port ||= EPP_DEFAULT_LOCAL_PORT;\n\n\t\tmy @addr = resolve($hostname);\n\t\t$self->log_debug(\"$hostname resolved to @addr\");\n\n\t\tfor my $addr ( @addr ) {\n\t\t\tmy $SOCKET_TYPE = \"IO::Socket::INET\";\n\t\t\tif ( $addr =~ /:/ ) {\n\t\t\t\t$SOCKET_TYPE .= \"6\";\n\t\t\t}\n\t\t\tmy $socket = $SOCKET_TYPE->new(\n\t\t\t\tListen => 5,\n\t\t\t\tLocalAddr => $addr,\n\t\t\t\tLocalPort => $port,\n\t\t\t\tProto => \"tcp\",\n\t\t\t\tReuseAddr => 1,\n\t\t\t       );\n\n\t\t\tmy $addr_port = fmt_addr_port($addr,$port);\n\n\t\t\tif ( !$socket ) {\n\t\t\t\t$self->log_error(\n\t\t\t\t\"Failed to listen on $addr_port; $!\",\n\t\t\t\t       );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$self->log_info(\n\t\t\t\t\t\"Listening on $addr_port\",\n\t\t\t\t       );\n\t\t\t\tpush @sockets, $socket;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( !@sockets ) {\n\t\tdie \"No listening sockets; aborting\";\n\t}\n\n\t@{ $self->sockets } = @sockets;\n}\n\nmethod accept( Int $timeout? ) {\n\tmy $select = IO::Select->new();\n\t$select->add($_) for @{$self->sockets};\n\tmy @ready = $select->can_read( $timeout )\n\t\tor return;\n\twhile ( @ready > 1 ) {\n\t\tif ( rand(1) > 0.5 ) {\n\t\t\tshift @ready;\n\t\t}\n\t\telse {\n\t\t\tpop @ready;\n\t\t}\n\t}\n\tmy $socket = $ready[0]->accept;\n\tif ( !$socket ) {\n\t\tdie \"accept lost a socket; exiting\";\n\t}\n\t$socket;\n}\n\nmethod close() {\n\tfor my $socket ( @{ $self->sockets } ) {\n\t\t$socket->close if $socket;\n\t}\n\t@{ $self->sockets } = ();\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Proxy/Listener.pm",
      "package" : "SRS::EPP::Proxy::Listener"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method loop() {\n\t$SIG{TERM} = sub { exit(0) };\n\twhile ( 1 ) {\n\t\t$self->log_trace(\"UA waiting for request\");\n\t\t$0 = __PACKAGE__.\" - idle\";\n\t\tmy $request = eval { fd_retrieve($self->read_fh) }\n\t\t\tor do {\n\t\t\t\tlast;\n\t\t\t};\n\t\t$self->log_debug(\"sending a request to back-end\");\n\t\t$0 = __PACKAGE__.\" - active\";\n\t\tmy $response = $self->ua->request($request);\n\t\t$self->log_debug(\"got response - writing to response socket\");\n\t\t$0 = __PACKAGE__.\" - responding\";\n\t\tstore_fd $response, $self->write_fh;\n\t\t$self->write_fh->flush;\n\t}\n\t$self->log_trace(\"UA exiting\");\n\texit(0);\n}\n\nmethod request( HTTP::Request $request ) {\n\tdie \"sorry, can't handle a request in state '\".$self->state.\"'\"\n\t\tunless $self->waiting;\n\t$self->log_trace(\"writing request to child UA socket\");\n\tstore_fd $request, $self->write_fh;\n\t$self->write_fh->flush;\n\t$self->log_trace(\"flushed\");\n\t$self->state(\"busy\");\n}\n\nmethod get_response() {\n\tdie \"sorry, not ready yet\" unless $self->ready;\n\tmy $response = retrieve_fd($self->read_fh);\n\t$self->state(\"waiting\");\n\treturn $response;\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Proxy/UA.pm",
      "package" : "SRS::EPP::Proxy::UA"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method process( SRS::EPP::Session $session ) {\n\t$session->shutdown;\n\t$self->make_response(code => 1500);\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Logout.pm",
      "package" : "SRS::EPP::Command::Logout"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method process( SRS::EPP::Session $session ) {\n  $self->session($session);\n\n  my $epp = $self->message;\n  my $message = $epp->message;\n  my $op = $message->argument->op;\n\n  if ( $op eq \"req\" ) {\n    return XML::SRS::GetMessages->new(\n      queue => 1,\n      max_results => 1,\n      type_filter => [\n        XML::SRS::GetMessages::TypeFilter->new(Type => \"third-party\"),\n        XML::SRS::GetMessages::TypeFilter->new(Type => \"server-generated-data\"),\n      ],\n    );\n  }\n\n  if ( $op eq \"ack\" ) {\n    my $msgId = $message->argument->msgID;\n    my ($registrar_id,$client_id) = $msgId =~ m/(....)(.*)/;\n    return XML::SRS::AckMessage->new(\n      transaction_id => $client_id,\n      originating_registrar => $registrar_id+0,\n      action_id => $message->client_id || sprintf(\"auto.%x\",time()),\n    );\n  }\n\n  return $self->make_response(code => 2400);\n}\n\nsub extract_fact {\n  my  ($self,$action,$domain) = @_;\n\n  if ( $action eq \"DomainTransfer\" ) {\n    my $name = $domain->TransferredDomain();\n    return XML::EPP::Domain::Info::Response->new(\n      name => $name,\n      roid => substr(md5_hex($name), 0, 12) . '-DOM',\n      transfer_date => $domain->timestamptz,\n      status => [],\n    );\n  }\n\n  if ( my $udai = $domain->UDAI() ) {\n    return XML::EPP::Domain::Info::Response->new(\n      name => $domain->name,\n      roid => substr(md5_hex($domain->name), 0, 12) . '-DOM',\n      status => [ SRS::EPP::Command::Info::Domain::getEppStatuses($domain) ],\n      auth_info => XML::EPP::Domain::AuthInfo->new(\n        pw => XML::EPP::Common::Password->new(\n          content => $udai,\n        ),\n      ),\n    );\n  }\n\n  if ( $domain->audit()->comment() =~ m/RenewDomains/ ) {\n    return XML::EPP::Domain::Info::Response->new(\n      name => $domain->name,\n      roid => substr(md5_hex($domain->name), 0, 12) . '-DOM',\n      status => [ SRS::EPP::Command::Info::Domain::getEppStatuses($domain) ],\n      expiry_date => $domain->billed_until->timestamptz,\n    ),\n  }\n\n  return SRS::EPP::Command::Info::Domain::buildInfoResponse($domain);\n}\n\nmethod notify( SRS::EPP::SRSResponse @rs ) {\n  my $epp = $self->message;\n\n  my $message = $rs[0]->message;\n  my $responses = $message->responses;\n\n  if ( !(scalar @$responses) ) {\n    return $self->make_response(code => 1300);\n  }\n\n  if ( my $response = $responses->[0] ) {\n\n    if ( $response->isa(\"XML::SRS::Message::Ack::Response\") ) {\n      $self->remaining($response->remaining());\n      my $msgQ = XML::EPP::MsgQ->new(\n        count => $self->remaining(), \n        id => sprintf(\"%04d%s\",$response->registrar_id(),$response->tx_id()),\n      );\n      return $self->make_response(code => 1000, msgQ => $msgQ);\n    }\n\n    if ( $response->isa(\"XML::SRS::Message\") ) {\n      my $record = $response->result();\n\n      my $id = sprintf(\"%04d%s\",$record->by_id,$record->client_id);\n      my $msgQ = XML::EPP::MsgQ->new(\n        count => $self->remaining(), \n        id => $id,\n      );\n\n      for my $resp ( $record->response() ) {\n        my $action = $record->action();\n        if ( my $fact = $self->extract_fact($action,$resp) ) {\n          return $self->make_response(code => 1301, payload => $fact, msgQ => $msgQ);\n        }\n      }\n    }\n  }\n\n  return $self->make_response(code => 2400);\n}\n\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Poll.pm",
      "package" : "SRS::EPP::Command::Poll"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method process( SRS::EPP::Session $session ) {\n\t$self->make_response(\"Greeting\");\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Hello.pm",
      "package" : "SRS::EPP::Command::Hello"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method process( SRS::EPP::Session $session ) {\n    $self->session($session);\n    my $epp = $self->message;\n    my $payload = $epp->message->argument->payload;\n\n    if ( $payload->has_auth_info ) {\n        return $self->make_response(code => 2307);\n    }\n\n\treturn (\n        XML::SRS::Whois->new(\n            domain => $payload->name->value,\n            full => 0,\n        ),\n        XML::SRS::Domain::Query->new(\n            domain_name_filter => $payload->name->value\n        )\n    );\n}\n\nmethod notify( SRS::EPP::SRSResponse @rs ) {\n    my $whois = $rs[0]->message->response;\n    my $domain = $rs[1]->message->response;\n\n    if ( $whois->status eq 'Available' ) {\n        return $self->make_response(code => 2303);\n    }\n\n    unless ( $domain ) {\n        return $self->make_response(code => 2201);\n    }\n\n    my $payload = $self->message->message->argument->payload;\n\n    return $self->make_response(\n        code => 1000,\n        payload => buildInfoResponse($domain),\n    );\n}\n\nsub buildInfoResponse {\n  my ($domain) = @_;\n\n  my $nsList;\n  if ( $domain->nameservers ) {\n      my @nameservers = map { $_->fqdn } @{$domain->nameservers->nameservers};\n      $nsList = XML::EPP::Domain::NS::List->new( ns => [ @nameservers ] );\n  }\n\n  return XML::EPP::Domain::Info::Response->new(\n      name => $domain->name,\n      roid => substr(md5_hex($domain->name), 0, 12) . '-DOM',\n      status => [ getEppStatuses($domain) ],\n      ($nsList ? (ns => $nsList) : ()),\n      client_id => sprintf(\"%03d\",$domain->registrar_id()), \n      created => ($domain->registered_date())->timestamptz, \n      expiry_date => ($domain->billed_until())->timestamptz, \n      updated => ($domain->audit->when->begin())->timestamptz, \n  );\n}\n\nsub getEppStatuses {\n  my ($domain) = @_;\n\n  my @status;\n  if ( $domain->delegate() == 0 ) {\n      push @status, 'inactive';\n  }\n  elsif ( $domain->status eq 'PendingRelease' ) {\n      push @status, 'pendingDelete';\n  }\n  elsif ( defined $domain->locked_date() ) {\n      push @status, qw( serverDeleteProhibited serverHold serverRenewProhibited serverTransferProhibited serverUpdateProhibited );\n  }\n  else {\n      push @status, 'ok';\n  }\n\n  return map { XML::EPP::Domain::Status->new( status => $_ ) } @status\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Info/Domain.pm",
      "package" : "SRS::EPP::Command::Info::Domain"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method notify( SRS::EPP::SRSResponse @rs ) {\n    my $message = $rs[0]->message;\n    my $response = $message->response;\n\n    if ( $self->code ) {\n        return $self->make_response(code => $self->code);\n    }\n\n    unless ( $response ) {\n        return $self->make_response(code => 2303);\n    }\n\n    my $r = XML::EPP::Contact::Info::Response->new(\n        id => $response->handle_id,\n        postal_info => [ XML::EPP::Contact::PostalInfo->new(\n            name => $response->name,\n            addr => XML::EPP::Contact::Addr->new(\n                street => [ $response->address->address1, $response->address->address2],\n                city   => $response->address->city,\n                sp     => $response->address->region, \n                pc     => $response->address->postcode,\n                cc     => $response->address->cc,\n            ),\n        ) ],\n        voice => XML::EPP::Contact::E164->new(\n            content => \"+\" . $response->phone->cc . \".\" . $response->phone->ndc . $response->phone->subscriber,\n        ),\n        email => $response->email,\n    );\n\n    return $self->make_response(\n        code => 1000,\n        payload => $r,\n    );\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Info/Contact.pm",
      "package" : "SRS::EPP::Command::Info::Contact"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method process( SRS::EPP::Session $session ) {\n  $self->session($session);\n\n  my $epp = $self->message;\n  my $message = $epp->message;\n  my $payload = $message->argument->payload;\n\n  my $op = $message->argument->op;\n\n  if ( $op eq \"request\" ) {\n    my $auth = $payload->auth_info();\n    my $pass = $auth->pw();\n    my $udaiType = Moose::Util::TypeConstraints::find_type_constraint(\"XML::SRS::UDAI\");\n    if ( ! $udaiType->check($pass->content()) ) {\n      return $self->make_response(code => 2202);\n    }\n\n    return (\n      XML::SRS::Whois->new(\n        domain => $payload->name,\n        full => 0,\n      ),\n      XML::SRS::Domain::Update->new(\n        filter => [$payload->name],\n        action_id => $message->client_id || sprintf(\"auto.%x\",time()),\n        udai => $pass->content(),\n      ),\n    );\n  }\n\n  if ( $op eq \"query\" ) {\n    my $msg = \"This server does support pending transfers\";\n    return $self->make_response(code => 2102, extra => $msg);\n  }\n\n  return $self->make_response(code => 2400);\n}\n\nmethod notify( SRS::EPP::SRSResponse @rs ) {\n  my $epp = $self->message;\n\n  for ( @rs ) {\n    my $message = $_->message;\n    my $response = $message->response;\n\n    if ( $response ) {\n      if ( $message->action() eq \"Whois\" ) {\n        if ( $response->status eq \"Available\" ) {\n          return $self->make_response(code => 2303);\n        }\n      }\n      if ( $message->action() eq \"DomainUpdate\" ) {\n        if ( $response->isa(\"XML::SRS::Domain\") ) {\n          return $self->make_response(code => 1000);\n        }\n      }\n    }\n  }\n\n  return $self->make_response(code => 2400);\n}\n\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Transfer/Domain.pm",
      "package" : "SRS::EPP::Command::Transfer::Domain"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method process( SRS::EPP::Session $session ) {\n    return $self->make_response(code => 2106);\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Transfer/Contact.pm",
      "package" : "SRS::EPP::Command::Transfer::Contact"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method process( SRS::EPP::Session $session ) {\n    $self->session($session);\n\n    my $epp = $self->message;\n    my $message = $epp->message;\n    my $payload = $message->argument->payload;\n\n\n    my $contacts = $payload->contact;\n\n    my $contact_registrant = XML::SRS::Contact->new( handle_id => $payload->registrant() );\n    my ($contact_admin, $contact_technical);\n    foreach my $contact ( @$contacts ) {\n        if ( $contact->type eq 'admin' ) {\n            $contact_admin = XML::SRS::Contact->new( handle_id => $contact->value );\n        }\n        if ( $contact->type eq 'tech' ) {\n            $contact_technical = XML::SRS::Contact->new( handle_id => $contact->value );\n        }\n    }\n\n    my $ns = $payload->ns->ns;\n    my $list = XML::SRS::Server::List->new(\n        nameservers => [ map { XML::SRS::Server->new( fqdn => $_ ) } @$ns ],\n        );\n\n    return XML::SRS::Domain::Create->new(\n        domain_name => $payload->name(),\n        term => 1, \n        contact_registrant => $contact_registrant,\n        contact_admin => $contact_admin,\n        contact_technical => $contact_technical,\n        nameservers => $list,\n        action_id => $message->client_id || sprintf('auto.%x',time()),\n    );\n}\n\nmethod notify( SRS::EPP::SRSResponse @rs ) {\n    my $epp = $self->message;\n    my $eppMessage = $epp->message;\n    my $eppPayload = $eppMessage->argument->payload;\n\n    my $message = $rs[0]->message;\n    my $response = $message->response;\n\n    if ( $response->isa('XML::SRS::Error') ) {\n        my $error = $response->error_id;\n        if ( $error eq 'HANDLE_DOES_NOT_EXIST' ) {\n            return $self->make_response(code => 2201);\n        }\n        elsif ( $error eq 'DOMAIN_ALREADY_EXISTS' ) {\n            return $self->make_response(code => 2201);\n        }\n        return $self->make_response(code => 2400);\n    }\n\n    my $r = XML::EPP::Domain::Create::Response->new(\n        name => $response->name,\n        created => $response->registered_date->timestamptz,\n        expiry_date => $response->billed_until->timestamptz,\n    );\n\n    return $self->make_response(\n        code => 1000,\n        payload => $r,\n    );\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Create/Domain.pm",
      "package" : "SRS::EPP::Command::Create::Domain"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method process( SRS::EPP::Session $session ) {\n  $self->session($session);\n\n  my $epp = $self->message;\n  my $message = $epp->message;\n  my $payload = $message->argument->payload;\n\n\n  my $epp_postal_info = $payload->postal_info();\n  if ( (scalar @$epp_postal_info) != 1 ) {\n    return $self->make_response(code => 2400);\n  }\n  my $postalInfo = $epp_postal_info->[0];\n\n  if ( $postalInfo->org ) {\n    return $self->make_response(code => 2306);\n  }\n\n  my $postalInfoAddr = $postalInfo->addr();\n  my $street = $postalInfoAddr->street();\n  my $address = XML::SRS::Contact::Address->new(\n    address1 => $street->[0],\n    city => $postalInfoAddr->city,\n    region => $postalInfoAddr->sp,\n    cc => $postalInfoAddr->cc,\n    postcode => $postalInfoAddr->pc,\n  );\n  if ( $address ) {\n    if ( $street->[1] ) {\n      $address->address2($street->[1]);\n    }\n\n    my $txn = {\n      handle_id => $payload->id(),\n      name => $postalInfo->name(),\n      phone => $payload->voice()->content(),\n      address => $address,\n      email => $payload->email(),\n      action_id => $message->client_id || sprintf(\"auto.%x\",time()),\n    };\n    if ( $payload->fax()->content() ) {\n      $txn->{fax} = $payload->fax()->content();\n    }\n    if ( my $srsTxn =  XML::SRS::Handle::Create->new(%$txn) ) {\n      return $srsTxn;\n    }\n  }\n\n  return $self->make_response(code => 2400);\n}\n\n\nmethod notify( SRS::EPP::SRSResponse @rs ) {\n  my $epp = $self->message;\n  my $eppMessage = $epp->message;\n  my $eppPayload = $eppMessage->argument->payload;\n\n  my $message = $rs[0]->message;\n  my $response = $message->response;\n\n  if ( $response->isa(\"XML::SRS::Handle\") ) {\n    return $self->make_response(code => 1000);\n  }\n\n  return $self->make_response(code => 2400);\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Create/Contact.pm",
      "package" : "SRS::EPP::Command::Create::Contact"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method process( SRS::EPP::Session $session ) {\n    $self->session($session);\n    my $epp = $self->message;\n    my $message = $epp->message;\n\n    my $payload = $message->argument->payload;\n    my $action_id = $message->client_id || sprintf(\"auto.%x\",time());\n\n    return XML::SRS::Domain::Update->new(\n            filter => [$payload->name],\n            action_id => $action_id,\n            cancel => 1,\n            full_result => 0,\n            );\n}\n\nmethod notify( SRS::EPP::SRSResponse @rs ) {\n  my $message = $rs[0]->message;\n  my $response = $message->response;\n\n  if ( ! $response ) {\n    return $self->make_response(code => 2303);\n  } \n  if ( $response->isa(\"XML::SRS::Error\") ) {\n    return $self->make_response(code => 2400);\n  } \n  if ( $response->status eq \"Available\" ) {\n    return $self->make_response(code => 1000);\n  }\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Delete/Domain.pm",
      "package" : "SRS::EPP::Command::Delete::Domain"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method process( SRS::EPP::Session $session ) {\n    $self->session($session);\n    my $epp = $self->message;\n    my $message = $epp->message;\n\n    my $payload = $message->argument->payload;\n    my $action_id = $message->client_id || sprintf(\"auto.%x\",time());\n\n    return XML::SRS::Handle::Update->new(\n            handle_id => $payload->id,\n            action_id => $action_id,\n            delete => 1,\n            );\n}\n\nmethod notify( SRS::EPP::SRSResponse @rs ) {\n  my $message = $rs[0]->message;\n  my $response = $message->response;\n\n  if ( ! $response ) {\n    return $self->make_response(code => 1000);\n  }\n\n  if ( $response->isa(\"XML::SRS::Error\") ) {\n    if ( $response->error_id() eq \"HANDLE_DOES_NOT_EXIST\" ) {\n      return $self->make_response(code => 2303);\n    }\n  }\n  return $self->make_response(code => 2400);\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Delete/Contact.pm",
      "package" : "SRS::EPP::Command::Delete::Contact"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method notify( SRS::EPP::SRSResponse @rs ) {\n    $self->avail({ map { $_->message->response->handle_id => 1 } grep { $_->message->response } @rs });\n\n    my $epp = $self->message;\n    my $payload = $epp->message->argument->payload;\n\n    my $ids = $payload->ids;\n    my $avail = $self->avail();\n\n    my @ids = map { XML::EPP::Contact::Check::ID->new(\n                        name => $_,\n                        available => ($avail->{$_} ? 0 : 1),\n                        ) } @$ids;\n\n    my $status = XML::EPP::Contact::Check::Status->new(\n        id_status => \\@ids,\n    );\n\n    my $r = XML::EPP::Contact::Check::Response->new(\n        items => [ $status ],\n    );\n\n    return $self->make_response(\n        code => 1000,\n        payload => $r,\n        );\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Check/Contact.pm",
      "package" : "SRS::EPP::Command::Check::Contact"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method notify( SRS::EPP::SRSResponse @rs ) {\n  my $epp = $self->message;\n  my $eppMessage = $epp->message;\n  my $eppPayload = $eppMessage->argument->payload;\n\n  my $message = $rs[0]->message;\n  my $response = $message->response;\n\n  if ( ! $self->billed_until() ) {\n\n    if ( $response ) {\n      if ( $response->status eq \"Available\" ) {\n        return $self->make_response(code => 2303);\n      }\n      if ( my $billDate = $response->billed_until() ) {\n          if ( ! $self->duplicateRenew($billDate,$eppPayload->expiry_date) ) {\n            $self->billed_until($response->billed_until());\n            return XML::SRS::Domain::Update->new(\n              filter => [$response->name],\n              action_id => $eppMessage->client_id || sprintf(\"auto.%x\",time()),\n              renew => 1,\n              term => $eppPayload->period->value,\n              );\n          }\n      }\n    }\n    return $self->make_response(code => 2400);\n  }\n\n  if ( ! $response ) {\n    return $self->make_response(code => 2201);\n  }\n\n  if ( $response->can(\"billed_until\") ) {\n    return $self->make_response(code => 1000);\n  }\n\n  return $self->make_response(code => 2400);\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Command/Renew/Domain.pm",
      "package" : "SRS::EPP::Command::Renew::Domain"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method queue_size() {\n\tsum 0, map { scalar @$_ } @{$self->queue};\n}\nmethod queue_flat() {\n\tmap { @$_ } @{$self->queue};\n}\n\nmethod backend_next( Int $how_many = 1 ) {\n\treturn unless $how_many;\n\tmy $sent = $self->sent;\n\tmy $waiting = $self->queue_size - $sent;\n\t$how_many = $waiting if $how_many > $waiting;\n\tmy @rv = ($self->queue_flat)[ $sent .. $sent + $how_many - 1 ];\n\t$self->sent($sent + @rv);\n\treturn @rv;\n}\n\nmethod backend_pending() {\n\tmy $sent = $self->sent;\n\tmy $waiting = $self->queue_size - $sent;\n\treturn $waiting;\n}\n\nmethod add_backend_response( SRS::EPP::SRSRequest $request, SRS::EPP::SRSResponse $response )\n{\n\tmy $rq_a = $self->queue->[0];\n\tmy $rs_a = $self->responses->[0];\n\tfor ( my $i = 0; $i <= $#$rq_a; $i++ ) {\n\t\tif ( $rq_a->[$i] == $request ) {\n\t\t\t$rs_a->[$i] = $response;\n\t\t}\n\t}\n}\n\nmethod backend_response_ready() {\n\tmy $rq_a = $self->queue->[0]\n\t\tor return;\n\tmy $rs_a = $self->responses->[0];\n\t@$rq_a == @$rs_a;\n}\n\nmethod dequeue_backend_response() {\n\tif ( $self->backend_response_ready ) {\n\t\tmy $rq_a = shift @{ $self->queue };\n\t\tmy $owner = shift @{ $self->owner };\n\t\tmy $rs_a = shift @{ $self->responses };\n\t\tmy $sent = $self->sent;\n\t\t$sent -= scalar @$rq_a;\n\t\tif ( $sent < 0 ) {\n\t\t\twarn \"Bug: sent < 0 ?\";\n\t\t\t$sent = 0;\n\t\t}\n\t\t$self->sent($sent);\n\n\t\tif ( wantarray ) {\n\t\t\t($owner, @$rs_a);\n\t\t}\n\t\telse {\n\t\t\t$owner->notify(@$rs_a);\n\t\t}\n\t}\n\telse {\n\t\t();\n\t}\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Session/BackendQ.pm",
      "package" : "SRS::EPP::Session::BackendQ"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method next_command() {\n\tmy $q = $self->queue;\n\tmy $next = $self->next;\n\tif ( my $item = $q->[$next] ) {\n\t\t$self->add_next(1);\n\t\treturn $item;\n\t}\n\telse {\n\t\t();\n\t}\n}\n\nmethod commands_queued() {\n\tmy $q = $self->queue;\n\treturn scalar(@$q);\n}\n\nmethod queue_command( SRS::EPP::Command $cmd ) {\n\tpush @{ $self->queue }, $cmd;\n\tpush @{ $self->responses }, undef;\n}\n\nmethod add_command_response( SRS::EPP::Response $response, SRS::EPP::Command $cmd? )\n{\n\tmy $q = $self->queue;\n\tmy $rs = $self->responses;\n\tmy $ok;\n\tfor ( my $i = 0; $i <= $#$q; $i++ ) {\n\t\tif ( ($cmd and $q->[$i] == $cmd) or\n\t\t\t!defined $rs->[$i] ) {\n\t\t\t$rs->[$i] = $response;\n\t\t\t$ok = 1;\n\t\t\tlast;\n\t\t}\n\t}\n\tconfess \"Could not queue response, not found\" if !$ok;\n}\n\nmethod response_ready() {\n\tdefined($self->responses->[0]);\n}\n\nmethod dequeue_response() {\n\tif ( $self->response_ready ) {\n\t\tmy $cmd = shift @{ $self->queue };\n\t\tmy $response = shift @{ $self->responses };\n\t\t$self->add_next(-1);\n\t\tif ( wantarray ) {\n\t\t\t($response, $cmd);\n\t\t}\n\t\telse {\n\t\t\t$response;\n\t\t}\n\t}\n\telse {\n\t\t();\n\t}\n}\n\n1",
      "file" : "/var/tmp/arv_0jTMdA/SRS-EPP-Proxy-0.21/lib/SRS/EPP/Session/CmdQ.pm",
      "package" : "SRS::EPP::Session::CmdQ"
   }
]
