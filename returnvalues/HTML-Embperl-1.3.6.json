[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub Execute\n\n    {\n    my $req = shift ;\n    \n    my $cwd ;\n    my $filename = norm_path ($req -> {inputfile}, $cwd) ;\n    my $r        ;\n    $r = $req -> {req_rec} if ($req -> {req_rec}) ;\n\n    if (exists $req -> {filesmatch} && \n                         !($filename =~ m{$req->{filesmatch}})) \n        {\n        return &DECLINED ;\n        }\n\n    if (exists $req -> {decline} && \n                         ($filename =~ m{$req->{decline}})) \n        {\n        return &DECLINED ;\n        }\n\n\n    my $basename  = $req -> {object_base} ;\n    $basename     =~ s/%modifier%/$req->{object_base_modifier}/ ;\n    my $addpath   =  $req -> {object_addpath}  ;\n    my @addpath   = $addpath?split (/$HTML::Embperl::pathsplit:/, $addpath):() ;\n    my $directory ;\n    my $rootdir   = $r?norm_path ($r -> document_root, $cwd):\"$volume/\" ;\n    my $stopdir   = norm_path ($req -> {object_stopdir}, $cwd) ;\n    my $debug     = $req -> {debug} & HTML::Embperl::dbgObjectSearch ;\n    \n    if (-d $filename)\n        {\n        $directory = $filename ;\n        }\n    else\n        {\n        $directory = dirname ($filename) ;\n        }\n    \n    my $searchpath  ;\n    \t \n    $r -> notes ('EMBPERL_orgfilename',  $filename) if ($r) ;\n \n    print HTML::Embperl::LOG \"[$$]EmbperlObject Request Filename: $filename\\n\" if ($debug);\n    print HTML::Embperl::LOG \"[$$]EmbperlObject basename: $basename\\n\"  if ($debug);\n    \n    my $fn ;\n    my $ap ;\n    my $ldir  = '' ;\n    my $found = 0 ;\n    my $fallback = 0 ;\n    \t\n    do\n        {\n        $fn = \"$directory/$basename\" ;\n        $searchpath .= \";$directory\" ; \n        print HTML::Embperl::LOG \"[$$]EmbperlObject Check for base: $fn\\n\"  if ($debug);\n        if (-e $fn)\n            {\n            $r -> filename ($fn) if ($r) ;\n            $found = 1 ;\n            }\n        else\n            {\n\t    $ldir      = $directory ;\n            $directory = dirname ($directory) ;\n            }\n        }\n    while (!$found && $ldir ne $rootdir && $ldir ne $stopdir && $directory ne '/' && $directory ne '.' && $directory ne $ldir) ;\n\n    while ($found && $stopdir && $stopdir ne $directory && $directory ne '/' && $directory ne '.' && $directory ne $ldir) \n        {\n\t$ldir      = $directory ;\n        $directory = dirname ($directory) ;\n        $searchpath .= \";$directory\" ; \n        }\n\n    $searchpath .= \";$addpath\" if ($addpath) ; \n    if (!$found)\n        {\n        foreach $ap (@addpath)\n            {\n            next if (!$ap) ;\n            $fn = \"$ap/$basename\" ;\n            print HTML::Embperl::LOG \"[$$]EmbperlObject Check for base: $fn\\n\"  if ($debug);\n            if (-e $fn)\n                {\n                $r -> filename ($fn) if ($r) ;\n                $found = 1 ;\n                last ;\n                }\n\n            }\n        }\n\n\n    if ($found)\n        {\n        print HTML::Embperl::LOG \"[$$]EmbperlObject Found Base: $fn\\n\"  if ($debug);\n        print HTML::Embperl::LOG \"[$$]EmbperlObject path: $searchpath\\n\"  if ($debug);\n        my ($basenew, $basepackage) = HTML::Embperl::GetPackageOfFile ($fn, $req -> {'package'} || '', -M _, $ENV{EMBPERL_EP1COMPAT} || 0) ;\n\n        if (!-f $filename && exists $req -> {object_fallback})\n            {\n            $fallback = 1 ;\n            $filename = $req -> {object_fallback} ;\n            print HTML::Embperl::LOG \"[$$]EmbperlObject use fallback: $filename\\n\"  if ($debug);\n            $r -> notes ('EMBPERL_orgfilename',  $filename) if ($r) ;\n            }\n\n\n        my ($new, $package)  ;\n        ($new, $package) = HTML::Embperl::GetPackageOfFile ($filename, $req -> {'package'} || '', -M _, $ENV{EMBPERL_EP1COMPAT} || 0) if (!$fallback) ;\n\n        if ($basenew)\n            {\n            print HTML::Embperl::LOG \"[$$]EmbperlObject new Base: $fn, package = $basepackage\\n\"  if ($debug);\n            \n            HTML::Embperl::Execute ({%$req, inputfile => $fn, import => 0 }) ;\n\n            }\n        no strict ;\n        if (!@{\"$basepackage\\:\\:ISA\"})\n            {\n            @{\"$basepackage\\:\\:ISA\"} = ($req -> {object_handler_class} || 'HTML::Embperl::Req') ;\n            }\n        use strict ;\n\n        if ($new || $fallback)\n            {\n            print HTML::Embperl::LOG \"[$$]EmbperlObject new file: $filename, package = $package\\n\"  if ($debug && !$fallback);\n            \n            HTML::Embperl::Execute ({%$req, inputfile => $filename, import => 0, 'path' => $searchpath }) ;\n\n            if ($fallback)\n                {\n                $package = $HTML::Embperl::evalpackage ;\n                print HTML::Embperl::LOG \"[$$]EmbperlObject new file: $filename, package = $package\\n\"  if ($debug);\n                }\n            }\n\n        no strict ;\n        if (!@{\"$package\\:\\:ISA\"})\n            {\n            @{\"$package\\:\\:ISA\"} = ($basepackage) if ($package ne $basepackage) ;\n            }\n        use strict ;\n\n        $req -> {'inputfile'} = $ENV{PATH_TRANSLATED} = $fn ;\n        $req -> {'bless'}     = $package ;\n        $req -> {'path'}      = $searchpath ;\n        $req -> {'reqfilename'} = $filename if ($filename ne $fn) ;\n        return HTML::Embperl::Execute ($req) ;\n        }\n\n   \n    $r -> log_error (\"EmbperlObject searched '$searchpath'\" . ($addpath?\" and '$addpath' \":''))  if ($r) ;\n\n    return &NOT_FOUND ;\n    }",
      "file" : "/var/tmp/arv_9qNPOQ/HTML-Embperl-1.3.6/EmbperlObject.pm",
      "package" : "HTML::EmbperlObject"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub Execute\n\n    {\n    my ($req) = @_ ;\n\n    my $data ;\n    my @errors ;\n\n    $req -> {options} ||= &HTML::Embperl::optDisableHtmlScan | &HTML::Embperl::optRawInput | \n                          &HTML::Embperl::optKeepSpaces      | &HTML::Embperl::optReturnError;\n    \n    $req -> {escmode} ||= 0 ;\n    $req -> {output}   = \\$data ;\n    $req -> {errors} ||= \\@errors ;\n\n    HTML::Embperl::Execute ($req) ;\n\n    die \"@errors\" if (@errors) ;\n\n    eval\n        {\n        require Net::SMTP ;\n        \n        $req -> {mailhost} ||= $ENV{'EMBPERL_MAILHOST'} || 'localhost' ;\n\n        my $helo = $req -> {mailhelo} || $ENV{'EMBPERL_MAILHELO'} ;\n\n        my $smtp = Net::SMTP->new($req -> {mailhost},\n                                  Debug => ($req -> {maildebug} || $ENV{'EMBPERL_MAILDEBUG'} || 0),\n                                  ($helo?(Hello => $helo):()) \n                                  ) or die \"Cannot connect to mailhost $req->{mailhost}\" ;\n\n        my $from =  $req -> {from} || $ENV{'EMBPERL_MAILFROM'} ;\n        $smtp->mail($from || \"WWW-Server\\@$ENV{SERVER_NAME}\");\n\n        my $to ;\n        if (ref ($req -> {'to'}))\n            {\n            $to = $req -> {'to'} ;\n            }\n        else\n            {\n            $to = [] ;\n            @$to = split (/\\s*;\\s*/, $req -> {'to'}) ;\n            }\n\n        my $cc ;\n        if (ref ($req -> {'cc'}))\n            {\n            $cc = $req -> {'cc'} ;\n            }\n        else\n            {\n            $cc = [] ;\n            @$cc = split (/\\s*;\\s*/, $req -> {'cc'}) ;\n            }\n\n        my $bcc ;\n        if (ref ($req -> {'bcc'}))\n            {\n            $bcc = $req -> {'bcc'} ;\n            }\n        else\n            {\n            $bcc = [] ;\n            @$bcc = split (/\\s*;\\s*/, $req -> {'bcc'}) ;\n            }\n\n        my $headers = $req->{mailheaders} ;        \n        $smtp -> to (@$to, @$cc, @$bcc) ;\n\n        $smtp->data() or die \"smtp data failed\" ;\n        $smtp->datasend(\"Reply-To: $req->{'reply-to'}\\n\") or die \"smtp data failed\"  if ($req->{'reply-to'}) ;\n        $smtp->datasend(\"From: $from\\n\") if ($from) ;\n        $smtp->datasend(\"To: \" . join (', ', @$to) . \"\\n\")  or die \"smtp datasend failed\" ;\n        $smtp->datasend(\"Cc: \" . join (', ', @$cc) . \"\\n\")  or die \"smtp datasend failed\" if ($req -> {'cc'}) ;\n        $smtp->datasend(\"Subject: $req->{subject}\\n\") or die \"smtp datasend failed\" ;\n        if (ref ($headers) eq 'ARRAY')\n            {\n            foreach (@$headers)\n                {\n                $smtp->datasend(\"$_\\n\") or die \"smtp datasend failed\" ;\n                }\n            }\n        $smtp->datasend(\"\\n\")  or die \"smtp datasend failed\" ;\n        $data =~ s/\\r//g ;\n\t$smtp->datasend($data)  or die \"smtp datasend failed\" ;\n        $smtp->quit or die \"smtp quit failed\" ; \n        } ;\n\n    if ($@)\n        {\n        die \"$@\" if (ref ($req -> {errors}) eq \\@errors) ;\n\n        push @{$req -> {errors}}, $@ ;\n        }\n\n    return ref ($req -> {errors})?@{$req -> {errors}}:0 ;\n    }",
      "file" : "/var/tmp/arv_9qNPOQ/HTML-Embperl-1.3.6/Embperl/Mail.pm",
      "package" : "HTML::Embperl::Mail"
   }
]
