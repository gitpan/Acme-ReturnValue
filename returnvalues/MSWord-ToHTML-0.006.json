[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method get_html {\n    my $base_html = $self->extract_base_html(@_);\n    return $self->html_to_html5($base_html);\n}\n\nmethod get_dom($file) {\n    return $self->parser->parse_file($file);\n}\n\nmethod extract_base_html {\n    my $new_file =\n      io->catfile( io->tmpdir, sha1_hex( $self->file->slurp ) . '.html' );\n    system( 'abiword', '-t', 'html', '-o', $new_file, $self->file );\n    return $self->pre_clean_html($new_file);\n}\n\nmethod prepare_charset($html) {\n    return utf8::decode($html)\n      if utf8::is_utf8($html);\n    my $decoder = Encode::Guess->guess($html);\n    if ( ref($decoder) ) {\n      return $decoder->decode($html);\n    }\n    else {\n      return $html;\n    }\n}\n\nmethod pre_clean_html($html) {\n    my $text         = $self->prepare_charset( $html->all );\n    my $tree_builder = HTML::TreeBuilder->new;\n    my $tree         = $tree_builder->parse($text);\n    my @ps           = $tree->look_down( '_tag', 'p' );\n    my @spans        = $tree->look_down( '_tag', 'span' );\n\n    for my $verbose (@ps) {\n      $verbose->attr( 'dir', undef );\n    }\n    for my $verbose (@spans) {\n      $verbose->attr( 'xml:lang', undef );\n      $verbose->attr( 'lang',     undef );\n    }\n\n    my @all_ps = $tree->look_down( '_tag', 'p' );\n    for my $all_p (@all_ps) {\n      foreach my $content ( $all_p->content_refs_list ) {\n        next if ref $$content;\n        $$content =~ s/\\s+//g  if $$content =~ /\\A\\s+\\z/;\n        $$content =~ s/\\R/ /g  if $$content =~ /\\R/;\n        $$content =~ s/\\s+/ /g if $$content =~ /\\s+/;\n      }\n    }\n\n    my @all_spans = $tree->look_down( '_tag', 'span' );\n    for my $all_span (@all_spans) {\n      foreach my $content ( $all_span->content_refs_list ) {\n        next if ref $$content;\n        $$content =~ s/\\s+//g  if $$content =~ /\\A\\s+\\z/;\n        $$content =~ s/\\R/ /g  if $$content =~ /\\R/;\n        $$content =~ s/\\s+/ /g if $$content =~ /\\s+/;\n      }\n    }\n\n    my $file = io(\"$html\")->utf8->print( $tree->as_HTML );\n    $tree->delete;\n    return $file;\n}\n\nmethod post_clean_html( IO::All $html, Str $title) {\n    my $tree_builder = HTML::TreeBuilder->new;\n    my $tree = $tree_builder->parse( HTML::Entities::decode( $html->all ) );\n\n    my $html_tag = $tree->look_down( '_tag', 'html' );\n    $html_tag->attr( 'xmlns', undef );\n\n    my $meta = $tree->look_down( '_tag', 'meta', 'name', 'generator' );\n    $meta->delete;\n\n    my $title_obj = $tree->look_down( '_tag', 'title' );\n    if ($title) {\n      foreach my $title_content ( $title_obj->content_refs_list ) {\n        next if ref $$title_content;\n        $$title_content = $title;\n      }\n    }\n\n    my @style_tags = $tree->look_down( '_tag', 'style' );\n\n    for my $style (@style_tags) {\n      my $parsed_style;\n      {\n        local *STDERR;\n        local *STDOUT;\n        open( STDOUT, '>', File::Spec->devnull() );\n        open( STDERR, '>', File::Spec->devnull() );\n        $parsed_style = $self->css->read_string( $style->as_HTML );\n      }\n      next unless $parsed_style;\n      my @selectors;\n      for my $parsed (@$parsed_style) {\n        push @selectors, $parsed->selectors;\n      }\n      if ( any { $_ =~ /#toc/ } @selectors ) {\n        $style->delete;\n      }\n    }\n\n    $tree = $self->filter_css($tree);\n\n\n    my @ps = $tree->look_down( '_tag', 'p' );\n    for my $p (@ps) {\n      $p->attr( 'class', undef );\n      $p->attr( 'style', undef );\n    }\n\n    my @spans = $tree->look_down( '_tag', 'span' );\n    for my $s (@spans) {\n      $s->attr( 'class', undef );\n      $s->attr( 'style', undef );\n    }\n\n    my @empty_spans = $tree->look_down( '_tag', 'span', 'id', undef );\n    for my $empty_span (@empty_spans) {\n      $empty_span->replace_with_content->delete;\n    }\n\n    my @classed_elements =\n      $tree->look_down( sub { defined $_[0]->attr('class') } );\n    for my $classed (@classed_elements) {\n      $classed->attr( 'class', undef );\n    }\n\n    my @footnotes =\n      $tree->look_down( '_tag', 'span',\n      sub { $_[0]->attr('id') =~ /footnote/ } );\n    for my $footnote (@footnotes) {\n      my $id = $footnote->attr('id');\n      my $anchor = $footnote->look_down( '_tag', 'a' );\n      $anchor->attr( 'id', $id );\n      my $new = HTML::Element->new('sup');\n      $new->push_content( $footnote->detach_content );\n      $footnote->replace_with($new);\n    }\n\n    my $final_style_tag = $tree->look_down( '_tag', 'style' );\n    $final_style_tag->delete;\n\n\n    if ( @footnotes > 0 ) {\n      my @divs = $tree->look_down( '_tag', 'div' );\n      $divs[$#divs]->attr( 'id', 'footnotes' );\n    }\n    my $text = $tree->as_HTML;\n    $tree->delete;\n    io(\"$html\")->print($text);\n    return $html;\n}\n\nmethod filter_css($tree) {\n    my $style_tag = $tree->look_down( '_tag', 'style' );\n    my $parsed_style;\n    {\n      local *STDERR;\n      local *STDOUT;\n      open( STDOUT, '>', File::Spec->devnull() );\n      open( STDERR, '>', File::Spec->devnull() );\n      my $style_string = HTML::Entities::decode( $style_tag->as_HTML );\n      $style_string =~ s/font\\-family\\:'.+?'//g;\n      $parsed_style = $self->css->read_string($style_string);\n    }\n\n    if ($parsed_style) {\n      my @italic_selectors = grep { $_ }\n        map {\n        $_->selectors =~ /^(?<tag>\\w+\\.)(?<class>\\w+)$/;\n        $+{class};\n        }\n        grep { $_->properties =~ /italic/ } @$parsed_style;\n      my @bold_selectors = grep { $_ }\n        map {\n        $_->selectors =~ /^(?<tag>\\w+\\.)(?<class>\\w+)$/;\n        $+{class};\n        }\n        grep { $_->properties =~ /bold/ } @$parsed_style;\n      my %bolds          = map  { $_ => 1 } @bold_selectors;\n      my @both_selectors = grep { defined $bolds{$_} } @italic_selectors;\n      my %array_for      = (\n        both   => \\@both_selectors,\n        bold   => \\@bold_selectors,\n        italic => \\@italic_selectors\n      );\n\n      for my $type (qw/both bold italic/) {\n        for my $selector ( @{ $array_for{$type} } ) {\n          if ($selector) {\n            my @to_filter = $tree->look_down( 'class', $selector );\n            if ( @to_filter > 0 ) {\n              for my $el (@to_filter) {\n                if ( $type eq 'both' ) {\n                  my $new_bold   = HTML::Element->new('strong');\n                  my $new_italic = HTML::Element->new('em');\n                  $new_bold->push_content( $el->detach_content );\n                  $new_italic->push_content($new_bold);\n                  $el->replace_with($new_italic);\n                }\n                else {\n                  my $new =\n                    $type eq 'bold'\n                    ? HTML::Element->new('strong')\n                    : HTML::Element->new('em');\n                  $new->push_content( $el->detach_content );\n                  $el->replace_with($new);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return $tree;\n}\n\nmethod html_to_html5( IO::All $base_html) {\n    try {\n      system(\n        \"tidy\",                  \"-f\",\n        \"$base_html.err\",        \"-m\",\n        \"--clean\",               \"yes\",\n        \"--preserve-entities\",   \"yes\",\n        \"--indent-cdata\",        \"yes\",\n        \"--escape-cdata\",        \"yes\",\n        \"--repeated-attributes\", \"keep-last\",\n        \"--char-encoding\",       \"utf8\",\n        \"--output-encoding\",     \"utf8\",\n        \"--merge-spans\",         \"yes\",\n        \"-quiet\",                \"--bare\",\n        \"yes\",                   \"--logical-emphasis\",\n        \"yes\",                   \"--word-2000\",\n        \"yes\",                   \"--drop-empty-paras\",\n        \"yes\",                   \"--drop-font-tags\",\n        \"yes\",                   \"--drop-proprietary-attributes\",\n        \"yes\",                   \"--hide-endtags\",\n        \"no\",                    \"-language\",\n        \"en\",                    \"--add-xml-decl\",\n        \"yes\",                   \"--output-xhtml\",\n        \"yes\",                   \"--doctype\",\n        \"strict\",                \"$base_html\"\n      );\n    }\n    catch {\n      \"I could not tidy the base_html: $_\";\n    };\n\n    ( my $title = $self->file->filename ) =~ s/\\s+/ /g;\n    $title =~ s/\\(|\\)|\\-//g;\n    $title =~ /\\A(?<filename>.+?)(?<extension>\\.\\w+)\\z/g;\n    my $new_title = $+{filename} || 'Untitled';\n    $new_title =~ s/[[:punct:]]/ /g;\n\n    ( my $filename = lc $self->file->filename ) =~ s/\\s+/_/g;\n    $filename =~ s/\\(|\\)|\\-//g;\n    $filename =~ /\\A(?<filename>.+?)(?<extension>\\.\\w+)\\z/g;\n    $filename = $+{filename};\n    $filename =~ s/[[:punct:]]/_/g;\n\n    $base_html = io(\"$base_html\")->utf8;\n    my $cleaned_html = $self->post_clean_html( $base_html, $new_title );\n    my $new_dom      = $self->parser->parse_html_fh( io(\"$cleaned_html\") );\n    my $html5        = $self->writer->document($new_dom);\n\n    my $html5_file = io->catfile( io->tmpdir, $filename . '.html' )->utf8->print($html5);\n    my $html5_images = \"$base_html\" . \"_files\";\n    my $new_filename = $html5_file->file;\n    return MSWord::ToHTML::HTML->new(\n      file => \"$new_filename\",\n      ( -e $html5_images ? ( images => $html5_images ) : () )\n    );\n}\n\n1",
      "file" : "/var/tmp/arv_b412vR/MSWord-ToHTML-0.006/lib/MSWord/ToHTML/Roles/HasHTML.pm",
      "package" : "MSWord::ToHTML::Roles::HasHTML"
   }
]
