[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub coalesce {\n\trequire Date::Parse;\n\tmy $intervals = shift() || [];\n\tmy %epoch_map = ();\n\tmy ($flag, $repeat) = (0,1);\n\t\n\tforeach my $int (@{$intervals}) {\n\t\tforeach (@{$int}){\n\t\t\t\n\t\t\tmy $epoch = \"\";\n\t\t\tif ($_ =~/^(\\d{10})$/){\n\t\t\t\t$epoch = $1;\n\t\t\t}else{\n\t\t\t\tmy $epoch = Date::Parse::str2time($_);\n\t\t\t}\n\t\t\t$epoch_map{$epoch} = $_;\n\t\t\t$_ = $epoch;\n\t\t}\n\t}\n\n\t@{$intervals} = sort { $a->[0] <=> $b->[0] } @{$intervals};\n\t\n\twhile ($repeat == 1) {\n\t\t@{$intervals} = sort {\n\t\t\tif ( (ref($a) eq \"ARRAY\") && (ref($b) eq \"ARRAY\") ){\n\t\t\t\n\t\t\t\tif (($b->[0] >= $a->[0]) && ($b->[0] <= $a->[1])){\n\t\t\t\t\tif ($b->[1] > $a->[1]){ $a->[1] = $b->[1]; }\n\t\t\t\t\t$b = ();\n\t\t\t\t\t$flag = 1;\n\t\t\t\t\treturn (1);\n\t\t\t\t}elsif (($a->[0] >= $b->[0]) && ($a->[0] <= $b->[1])){\n\t\t\t\t\tif ($a->[1] > $b->[1]){ $b->[1] = $a->[1]; }\n\t\t\t\t\t$a = ();\n\t\t\t\t\t$flag = 1;\n\t\t\t\t\treturn (0);\n\t\t\t\t}else{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\n\t\t\t}else{\n\t\t\t\treturn (1);\n\t\t\t}\n\t\n\t\t} @{$intervals};\n\t\n\t\tmy $i = 0;\n\t\tforeach (@{$intervals}){\n\t\t\tif ( ref($_) ne \"ARRAY\" ){ splice (@{$intervals}, $i, 1); }\n\t\t\t$i ++;\n\t\t}\n\t\t\n\t\tif ($flag == 1){ \n\t\t\t$repeat = 1;  \n\t\t\t$flag = 0;\n\t\t}else{ \n\t\t\t$repeat = 0;\n\t\t}\n\t}\n\t\n\tforeach my $pair (@{$intervals}){\n\t\tif ( ref($pair) eq \"ARRAY\"){\n\t\t\tforeach (@{$pair}){ $_ = $epoch_map{$_}; }\n\t\t}\n\t}\n\t\n\tmy $i = 0;\n\tforeach (@{$intervals}){\n\t\tunless (ref($_) eq \"ARRAY\"){ splice (@{$intervals}, $i, 1); }\n\t\t$i ++;\n\t}\n\treturn ($intervals);\n}",
      "file" : "/var/tmp/arv_ZQigBx/Time-Interval-1.232/Interval.pm",
      "package" : "Time::Interval"
   }
]
