[
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\nuse strict;\n\npackage Net::Google;\nuse base qw (Net::Google::tool);\n\nuse Carp;\n\n$Net::Google::VERSION     = '1.0';\n\n$Net::Google::QUERY_LIMIT = 1000;\n$Net::Google::KEY_QUERIES = {};\n\n\n\nsub new {\n  my $pkg = shift;\n\n  my $self = {};\n  bless $self,$pkg;\n\n  if (! $self->init(@_)) {\n    return undef;\n  }\n\n  return $self;\n}\n\nsub init {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : {@_};\n\n  $self->{'_debug'}      = $args->{'debug'};\n  $self->{'_key'}        = $args->{'key'};\n  $self->{'_http_proxy'} = $args->{'http_proxy'};\n\n\n  return 1;\n}\n\n\n\n\n\n\nsub http_proxy {\n  my $self = shift;\n  my $uri  = shift;\n\n  if ($uri) {\n    $self->{'_http_proxy'} = $uri;\n  }\n\n  return $self->{'_http_proxy'};\n}\n\n\nsub search {\n  my $self = shift;\n  require Net::Google::Search;\n  return Net::Google::Search->new($self->_parse_args(@_));\n}\n\n\nsub spelling {\n  my $self = shift;\n  require Net::Google::Spelling;\n  return Net::Google::Spelling->new($self->_parse_args(@_));\n}\n\n\nsub speling { return shift->spelling(@_); }\n\n\nsub cache {\n  my $self = shift;\n  require Net::Google::Cache;\n  return Net::Google::Cache->new($self->_parse_args(@_));\n}\n\n\n\n\nsub _parse_args {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : {@_};\n\n  foreach my $el (\"key\",\"debug\",\"http_proxy\") {\n    next if (defined($args->{$el}));\n    $args->{$el} = $self->{\"_$el\"};\n  }\n\n  return $args;\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_wFavfy/Net-Google-1.0/lib/Net/Google.pm",
      "package" : "Net::Google"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\nuse strict;\npackage Net::Google::Cache;\nuse base qw (Net::Google::tool);\n\nuse Carp;\n\n$Net::Google::Cache::VERSION   = '1.0';\n\n\n\nsub new {\n  my $pkg = shift;\n\n  my $self = {};\n  bless $self,$pkg;\n\n  if (! $self->init(@_)) {\n    return undef;\n  }\n\n  return $self;\n}\n\nsub init {\n  my $self = shift;\n\n  my $args = $self->SUPER::init(\"cache\",@_)\n    || return 0;\n\n\n  if ($args->{'url'}) {\n    $self->url($args->{'url'});\n  }\n\n  return 1;\n}\n\n\n\n\n\n\n\nsub url {\n  my $self = shift;\n  my $url  = shift;\n\n  if (defined($url)) {\n    $self->{'_url'} = $url;\n  }\n\n  return $self->{'_url'};\n}\n\n\nsub get {\n  my $self = shift;\n\n  $self->_queries(1);\n\n  return $self->{'_service'}->doGetCachedPage(\n\t\t\t\t\t      $self->key(),\n\t\t\t\t\t      $self->url(),\n\t\t\t\t\t     );\n}\n\n\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_wFavfy/Net-Google-1.0/lib/Net/Google/Cache.pm",
      "package" : "Net::Google::Cache"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\nuse strict;\n\npackage Net::Google::Spelling;\nuse base qw (Net::Google::tool);\n\nuse Carp;\n\n$Net::Google::Spelling::VERSION   = '1.0';\n\n\n\nsub new {\n  my $pkg = shift;\n\n  my $self = {};\n  bless $self,$pkg;\n\n  if (! $self->init(@_)) {\n    return undef;\n  }\n\n  return $self;\n}\n\nsub init {\n  my $self    = shift;\n\n  my $args = $self->SUPER::init(\"spelling\",@_)\n    || return 0;\n\n\n  if ($args->{'phrase'}) {\n    defined($self->phrase( (ref($args->{'phrase'}) eq \"ARRAY\") ? @{$args->{'phrase'}} : $args->{'phrase'} )) || return 0;\n  }\n  \n  return 1;\n}\n\n\n\n\n\n\n\nsub phrase {\n  my $self  = shift;\n  my @words = @_;\n\n  if ((scalar(@words) > 1) && ($words[0] == \"\")) {\n    $self->{'_phrase'} = [];\n  }\n\n  if (@words) {\n    push @{$self->{'_phrase'}} , @words;\n  }\n\n  return join(\"\",@{$self->{'_phrase'}});\n}\n\n\nsub suggest {\n  my $self = shift;\n\n  $self->_queries(1);\n\n  return $self->{'_service'}->doSpellingSuggestion(\n\t\t\t\t\t\t   $self->key(),\n\t\t\t\t\t\t   $self->phrase(),\n\t\t\t\t\t\t  );\n}\n\n\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_wFavfy/Net-Google-1.0/lib/Net/Google/Spelling.pm",
      "package" : "Net::Google::Spelling"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\nuse strict;\n\npackage Net::Google::Search;\nuse base qw (Net::Google::tool);\n\nuse Carp;\nuse Net::Google::Response;\n\n$Net::Google::Search::VERSION   = '1.0';\n\nuse constant RESTRICT_ENCODING => qw [ arabic gb big5 latin1 latin2 latin3 latin4 latin5 latin6 greek hebrew sjis euc-jp euc-kr cyrillic utf8 ];\n\nuse constant RESTRICT_LANGUAGES => qw [ ar zh-CN zh-TW cs da nl en et fi fr de el iw hu is it ja ko lv lt no pt pl ro ru es sv tr ];\n\nuse constant RESTRICT_COUNTRIES => qw [ AD AE AF AG AI AL AM AN AO AQ AR AS AT AU AW AZ BA BB BD BE BF BG BH BI BJ BM BN BO BR BS BT BV BW BY BZ CA CC CD CF CG CH CI CK CL CN CO CR CU CV CX CY CZ DE DJ DK DM DO DZ EC EE EG EH ER ES ET EU FI FJ FK FM FO FR FX GA GD GE GF GH GI GL GM GN GP GQ GR GS GT GU GW GY HK HM HN HR HT HU ID IE IL IO IQ IR IS IT JM JO JP KE KG KH KI KM KN KP KR KW KY KZ LA LB LC LI LK LR LS LT LU LV LY MA MC MD MG MH MK ML MM MN MO MP MQ MR MS MT MU MV MW MX MY MZ NA NC NE NF NG NI ML NO NP NR NU NZ OM PA PE PF PG PH PK PL PM PN PR PS PT PW PY QA RE RO RU RW SA SB SC SD SE SG SH SI SJ SK SL SM SN SO SR ST SV SY SZ TC TD TF TG TH TJ TK TM TN TO TP TR TT TV TW TZ UA UG UK UM US UY UZ VA VC VE VG VI VN VU WF WS YE YT YU ZA ZM ZR ];\n\nuse constant RESTRICT_TOPICS => qw [ unclesam linux mac bsd ];\n\nuse constant WATCH => \"__estimatedTotalResultsCount\";\n\n\n\nsub new {\n  my $pkg = shift;\n  \n  my $self = {};\n  bless $self,$pkg;\n\n  if (! $self->init(\"search\",@_)) {\n    return undef;\n  }\n\n  return $self;\n}\n\nsub init {\n  my $self = shift;\n\n  my $args = $self->SUPER::init(@_)\n    || return 0;\n\n\n  $self->{'_query'}       = [];\n  $self->{'_lr'}          = [];\n  $self->{'_restrict'}    = [];\n  $self->{'_safe'}        = 0;\n  $self->{'_filter'}      = 0;\n  $self->{'_starts_at'}   = 0;\n  $self->{'_max_results'} = 10;\n\n  $self->starts_at(($args->{'starts_at'} || 0));\n  $self->max_results(($args->{'max_results'}) || 10);\n\n  if ($args->{lr}) {\n    defined($self->lr( ((ref($args->{'lr'}) eq \"ARRAY\") ? @{$args->{'lr'}} : $args->{'lr'}) )) || return 0;\n  }\n\n  if ($args->{restrict}) {\n    defined($self->restrict( ((ref($args->{'restrict'}) eq \"ARRAY\") ? @{$args->{'restrict'}} : $args->{'restrict'}) )) || return 0;\n  }\n\n  if (defined($args->{'filter'})) {\n    defined($self->filter($args->{'filter'})) || return 0;\n  }\n\n  if (defined($args->{'safe'})) {\n    defined($self->safe($args->{'safe'})) || return 0;\n  }\n\n  if (defined($args->{'starts_at'})) {\n    defined($self->starts_at($args->{'starts_at'})) || return 0;\n  }\n\n  if (defined($args->{'max_results'})) {\n    defined($self->max_results($args->{'max_results'})) || return 0;\n  }\n\n  return 1;\n}\n\n\nsub ie {\n    carp \"The 'ie' method has been deprecated\";\n}\n\nsub oe {\n    carp \"The 'oe' method has been deprecated\";\n}\n\n\n\n\n\n\nsub query {\n  my $self = shift;\n  my @data = @_;\n\n  if ((scalar(@data) > 1) && ($data[0] eq \"\")) {\n    $self->{'_query'} = [];\n  }\n\n  if (@data) {\n    push @{$self->{'_query'}}, @data;\n  }\n\n  return join(\" \",@{$self->{'_query'}});\n}\n\n\nsub starts_at {\n  my $self = shift;\n  my $at   = shift;\n\n  if (defined($at)) {\n    $self->{'_starts_at'} = $at;\n  }\n\n  return $self->{'_starts_at'};\n}\n\n\nsub max_results {\n  my $self = shift;\n  my $max  = shift;\n\n  if (defined($max)) {\n\n    if (int($max) < 1) {\n      carp \"'$max' must be a int greater than 0\";\n      $max = 1;\n    }\n\n    $self->{'_max_results'} = $max;\n  }\n\n  return $self->{'_max_results'};\n}\n\n\nsub restrict {\n  my $self  = shift;\n  my @types = @_;\n\n  if ((scalar(@types) > 1) && ($types[0] eq \"\")) {\n    $self->{'_restrict'} = [];\n    shift @types;\n  }\n\n  if (@types) {\n    push @{$self->{'_restrict'}},@types;\n  }\n  \n  return join(\"\",@{$self->{'_restrict'}});\n}\n\n\nsub filter {\n  my $self = shift;\n  my $bool = shift;\n\n \n  if (defined($bool)) {\n    $self->{'_filter'} = ($bool) ? 1 : 0;\n  }\n\n  return $self->{'_filter'};\n}\n\n\nsub safe {\n  my $self = shift;\n  my $bool = shift;\n\n  if (defined($bool)) {\n    $self->{'_safe'} = ($bool) ? 1 : 0;\n  }\n\n  return $self->{'_safe'};\n}\n\n\nsub lr {\n  my $self = shift;\n  my @lang = @_;\n\n  if ((scalar(@lang) > 1) && ($lang[0] eq \"\")) {\n    $self->{'_lr'} = [];\n    shift @lang;\n  } \n\n  if (@lang) {\n    push @{$self->{'_lr'}},@lang;\n  }\n  \n  return join(\"\",@{$self->{'_lr'}});\n}\n\n\nsub return_estimatedTotal {\n  my $self = shift;\n  my $bool = shift;\n\n  if (defined($bool)) {\n    $self->{'__estimatedTotal'} = ($bool) ? 1 : 0;\n  }\n\n  return $self->{'__estimatedTotal'};\n}\n\n\nsub response {\n  my $self = shift;\n\n  if (defined($self->{'__state'}) &&\n      ($self->{'__state'} eq $self->_state())) {\n\n    return $self->{'__response'};\n  }\n\n  $self->{'__response'} = [];\n\n  my $start_at  = $self->starts_at();\n  my $to_fetch  = $self->max_results();\n\n  while ($to_fetch > 0) {\n    my $count = ($to_fetch > 10) ? 10 : $to_fetch;\n\n\n    my $res = $self->_response($start_at,$count);\n\n    if (! defined($res)) {\n\tlast;\n    }\n\n\n    if ((! $self->return_estimatedTotal()) &&\n\t($start_at >= $res->{__endIndex})) {\n\n      last;\n    }\n\n\n    if ($self->return_estimatedTotal()) {\n\n      if (($self->{'__possible'} + scalar(@{$res->resultElements()})) >  $res->{'__estimatedTotalResultsCount'}) {\n\n\tmy $justright = int($res->{'__estimatedTotalResultsCount'} - $self->{'__possible'});\n\t@{$res->resultElements()} = @{$res->resultElements()}[0..($justright -1)];\n\n\tpush @{$self->{'__response'}} , $res;\n\tlast;\n      }\n\n      $self->{'__possible'} += scalar(@{$res->resultElements()});\n\n      if (($self->{'__possible'} + scalar(@{$res->resultElements()})) ==  $res->{'__estimatedTotalResultsCount'}) {\n\tlast;\n      }\n    }\n\n\n    push @{$self->{'__response'}}, $res;\n\n    $start_at += 10;\n    $to_fetch -= 10;\n  }\n\n  return $self->{'__response'};\n}\n\n\nsub results {\n  my $self = shift;\n  return [ map { @{ $_->resultElements() } } @{$self->response()} ];\n}\n\n\n\nsub _response {\n  my $self  = shift;\n  my $first = shift;\n  my $count = shift;\n\n  $self->_queries(1);\n\n  my $response = \n    $self->{'_service'}\n      ->doGoogleSearch(\n\t\t       $self->key(),\n\t\t       $self->query(),\n\t\t       $first,\n\t\t       $count,\n\t\t       SOAP::Data->type(boolean=>($self->filter() \n\t\t\t\t\t\t  ? \"true\" : \"false\")),\n\t\t       $self->restrict(),\n\t\t       SOAP::Data->type(boolean=>($self->safe() \n\t\t\t\t\t\t  ? \"true\" : \"false\")),\n\t\t       $self->lr(),\n\t\t       undef,\n\t\t       undef,\n\t\t      );\n\n  if (! $response) {\n    return undef;\n  }\n\n  $self->{'__state'} = $self->_state();\n  return Net::Google::Response->new($response);\n}\n\nsub _state {\n  my $self  = shift;\n  my $state = undef;\n  map {$state .= $self->$_()} qw (query lr restrict safe filter starts_at max_results);\n  return $state;\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_wFavfy/Net-Google-1.0/lib/Net/Google/Search.pm",
      "package" : "Net::Google::Search"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\nuse strict;\n\npackage Net::Google::Response;\n\nuse vars qw ($AUTOLOAD);\n\nuse Carp;\n\n$Net::Google::Response::VERSION   = '1.0';\n\n\nuse constant RESPONSE_FIELDS => qw [ directoryCategories estimateIsExact startIndex searchTime estimatedTotalResultsCount searchTips searchComments searchQuery endIndex documentFiltering ];\n\n\n\nsub new {\n  my $pkg    = shift;\n\n  my $self = {};\n  bless $self,$pkg;\n\n  if (! $self->init(@_)) {\n    return undef;\n  }\n\n  return $self;\n}\n\nsub init {\n  my $self     = shift;\n  my $response = shift;\n\n  if (ref($response) ne \"GoogleSearchResult\") {\n    carp \"Unknown response object.\";\n    return 0;\n  }\n\n  foreach my $el (@{$response->{'resultElements'}}) {\n    if (my $res = Result->new($el)) {\n      push @{$self->{'__resultElements'}},$res;\n    }\n  }\n\n  map { $self->{'__'.$_} = $response->{$_}; } &RESPONSE_FIELDS;\n  return 1;\n}\n\n\n\nsub resultElements {\n  my $self    = shift;\n\n  if(ref($self->{'__resultElements'}) eq \"ARRAY\") {\n    return $self->{'__resultElements'};\n  } \n\n  return [];\n}\n\n\nsub to_string {\n  my $self = shift;\n  my $string = '';\n\n  foreach my $key (keys %$self) {\n    $string .= \"$key: $$self{$key}\\n\";\n  }\n\n  return $string;\n}\n\nsub DESTROY {\n  return 1;\n}\n\nsub AUTOLOAD {\n  my $self = shift;\n\n  $AUTOLOAD =~ s/.*:://;\n  \n  unless (grep/^($AUTOLOAD)$/,&RESPONSE_FIELDS) {\n    carp \"Unknown attribute : \".$AUTOLOAD;\n    return undef;\n  }\n\n  return $self->{'__'.$AUTOLOAD};\n}\n\npackage Result;\nuse Carp;\n\nuse vars qw ($AUTOLOAD);\n\nuse constant RESULT_FIELDS => qw [ title URL snippet cachedSize directoryTitle summary hostName directoryCategory relatedInformationPresent ];\n\nsub new {\n  my $pkg = shift;\n\n  my $self = {};\n  bless $self,$pkg;\n\n  if (! $self->init(@_)) {\n    return undef;\n  }\n\n  return $self;\n}\n\nsub init {\n  my $self = shift;\n  my $res  = shift;\n\n  unless (ref($res) eq \"ResultElement\") {\n    carp \"Unknown result object\";\n    return 0;\n  }\n\n  map { $self->{'__'.$_} = $res->{$_}; } &RESULT_FIELDS;\n  return 1;\n}\n\n\n\nsub AUTOLOAD {\n  my $self = shift;\n  $AUTOLOAD =~ s/.*:://;\n\n  unless (grep/^($AUTOLOAD)$/,&RESULT_FIELDS) {\n    carp \"Unknown attribute :\".$AUTOLOAD;\n    return undef;\n  }\n\n  return $self->{'__'.$AUTOLOAD};\n}\n\nsub DESTROY {\n  return 1;\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_wFavfy/Net-Google-1.0/lib/Net/Google/Response.pm",
      "package" : "Net::Google::Response"
   }
]
