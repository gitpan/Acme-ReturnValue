[
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger;\nuse strict;\n\nuse vars qw ( $AUTOLOAD $LAST_ERROR );\n\n$Net::Blogger::VERSION   = '1.02';\n\n\n\nsub new {\n    my $pkg = shift;\n    my $self = {};\n    bless $self,$pkg;\n    $self->init(@_) || return undef;\n    return $self;\n}\n\nsub init {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n    my $engine = $args->{'engine'} || \"blogger\";\n    my $class  = join(\"::\",__PACKAGE__,\"Engine\",ucfirst $engine);\n\n    eval \"require $class\";\n\n    if ($@) {\n\tprint $@,\"\\n\";\n\t$LAST_ERROR = \"Unrecognized implementation of the Blogger API.\";\n\treturn 0;\n    }\n\n    $self->{\"_class\"} = $class->new(%$args)\n\t|| &{ $LAST_ERROR = Error->prior(); return 0; };\n\n    return 1;\n}\n\n\n\nsub DESTROY {\n    return 1;\n}\n\nsub AUTOLOAD {\n    my $self = shift;\n    $AUTOLOAD =~ s/.*:://;\n    return $self->{\"_class\"}->$AUTOLOAD(@_);\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger.pm",
      "package" : "Net::Blogger"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger::API::Core;\nuse strict;\n\n$Net::Blogger::API::Core::VERSION   = '1.0';\n@Net::Blogger::API::Core::ISA       = qw ( Exporter );\n@Net::Blogger::API::Core::EXPORT    = qw ();\n@Net::Blogger::API::Core::EXPORT_OK = qw ();\n\nuse Exporter;\n\n\nsub getUsersBlogs {\n    my $self  = shift;\n    my $blogs = [];\n    \n    my $call = $self->_Client->call(\n\t\t\t\t    \"blogger.getUsersBlogs\",\n\t\t\t\t    $self->_Type(string=>$self->AppKey()),\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(string=>$self->Password()),\n\t\t\t\t    );\n\n    ($call) ? return $call->result() : return [];\n}\n\n\nsub newPost {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n    if (! $self->check_newPost($args)) { \n      return 0; \n    }\n\n    if ($self->check_exceedsMaxLength($args)) { \n      return $self->_PostInChunks(%$args); \n    }\n\n    my $postbody = $args->{'postbody'};\n    my $publish  = ($args->{'publish'}) ? 1 : 0;\n\n    my $call = $self->_Client->call(\n\t\t\t\t    \"blogger.newPost\",\n\t\t\t\t    $self->_Type(string=>$self->AppKey()),\n\t\t\t\t    $self->_Type(string=>$self->BlogId()),\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(string=>$self->Password()),\n\t\t\t\t    $self->_Type(string=>$$postbody),\n\t\t\t\t    $self->_Type(boolean=>$publish),\n\t\t\t\t    );\n    \n    return ($call) ? $call->result() : return 0;\n}\n\n\nsub getPost {\n    my $self   = shift;\n    my $postid = shift;\n\n    if (! $self->check_getPost($postid)) { \n      return 0;\n    }\n    \n    my $call = $self->_Client->call(\n\t\t\t\t    \"blogger.getPost\",\n\t\t\t\t    $self->_Type(string=>$self->AppKey()),\n\t\t\t\t    $self->_Type(string=>$postid),\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(string=>$self->Password()),\n\t\t\t\t    );\n\n    if (! $call) { return 0; }\n\n    my $post = $call->result();\n\n\n    if ($post eq \"0\") {\n\t$self->LastError(\"Unable to locate post.\");\n\treturn 0;\n    }\n\n    return $post;\n}\n\n\nsub getRecentPosts {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n    if (! $self->check_getRecentPosts($args)) { \n      return (0); \n    }\n\n    my $call = $self->_Client->call(\n\t\t\t\t    \"blogger.getRecentPosts\",\n\t\t\t\t    $self->_Type(string=>$self->AppKey()),\n\t\t\t\t    $self->_Type(string=>$self->BlogId()),\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(string=>$self->Password()),\n\t\t\t\t    $self->_Type(int=>$args->{'numposts'}),\n\t\t\t\t  );\n\n    my @posts = ($call) ? (1,@{$call->result()}) : (0,undef);\n    return @posts;\n}\n\n\nsub editPost {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n    if (! $self->check_editPost($args)) { \n      return 0; \n    }\n\n    if ($self->check_exceedsMaxLength($args)) { \n      return $self->_PostInChunks(%$args); \n    }\n\n    my $postbody = $args->{'postbody'};\n    my $postid   = $args->{'postid'};\n    \n    if (($self->MaxPostLength()) && (length($$postbody) > $self->MaxPostLength())) {\n\treturn $self->_PostInChunks(%$args);\n    }\n\n    my $publish = ($args->{'publish'}) ? 1 : 0;\n\n    my $ok = undef;\n\n    my $call= $self->_Client->call(\n\t\t\t\t   \"blogger.editPost\",\n\t\t\t\t   $self->_Type(string=>$self->AppKey()),\n\t\t\t\t   $self->_Type(string=>$postid),\n\t\t\t\t   $self->_Type(string=>$self->Username()),\n\t\t\t\t   $self->_Type(string=>$self->Password()),\n\t\t\t\t   $self->_Type(string=>$$postbody),\n\t\t\t\t   $self->_Type(boolean=>$publish),\n\t\t\t\t   );\n\n    ($call) ? return $call->result() : return 0;\n}\n\n\nsub deletePost {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n    if (! $self->check_deletePost($args)) { \n      return 0; \n    }\n    \n    my $postid  = $args->{'postid'};\n    my $publish = ($args->{'publish'}) ? 1 : 0;\n\n    my $call = $self->_Client->call(\n\t\t\t\t    \"blogger.deletePost\",\n\t\t\t\t    $self->_Type(string=>$self->AppKey()),\n\t\t\t\t    $self->_Type(string=>$postid),\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(string=>$self->Password()),\n\t\t\t\t    $self->_Type(boolean=>$publish),\n\t\t\t\t    );\n\n    ($call) ? return $call->result() : return 0;\n}\n\n\nsub setTemplate {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n    if (! $self->check_setTemplate($args)) {\n      return 0;\n    }\n\n    my $call = $self->_Client->call(\n\t\t\t\t    \"blogger.setTemplate\",\n\t\t\t\t    $self->_Type(string=>$self->AppKey()),\n\t\t\t\t    $self->_Type(string=>$self->BlogId()),\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(string=>$self->Password()),\n\t\t\t\t    $self->_Type(string=>${$args->{'template'}}),\n\t\t\t\t    $self->_Type(string=>$args->{'type'}),\n\t\t\t\t    );\n\n    ($call) ? return $call->result() : return 0;\n}\n\n\nsub getTemplate {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n    \n    if (! $self->check_getTemplate($args)) {\n      return 0;\n    }\n\n    my $call = $self->_Client->call(\n\t\t\t\t    \"blogger.getTemplate\",\n\t\t\t\t    $self->_Type(string=>$self->AppKey()),\n\t\t\t\t    $self->_Type(string=>$self->BlogId()),\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(string=>$self->Password()),\n\t\t\t\t    $self->_Type(string=>$args->{'type'}),\n\t\t\t\t    );\n\n    ($call) ? return $call->result() : return 0;\n}\n\nsub check_exceedsMaxLength {\n  my $self = shift;\n  my $args = shift;\n\n  if (! $self->MaxPostLength()) {\n    return 0;\n  }\n\n  if (length(${$args->{'postbody'}}) < $self->MaxPostLength()) {\n    return 0;\n  }\n\n  return 1;\n}\n\nsub check_newPost {\n  my $self = shift;\n  my $args = shift;\n\n  if (ref($args->{'postbody'}) ne \"SCALAR\") {\n    $self->LastError(\"You must pass postbody as a scalar reference.\");\n    return 0;\n  }\n    \n  return 1;\n}\n\nsub check_getPost {\n  my $self   = shift;\n  my $postid = shift;\n\n  if (! $postid) {\n    $self->LastError(\"You must specify a postid.\");\n    return 0;\n  }\n\n  return 1;\n}\n\nsub check_getRecentPosts {\n  my $self = shift;\n  my $args = shift;\n\n  my $num   = (defined $args->{'numposts'}) ? $args->{'numposts'} : 1;\n  \n  unless ($num =~ /^(\\d+)$/) {\n    $self->LastError(\"Argument $args->{'numposts'} isn't numeric.\");\n    return 0;\n  }\n  \n  unless (($num >= 1) && ($num <= 20)) {\n    $self->LastError(\"You must specify 'numposts' as an integer between 1 and 20.\");\n    return (0);\n  }\n  \n  return 1;\n}\n\nsub check_editPost {\n  my $self = shift;\n  my $args = shift;\n\n  if (! $args->{'postid'}) { \n    $self->LastError(\"You must specify a postid.\");\n    return 0; \n  }\n  \n  if (ref($args->{'postbody'}) ne \"SCALAR\") {\n    $self->LastError(\"You must pass postbody as a scalar reference.\");\n    return 0;\n  }\n  \n    return 1;\n}\n\nsub check_deletePost {\n  my $self = shift;\n  my $args = shift;\n\n  if (! $args->{'postid'}) {\n    $self->LastError(\"No post id.\");\n    return 0;\n  }\n  \n  return 1;\n}\n\nsub check_setTemplate {\n  my $self = shift;\n  my $args = shift;\n\n  if (ref($args->{'template'}) ne \"SCALAR\") {\n    $self->LastError(\"You must pass template as a scalar reference.\");\n    return 0;\n  }\n  \n  unless ($args->{'type'} =~ /^(main|archiveIndex)$/) {\n    $self->LastError(\"Valid template types are 'main' and 'archiveIndex'.\");\n    return 0;\n  }\n\n  unless (${$args->{'template'}} =~ /(<Blogger>)[^<]*(?:(?! <\\/?Blogger>)<[^<]*)*(<\\/Blogger>)/m) {\n    $self->LastError(\"Your template must contain opening and closing <Blogger> tags.\");\n    return 0;\n  }\n  \n  return 1;\n}\n\nsub check_getTemplate {\n  my $self = shift;\n  my $args = shift;\n\n  unless ($args->{'type'} =~ /^(main|archiveIndex)$/) {\n    $self->LastError(\"Valid template types are 'main' and 'archiveIndex'.\");\n    return 0;\n  }\n\n  return 1;\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger/API/Core.pm",
      "package" : "Net::Blogger::API::Core"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger::API::Extended;\nuse strict;\n\n$Net::Blogger::API::Extended::VERSION   = '1.0';\n@Net::Blogger::API::Extended::ISA       = qw ( Exporter );\n@Net::Blogger::API::Extended::EXPORT    = qw ();\n@Net::Blogger::API::Extended::EXPORT_OK = qw ();\n\nuse Exporter;\nuse FileHandle;\n\n\nsub MaxPostLength {\n    return undef;\n}\n\n\nsub GetBlogId {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n    my $blogid = undef;\n\n    if (! $args->{'blogname'}) {\n\treturn $self->{'_blogid'};\n    }\n\n    my $blogs = $self->getUsersBlogs()\n\t|| return undef;\n\n    foreach my $b (@$blogs) {\n\tif ($b->{'blogName'} eq $args->{'blogname'}) {\n\t    $blogid = $b->{'blogid'};\n\t    last;\n\t}\n    }\n\n    return $blogid;\n}\n\n\nsub DeleteAllPosts {\n    my $self = shift;\n    my $args = { @_ };\n\n    my ($ok,@pids) = $self->getRecentPosts(numposts=>20);\n\n    while (@pids) {\n\tforeach my $p (@pids) {\n\t    $self->deletePost(postid=>$p->{'postid'},publish=>$args->{'publish'});\n\t}\n\n\t($ok,@pids) = $self->getRecentPosts(numposts=>20);\n    }\n\n    return $ok;\n}\n\n\nsub PostFromFile {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n    if (! -f $args->{'file'}) {\n      $self->LastError(\"Not a file.\");\n\treturn 0;\n    }\n\n    my $fh = FileHandle->new();\n    my $ok = $fh->open(\"<$args->{'file'}\");\n\n    if (! $ok) {\n      $self->LastError(\"Failed to open file : $!\");\n\treturn 0;\n    }\n\n    my $method  = ($args->{'postid'}) ? \"editPost\" : \"newPost\";\n\n    if (! $args->{'tail'}) {\n\n\tlocal $/;\n\tundef $/;\n\n\tmy $postbody = <$fh>;\n\t$fh->close();\n\n\treturn $self->$method(postbody=>\\$postbody,%$args);\n    }\n\n    my $post    = \"\";\n    my @postids = ();\n\n    while (<$fh>) {\n\tmy $line = $_;\n\tchomp $line;\n\n\t$post  .= $line;\n\tmy $len = length($post);\n\n\tif (($self->MaxPostLength()) && ($len > $self->MaxPostLegth())) {\n\n\t    my $postbody  = substr($post,0,$self->MaxPostLength());\n\t    my $remainder = $self->_TrimPostBody(\\$postbody);\n\n\t    my ($pid) = $self->$method(\n\t\t\t\t       postbody => \\$postbody,\n\t\t\t\t       postid   => $args->{'postid'},\n\t\t\t\t       publish  => $args->{'publish'},\n\t\t\t\t       );\n\n\t    if (! $pid) {\n\t\t$fh->close();\n\n\t      $self->LastError(\"Encountered an error posting. Exiting prematurely.\");\n\t\treturn (0,@postids);\n\t    }\n\n\t    push(@postids,$pid);\n\t    $post = $remainder.substr($post,$self->MaxPostLength(),$len);\n\t}\n    }\n\n    $fh->close();\n\n    if (! $post) {\n      $self->LastError(\"Failed to read any data from file.\");\n\treturn 0;\n    }\n\n    my ($pid) = $self->$method(\n\t\t\t       postbody => \\$post,\n\t\t\t       postid   => $args->{'postid'},\n\t\t\t       publish  => $args->{'publish'},\n\t\t\t       );\n\n    if (! $pid) {\n      $self->LastError(\"Encountered an error posting last chunk : \".Error->prior());\n\treturn (0, @postids);\n    }\n\n    push (@postids,$pid);\n    return (1,@postids);\n}\n\n\nsub PostFromOutline {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n    my $class = \"Text::Outline\";\n\n    eval \"require $class\"\n\t|| &{ $self->LastError($@); return 0; };\n\n    my $outline = $class->new(load=>$args->{'file'})\n\t|| &{ $self->LastError($!); return 0; };\n\n    my $postbody = $outline->asRenderedHTML();\n\n    my $method   = ($args->{'postid'}) ? \"editPost\" : \"newPost\";\n\n    return $self->$method(postbody=>\\$postbody,%$args);\n}\n\nsub _PostInChunks {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n    my $caller  = (caller(1))[3];\n    my @chunks  = ();\n    my @postids = ();\n\n    unless ($caller =~ /^(Net::Blogger::Base::API::)(editPost|newPost)$/) {\n\t$self->LastError(\"$caller is not a valid caller for this method.\");\n\treturn 0;\n    }\n\n    my $text = $args->{\"postbody\"};\n\n    while ( $$text ) {\n\tmy $chunk     = substr($$text,0,$self->MaxPostLength());\n\tmy $remainder = $self->_TrimPostBody(\\$chunk);\n\n\t$$text = $remainder.substr($$text,length($chunk),length($$text));\n\n\n\tunshift (@chunks, \\$chunk);\n    }\n\n    map {\n\t$args->{\"postbody\"} = $_;\n\tpush(@postids, $self->$caller(%$args));\n    } @chunks;\n\n    return @postids;\n}\n\nsub _TrimPostBody {\n    my $self = shift;\n    my $body = shift;\n\n    if (ref($body) ne \"SCALAR\") {\n\t$self->LastError(\"Input must be a scalar ref.\");\n\treturn undef;\n    }\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger/API/Extended.pm",
      "package" : "Net::Blogger::API::Extended"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger::Engine::Blogger;\nuse strict;\n\nuse constant BLOGGER_PROXY  => \"http://plant.blogger.com/api/RPC2\";\nuse constant MAX_POSTLENGTH => 65536;\n\n$Net::Blogger::Engine::Blogger::VERSION   = '1.0';\n@Net::Blogger::Engine::Blogger::ISA       = qw ( Exporter Net::Blogger::Engine::Base );\n@Net::Blogger::Engine::Blogger::EXPORT    = qw ();\n@Net::Blogger::Engine::Blogger::EXPORT_OK = qw ();\n\nuse Exporter;\nuse Net::Blogger::Engine::Base;\n\nsub new {\n    my $pkg = shift;\n\n    my $self = {};\n    bless $self,$pkg;\n\n    if (! $self->SUPER::init(@_)) {\n\treturn 0;\n    }\n\n    return $self;\n}\n\n\nsub Proxy {\n  my $self = shift;\n  return $self->SUPER::Proxy(@_) || BLOGGER_PROXY;\n}\n\n\nsub MaxPostLength {\n    return MAX_POSTLENGTH;\n}\n\nsub DESTROY {\n    return 1;\n}\n\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger/Engine/Blogger.pm",
      "package" : "Net::Blogger::Engine::Blogger"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger::Engine::Manila;\nuse strict;\n\n$Net::Blogger::Engine::Manila::VERSION   = '1.0';\n@Net::Blogger::Engine::Manila::ISA       = qw ( Exporter Net::Blogger::Engine::Userland );\n@Net::Blogger::Engine::Manila::EXPORT    = qw ();\n@Net::Blogger::Engine::Manila::EXPORT_OK = qw ();\n\nuse Exporter;\nuse Net::Blogger::Engine::Userland;\n\n\nsub new {\n    my $pkg  = shift;\n\n    my $self = {};\n    bless $self,$pkg;\n\n    if (! $self->SUPER::init(@_)) {\n\treturn 0;\n    }\n\n    return $self;\n}\n\n\n\nsub getUsersBlogs {\n    my $self = shift;\n    $self->LastError(\"Unsupported method.\");\n    return 0;\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger/Engine/Manila.pm",
      "package" : "Net::Blogger::Engine::Manila"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger::Engine::Slash;\nuse strict;\n\nuse Exporter;\nuse Net::Blogger::Engine::Base;\n\nuse CGI qw (unescape);\n\n$Net::Blogger::Engine::Slash::VERSION   = '1.0';\n\n@Net::Blogger::Engine::Slash::ISA       = qw ( Net::Blogger::Engine::Base );\n@Net::Blogger::Engine::Slash::EXPORT    = qw ();\n@Net::Blogger::Engine::Slash::EXPORT_OK = qw ();\n\n\n\nsub getUserBlogs {\n  my $self = shift;\n\n  if ((! $self->{'__blogs'}) || (! $self->{'__blogs'}->[0]->{'blogName'})) {\n    \n    my $post = $self->slash()->get_entries($self->Username(),1);\n\n    if (ref($post) eq \"ARRAY\") {\n      $post = $post->[0];\n      \n      $post->{'url'} =~ /^((.*)\\/~(.*)\\/journal)\\/(\\d+)$/;\n\n      my $url  = $1;\n      my $name = &CGI::unescape($3);\n      \n      $self->{'__blogs'} = [\n\t\t\t    {\n\t\t\t     blogid   => $self->Username(),\n\t\t\t     url      => $url,\n\t\t\t     blogName => $name.\"'s journal\",\n\t\t\t    },\n\t\t\t   ];\n    } \n\n    else { $self->{'__blogs'} = [{ blogid => $self->Username() }]; }\n  }\n\n  return $self->{'__blogs'};\n}\n\n\nsub newPost {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n  if (! $self->check_newPost($args)) { \n    return 0; \n  }\n\n  return $self->slash()->add_entry(&_bloggerpost2slash($args->{'postbody'}));\n}\n\n\nsub getPost {\n  my $self   = shift;\n  my $postid = shift;\n\n  if (! $self->check_getPost($postid)) { \n    return 0;\n  }\n\n  my $post = $self->slash()->get_entry($postid);\n\n  return ($post) ? &_slashpost2blogger($post) : 0;\n}\n\n\nsub getRecentPosts {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n  if (! $self->check_getRecentPosts($args)) { \n    return (0); \n  }\n  \n  my $posts = $self->slash()->get_entries($self->Username(),$args->{'numposts'});\n\n  if (! $posts ) { \n    return (0); \n  }\n  \n  map { $_ = &_slashpost2blogger($_); } @$posts;\n\n  return (1,@$posts);\n}\n\n\nsub editPost {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n  if (! $self->check_editPost($args)) {\n    return 0;\n  }\n\n  return $self->slash()->modify_entry($args->{'postid'},&_bloggerpost2slash($args->{'postbody'}));\n}\n\n\nsub deletePost {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : {@_};\n\n  if (! $self->check_deletePost($args)) {\n    return 0;\n  }\n\n  return $self->slash()->delete_entry($args->{'postid'});\n}\n\n\nsub setTemplate {\n  my $self = shift;\n  $self->LastError(\"This method is not supported by the Slash engine.\");\n  return undef;\n}\n\n\nsub getTemplate {\n  my $self = shift;\n  $self->LastError(\"This method is not supported by the Slash engine.\");\n  return undef;\n}\n\n\n\nsub slash {\n  my $self = shift;\n\n  if (! $self->{'__slash'}) {\n\n    require Net::Blogger::Engine::Slash::slashcode;\n    my $slash = Net::Blogger::Engine::Slash::slashcode->new(debug=>$self->{debug});\n\n\n    map { $slash->$_($self->$_()); } qw (BlogId Username Password Proxy Uri);\n    $self->{'__slash'} = $slash;\n  }\n\n  return $self->{'__slash'};\n}\n\nsub _bloggerpost2slash {\n  my @post = split(\"\\n\",${$_[0]});\n  \n  return (\n\t  subject => $post[0],\n\t  body    => ((scalar(@post) > 1) ? join(\"\\n\",@post[1..$#post]) : $post[0]),\n\t );\n}\n\nsub _slashpost2blogger {\n  my $post = shift;\n  return {\n\t  postid      => $post->{'id'},\n\t  userid      => $post->{'uid'},\n\t  dateCreated => $post->{'date'},\n\t  content     => join(\"\\n\",$post->{'subject'},$post->{'body'}),\n\t };\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger/Engine/Slash.pm",
      "package" : "Net::Blogger::Engine::Slash"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger::Engine::Base;\nuse strict;\n\nuse vars qw ( $AUTOLOAD );\n\n$Net::Blogger::Engine::Base::VERSION        = '1.0';\n@Net::Blogger::Engine::Base::ISA            = qw ( Exporter Net::Blogger::API::Core Net::Blogger::API::Extended );\n@Net::Blogger::Engine::Base::ISA::EXPORT    = qw ();\n@Net::Blogger::Engine::Base::ISA::EXPORT_OK = qw ();\n\nuse Carp;\nuse Error;\nuse Exporter;\n\nuse SOAP::Lite;\n\nuse Net::Blogger::API::Core;\nuse Net::Blogger::API::Extended;\n\n\n\nsub new {\n    my $pkg = shift;\n\n    my $self = {};\n    bless $self,$pkg;\n\n    $self->init(@_) || return undef;\n\n    return $self;\n}\n\nsub init {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n    $self->AppKey($args->{'appkey'});\n    $self->Username($args->{'username'});\n    $self->Password($args->{'password'});\n    $self->BlogId($args->{'blogid'});\n\n    $self->{'debug'}   = $args->{'debug'};\n    $self->{\"_posts\"}  = [];\n\n\n    (my $caller = (caller(2))[3]) =~ /(.*)[:]{2}([^:]{1,})[:]{2}([^:]{1,})$/;\n\n    $self->{'__parent'} = $2;\n    return 1;\n}\n\n\n\n\n\nsub LastError {\n    my $self = shift;\n    my $e    = shift;\n\n    if ($e) {\n\tError::Simple->record($e);\n\treturn 1;\n    }\n\n    $e = Error->prior();\n    chomp $e;\n\n    return $e;\n}\n\n\nsub Transport {\n  return \"XMLRPC\";\n}\n\nsub _Client {\n    my $self = shift;\n\n    unless (ref($self->{\"_client\"}) =~ /^(XMLRPC|SOAP)::Lite$/) {\n\n      my $pkg = uc $self->Transport();\n\n      if ($pkg =~ /^(XMLRPC|SOAP)$/) {\n\t$pkg = join(\"::\",$pkg,\"Lite\");\n      }\n\n      else {\n\tdie \"Unknown transport : '$pkg'\\n\";\n\t$self->LastError(\"Unknown transport : $pkg\");\n\treturn undef;\n      }\n\n      eval \"require $pkg\";\n\n      if ($@) {\n\tdie \"Failed to eval, $@\\n\";\n      }\n      my $client = $pkg->new()\n\t|| Error->throw(-text=>$!);\n\n      $client->on_fault(\\&_ClientFault);\n\n\n      if (defined($ENV{http_proxy})) {\n\t  $client->proxy($self->Proxy, proxy => ['http' => $ENV{http_proxy} ]);\n      } else {\n\t  $client->proxy($self->Proxy);\n      }\n\n      $client->uri($self->Uri());\n\n      if ($self->{'debug'}) {\n\t$client->on_debug(sub { print @_; });\n      }\n\n      $self->{\"_client\"} = $client;\n    }\n\n    return $self->{\"_client\"};\n}\n\nsub _ClientFault {\n    my $client = shift;\n    my $res    = shift;\n    Error::Simple->record(join(\"\\n\",\n\t\t\t       \"Fatal client error.\",\n\t\t\t       ((ref $res) ? $res->faultstring() : $client->transport->status()))\n\t\t\t  );\n    return 0;\n}\n\nsub _Type {\n  my $self = shift;\n  my $name = shift;\n\n  if ($name =~ /^(hash|array)$/) {\n    return SOAP::Data->name(args=>@_);\n  }\n\n  return SOAP::Data->type($name,@_);\n}\n\nsub DESTROY {\n    return 1;\n}\n\nsub AUTOLOAD {\n    my $self  = shift;\n    $AUTOLOAD =~ s/.*:://;\n\n    if ($AUTOLOAD eq \"Publish\") {\n\t$self->LastError(\"This method has been deprecated.\");\n\treturn undef;\n    }\n\n    unless ($AUTOLOAD =~ /^(Proxy|Uri|AppKey|BlogId|Username|Password)$/) {\n\t$self->LastError(\"Unknown method '$AUTOLOAD' called. Skipping.\");\n\treturn undef;\n    }\n\n    my $property = lc \"_\".$AUTOLOAD;\n\n    if (my $arg = shift) {\n      $self->{ $property } = $arg;\n\n      if ($AUTOLOAD eq \"Proxy\") {\n\t$self->{\"_client\"} = undef;\n      }\n\n\n      if (exists $self->{'__meta'}) {\n\t$self->{'__meta'}->$property($arg);\n      }\n\n      if (exists $self->{'__mt'}) {\n\t$self->{'__mt'}->$property($arg);\n      }\n\n      if (exists $self->{'__slash'}) {\n\t$self->{'__slash'}->$property($arg);\n      }\n\n    }\n\n    return $self->{ $property };\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger/Engine/Base.pm",
      "package" : "Net::Blogger::Engine::Base"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger::Engine::Movabletype;\nuse strict;\n\n$Net::Blogger::Engine::Movabletype::VERSION   = '1.0';\n@Net::Blogger::Engine::Movabletype::ISA       = qw ( Exporter Net::Blogger::Engine::Base );\n@Net::Blogger::Engine::Movabletype::EXPORT    = qw ();\n@Net::Blogger::Engine::Movabletype::EXPORT_OK = qw ();\n\nuse Exporter;\nuse Net::Blogger::Engine::Base;\n\n\n\nsub getRecentPosts {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : {@_};\n\n    my $num   = (defined $args->{'numposts'}) ? $args->{'numposts'} : 1;\n    my $posts = [];\n\n    unless ($num =~ /^(-)*(\\d+)$/) {\n\t$self->LastError(\"Argument $args->{'numposts'} isn't numeric.\");\n        return 0;\n    }\n\n    if ($num > -1) { $num = 0; }\n\n    return $self->SUPER::getRecentPosts($args);\n}\n\n\n\nsub mt {\n  my $self = shift;\n\n  if (! $self->{'__mt'}) {\n\n    require Net::Blogger::Engine::Movabletype::mt;\n    my $mt = Net::Blogger::Engine::Movabletype::mt->new(debug=>$self->{debug});\n\n    map { $mt->$_($self->$_()); } qw (BlogId Proxy Username Password);\n    $self->{'__mt'} = $mt;\n  }\n\n  return $self->{'__mt'};\n}\n\n\n\nsub metaWeblog {\n  my $self = shift;\n\n  if (! $self->{__meta}) {\n\n    require Net::Blogger::Engine::Userland::metaWeblog;\n    my $meta = Net::Blogger::Engine::Userland::metaWeblog->new(debug=>$self->{debug});\n\n    map { $meta->$_($self->$_()); } qw (BlogId Proxy Username Password);\n    $self->{__meta} = $meta;\n  }\n\n  return $self->{__meta};\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger/Engine/Movabletype.pm",
      "package" : "Net::Blogger::Engine::Movabletype"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger::Engine::Userland;\nuse strict;\n\n$Net::Blogger::Engine::Userland::VERSION   = '1.0';\n@Net::Blogger::Engine::Userland::ISA       = qw ( Exporter Net::Blogger::Engine::Base );\n@Net::Blogger::Engine::Userland::EXPORT    = qw ();\n@Net::Blogger::Engine::Userland::EXPORT_OK = qw ();\n\nuse Net::Blogger::Engine::Base;\n\nuse Exporter;\nuse URI;\n\n\n\nsub init {\n    my $self = shift;\n    my $args = (ref($_[0]) eq \"HASH\") ? shift : {@_};\n\n    my $child = caller();\n    \n    if (! $child =~ /^(Net::Blogger::Engine::(Manila|Radio))$/) {\n\treturn 0;\n    }\n\n    if (exists $args->{'proxy'}) {\n\t$self->Proxy($args->{'proxy'});\n\tdelete $args->{'proxy'};\n    }\n\n    return $self->SUPER::init($args);\n}\n\n\nsub Proxy {\n    my $self  = shift;\n    my $proxy = shift;\n\n    if ($proxy) {\n\t$self->{\"_proxy\"} = $proxy;\n\treturn $self->{\"_proxy\"};\n    }\n\n    if ($self->{\"_proxy\"}) {\n\treturn $self->{\"_proxy\"};\n    }\n    \n    if (my $blog = $self->BlogId()) {\n\tmy $uri = URI->new($blog);\n\t$self->{\"_proxy\"} = $uri->scheme().\"://\".$uri->host().\"/RPC2\";\n\n\t$self->{\"_client\"} = undef;\n\treturn $self->{\"_proxy\"};\n    }\n\n    $self->LastError(\"Unable to determine proxy explicitly or by parsing blogid.\");\n    return undef;\n}\n\n\nsub AppKey {\n    my $self = shift;\n    return 1;\n}\n\n\nsub BlogId {\n  my $self = shift;\n  my $id   = shift;\n\n  if ($id) {\n    unless ($id =~ /^(.*)\\/$/) { $id .= \"/\"; }\n    $self->{'_blogid'} = $id;\n  }\n\n  return $self->{'_blogid'};\n}\n\n\nsub MaxPostLength {\n    my $self = shift;\n    return undef;\n}\n\n\n\n\nsub metaWeblog {\n  my $self = shift;\n\n  if (! $self->{__meta}) {\n\n    require Net::Blogger::Engine::Userland::metaWeblog;\n    my $meta = Net::Blogger::Engine::Userland::metaWeblog->new(debug=>$self->{debug});\n\n    map { $meta->$_($self->$_()); } qw (BlogId Proxy Username Password );\n    $self->{__meta} = $meta;\n  }\n\n  return $self->{__meta};\n}\n\nreturn 1;\n\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger/Engine/Userland.pm",
      "package" : "Net::Blogger::Engine::Userland"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger::Engine::Radio;\nuse strict;\n\n$Net::Blogger::Engine::Radio::VERSION   = '1.0';\n@Net::Blogger::Engine::Radio::ISA       = qw (\n                                         Exporter\n                                         Net::Blogger::Engine::Userland\n                                         );\n@Net::Blogger::Engine::Radio::EXPORT    = qw ();\n@Net::Blogger::Engine::Radio::EXPORT_OK = qw ();\n\nuse Exporter;\nuse Net::Blogger::Engine::Userland;\n\n\n\nsub new {\n    my $pkg  = shift;\n\n    my $self = {};\n    bless $self,$pkg;\n    \n    if (! $self->SUPER::init(@_)) {\n\treturn undef;\n    }\n\n    return $self;\n}\n\n\n\nsub GetBlogId {\n    my $self = shift;\n    return \"home\";\n}\n\n\nsub BlogId {\n  my $self = shift;\n  return $self->GetBlogId();\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger/Engine/Radio.pm",
      "package" : "Net::Blogger::Engine::Radio"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger::Engine::Userland::metaWeblog;\nuse strict;\n\n$Net::Blogger::Engine::Userland::metaWeblog::VERSION   = '1.0';\n\n@Net::Blogger::Engine::Userland::metaWeblog::ISA       = qw ( Exporter Net::Blogger::Engine::Base );\n@Net::Blogger::Engine::Userland::metaWeblog::EXPORT    = qw ();\n@Net::Blogger::Engine::Userland::metaWeblog::EXPORT_OK = qw ();\n\nuse Exporter;\nuse Net::Blogger::Engine::Base;\n\n\nsub getRecentPosts {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : {@_};\n  my $call = $self->_Client()->call(\n\t\t\t\t    \"metaWeblog.getRecentPosts\",\n\t\t\t\t    $self->_Type(string=>$self->BlogId()),\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(string=>$self->Password()),\n                    $self->_Type(int=>$args->{'numberOfPosts'}),\n\t\t\t\t    );\n\n    my @posts = ($call) ? (1,@{$call->result()}) : (0,undef);\n    return @posts;\n};\n\nsub newPost {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : {@_};\n\n  my $publish = 0;\n\n  if (exists $args->{publish}) {\n    $publish = $args->{publish};\n    delete $args->{publish};\n  }\n\n  if (($args->{categories}) && (ref($args->{categories}) ne \"ARRAY\")) {\n    $self->LastError(\"Categories must be passed as an array reference.\");\n    return 0;\n  }\n\n  my $call = $self->_Client->call(\n\t\t\t\t  \"metaWeblog.newPost\",\n\t\t\t\t  $self->_Type(string=>$self->BlogId()),\n\t\t\t\t  $self->_Type(string=>$self->Username()),\n\t\t\t\t  $self->_Type(string=>$self->Password()),\n\t\t\t\t  $self->_Type(hash=>$args),\n\t\t\t\t  $self->_Type(boolean=>$publish),\n\t\t\t\t );\n\n  return ($call) ? $call->result() : return 0;\n}\n\n\nsub newMediaObject {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : {@_};\n\n\n  if ($args->{file}) {\n\n    my $pkg = \"MIME::Base64\";\n    eval \"require $pkg\";\n\n    if ($@) {\n      $self->LastError(\"Failed to load $pkg for automagic encoding, $@\");\n      return undef;\n    }\n\n    open(FILE, $args->{file}) or &{\n      $self->LastError(\"Failed to open $args->{file} for reading, $!\");\n      return undef;\n    };\n\n    my $buf = undef;\n\n    while (read(FILE, $buf, 60*57)) {\n      $args->{bits} .= &{$pkg.\"::encode_base64\"}($buf);\n    }\n\n    close FILE;\n\n\n    if (! $args->{type}) {\n      eval \"require $pkg\";\n\n      if ($@) {\n\t$self->LastError(\"Failed to load $pkg for automagic type checking $@\");\n\treturn undef;\n      }\n\n\n      my $mm = undef;\n\n      eval { $mm = $pkg->new(); };\n\n      if ($@) {\n\t$self->LastError(\"Failed to instantiate $pkg for automagic type checking, $@\");\n\treturn undef;\n      }\n\n      $args->{type} = $mm->checktype_filename($args->{file});\n\n      if (! $args->{type}) {\n\t$self->LastError(\"Unable to determine file type \");\n      }\n    }\n\n\n    if (! $args->{name}) {\n      require \"File::Basename\";\n      $args->{name} = File::Basename::basename($args->{file});\n    }\n  }\n\n\n  else {\n    foreach (\"name\",\"type\",\"bin\") {\n      if (! $args->{$_}) {\n\t$self->LastError(\"You must define a value for the $_ property.\");\n\treturn undef;\n      }\n    }\n  }\n\n\n  my $call = $self->_Client->call(\n\t\t\t\t  \"metaWeblog.newMediaObject\",\n\t\t\t\t  $self->_Type(string=>$self->BlogId()),\n\t\t\t\t  $self->_Type(string=>$self->Username()),\n\t\t\t\t  $self->_Type(string=>$self->Password()),\n\t\t\t\t  $self->_Type(hash=>$args),\n\t\t\t\t );\n\n  return ($call) ? $call->result() : undef;\n}\n\n\nsub editPost {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : {@_};\n\n  my $postid = $args->{postid};\n\n  if (! $postid) {\n    $self->LastError(\"You must specify a postid\");\n    return 0;\n  }\n\n  delete $args->{postid};\n\n  if (($args->{categories}) && (ref($args->{categories}) ne \"ARRAY\")) {\n    $self->LastError(\"Categories must be passed as an array reference.\");\n    return 0;\n  }\n\n  my $publish = 0;\n\n  if (exists $args->{publish}) {\n    $publish = $args->{publish};\n    delete $args->{publish};\n  }\n\n  my $call = $self->_Client->call(\n\t\t\t\t  \"metaWeblog.editPost\",\n\t\t\t\t  $postid,\n\t\t\t\t  $self->_Type(string=>$self->Username()),\n\t\t\t\t  $self->_Type(string=>$self->Password()),\n\t\t\t\t  $self->_Type(hash=>$args),\n\t\t\t\t  $self->_Type(boolean=>$publish),\n\t\t\t\t );\n\n  return ($call) ? $call->result() : undef;\n}\n\n\nsub getPost {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : {@_};\n\n  my $postid = $args->{postid};\n\n  if (! $postid) {\n    $self->LastError(\"You must specify a postid\");\n    return 0;\n  }\n\n  my $call = $self->_Client->call(\n\t\t\t\t  \"metaWeblog.getPost\",\n\t\t\t\t  $postid,\n\t\t\t\t  $self->_Type(string=>$self->Username()),\n\t\t\t\t  $self->_Type(string=>$self->Password()),\n\t\t\t\t );\n\n  return ($call) ? $call->result() : undef;\n}\n\n\nsub getCategories {\n  my $self = shift;\n\n  if ($self->{'__parent'} eq \"Movabletype\") {\n    $self->LastError(\"This method is not supported by the $self->{'__parent'} engine.\");\n    return undef;\n  }\n\n  my $call = $self->_Client()->call(\n\t\t\t\t    \"metaWeblog.getCategories\",\n\t\t\t\t    $self->_Type(string=>$self->BlogId()),\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(string=>$self->Password()),\n\t\t\t\t    );\n\n  return ($call) ? $call->result() : undef;\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger/Engine/Userland/metaWeblog.pm",
      "package" : "Net::Blogger::Engine::Userland::metaWeblog"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger::Engine::Slash::slashcode;\nuse strict;\n\nuse Exporter;\nuse Digest::MD5 'md5_hex';\nuse HTTP::Cookies;\nuse URI;\n\nuse Net::Blogger::Engine::Base;\n\n$Net::Blogger::Engine::Slash::slashcode::VERSION   = '1.0';\n\n@Net::Blogger::Engine::Slash::slashcode::ISA       = qw ( Net::Blogger::Engine::Base );\n@Net::Blogger::Engine::Slash::slashcode::EXPORT    = qw ();\n@Net::Blogger::Engine::Slash::slashcode::EXPORT_OK = qw ();\n\nsub Transport {\n  return \"SOAP\";\n}\n\nsub Proxy {\n  my $self  = shift;\n  my $proxy = shift;\n\n  if ($proxy) {\n    $self->{'_cookie'} = undef;\n    $self->{'_client'} = undef;\n\n    $self->{'_Proxy'} = $proxy;\n  }\n\n  return (\n\t  $self->{'_Proxy'},\n\t  cookie_jar => $self->_setUserCookie(),\n\t  );\n}\n\n\nsub add_entry {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n  my $call = $self->_Client()->call(\n\t\t\t\t    \"add_entry\",\n\t\t\t\t    $self->_Type(string=>$args->{\"subject\"}),\n\t\t\t\t    $self->_Type(string=>$args->{\"body\"}),\n\t\t\t\t   );\n\n  return ($call) ? $call->result() : return 0;\n}\n\n\nsub get_entry {\n  my $self = shift;\n\n  my $call = $self->_Client()->call(\n\t\t\t\t    \"get_entry\",\n\t\t\t\t    $self->_Type(int=>$_[0]),\n\t\t\t\t   );\n\n  return ($call) ? $call->result() : return 0;\n}\n\n\nsub get_entries {\n  my $self = shift;\n\n  my $call = $self->_Client()->call(\"get_entries\",\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(int=>$_[0]),\n\t\t\t\t   );\n\n  return ($call) ? $call->result() : return 0;\n}\n\n\nsub modify_entry {\n  my $self   = shift;\n  my $postid = shift;\n  my $args   = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n\n  my $call = $self->_Client()->call(\"modify_entry\",\n\t\t\t\t    $self->_Type(int=>$postid),\n\t\t\t\t    $self->_Type(string=>$args->{\"subject\"}),\n\t\t\t\t    $self->_Type(string=>$args->{\"body\"}),\n\t\t\t\t   );\n\n  return ($call) ? $call->result() : return 0;\n}\n\n\nsub delete_entry {\n  my $self = shift;\n\n  my $call = $self->_Client()->call(\"delete_entry\",\n\t\t\t\t    $self->_Type(int=>$_[0]),\n\t\t\t\t   );\n\n  return ($call) ? $call->result() : return 0;\n}\n\nsub _setUserCookie {\n  my $self = shift;\n\n  if (! $self->{'_cookie'}) {\n    my $cookie = join(\"::\",$self->Username(),md5_hex($self->Password()));\n\n    $cookie =~ s/(.)/sprintf(\"%%%02x\", ord($1))/ge;\n    $cookie =~ s/%/%25/g;\n    $self->{'_cookie'} = HTTP::Cookies->new()->set_cookie(0,\n\t\t\t\t\t\t\t  user=>$cookie,\n\t\t\t\t\t\t\t  '/',\n\t\t\t\t\t\t\t  URI->new($self->{'_Proxy'})->host(),\n\t\t\t\t\t\t\t ),\n  }\n\n  return $self->{'_cookie'};\n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger/Engine/Slash/slashcode.pm",
      "package" : "Net::Blogger::Engine::Slash::slashcode"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\n\npackage Net::Blogger::Engine::Movabletype::mt;\nuse strict;\n\nuse Exporter;\nuse Net::Blogger::Engine::Base;\n\n$Net::Blogger::Engine::Movabletype::mt::VERSION   = '1.0';\n\n@Net::Blogger::Engine::Movabletype::mt::ISA       = qw ( Exporter Net::Blogger::Engine::Base );\n@Net::Blogger::Engine::Movabletype::mt::EXPORT    = qw ();\n@Net::Blogger::Engine::Movabletype::mt::EXPORT_OK = qw ();\n\n\n\nsub getRecentPostTitles {\n    my $self = shift;\n    my $args = shift;\n\n\n    my $count = 19;\n\n    if (exists($args->{count})) {\n\t$count = ($args->{count} - 1);\n    }\n\n\n    my $call = $self->_Client()->call(\n\t\t\t\t      \"mt.getRecentPostTitles\",\n\t\t\t\t      $self->_Type(string=>$self->BlogId()),\n\t\t\t\t      $self->_Type(string=>$self->Username()),\n\t\t\t\t      $self->_Type(string=>$self->Password()),\n\t\t\t\t      $self->_Type((int=>$_[0] || 20)),\n\t\t\t\t      );\n\n\n    if (! exists($args->{asc})) {\n\treturn ($call) ? $call->result() : undef;\n    }\n\n    elsif (! $call) {\n\treturn undef;\n    }\n\n    else {\n\treturn [ reverse @{$call->result()} ];\n    }\n}\n\n\nsub getCategoryList {\n  my $self = shift;\n\n  my $call = $self->_Client()->call(\n\t\t\t\t    \"mt.getCategoryList\",\n\t\t\t\t    $self->_Type(string=>$self->BlogId()),\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(string=>$self->Password()),\n\t\t\t\t    );\n\n  return ($call) ? $call->result() : undef;\n}\n\n\nsub getPostCategories {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : {@_};\n\n  if (! $args->{'postid'}) {\n    $self->LastError(\"You must specify a postid\");\n    return undef;\n  }\n\n  my $call = $self->_Client()->call(\n\t\t\t\t    \"mt.getPostCategories\",\n\t\t\t\t    $self->_Type(string=>$args->{'postid'}),\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(string=>$self->Password()),\n\t\t\t\t    );\n\n  return ($call) ? $call->result() : undef;\n}\n\n\nsub setPostCategories {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : {@_};\n  \n  if (! $args->{'postid'}) {\n    $self->LastError(\"You must specify a postid\");\n    return undef;\n  }\n\n  if (ref($args->{'categories'}) ne \"ARRAY\") {\n    $self->LastError(\"You must pass category data as an array reference.\");\n    return undef;\n  }\n\n  foreach my $struct (@{$args->{'categories'}}) {\n    if (! $struct->{'categoryId'}) {\n      $self->LastError(\"Category struct requires a categoryId.\");\n      return undef;\n    }\n  }\n\n  my $call = $self->_Client()->call(\n\t\t\t\t    \"mt.setPostCategories\",\n\t\t\t\t    $self->_Type(string=>$args->{'postid'}),\n\t\t\t\t    $self->_Type(string=>$self->Username()),\n\t\t\t\t    $self->_Type(string=>$self->Password()),\n\t\t\t\t    $self->_Type(array=>$args->{'categories'}),\n\t\t\t\t    );\n\n  return ($call) ? $call->result() : undef;\n}\n\n\nsub getTrackbackPings {\n  my $self = shift;\n  my $args = (ref($_[0]) eq \"HASH\") ? shift : { @_ };\n  my $call = $self->_Client()->call(\n\t\t\t\t    \"mt.getTrackbackPings\",\n\t\t\t\t    $self->_Type(string=>$args->{'postid'})\n\t\t\t\t   );\n\n  return ($call) ? $call->result() : undef;\n}\n\n\nsub supportedMethods {\n  my $self = shift;\n  my $call = $self->_Client()->call(\"mt.setPostCategories\");\n  return ($call) ? $call->result() : undef;\n}\n\n\nsub publishPost {\n    my $self = shift;\n\n    my $call = $self->_Client()->call(\n\t\t\t\t      \"mt.publishPost\",\n\t\t\t\t      $self->_Type(int=>$_[0]),\n\t\t\t\t      $self->_Type(string=>$self->Username()),\n\t\t\t\t      $self->_Type(string=>$self->Password()),\n\t\t\t\t      );\n\n    return ($call) ? 1 : 0;    \n}\n\n\nreturn 1;\n\n}",
      "file" : "/var/tmp/arv_xdzjd6/Net-Blogger-1.02/lib/Net/Blogger/Engine/Movabletype/mt.pm",
      "package" : "Net::Blogger::Engine::Movabletype::mt"
   }
]
