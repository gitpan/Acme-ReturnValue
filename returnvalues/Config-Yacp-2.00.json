[
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n  use Object::InsideOut;\n  use Parse::RecDescent;\n  use Fcntl qw/:flock/;\n  use Carp;\n  use strict;\n  use Data::Dumper;\n  use vars qw($VERSION $grammar $CONFIG);\n\n  $VERSION='2.00';\n  BEGIN{ $::RD_AUTOACTION=q{ [@item[1..$#item]] }; }\n\n  $grammar = q(\n                 file: section(s)\n                 section: header pair(s?)\n                 header:  /\\[(\\w+)\\]/ { $1 }\n                 pair:    /(\\w+)\\s?=\\s?(\\w+)?(\\s+[;#][\\s\\w]+)?\\n/\n                 {\n                   if(!defined $3){\n                     [$1,$2];\n                   }else{\n                     [$1,$2,$3];\n                   } \n                 }\n              );\n  my @FileName      :Field('Standard'=>'FileName','Type'=>'LIST');\n  my @CommentMarker :Field('Standard'=>'CommentMarker','Type'=>'LIST');\n\n  my %init_args :InitArgs=(\n    'FileName'=>{\n        'Regex' => qr/^FileName$/i,\n\t'Mandatory' => 1,\n    },\n    'CommentMarker'=>{\n        'Regex' => qr/^CommentMarker$/i,\n\t'Default' => '#',\n    }\n  );\n\n  sub _init :Init{\n    my ($self,$args)=@_;\n    if(exists($args->{'FileName'})){\n      $self->set(\\@FileName,$args->{'FileName'});\n    }\n    if(exists($args->{'CommentMarker'})){\n      $self->set(\\@CommentMarker,$args->{'CommentMarker'});\n    }\n    my $cm=$self->get_CommentMarker;\n    if($cm!~/[#;]/){\n      croak \"Incorrect Comment Marker detected. Use either # or ; to mark comments\";\n    }\n    my $parser = Parse::RecDescent->new($grammar);\n    my $file=$self->get_FileName;\n    my $ini;\n    {\n      no strict 'subs';\n      $/=undef;\n      open(FILE,\"$file\")||croak \"Can't open $file: $!\";\n      flock(FILE,LOCK_SH) or die \"Unable to obtain a file lock: $!\\n\";\n      $ini=<FILE>;\n      flock(FILE,LOCK_UN);\n      close FILE;\n    }\n\n    my $tree = $parser->file($ini);\n    $CONFIG = deparse($tree);\n  }\n\n  sub retrieve_sections{\n    my @sections = sort keys %$CONFIG;\n    return @sections;\n  }\n\n  sub retrieve_parameters{\n    my ($self,$section)=@_;\n    croak \"No section given\" if !defined $section;\n    croak \"Non-existent section given\" if !exists $CONFIG->{$section};\n    my @params = sort keys %{$CONFIG->{$section}};\n    return @params;\n  }\n\n  sub retrieve_value{\n    my($self,$section,$parameter)=@_;\n    croak \"Missing arguments\" if scalar @_ < 3;\n    croak \"Non-existent section given\" if !exists $CONFIG->{$section};\n    croak \"Non-existent parameter given\" if !exists $CONFIG->{$section}->{$parameter};\n    my $value=$CONFIG->{$section}->{$parameter}->[0];\n    return $value;\n  }\n\n  sub change_value{\n    my($self,$section,$parameter,$value)=@_;\n    croak \"Missing arguments\" if scalar @_ < 4;\n    croak \"Non-existent section given\" if !exists $CONFIG->{$section};\n    croak \"Non-existent parameter given\" if !exists $CONFIG->{$section}->{$parameter};\n    $CONFIG->{$section}->{$parameter}->[0]=$value;\n  }\n\n  sub retrieve_comment{\n    my($self,$section,$parameter)=@_;\n    croak\"Missing arguments\" if scalar @_ < 3;\n    croak\"Invalid section argument\" if !exists $CONFIG->{$section};\n    croak\"Invalid parameter argument\" if !exists $CONFIG->{$section}->{$parameter};\n    if (!defined $CONFIG->{$section}->{$parameter}->[1]){\n      local $SIG{__WARN__}=sub{ $@=shift; };\n      carp\"No comment available for this parameter\";\n    }else{\n      my $comment=$CONFIG->{$section}->{$parameter}->[1];\n      return $comment;\n    }\n  }\n\n  sub add_section{\n    my ($self,$section)=@_;\n    croak\"Missing arguments\" if scalar @_ < 2;\n    croak\"Section exists!\" if exists $CONFIG->{$section};\n    $CONFIG->{$section}=undef;  \n  }\n\n  sub add_parameter{\n    my ($self,$section,$para,$value,$comment)=@_;\n    croak\"Missing arguments\" if scalar @_ < 4;\n    if(!exists $CONFIG->{$section}){\n      $self->add_section($section);\n    }\n    croak\"Parameter exists\" if exists $CONFIG->{$section}->{$para};\n    $CONFIG->{$section}->{$para}=[$value];\n    if(defined $comment){ push @{$CONFIG->{$section}->{$para}},$comment; } \n  }\n\n  sub add_comment{\n    my ($self,$section,$para,$comment)=@_;\n    croak\"Missing arguments\" if scalar @_ < 4; \n    croak\"Non-Existent section\" if !exists $CONFIG->{$section};\n    croak\"Non-Existent parameter\" if !exists $CONFIG->{$section}->{$para};\n    $CONFIG->{$section}->{$para}->[1]=$comment;\n  }\n\n  sub display_config{\n    print Dumper($CONFIG);\n  }\n\n  sub delete_section{\n    my ($self,$section)=@_;\n    croak\"Missing arguments\" if scalar @_ < 2;\n    croak\"Non-Existent section\" if !exists $CONFIG->{$section};\n    delete $CONFIG->{$section};\n  }\n\n  sub delete_parameter{\n    my ($self,$section,$para)=@_;\n    croak\"Missing arguments\" if scalar @_ < 3;\n    croak\"Non-Existent section\" if !exists $CONFIG->{$section};\n    croak\"Non-Existent parameter\" if !exists $CONFIG->{$section}->{$para};\n    delete $CONFIG->{$section}->{$para};\n  }\n\n  sub delete_comment{\n    my ($self,$section,$para)=@_;\n    croak\"Missing arguments\" if scalar @_ < 3;\n    croak\"Non-Existent section\" if !exists $CONFIG->{$section};\n    croak\"Non-Existent parameter\" if !exists $CONFIG->{$section}->{$para};\n    if(defined $CONFIG->{$section}->{$para}->[1]){\n      pop @{$CONFIG->{$section}->{$para}};\n    }else{\n      local $SIG{__WARN__}=sub{ $@=shift; };\n      carp\"No comment located for that parameter\";\n    }\n  }\n\n  sub save{\n    no strict \"refs\";\n    my $self=shift;\n    my $file=$self->get_FileName;\n    my $CM=$self->get_CommentMarker;\n    open FH,\">$file\"||die\"Unable to open $file: $!\\n\";\n    flock(FH,LOCK_EX) or die \"Unable to obtain file lock: $!\\n\";\n    foreach my $section(sort keys %{$CONFIG}){\n      print FH \"[$section]\\n\";\n      foreach my $para(sort keys %{$CONFIG->{$section}}){\n        print FH \"$para = $CONFIG->{$section}{$para}[0]\";\n\tif(defined $CONFIG->{$section}{$para}[1]){\n\t  print FH \"    $CM$CONFIG->{$section}{$para}[1]\\n\";\n\t}else{\n\t  print FH \"\\n\";\n\t}\n      }\n      print FH \"\\n\";\n    }\n    flock(FH,LOCK_UN) or die\"Unable to unlock file: $!\\n\";\n    close FH;\n  }\n\n  sub deparse{\n    my $tree=shift;\n    my $deparsed={};\n      for my $aref(@$tree){\n        for my $sec(@$aref){\n          my $hash=$deparsed->{$sec->[0]}={};\n          for my $aref(@{$sec->[1]}){\n\t    $hash->{$aref->[0]}=[$aref->[1]];\n\t    if(my $cmmnt=$aref->[2]){\n\t      $cmmnt=~s/^\\s+[#;]//;\n              push @{$hash->{$aref->[0]}},$cmmnt;\n            }\n          }\n        }\n      }\n    return $deparsed;\n  }\n1;\n}",
      "file" : "/var/tmp/arv_DW1ujw/Config-Yacp-2.00/lib/Config/Yacp.pm",
      "package" : "Config::Yacp"
   }
]
