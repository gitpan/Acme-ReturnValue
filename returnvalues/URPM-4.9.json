[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub parse_rpms_build_headers {\n    my ($urpm, %options) = @_;\n    my ($dir, %cache, @headers);\n\n    if (@{$options{rpms} || []} > 0) {\n\t$dir = $options{dir} || _get_tmp_dir();\n\t$options{clean} and system($ENV{LD_LOADER} ? $ENV{LD_LOADER} : @{[]}, \"rm\", \"-rf\", $dir);\n\t-d $dir or mkdir $dir, 0755 or die \"cannot create directory $dir\\n\";\n\n\tunless ($options{clean}) {\n\t    my $dirh;\n\t    opendir $dirh, $dir;\n\t    while (defined (my $file = readdir $dirh)) {\n\t\tmy ($fullname, $filename) = $file =~ /(.+?-[^:\\-]+-[^:\\-]+\\.[^:\\-\\.]+)(?::(\\S+))?$/ or next;\n\t\tmy @stat = stat \"$dir/$file\";\n\t\t$cache{$filename || $fullname} = {\n\t\t    file => $file,\n\t\t    size => $stat[7],\n\t\t    'time' => $stat[9],\n\t\t};\n\t    }\n\t    closedir $dirh;\n\t}\n\n\tforeach (@{$options{rpms}}) {\n\t    my ($key) = m!([^/]*)\\.rpm$! or next; \n\t    my ($id, $filename);\n\n\t    if ($cache{$key} && $cache{$key}{time} > 0 && $cache{$key}{time} >= (stat $_)[9]) {\n\t\t($id, undef) = $urpm->parse_hdlist(\"$dir/$cache{$key}{file}\", packing => $options{packing}, keep_all_tags => $options{keep_all_tags});\n\t\tunless (defined $id) {\n\t\t  if ($options{dontdie}) {\n\t\t    print STDERR \"bad header $dir/$cache{$key}{file}\\n\";\n\t\t    next;\n\t\t  } else {\n\t\t    die \"bad header $dir/$cache{$key}{file}\\n\";\n\t\t  }\n\t\t}\n\n\t\t$options{callback} and $options{callback}->($urpm, $id, %options, (file => $_));\n\n\t\t$filename = $cache{$key}{file};\n\t    } else {\n\t\t($id, undef) = $urpm->parse_rpm($_, keep_all_tags => $options{keep_all_tags});\n\t\tunless (defined $id) {\n\t\t    if ($options{dontdie}) {\n\t\t\tprint STDERR \"bad rpm $_\\n\";\n\t\t\tnext;\n\t\t    } else {\n\t\t\tdie \"bad rpm $_\\n\";\n\t\t    }\n\t\t}\n\t\t\n\t\tmy $pkg = $urpm->{depslist}[$id];\n\n\t\t$filename = $pkg->fullname;\n\n\t\tunless (-s \"$dir/$filename\") {\n\t\t    open my $fh, \">$dir/$filename\" or die \"unable to open $dir/$filename for writing\\n\";\n\t\t    $pkg->build_header(fileno $fh);\n\t\t    close $fh;\n\t\t}\n\t\t-s \"$dir/$filename\" or unlink(\"$dir/$filename\"), die \"can create header $dir/$filename\\n\";\n\n\t\t#- make smart use of memory (no need to keep header in memory now).\n\t\tif ($options{callback}) {\n\t\t    $options{callback}->($urpm, $id, %options, (file => $_));\n\t\t} else {\n\t\t\t$pkg->pack_header;\n\t\t}\n\n\t\t# Olivier Thauvin <thauvin@aerov.jussieu.fr>\n\t\t# isn't this code better, but maybe it will break some tools:\n\t\t# $options{callback}->($urpm, $id, %options, (file => $_)) if ($options{callback});\n\t\t# $pkg->pack_header;\n\t    }\n\n\t    #- keep track of header associated (to avoid rereading rpm filename directly\n\t    #- if rereading has been made neccessary).\n\t    push @headers, $filename;\n\t}\n    }\n    @headers;\n}\n\n# DEPRECATED. ONLY USED BY MKCD\n#\n#- allow rereading of hdlist and clean.\nsub unresolved_provides_clean {\n    my ($urpm) = @_;\n    $urpm->{depslist} = [];\n    $urpm->{provides}{$_} = undef foreach keys %{$urpm->{provides} || {}};\n}\n\n# DEPRECATED. ONLY USED BY MKCD\n#\n#- read a list of headers (typically when building an hdlist when provides have\n#- been cleaned).\n#- parameters are :\n#-   headers  : array containing all headers filenames to parse (mandatory)\n#-   dir      : directory which contains headers (defaults to /tmp/.build_hdlist)\n#-   callback : perl code to be called for each package read (defaults to pack_header)\nsub parse_headers {\n    my ($urpm, %options) = @_;\n    my ($dir, $start, $id);\n\n    $dir = $options{dir} || _get_tmp_dir();\n    -d $dir or die \"no directory $dir\\n\";\n\n    $start = @{$urpm->{depslist} || []};\n    foreach (@{$options{headers} || []}) {\n\t#- make smart use of memory (no need to keep header in memory now).\n\t($id, undef) = $urpm->parse_hdlist(\"$dir/$_\", packing => !$options{callback});\n\tdefined $id or die \"bad header $dir/$_\\n\";\n\t$options{callback} and $options{callback}->($urpm, $id, %options);\n    }\n    defined $id ? ($start, $id) : @{[]};\n}\n\n# DEPRECATED. ONLY USED BY MKCD\n#- compute dependencies, result in stored in info values of urpm.\n#- operations are incremental, it is possible to read just one hdlist, compute\n#- dependencies and read another hdlist, and again.\n#- parameters are :\n#-   callback : callback to relocate reference to package id.\nsub compute_deps {\n    my ($urpm, %options) = @_;\n    my %propagated_weight = (\n\tbasesystem => 10000,\n\tmsec       => 20000,\n\tfilesystem => 50000,\n    );\n    my ($locales_weight, $step_weight, $fixed_weight) = (-5000, 10000, $propagated_weight{basesystem});\n\n    #- avoid recomputing already present infos, take care not to modify\n    #- existing entries, as the array here is used instead of values of infos.\n    my $start = @{$urpm->{deps} ||= []};\n    my $end = $#{$urpm->{depslist} || []};\n\n    #- check if something has to be done.\n    $start > $end and return;\n\n    #- keep track of prereqs.\n    my %prereqs;\n\n    #- take into account in which hdlist a package has been found.\n    #- this can be done by an incremental take into account generation\n    #- of depslist.ordered part corresponding to the hdlist.\n    #- compute closed requires, do not take into account choices.\n    foreach ($start .. $end) {\n\tmy $pkg = $urpm->{depslist}[$_];\n\n\tmy %required_packages;\n\tmy @required_packages;\n\tmy %requires;\n\n\tforeach ($pkg->requires) {\n\t    my ($n, $prereq) = /^([^\\s\\[]*)(\\[\\*\\])?/;\n\t    $requires{$n} = $prereq && 1;\n\t}\n\tmy @requires = keys %requires;\n\n\twhile (my $req = shift @requires) {\n\t    $req =~ /^basesystem/ and next; #- never need to requires basesystem directly as always required! what a speed up!\n\t    my $treq = (\n\t\t$req =~ /^\\d+$/ ? [ $req ]\n\t\t: $urpm->{provides}{$req} ? [ keys %{$urpm->{provides}{$req}} ]\n\t\t: [ ($req !~ /NOTFOUND_/ ? \"NOTFOUND_\" : \"\") . $req ]\n\t    );\n\t    if (@$treq > 1) {\n\t\t#- this is a choice, no closure need to be done here.\n\t\tpush @required_packages, $treq;\n\t    } else {\n\t\t#- this could be nothing if the provides is a file not found.\n\t\t#- and this has been fixed above.\n\t\tforeach (@$treq) {\n\t\t    my $pkg_ = /^\\d+$/ && $urpm->{depslist}[$_];\n\t\t    exists $required_packages{$_} and $pkg_ = undef;\n\t\t    $required_packages{$_} ||= $requires{$req}; $pkg_ or next;\n\t\t    foreach ($pkg_->requires_nosense) {\n\t\t\texists $requires{$_} or push @requires, $_;\n\t\t\t$requires{$_} ||= $requires{$req};\n\t\t    }\n\t\t}\n\t    }\n\t}\n\t#- examine choice to remove those which are not mandatory.\n\tforeach (@required_packages) {\n\t    unless (grep { exists $required_packages{$_} } @$_) {\n\t\t$required_packages{join '|', sort { $a <=> $b } @$_} = undef;\n\t    }\n\t}\n\n\t#- store a short representation of requires.\n\t$urpm->{requires}[$_] = join ' ', keys %required_packages;\n\tforeach my $d (keys %required_packages) {\n\t    $required_packages{$d} or next;\n\t    $prereqs{$d}{$_} = undef;\n\t}\n    }\n\n    #- expand choices and closure again.\n    my %ordered;\n    foreach ($start .. $end) {\n\tmy @requires = $_;\n\tmy ($dep, %requires);\n\twhile (defined ($dep = shift @requires)) {\n\t    exists $requires{$dep} || /^[^\\d\\|]*$/ and next;\n\t    foreach ($dep, split ' ', (defined $urpm->{deps}[$dep] ? $urpm->{deps}[$dep] : $urpm->{requires}[$dep])) {\n\t\tif (/\\|/) {\n\t\t    push @requires, split /\\|/, $_;\n\t\t} else {\n\t\t    /^\\d+$/ and $requires{$_} = undef;\n\t\t}\n\t    }\n\t}\n\n\tmy $pkg = $urpm->{depslist}[$_];\n\tmy $delta = 1 + $propagated_weight{$pkg->name};\n\tforeach (keys %requires) {\n\t    $ordered{$_} += $delta;\n\t}\n    }\n\n    #- some package should be sorted at the beginning.\n    foreach (qw(basesystem msec rpm locales filesystem setup glibc sash bash libtermcap2 termcap readline ldconfig)) {\n\tforeach (keys %{$urpm->{provides}{$_} || {}}) {\n\t    /^\\d+$/ and $ordered{$_} = $fixed_weight;\n\t}\n\t/locales/ and $locales_weight += $fixed_weight;\n\t$fixed_weight += $step_weight;\n    }\n    foreach ($start .. $end) {\n\tmy $pkg = $urpm->{depslist}[$_];\n\n\t$pkg->name =~ /locales-[a-zA-Z]/ and $ordered{$_} = $locales_weight;\n    }\n\n    #- compute base flag, consists of packages which are required without\n    #- choices of basesystem and are ALWAYS installed. these packages can\n    #- safely be removed from requires of others packages.\n    foreach (qw(basesystem glibc kernel)) {\n\tforeach (keys %{$urpm->{provides}{$_} || {}}) {\n\t    foreach ($_, split ' ', (defined $urpm->{deps}[$_] ? $urpm->{deps}[$_] : $urpm->{requires}[$_])) {\n\t\t/^\\d+$/ and $urpm->{depslist}[$_] and $urpm->{depslist}[$_]->set_flag_base(1);\n\t    }\n\t}\n    }\n\n    #- give an id to each packages, start from number of package already\n    #- registered in depslist.\n    my %remap_ids; @remap_ids{sort {\n\texists $prereqs{$b}{$a} && ! exists $prereqs{$a}{$b} ? 1 :\n\t  $ordered{$b} <=> $ordered{$a} or do {\n\t      my ($na, $nb) = map { $urpm->{depslist}[$_]->name } ($a, $b);\n\t      my ($sa, $sb) = map { /^lib(.*)/ ? $1 : '' } ($na, $nb);\n\t      $sa && $sb ? $sa cmp $sb : $sa ? -1 : $sb ? 1 : $na cmp $nb;\n\t  } } ($start .. $end)} = ($start .. $end);\n\n    #- now it is possible to clean ordered and prereqs.\n    %ordered = %prereqs = ();\n\n    #- recompute requires to use packages id, drop any base packages or\n    #- reference of a package to itself.\n    my @depslist;\n    foreach ($start .. $end) {\n\tmy $pkg = $urpm->{depslist}[$_];\n\n\t#- set new id.\n\t$pkg->set_id($remap_ids{$_});\n\n\tmy ($id, $base, %requires_id, %not_founds);\n\tforeach (split ' ', $urpm->{requires}[$_]) {\n\t    if (/\\|/) {\n\t\t#- all choices are grouped together at the end of requires,\n\t\t#- this allow computation of dropable choices.\n\t\tmy ($to_drop, @choices_base_id, @choices_id);\n\t\tforeach (split /\\|/, $_) {\n\t\t    my ($id, $base) = (exists($remap_ids{$_}) ? $remap_ids{$_} : $_, $urpm->{depslist}[$_]->flag_base);\n\t\t    $base and push @choices_base_id, $id;\n\t\t    $base &&= ! $pkg->flag_base;\n\t\t    $to_drop ||= $id == $pkg->id || exists $requires_id{$id} || $base;\n\t\t    push @choices_id, $id;\n\t\t}\n\n\t\t#- package can safely be dropped as it will be selected in requires directly.\n\t\t$to_drop and next;\n\n\t\t#- if a base package is in a list, keep it instead of the choice.\n\t\tif (@choices_base_id) {\n\t\t    @choices_id = @choices_base_id;\n\t\t    $base = 1;\n\t\t}\n\t\tif (@choices_id == 1) {\n\t\t    $id = $choices_id[0];\n\t\t} else {\n\t\t    my $choices_key = join '|', sort { $a <=> $b } @choices_id;\n\t\t    $requires_id{$choices_key} = undef;\n\t\t    next;\n\t\t}\n\t    } elsif (/^\\d+$/) {\n\t\t($id, $base) =  (exists($remap_ids{$_}) ? $remap_ids{$_} : $_, $urpm->{depslist}[$_]->flag_base);\n\t    } else {\n\t\t$not_founds{$_} = undef;\n\t\tnext;\n\t    }\n\n\t    #- select individual package from choices or defined package.\n\t    $base &&= ! $pkg->flag_base;\n\t    $base || $id == $pkg->id or $requires_id{$id} = undef;\n\t}\n\t#- be smart with memory usage.\n\tdelete $urpm->{requires}[$_];\n\t$urpm->{deps}[$remap_ids{$_}] = join ' ', ((sort { ($a =~ /^(\\d+)/)[0] <=> ($b =~ /^(\\d+)/)[0] } keys %requires_id),\n\t\t\t\t\t\t   keys %not_founds);\n\t$depslist[$remap_ids{$_}-$start] = $pkg;\n    }\n\n    #- remap all provides ids for new package position and update depslist.\n    delete $urpm->{requires};\n    @{$urpm->{depslist}}[$start .. $end] = @depslist;\n    foreach my $h (values %{$urpm->{provides}}) {\n\tmy %provided;\n\tforeach (keys %{$h || {}}) {\n\t    $provided{exists($remap_ids{$_}) ? $remap_ids{$_} : $_} = delete $h->{$_};\n\t}\n\t$h = \\%provided;\n    }\n    $options{callback} and $options{callback}->($urpm, \\%remap_ids, %options);\n\n    ($start, $end);\n}\n\n# DEPRECATED. ONLY USED BY MKCD\n#\n#- build an hdlist from existing depslist, from start to end inclusive.\n#- parameters are :\n#-   hdlist   : hdlist file to use.\n#-   dir      : directory which contains headers (defaults to /tmp/.build_hdlist)\n#-   start    : index of first package (defaults to first index of depslist).\n#-   end      : index of last package (defaults to last index of depslist).\n#-   idlist   : id list of rpm to compute (defaults is start .. end)\n#-   ratio    : compression ratio (default 4).\n#-   split    : split ratio (default 400kb, see MDV::Packdrakeng).\nsub build_hdlist {\n    my ($urpm, %options) = @_;\n    my ($dir, $ratio, @idlist);\n\n    $dir = $options{dir} || _get_tmp_dir();\n     -d $dir or die \"no directory $dir\\n\";\n\n    @idlist = $urpm->build_listid($options{start}, $options{end}, $options{idlist});\n\n    #- compression ratio are not very high, sample for cooker\n    #- gives the following (main only and cache fed up):\n    #- ratio compression_time  size\n    #-   9       21.5 sec     8.10Mb   -> good for installation CD\n    #-   6       10.7 sec     8.15Mb\n    #-   5        9.5 sec     8.20Mb\n    #-   4        8.6 sec     8.30Mb   -> good for urpmi\n    #-   3        7.6 sec     8.60Mb\n    $ratio = $options{ratio} || 4;\n\n    require MDV::Packdrakeng;\n    my $pack = MDV::Packdrakeng->new(\n\tarchive => $options{hdlist},\n\tcompress => \"gzip\",\n\tuncompress => \"gzip -d\",\n\tblock_size => $options{split},\n\tcomp_level => $ratio,\n    ) or die \"Can't create archive\";\n    foreach my $pkg (@{$urpm->{depslist}}[@idlist]) {\n\tmy $filename = $pkg->fullname;\n\t-s \"$dir/$filename\" or die \"bad header $dir/$filename\\n\";\n\t$pack->add($dir, $filename);\n    }\n}\n\n#- build synthesis file.\n#- used by genhdlist2 and mkcd\n#-\n#- parameters are :\n#-   synthesis : synthesis file to create (mandatory if fd not given).\n#-   fd        : file descriptor (mandatory if synthesis not given).\n#-   start     : index of first package (defaults to first index of depslist).\n#-   end       : index of last package (defaults to last index of depslist).\n#-   idlist    : id list of rpm to compute (defaults is start .. end)\n#-   ratio     : compression ratio (default 9).\n#-   filter    : program to filter through (default is 'gzip -$ratio').\n#- returns true on success\nsub build_synthesis {\n    my ($urpm, %options) = @_;\n    my ($ratio, $filter, @idlist);\n\n    @idlist = $urpm->build_listid($options{start}, $options{end}, $options{idlist});\n\n    $ratio = $options{ratio} || 9;\n    $filter = $options{filter} || \"gzip -$ratio\";\n    $options{synthesis} || defined $options{fd} or die \"invalid parameters given\";\n\n    #- first pass: traverse provides to find files provided.\n    my %provided_files;\n    foreach (keys %{$urpm->{provides}}) {\n\tm!^/! or next;\n\tforeach my $id (keys %{$urpm->{provides}{$_} || {}}) {\n\t    push @{$provided_files{$id} ||= []}, $_;\n\t}\n    }\n\n\n    #- second pass: write each info including files provided.\n    $options{synthesis} and open my $fh, \"| \" . ($ENV{LD_LOADER} || '') . \" $filter >'$options{synthesis}'\";\n    foreach (@idlist) {\n\tmy $pkg = $urpm->{depslist}[$_];\n\tmy %files;\n\n\tif ($provided_files{$_}) {\n\t    @files{@{$provided_files{$_}}} = undef;\n\t    delete @files{$pkg->provides_nosense};\n\t}\n\n\t$pkg->build_info($options{synthesis} ? fileno $fh : $options{fd}, join('@', keys %files));\n    }\n    close $fh; # returns true on success\n}\n\n# DEPRECATED. ONLY USED BY MKCD\n#- write depslist.ordered file according to info in params.\n#- parameters are :\n#-   depslist : depslist.ordered file to create.\n#-   provides : provides file to create.\n#-   compss   : compss file to create.\nsub build_base_files {\n    my ($urpm, %options) = @_;\n\n    if ($options{depslist}) {\n\topen my $fh, \">\", $options{depslist} or die \"Can't write to $options{depslist}: $!\\n\";\n\tforeach (0 .. $#{$urpm->{depslist}}) {\n\t    my $pkg = $urpm->{depslist}[$_];\n\n\t    printf $fh (\"%s-%s-%s.%s%s %s %s\\n\", $pkg->fullname,\n\t\t      ($pkg->epoch ? ':' . $pkg->epoch : ''), $pkg->size || 0, $urpm->{deps}[$_]);\n\t}\n\tclose $fh;\n    }\n\n    if ($options{provides}) {\n\topen my $fh, \">\", $options{provides} or die \"Can't write to $options{provides}: $!\\n\";\n\twhile (my ($k, $v) = each %{$urpm->{provides}}) {\n\t    printf $fh \"%s\\n\", join '@', $k, map { scalar $urpm->{depslist}[$_]->fullname } keys %{$v || {}};\n\t}\n\tclose $fh;\n    }\n\n    if ($options{compss}) {\n\tmy %p;\n\n\topen my $fh, \">\", $options{compss} or die \"Can't write to $options{compss}: $!\\n\";\n\tforeach (@{$urpm->{depslist}}) {\n\t    $_->group or next;\n\t    push @{$p{$_->group} ||= []}, $_->name;\n\t}\n\tforeach (sort keys %p) {\n\t    print $fh $_, \"\\n\";\n\t    foreach (@{$p{$_}}) {\n\t\tprint $fh \"\\t\", $_, \"\\n\";\n\t    }\n\t    print $fh \"\\n\";\n\t}\n\tclose $fh;\n    }\n\n    1;\n}\n\nour $MAKEDELTARPM = '/usr/bin/makedeltarpm';\n\n#- make_delta_rpm($old_rpm_file, $new_rpm_file)\n# Creates a delta rpm in the current directory.\n\n# DEPRECATED. UNUSED\nsub make_delta_rpm ($$) {\n    @_ == 2 or return 0;\n    -e $_[0] && -e $_[1] && -x $MAKEDELTARPM or return 0;\n    my @id;\n    my $urpm = new URPM;\n    foreach my $i (0, 1) {\n\t($id[$i]) = $urpm->parse_rpm($_[$i]);\n\tdefined $id[$i] or return 0;\n    }\n    my $oldpkg = $urpm->{depslist}[$id[0]];\n    my $newpkg = $urpm->{depslist}[$id[1]];\n    $oldpkg->arch eq $newpkg->arch or return 0;\n    #- construct filename of the deltarpm\n    my $patchrpm = $oldpkg->name . '-' . $oldpkg->version . '-' . $oldpkg->release . '_' . $newpkg->version . '-' . $newpkg->release . '.' . $oldpkg->arch . '.delta.rpm';\n    !system($MAKEDELTARPM, @_, $patchrpm);\n}\n\n1\n",
      "file" : "/var/tmp/arv_OMdl06/URPM-4.9/URPM/Build.pm",
      "package" : "URPM"
   }
]
