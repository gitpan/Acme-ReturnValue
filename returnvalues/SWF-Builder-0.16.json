[
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n    package SWF::Builder::Shape::Transformer;\n\n    use warnings::register;\n\n    @SWF::Builder::Shape::Transformer::ISA = ('SWF::Builder::Shape::ExDraw');\n\n    sub new {\n\tmy ($class, $shape, $matrix) = @_;\n\n\t my $self = bless {\n\t    shape => $shape,\n\t    matrix => $matrix,\n\t    inv_matrix => undef,\n\t}, $class;\n    }\n\n    sub get_pos {\n\tmy $self = shift;\n\tmy $m = $self->{matrix};\n\tmy $im = $self->{inv_matrix};\n\n\tunless (defined $im) {\n\t    my $a = $m->ScaleX;\n\t    my $b = $m->RotateSkew0;\n\t    my $c = $m->RotateSkew1;\n\t    my $d = $m->ScaleY;\n\t    my $det = $a*$d - $b*$c;\n\n\t    $im = SWF::Element::MATRIX->new;\n\n\t    if ($det) {\n\t\t$im->ScaleX($d / $det);\n\t\t$im->RotateSkew0(-$b / $det);\n\t\t$im->RotateSkew1(-$c / $det);\n\t\t$im->ScaleY($a / $det);\n\t    } else {\n\t\tif (warnings::enabled()) {\n\t\t    warnings::warn(\"Can't calculate inverse mapping\");\n\t\t}\n\t\tif ($a-$b == 0) {\n\t\t    $im->RotateSkew1(0);\n\t\t    $im->ScaleX(0);\n\t\t    if ($c-$d == 0) {\n\t\t\t$im->RotateSkew0(0);\n\t\t\t$im->ScaleY(0);\n\t\t    } else {\n\t\t\t$im->RotateSkew0(1/($c-$d));\n\t\t\t$im->ScaleY(-1/($c-$d));\n\t\t    }\n\t\t} else {\n\t\t    $im->ScaleX(1/($a-$b));\n\t\t    $im->RotateSkew0(0);\n\t\t    $im->RotateSkew1(-1/($a-$b));\n\t\t    $im->ScaleY(0);\n\t\t}\n\t    }\n\t    $self->{inv_matrix} = $im;\n\t}\n\tmy ($x, $y) = $self->{shape}->get_pos;\n\t$x -= $m->TranslateX * 20;  \n\t$y -= $m->TranslateY * 20;\n\treturn ($x * $im->ScaleX + $y * $im->RotateSkew1, $x * $im->RotateSkew0 + $y * $im->ScaleY);\n    }\n\n    sub _transform {\n\tmy $self = shift;\n\tmy $sx = $self->{matrix}->ScaleX;\n\tmy $sy = $self->{matrix}->ScaleY;\n\tmy $r0 = $self->{matrix}->RotateSkew0;\n\tmy $r1 = $self->{matrix}->RotateSkew1;\n\tmy $tx = $self->{matrix}->TranslateX||0;\n\tmy $ty = $self->{matrix}->TranslateY||0;\n\tmy @p;\n\n\twhile (my ($x, $y) = splice(@_, 0, 2)) {\n\t    push @p, $x * $sx + $y * $r1 + $tx, $x * $r0 + $y * $sy + $ty;\n\t}\n\treturn @p;\n    }\n\n    sub _r_transform {\n\tmy $self = shift;\n\tmy $sx = $self->{matrix}->ScaleX;\n\tmy $sy = $self->{matrix}->ScaleY;\n\tmy $r0 = $self->{matrix}->RotateSkew0;\n\tmy $r1 = $self->{matrix}->RotateSkew1;\n\tmy @p;\n\n\twhile (my ($x, $y) = splice(@_, 0, 2)) {\n\t    push @p, $x * $sx + $y * $r1, $x * $r0 + $y * $sy;\n\t}\n\treturn @p;\n    }\n\n    sub end_transform {\n\treturn shift->{shape};\n    }\n\n    sub AUTOLOAD {\n\tour $AUTOLOAD;\n\treturn if $AUTOLOAD =~ /::DESTROY$/;\n\n\tmy $self = shift;\n\tif ($AUTOLOAD =~ /::((_r)?[^:]+to_twips)$/) {\n\t    my $method = $1;\n\t    if ($2) {\n\t\t$self->{shape}->$method($self->_r_transform(@_));\n\t    } else {\n\t\t$self->{shape}->$method($self->_transform(@_));\n\t    }\n\t} else {\n\t    $self->{shape}->$1(@_);\n\t}\n\t$self;\n    }\n}",
      "file" : "/var/tmp/arv_5AUqqT/SWF-Builder-0.16/lib/SWF/Builder/Shape.pm",
      "package" : "SWF::Builder::Shape"
   }
]
