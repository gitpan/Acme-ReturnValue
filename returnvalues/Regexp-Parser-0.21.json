[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub init {\n  my ($self) = @_;\n\n  $self->add_handler('atom' => sub {\n    my ($S) = @_;\n    $S->nextchar;\n\n    ${&Rx} =~ m{ \\G (.) }xgcs or return;\n    my $c = $1;\n\n    push @{ $S->{next} }, qw< atom >;\n    return $S->$c if $S->can($c);\n    return $S->object(exact => $c);\n  });\n\n\n  $self->add_handler('\\\\' => sub {\n    my ($S, $cc) = @_;\n    my $c = '\\\\';\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      $c .= (my $n = $1);\n\n      return $S->$c($cc) if $S->can($c);\n      --&RxPOS;\n\n      $S->warn(RPe_BADESC, $c = $n, \"\") if $n =~ /[a-zA-Z]/;\n\n      return $S->object(exact => $n, $c);\n    }\n\n    $S->error(RPe_ESLASH);\n  });\n\n  $self->add_handler('\\b' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char => \"\\b\", '\\b') if $cc;\n    return $S->object(bound => bound => '\\b');\n  });\n\n  $self->add_handler('\\B' => sub {\n    my ($S, $cc) = @_;\n    $S->warn(RPe_BADESC, \"B\", \" in character class\") if $cc;\n    return $S->force_object(anyof_char => 'B') if $cc;\n    return $S->object(bound => nbound => '\\B');\n  });\n\n  $self->add_handler('\\c' => sub {\n    my ($S, $cc) = @_;\n\n    if (${&Rx} =~ m{ \\G ($non_nest_brack) }xgc) {\n      my $n = substr($1, 1, -1);\n      my @names = split /;/, $n;\n\n      if ($cc) {\n        $S->error(0, \"\\\\c[A;B] in character class\") if @names > 1;\n        return $S->force_object(anyof_char => $S->nchar($n), \"\\\\c[$n]\");\n      }\n\n      return $S->object(exact => join(\"\", $S->nchar(@names)), \"\\\\c[$n]\");\n    }\n\n    $S->error(0, \"Missing right %s on \\\\%s\", 'brace', \"c$1\") if ${&Rx} =~ m{ \\G ([[({<]) }xgc;\n    $S->error(0, \"Missing brackets on \\\\%s\", 'c');\n  });\n\n  $self->add_handler('\\C' => sub {\n    my ($S, $cc) = @_;\n\n    if (${&Rx} =~ m{ \\G ($non_nest_brack) }xgc) {\n      my $n = substr($1, 1, -1);\n      my @names = split /;/, $n;\n\n      if ($cc) {\n        $S->error(0, \"\\\\C[A;B] in character class\") if @names > 1;\n        return $S->force_object(anyof_char_comp => $S->nchar($n), \"\\\\C[$n]\");\n      }\n\n      return $S->object(exact_comp => join(\"\", $S->nchar(@names)), \"\\\\C[$n]\");\n    }\n\n    $S->error(0, \"Missing right %s on \\\\%s\", 'brace', \"C$1\") if ${&Rx} =~ m{ \\G ([[({<]) }xgc;\n    $S->error(0, \"Missing brackets on \\\\%s\", 'C');\n  });\n\n  $self->add_handler('\\d' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(digit => 0)) if $cc;\n    return $S->object(digit => 0);\n  });\n\n  $self->add_handler('\\D' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(digit => 1)) if $cc;\n    return $S->object(digit => 1);\n  });\n\n  $self->add_handler('\\e' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char => \"\\e\", '\\e') if $cc;\n    return $S->object(exact => \"\\e\", '\\e');\n  });\n\n  $self->add_handler('\\E' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char_comp => \"\\e\", '\\E') if $cc;\n    return $S->object(exact_comp => \"\\e\", '\\E');\n  });\n\n  $self->add_handler('\\f' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char => \"\\f\", '\\f') if $cc;\n    return $S->object(exact => \"\\f\", '\\f');\n  });\n\n  $self->add_handler('\\F' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char_comp => \"\\f\", '\\F') if $cc;\n    return $S->object(exact_comp => \"\\f\", '\\F');\n  });\n\n  $self->add_handler('\\h' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(horiz => 0)) if $cc;\n    return $S->object(horiz => 0);\n  });\n\n  $self->add_handler('\\H' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(horiz => 1)) if $cc;\n    return $S->object(horiz => 1);\n  });\n\n  $self->add_handler('\\n' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char => \"\\n\", '\\n') if $cc;\n    return $S->object(exact => \"\\n\", '\\n');\n  });\n\n  $self->add_handler('\\N' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char_comp => \"\\n\", '\\N') if $cc;\n    return $S->object(exact_comp => \"\\n\", '\\N');\n  });\n\n  $self->add_handler('\\r' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char => \"\\r\", '\\r') if $cc;\n    return $S->object(exact => \"\\r\", '\\r');\n  });\n\n  $self->add_handler('\\R' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char_comp => \"\\r\", '\\R') if $cc;\n    return $S->object(exact_comp => \"\\r\", '\\R');\n  });\n\n  $self->add_handler('\\s' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(space => 0)) if $cc;\n    return $S->object(space => 0);\n  });\n\n  $self->add_handler('\\S' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(space => 1)) if $cc;\n    return $S->object(space => 1);\n  });\n\n  $self->add_handler('\\t' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char => \"\\t\", '\\t') if $cc;\n    return $S->object(exact => \"\\t\", '\\t');\n  });\n\n  $self->add_handler('\\T' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_char_comp => \"\\t\", '\\T') if $cc;\n    return $S->object(exact_comp => \"\\t\", '\\T');\n  });\n\n  $self->add_handler('\\v' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(vert => 0)) if $cc;\n    return $S->object(vert => 0);\n  });\n\n  $self->add_handler('\\V' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(vert => 1)) if $cc;\n    return $S->object(vert => 1);\n  });\n\n  $self->add_handler('\\w' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(alnum => 0)) if $cc;\n    return $S->object(alnum => 0);\n  });\n\n  $self->add_handler('\\W' => sub {\n    my ($S, $cc) = @_;\n    return $S->force_object(anyof_class => $S->force_object(alnum => 1)) if $cc;\n    return $S->object(alnum => 1);\n  });\n\n  $self->add_handler('\\x' => sub {\n    my ($S, $cc) = @_;\n\n    if (${&Rx} =~ m{ \\G ($non_nest_brack) }xgc) {\n      my $h = substr($1, 1, -1);\n      my @hex = split /;/, $h;\n\n      $S->warn(0, \"Illegal hexadecimal digit '%s' ignored\", $1) if $h =~ /([^a-fA-F0-9;])/;\n\n      if ($cc) {\n        $S->error(0, \"\\\\x[A;B] in character class\") if @hex > 1;\n        return $S->force_object(anyof_char => chr(hex $h), \"\\\\x[$h]\");\n      }\n\n      return $S->object(exact => join(\"\", map chr(hex), @hex), \"\\\\x[$h]\");\n    }\n\n    $S->error(0, \"Missing right %s on \\\\%s\", 'brace', \"x$1\") if ${&Rx} =~ m{ \\G ([[({<]) }xgc;\n\n    if (${&Rx} =~ m{ \\G ( [a-fA-F0-9]+ ) }xgc) {\n      return $S->force_object(anyof_char => chr(hex $1), \"\\\\x$1\") if $cc;\n      return $S->object(exact => chr(hex $1), \"\\\\x$1\");\n    }\n\n    $S->warn(0, \"Illegal hexadecimal digit '%s' ignored\", substr(${&Rx}, &RxPOS, 1));\n    return $S->force_object(anyof_char => \"\\0\", \"\\\\x[0]\") if $cc;\n    return $S->object(exact => \"\\0\", \"\\\\x[0]\");\n  }\n\n  $self->add_handler('\\X' => sub {\n    my ($S, $cc) = @_;\n\n    if (${&Rx} =~ m{ \\G ($non_nest_brack) }xgc) {\n      my $h = substr($1, 1, -1);\n      my @hex = split /;/, $h;\n\n      $S->warn(0, \"Illegal hexadecimal digit '%s' ignored\", $1) if $h =~ /([^a-fA-F0-9;])/;\n\n      if ($cc) {\n        $S->error(0, \"\\\\X[A;B] in character class\") if @hex > 1;\n        return $S->force_object(anyof_char_comp => chr(hex $h), \"\\\\X[$h]\");\n      }\n\n      return $S->object(exact_comp => join(\"\", map chr(hex), @hex), \"\\\\X[$h]\");\n    }\n\n    $S->error(0, \"Missing right %s on \\\\%s\", 'brace', \"X$1\") if ${&Rx} =~ m{ \\G ([[({<]) }xgc;\n\n    if (${&Rx} =~ m{ \\G ( [a-fA-F0-9]+ ) }xgc) {\n      return $S->force_object(anyof_char_comp => chr(hex $1), \"\\\\X$1\") if $cc;\n      return $S->object(exact_comp => chr(hex $1), \"\\\\X$1\");\n    }\n\n    $S->warn(0, \"Illegal hexadecimal digit '%s' ignored\", substr(${&Rx}, &RxPOS, 1));\n    return $S->force_object(anyof_char_comp => \"\\0\", \"\\\\X[0]\") if $cc;\n    return $S->object(exact_comp => \"\\0\", \"\\\\X[0]\");\n  }\n\n  $self->add_handler('\\0' => sub {\n    my ($S, $cc) = @_;\n\n    if (${&Rx} =~ m{ \\G ($non_nest_brack) }xgc) {\n      my $o = substr($1, 1, -1);\n      my @oct = split /;/, $o;\n\n      $S->warn(0, \"Illegal octal digit '%s' ignored\", $1) if $o =~ /([^0-7;])/;\n\n      if ($cc) {\n        $S->error(0, \"\\\\0[A;B] in character class\") if @oct > 1;\n        return $S->force_object(anyof_char => chr(oct $o), \"\\\\0[$o]\");\n      }\n\n      return $S->object(exact => join(\"\", map chr(oct), @oct), \"\\\\0[$o]\");\n    }\n\n    $S->error(0, \"Missing right %s on \\\\%s\", 'brace', \"0$1\") if ${&Rx} =~ m{ \\G ([[({<]) }xgc;\n\n    if (${&Rx} =~ m{ \\G ( [0-7]+ ) }xgc) {\n      return $S->force_object(anyof_char => chr(oct $1), \"\\\\0$1\") if $cc;\n      return $S->object(exact => chr(oct $1), \"\\\\0$1\");\n    }\n\n    $S->warn(0, \"Illegal octal digit '%s' ignored\", substr(${&Rx}, &RxPOS, 1));\n    return $S->force_object(anyof_char => \"\\0\", \"\\\\0[0]\") if $cc;\n    return $S->object(exact => \"\\0\", \"\\\\0[0]\");\n  });\n\n\n\n  $self->add_flag('i' =>  sub { 0x01 });\n\n  $self->add_handler(':' => sub {\n    my ($S) = @_;\n\n    if (${&Rx} =~ m{ \\G \\: }xgc) {\n      my $n = '::';\n      return $S->$n;\n    }\n\n    if (${&Rx} =~ m{ \\G ([a-z]+) }xgc) {\n    }\n\n  });\n\n  $self->add_handler('::' => sub {\n    my ($S) = @_;\n\n    if (${&Rx} =~ m{ \\G \\: }xgc) {\n      my $n = ':::';\n      return $S->$n;\n    }\n  });\n\n  $self->add_handler(':::' => sub {\n    my ($S) = @_;\n  });\n\n\n\n\n\n\n  $self->add_handler('$' => sub {\n    my ($S) = @_;\n\n    if (${&Rx} =~ m{ \\G \\$ }xgc) {\n      my $n = '$$';\n      return $S->$n;\n    }\n\n    if ($S->match_scalar) {\n    }\n\n    return $S->object(eol => eos => '$');\n  });\n\n  $self->add_handler('$$' => sub {\n    my ($S) = @_;\n\n    if ($S->match_scalar) {\n    }\n\n    return $S->object(eol => eol => '$$');\n  });\n\n\n\n\n\n\n\n  $self->add_handler('^' => sub {\n    my ($S) = @_;\n\n    if (${&Rx} =~ m{ \\G \\^ }xgc) {\n      my $n = '^^';\n      return $S->$n;\n    }\n\n    return $S->object(bol => bos => '^');\n  });\n\n  $self->add_handler('^^' => sub {\n    my ($S) = @_;\n    return $S->object(bol => bol => '^^');\n  });\n\n\n\n\n\n  $self->add_handler('*' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< minmod >;\n    return $S->object(quant => 0, '');\n  });\n\n\n\n  $self->add_handler('+' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< minmod >;\n    return $S->object(quant => 1, '');\n  });\n\n\n\n  $self->add_handler('?' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< minmod >;\n    return $S->object(quant => 0, 1);\n  });\n\n\n\n  $self->add_handler('(' => sub {\n    my ($S) = @_;\n    $S->nextchar;\n\n    push @{ $S->{next} }, qw< c) atom >;\n    &SIZE_ONLY ? ++$S->{maxpar} : ++$S->{nparen};\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(open => $S->{nparen});\n  });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  $self->add_handler('.' => sub {\n    my ($S) = @_;\n    return $S->object(reg_any => sany => '.');\n  });\n\n\n\n  $self->add_handler('|' => sub {\n    my ($S) = @_;\n    return $S->object(branch =>);\n  });\n\n\n  return;\n\n  $self->add_handler('\\c' => sub {\n    my ($S, $cc) = @_;\n    ${&Rx} =~ m{ \\G (.?) }xgc;\n    my $c = $1;\n    return $S->force_object(anyof_char => chr(64 ^ ord $c), \"\\\\c$c\") if $cc;\n    return $S->object(exact => chr(64 ^ ord $c), \"\\\\c$c\");\n  });\n\n  $self->add_handler('\\P' => sub {\n    my ($S, $cc) = @_;\n    $S->error(RPe_EMPTYB, 'P') if ${&Rx} !~ m{ \\G (.) }xgcs;\n\n    my $name = $1;\n    if ($name eq '{') {\n      $S->error(RPe_RBRACE, 'P') if ${&Rx} !~ m{ \\G ([^\\}]*) \\} }xgc;\n      $name = $1;\n    }\n\n    return $S->force_object(anyof_class => $S->force_object(prop => $name, 1)) if $cc;\n    return $S->object(prop => $name, 1);\n  });\n\n  $self->add_handler('\\p' => sub {\n    my ($S, $cc) = @_;\n    $S->error(RPe_EMPTYB, 'p') if ${&Rx} !~ m{ \\G (.) }xgcs;\n\n    my $name = $1;\n    if ($name eq '{') {\n      $S->error(RPe_RBRACE, 'p') if ${&Rx} !~ m{ \\G ([^\\}]*) \\} }xgc;\n      $name = $1;\n    }\n\n    return $S->force_object(anyof_class => $S->force_object(prop => $name, 0)) if $cc;\n    return $S->object(prop => $name, 0);\n  });\n\n  $self->add_handler('\\X' => sub {\n    my ($S, $cc) = @_;\n    $S->warn(RPe_BADESC, 'X', ' in character class') if $cc;\n    return $S->force_object(anyof_char => 'X') if $cc;\n    return $S->object(clump => '\\X');\n  });\n\n  $self->add_handler('\\x' => sub {\n    my ($S, $cc) = @_;\n    ${&Rx} =~ m{ \\G ( \\{ | .{0,2} ) }sxgc;\n    my $brace = 0;\n    my $num = $1;\n\n    if ($num eq '{') {\n      $S->error(RPe_RBRACE, 'x') if ${&Rx} !~ m{ \\G ( [^\\}]* ) \\} }xgc;\n      $num = $1;\n      $brace = 1;\n    }\n    else {\n      my $good = ($num =~ s/^([a-fA-F0-9]*)// and $1);\n      &RxPOS -= length $num;\n      $num = $good;\n    }\n\n    my $rep = $brace ? \"\\\\x{$num}\" : sprintf(\"\\\\x%02s\", $num);\n    return $S->force_object(anyof_char => chr hex $num, $rep) if $cc;\n    return $S->object(exact => chr hex $num, $rep);\n  });\n\n  $self->add_handler('POSIX_alpha' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => alpha => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_alnum' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => alnum => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_ascii' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => ascii => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_cntrl' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => cntrl => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_digit' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => digit => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_graph' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => graph => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_lower' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => lower => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_print' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => print => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_punct' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => punct => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_space' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => space => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_upper' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => upper => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_word' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => word => $neg, \\$how);\n  });\n\n  $self->add_handler('POSIX_xdigit' => sub {\n    my ($S, $neg, $how) = @_;\n    return $S->force_object(anyof_class => xdigit => $neg, \\$how);\n  });\n\n  $self->add_handler('{' => sub {\n    my ($S) = @_;\n    if (${&Rx} =~ m{ \\G (\\d+) (,?) (\\d*) \\} }xgc) {\n      my ($min, $range, $max) = ($1, $2, $3);\n      $max = $min unless $range;\n      push @{ $S->{next} }, qw< minmod >;\n      $S->error(RPe_BCURLY) if length($max) and $min > $max;\n      return $S->object(quant => $min, $max);\n    }\n    return $S->object(exact => '{');\n  });\n\n  $self->add_handler('minmod' => sub {\n    my ($S) = @_;\n    $S->nextchar;\n    return $S->object(minmod =>) if ${&Rx} =~ m{ \\G \\? }xgc;\n    return;\n  });\n\n\n\n\n\n  $self->add_handler('[' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< cce] cc cc] >;\n    my $neg = ${&Rx} =~ m{ \\G \\^ }xgc;\n\n    my $pos = &RxPOS;\n    if (${&Rx} =~ m{ \\G ([:.=]) .*? \\1 ] }xgc) {\n      $S->warn(RPe_OUTPOS, $1, $1);\n      &RxPOS = $pos;\n    }\n\n    return $S->object(anyof => $neg);\n  });\n\n  $self->add_handler('cc]' => sub {\n    my ($S) = @_;\n    return unless ${&Rx} =~ m{ \\G ] }xgc;\n    return $S->object(anyof_char => \"]\");\n  });\n\n  $self->add_handler('cc' => sub {\n    my ($S) = @_;\n    return if ${&Rx} =~ m{ \\G (?= ] | \\z ) }xgc;\n    push @{ $S->{next} }, qw< cc >;\n    my ($lhs, $rhs, $before_range);\n    my $ret = \\$lhs;\n\n    {\n      if (${&Rx} =~ m{ \\G ( \\\\ ) }xgcs) {\n        my $c = $1;\n        $$ret = $S->$c(1);\n      }\n      elsif (${&Rx} =~ m{ \\G \\[ ([.=:]) (\\^?) (.*?) \\1 \\] }xgcs) {\n        my ($how, $neg, $name) = ($1, $2, $3);\n        my $posix = \"POSIX_$name\";\n        if ($S->can($posix)) { $$ret = $S->$posix($neg, $how) }\n        else { $S->error(RPe_BADPOS, \"$how$neg$name$how\") }\n      }\n      elsif (${&Rx} =~ m{ \\G (.) }xgcs) {\n        $$ret = $S->force_object(anyof_char => $1);\n      }\n\n      if ($ret == \\$lhs) {\n        if (${&Rx} =~ m{ \\G (?= - ) }xgc) {\n          if ($lhs->visual =~ /^(?:\\[[:.=]|\\\\[dDsSwWpP])/) {\n            $S->warn(RPe_FRANGE, $lhs->visual, \"\");\n            $ret = $lhs;\n            last;\n          }\n          $before_range = &RxPOS++;\n          $ret = \\$rhs;\n          redo;\n        }\n        $ret = $lhs;\n      }\n      elsif ($ret == \\$rhs) {\n        if ($rhs->visual =~ /^(?:\\[[:.=]|\\\\[dDsSwWpP])/) {\n          $S->warn(RPe_FRANGE, $lhs->visual, $rhs->visual);\n          &RxPOS = $before_range;\n          $ret = $lhs;\n        }\n        elsif ($lhs->visual gt $rhs->visual) {\n          $S->error(RPe_IRANGE, $lhs->visual, $rhs->visual);\n        }\n        else {\n          $ret = $S->object(anyof_range => $lhs, $rhs);\n        }\n      }\n    }\n\n    return if &SIZE_ONLY;\n    return $ret;\n  });\n\n  $self->add_handler('cce]' => sub {\n    my ($S) = @_;\n    $S->error(RPe_LBRACK) if ${&Rx} !~ m{ \\G ] }xgc;\n    return $S->object(anyof_close => \"]\");\n  });\n\n  $self->add_handler(')' => sub {\n    my ($S) = @_;\n    pop @{ $S->{next} };\n    &RxPOS--;\n    return;\n  });\n\n  $self->add_handler('c)' => sub {\n    my ($S) = @_;\n    $S->error(RPe_LPAREN) if ${&Rx} !~ m{ \\G \\) }xgc;\n    pop @{ $S->{flags} };\n    return $S->object(close =>);\n  });\n\n  $self->add_handler('(?' => sub {\n    my ($S) = @_;\n    my $c = '(?';\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n      &RxPOS--;\n    }\n    else {\n      $S->error(RPe_SEQINC);\n    }\n\n    ${&Rx} =~ m{ \\G ([a-zA-Z]*) (-? [a-zA-Z]*) }xgc;\n    my ($on, $off) = ($1, $2);\n    my ($r_on, $r_off) = (\"\", \"\");\n    my ($f_on, $f_off) = (0,0);\n\n    &RxPOS -= length($on.$off);\n    my $old = &RxPOS;\n\n    for (split //, $on) {\n      &RxPOS++;\n      if (my $f = $S->can(\"FLAG_$_\")) {\n        my $v = $S->$f(1) and $r_on .= $_;\n        $f_on |= $v;\n        next;\n      }\n      my $bad = substr ${&Rx}, $old;\n      $S->error(RPe_NOTREC, &RxPOS - $old, $bad);\n    }\n\n    &RxPOS++ if $off =~ s/^-//;\n\n    for (split //, $off) {\n      &RxPOS++;\n      if (my $f = $S->can(\"FLAG_$_\")) {\n        my $v = $S->$f(0) and $r_off .= $_;\n        $f_off |= $v;\n        next;\n      }\n      my $bad = substr ${&Rx}, $old;\n      $S->error(RPe_NOTREC, &RxPOS - $old, $bad);\n    }\n\n    if (${&Rx} =~ m{ \\G ([:)]) }xgc) {\n      my $type = $1 eq ':' ? 'group' : 'flags';\n      if ($type eq 'group') {\n        push @{ $S->{flags} }, &Rf;\n        push @{ $S->{next} }, qw< c) atom >;\n      }\n      &Rf |= $f_on;\n      &Rf &= ~$f_off;\n      return $S->object($type => $r_on, $r_off);\n    }\n\n    &RxPOS++;\n    my $l = length($on.$off) + 2;\n    $S->error(RPe_NOTREC, $l, substr(${&Rx}, $old));\n  });\n\n  $self->add_handler('(?#' => sub {\n    my ($S) = @_;\n    ${&Rx} =~ m{ \\G [^)]* }xgc;\n    $S->error(RPe_NOTERM) unless ${&Rx} =~ m{ \\G \\) }xgc;\n    return;\n  });\n\n  $self->add_handler('(?$' => sub {\n    my ($S) = @_;\n    $S->error(RPe_NOTREC, 1, substr(${&Rx}, &RxPOS - 1));\n  });\n\n  $self->add_handler('(?@' => sub {\n    my ($S) = @_;\n    $S->error(RPe_NOTREC, 1, substr(${&Rx}, &RxPOS - 1));\n  });\n\n  $self->add_handler('(?=' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< c) atom >;\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(ifmatch => 1);\n  });\n\n  $self->add_handler('(?!' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< c) atom >;\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(unlessm => 1);\n  });\n\n  $self->add_handler('(?<' => sub {\n    my ($S) = @_;\n    my $c = '(?<';\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n    }\n\n    $S->error(RPe_NOTREC, 2, substr(${&Rx}, &RxPOS - 2));\n  });\n\n  $self->add_handler('(?<=' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< c) atom >;\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(ifmatch => -1);\n  });\n\n  $self->add_handler('(?<!' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< c) atom >;\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(unlessm => -1);\n  });\n\n  $self->add_handler('(?>' => sub {\n    my ($S) = @_;\n    push @{ $S->{next} }, qw< c) atom >;\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(suspend =>);\n  });\n\n  $self->add_handler('(?{' => sub {\n    my ($S) = @_;\n    if (${&Rx} =~ m{ \\G ($nest_eval) \\} \\) }xgc) {\n      push @{ $S->{flags} }, &Rf;\n      return $S->object(eval => $1);\n    }\n    $S->error(RPe_NOTBAL);\n  });\n\n  $self->add_handler('(??' => sub {\n    my ($S) = @_;\n    my $c = '(??';\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n    }\n\n    $S->error(RPe_NOTREC, 2, substr(${&Rx}, &RxPOS - 2));\n  });\n\n  $self->add_handler('(??{' => sub {\n    my ($S) = @_;\n    if (${&Rx} =~ m{ \\G ($nest_logical) \\} \\) }xgc) {\n      push @{ $S->{flags} }, &Rf;\n      return $S->object(logical => $1);\n    }\n    $S->error(RPe_NOTBAL);\n  });\n\n  $self->add_handler('(?p' => sub {\n    my ($S) = @_;\n    my $c = '(?p';\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n    }\n\n    $S->error(RPe_NOTREC, 2, substr(${&Rx}, &RxPOS - 2));\n  });\n\n  $self->add_handler('(?p{' => sub {\n    my ($S) = @_;\n    $S->warn(RPe_LOGDEP);\n    my $c = \"(??{\";\n    return $S->$c;\n  });\n\n  $self->add_handler('(?(' => sub {\n    my ($S) = @_;\n    my $c = '(?(';\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n      &RxPOS--;\n    }\n\n    push @{ $S->{next} }, qw< ifthen( >;\n    push @{ $S->{flags} }, &Rf;\n    return $S->object(ifthen =>);\n  });\n\n  $self->add_handler('ifthen(' => sub {\n    my ($S) = @_;\n    my $c = 'ifthen(';\n\n    push @{ $S->{next} }, qw< c) atom >;\n\n    if (${&Rx} =~ m{ \\G (.) }xgcs) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n      &RxPOS--;\n    }\n\n    if (${&Rx} =~ m{ \\G ( [1-9]\\d* ) }xgc) {\n      my $n = $1;\n      $S->error(RPe_SWNREC) if ${&Rx} !~ m{ \\G \\) }xgc;\n      push @{ $S->{next} }, qw< ifthen|2 ifthen| ifthen_atom >;\n      return $S->object(groupp => $n);\n    }\n\n    $S->error(RPe_SWUNKN, &RxCUR);\n  });\n\n  $self->add_handler('ifthen_atom' => sub {\n    my ($S) = @_;\n    $S->nextchar;\n    ${&Rx} =~ m{ \\G ([^|]) }xgcs or return;\n    my $c = $1;\n\n    push @{ $S->{next} }, qw< ifthen_atom >;\n    return $S->$c if $S->can($c);\n    return $S->object(exact => $c);\n  });\n\n  $self->add_handler('ifthen|' => sub {\n    my ($S) = @_;\n    return if ${&Rx} !~ m{ \\G \\| }xgc;\n    push @{ $S->{next} }, qw< ifthen_atom >;\n    return $S->object(branch =>);\n  });\n\n  $self->add_handler('ifthen|2' => sub {\n    my ($S) = @_;\n    return if ${&Rx} !~ m{ \\G \\| }xgc;\n    $S->error(RPe_SWBRAN);\n  });\n\n  $self->add_handler('ifthen(?' => sub {\n    my ($S) = @_;\n    my $c = '(?';\n\n    push @{ $S->{next} }, qw< ifthen|2 ifthen| ifthen_atom >;\n\n    if (${&Rx} =~ m{ \\G ( (?: <? [!=] | \\{ ) ) }xgc) {\n      my $n = \"$c$1\";\n      return $S->$n if $S->can($n);\n      &RxPOS -= length $1;\n    }\n\n    $S->error(RPe_SEQINC);\n  });\n}\n\n\n1;\n\n__END__\n",
      "file" : "/var/tmp/arv_hx6v16/Regexp-Parser-0.21/lib/Perl6/Rule/Parser.pm",
      "package" : "Perl6::Rule::Parser"
   }
]
