[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub new {\n    my $proto = shift;  my $msg = shift;  my $code = shift;\n    $self = { msg => $msg, code => $code };\n    bless($self, (ref($proto) || $proto));\n}",
      "file" : "/var/tmp/arv_clSHti/XML-EP-0.01/lib/XML/EP/Error.pm",
      "package" : "XML::EP::Error"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub Save {\n    my $self = shift;  my $file = shift;\n    my $array = [ @$self ];\n    my $dump = Data::Dumper->new([$array])->Terse(1)->Indent(1)->Dump();\n    my $fh = Symbol::gensym();\n    (open($fh, \">$file\") and\n     (print $fh \"package XML::EP::Config;\\n\\$XML::EP::Config::config = $dump\\n\") and\n     close($fh))  ||  die \"Failed to create config file $file: $!\";\n}",
      "file" : "/var/tmp/arv_clSHti/XML-EP-0.01/lib/XML/EP/Install.pm",
      "package" : "XML::EP::Install"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub Headers {\n    my $self = shift;\n    \"content-type: \" . $self->ContentType() . \"\\n\\n\";\n}",
      "file" : "/var/tmp/arv_clSHti/XML-EP-0.01/lib/XML/EP/Response.pm",
      "package" : "XML::EP::Response"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub CreatePipe {\n    my $self = shift;  my $ep = shift;\n    my $class = $ep->{cfg}->{Producer} || \"XML::EP::Producer::File\";\n    $ep->Require($class);\n    my $producer = $class->new();\n    my $xml = $producer->Produce($ep);\n    my $processors = $ep->{cfg}->{Processors} || [];\n    my $formatter = $ep->{cfg}->{Formatter} || \"XML::EP::Formatter::HTML\";\n    my $elem = $xml->getFirstChild();\n    while ($elem) {\n\tmy $pi = $elem;\n\t$elem = $pi->getNextSibling();\n\tnext unless $pi->getNodeType() ==\n\t    XML::DOM::PROCESSING_INSTRUCTION_NODE();\n\tif ($pi->getTarget() eq \"xmlep:processor\") {\n\t    my $data = $pi->getData();\n\t    if ($data =~ /^\\s*(\\S+)\\s*(.*)/) {\n\t\t$ep->Require($1);\n\t\tpush(@$processors, $1->new('pidata' => $2));\n\t\t$xml->removeChild($pi);\n\t    } else {\n\t\tdie \"Failed to parse processor instruction: $data\";\n\t    }\n\t} elsif ($pi->getTarget() eq \"xml-stylesheet\") {\n\t    my $data = $pi->getData();\n\t    require XML::EP::Processor::XSLT;\n\t    push(@$processors,\n\t         XML::EP::Processor::XSLT->new('pidata' => $data));\n\t    $xml->removeChild($pi);\n\t} elsif ($pi->getTarget() eq \"xmlep:formatter\") {\n\t    my $data = $pi->getData();\n\t    if ($data =~ /^\\s*(\\S+)\\s*(.*)/) {\n\t\t$ep->Require($1);\n\t\t$formatter = $1->new('pidata' => $2);\n\t\t$xml->removeChild($pi);\n\t    } else {\n\t\tdie \"Failed to parse formatter instruction: $data\";\n\t    }\n\t}\n    }\n    $ep->Formatter($formatter);\n    $ep->Processors($processors);\n    $xml;\n}",
      "file" : "/var/tmp/arv_clSHti/XML-EP-0.01/lib/XML/EP/Control.pm",
      "package" : "XML::EP::Control"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub Format {\n    my $self = shift;  my $ep = shift;  my $xml = shift;\n    my $response = $ep->Response();\n    $response->ContentType(\"text/html\") unless $response->ContentType();\n    my $fh = $ep->Request()->FileHandle();\n    XML::DOM::setTagCompression(sub {1});\n\n    $xml->setXMLDecl(undef);\n\n    print $fh $ep->Response->Headers();\n\n    $xml->printToFileHandle($fh);\n}",
      "file" : "/var/tmp/arv_clSHti/XML-EP-0.01/lib/XML/EP/Formatter/HTML.pm",
      "package" : "XML::EP::Formatter::HTML"
   }
]
