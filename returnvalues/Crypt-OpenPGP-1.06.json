[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "sub v3_checksum {\n    my $cert = shift;\n    my $k = $cert->{encrypted};\n    my $sum = 0;\n    my @sec = $cert->{key}->secret_props;\n    for my $e (@sec) {\n        $sum += unpack '%16C*', $k->{\"${e}h\"};\n        $sum += unpack '%16C*', $k->{\"${e}b\"};\n    }\n    $sum & 0xFFFF;\n}\n\nsub unlock {\n    my $cert = shift;\n    return 1 unless $cert->{is_secret} && $cert->{is_protected};\n    my($passphrase) = @_;\n    my $cipher = Crypt::OpenPGP::Cipher->new($cert->{cipher}) or\n        return $cert->error( Crypt::OpenPGP::Cipher->errstr );\n    my $key = $cert->{s2k}->generate($passphrase, $cipher->keysize);\n    $cipher->init($key, $cert->{iv});\n    my @sec = $cert->{key}->secret_props;\n    if ($cert->{version} < 4) {\n        my $k = $cert->{encrypted};\n        my $r = {};\n        for my $e (@sec) {\n            $r->{$e} = $k->{\"${e}b\"};\n            $k->{\"${e}b\"} = $cipher->decrypt($r->{$e});\n        }\n        unless ($cert->{csum} == $cert->v3_checksum) {\n            $k->{\"${_}b\"} = $r->{$_} for @sec;\n            return $cert->error(\"Bad checksum\");\n        }\n        for my $e (@sec) {\n            $cert->{key}->$e(bin2mp($k->{\"${e}b\"}));\n        }\n        unless ($cert->{key}->check) {\n            $k->{\"${_}b\"} = $r->{$_} for @sec;\n            return $cert->error(\"p*q != n\");\n        }\n    }\n    else {\n        my $decrypted = $cipher->decrypt($cert->{encrypted});\n        if ($cert->{sha1check}) {\n            my $dgst = Crypt::OpenPGP::Digest->new('SHA1');\n            my $csum = substr $decrypted, -20, 20, '';\n            unless ($dgst->hash($decrypted) eq $csum) {\n                return $cert->error(\"Bad SHA-1 hash\");\n            }\n        } else {\n            my $csum = unpack \"n\", substr $decrypted, -2, 2, '';\n            my $gen_csum = unpack '%16C*', $decrypted;\n            unless ($csum == $gen_csum) {\n               return $cert->error(\"Bad simple checksum\");\n            }\n        }\n        my $buf = Crypt::OpenPGP::Buffer->new;\n        $buf->append($decrypted);\n        for my $e (@sec) {\n            $cert->{key}->$e( $buf->get_mp_int );\n        }\n    }\n\n    $cert->{is_protected} = 0;\n\n    1;\n}\n\nsub lock {\n    my $cert = shift;\n    return if !$cert->{is_secret} || $cert->{is_protected};\n    my($passphrase) = @_;\n    my $cipher = Crypt::OpenPGP::Cipher->new($cert->{cipher});\n    my $sym_key = $cert->{s2k}->generate($passphrase, $cipher->keysize);\n    require Crypt::Random;\n    $cert->{iv} = Crypt::Random::makerandom_octet( Length => 8 );\n    $cipher->init($sym_key, $cert->{iv});\n    my @sec = $cert->{key}->secret_props;\n    if ($cert->{version} < 4) {\n        my $k = $cert->{encrypted} = {};\n        my $key = $cert->key;\n        for my $e (@sec) {\n            $k->{\"${e}b\"} = mp2bin($key->$e());\n            $k->{\"${e}h\"} = pack 'n', bitsize($key->$e());\n        }\n        $cert->{csum} = $cert->v3_checksum;\n        for my $e (@sec) {\n            $k->{\"${e}b\"} = $cipher->encrypt( $k->{\"${e}b\"} );\n        }\n    }\n    else {\n        my $buf = Crypt::OpenPGP::Buffer->new;\n        for my $e (@sec) {\n            $buf->put_mp_int($cert->{key}->$e());\n        }\n        my $cnt = $buf->bytes;\n        $cnt .= pack 'n', unpack '%16C*', $cnt;\n        $cert->{encrypted} = $cipher->encrypt($cnt);\n    }\n\n    $cert->{is_protected} = 1;\n    1;\n}\n\n1",
      "file" : "/var/tmp/arv_n6kN7i/Crypt-OpenPGP-1.06/lib/Crypt/OpenPGP/Certificate.pm",
      "package" : "Crypt::OpenPGP::Certificate"
   }
]
