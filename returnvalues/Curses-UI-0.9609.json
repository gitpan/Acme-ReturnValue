[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "DESTROY()\n{\n    my $this = shift;\n    $this->SUPER::delete_subwindows();\n}\n\nsub add($@)\n{\n    my $this = shift;\n    my $id = shift;\n    my $class = shift;\n    my %args = @_;\n    \n    $this->root->fatalerror(\n\t\"The object id \\\"$id\\\" is already in use!\"\n    ) if defined $id and  \n         defined $this->{-id2object}->{$id};\n\n    if (not defined $id) \n    {\n        my $i = 0;\n        my $id_pre = \"__container_auto_id_\";\n        do { $id = $id_pre . $i++ } \n\t    until (not defined $this->{-id2object}->{$id});\n    }\n\n    $class = \"Curses::UI::$class\" \n        if $class !~ /\\:\\:/ or \n\t   $class =~ /^Dialog\\:\\:[^\\:]+$/;\n\n    $this->root->usemodule($class);\n    my $object = $class->new(\n        %args,\n        -parent => $this\n    );\n\n    $this->{-id2object}->{$id} = $object;\n    $this->{-object2id}->{$object} = $id; \n\n    if (defined( $object->{-bg} )) {\n    \tif ($object->{-bg} eq \"-1\" ) {\n    \t\tif (defined( $this->{-bg} )) {\n    \t\t\t$object->{-bg} = $this->{-bg};\n\t\t}\n\t}\n    }\n    if (defined( $object->{-fg} )) {\n    \tif ($object->{-fg} eq \"-1\" ) {\n    \t\tif (defined( $this->{-fg} )) {\n    \t\t\t$object->{-fg} = $this->{-fg};\n\t\t}\n\t}\n    }\n\n    push @{$this->{-focusorder}}, $id;\n    unshift @{$this->{-draworder}}, $id;\n\n    return $object;\n}\n\nsub delete(;$)\n{\n    my $this = shift;\n    my $id = shift;\n\n    return $this unless defined $this->{-id2object}->{$id};\n\n    $this->{-id2object}->{$id}->delete_subwindows(); \n   \n    undef $this->{-object2id}->{$this->{-id2object}->{$id}};\n    delete $this->{-object2id}->{$this->{-id2object}->{$id}};\n    undef $this->{-id2object}->{$id};\n    delete $this->{-id2object}->{$id};\n\n    foreach my $param (qw(-focusorder -draworder))\n    {\n        my ($current_focused_id, $new_focused_id, $new_focused_obj);\n        $current_focused_id = $this->{-draworder}->[-1];\n        my $idx = $this->base_id2idx($param, $id);\n        splice(@{$this->{$param}}, $idx, 1)\n            if defined $idx;\n\n        if ($current_focused_id eq $id)\n        {\n            $new_focused_id = $this->{-draworder}->[-1];\n            $new_focused_obj = $this->{-id2object}->{$new_focused_id}\n                if $new_focused_id;\n            $new_focused_obj->event_onfocus\n                if $new_focused_obj;\n        }\n    }\n\n    return $this;\n}\n\nsub delete_subwindows()\n{\n    my $this = shift;\n    while (my ($id, $object) = each %{$this->{-id2object}}) {\n        $object->delete_subwindows();\n    }\n    $this->SUPER::delete_subwindows();\n    return $this;\n}\n\n\nsub draw(;$)\n{\n    my $this = shift;\n    my $no_doupdate = shift || 0;\n    \n    $this->SUPER::draw(1) or return $this;\n    \n    foreach my $id (@{$this->{-draworder}}) {\n        $this->{-id2object}->{$id}->draw(1);\n      }\n\n    doupdate() unless $no_doupdate;\n\n    return $this;\n}\n\nsub layout()\n{\n    my $this = shift;\n    $this->SUPER::layout() or return;\n    $this->layout_contained_objects();\n    return $this;    \n}\n\nsub layout_contained_objects()\n{\n    my $this = shift;\n\n    foreach my $id (@{$this->{-draworder}})\n    {\n        my $obj = $this->{-id2object}->{$id};\n        $obj->{-parent} = $this;\n        $obj->layout();\n\t$obj->draw();\n    }\n\n    return $this;\n}\n\nsub hasa($;)\n{\n    my $this = shift;\n    my $class = shift;\n\n    my $count = 0;\n    while (my ($id,$obj) = each %{$this->{-id2object}}) {\n        $count++ if ref $obj eq $class;\n    }\n    return $count;\n}\n\nsub window_is_ontop($;)\n{\n    my $this = shift;\n    my $win = shift;\n\n    return undef if @{$this->{-draworder}} == 0;\n\n    my $topwin = $this->{-draworder}->[-1];\n    if (ref $win) { $topwin = $this->getobj($topwin) }\n\n    return $topwin eq $win;\n}\n\nsub event_keypress($;)\n{\n    my $this = shift;\n    my $key = shift;\n\n    my $return = $this->process_bindings($key);\n    return $return \n        unless defined $return and \n                   $return eq 'DELEGATE';\n\n    $obj = $this->getfocusobj;\n    if (defined $obj) {\n\treturn $obj->event_keypress($key);\n    } else {    \n\treturn 'DELEGATE';\n    }\n}\n\nsub focus_prev()\n{\n    my $this = shift;\n\n    return $this unless @{$this->{-focusorder}};\n                \n    my $id = $this->{-draworder}->[-1];\n\n    my $idx = $this->focusorder_id2idx($id);\n\n    my $circle_flag = 0;\n\n    until ($circle_flag) {\n\t$idx--;\n\tif ($idx < 0) {\n\t    $idx = @{$this->{-focusorder}} - 1;\n\t    $circle_flag = 1;\n\t}\n\tmy $new_obj = $this->getobj($this->{-focusorder}[$idx]);\n\tlast if (defined $new_obj && $new_obj->focusable);\n    }\n\n    $this->focus($this->{-focusorder}->[$idx], undef, -1);\n    if ( $circle_flag && $this->{-releasefocus} ) {\n        $this->{-parent}->focus_prev;\n    }\n}\n\nsub focus_next()\n{\n    my $this = shift;\n\n    return $this unless @{$this->{-focusorder}};\n                \n    my $id = $this->{-draworder}->[-1];\n\n    my $idx = $this->focusorder_id2idx($id);\n\n    my $circle_flag = 0;\n    until ($circle_flag) {\n\t$idx++;\n\tif ($idx >= scalar (@{$this->{-focusorder}}) ) {\n\t    $idx = 0;\n\t    $circle_flag = 1;\n\t}\n\tmy $new_obj = $this->getobj($this->{-focusorder}[$idx]);\n\tlast if (defined $new_obj && $new_obj->focusable);\n    }\n    \n    $this->focus($this->{-focusorder}->[$idx], undef, +1);\n    if ( $circle_flag && $this->{-releasefocus} ) {\n        $this->{-parent}->focus_next;\n    }\n}\n\nsub focus(;$$$)\n{\n    my $this      = shift;\n    my $focus_to  = shift;\n    my $forced    = shift || 0;\n    my $direction = shift || 1;\n\n    $direction = ($direction < 0 ? -1 : 1);\n\n    my $new_id = ref $focus_to \n\t       ? $this->{-object2id}->{$focus_to} \n\t       : $focus_to;\n\n    if ($forced and not defined $new_id) {\n        $new_id = $this->{-draworder}->[-1]; \n    }\n\n    if (defined $new_id)\n    {\n        my $cur_id  = $this->{-draworder}->[-1];\n        my $cur_obj = $this->{-id2object}->{$cur_id}; \n        \n        my $new_obj = $this->{-id2object}->{$new_id};\n        $this->root->fatalerror(\n\t    \"focus(): $this has no element with id='$new_id'\" \n        ) unless defined $new_obj;\n\n        unless ($new_obj->focusable)\n        {\n            my $idx = $start_idx = $this->focusorder_id2idx($cur_id);\n\n            undef $new_obj;\n            undef $new_id;\n\n            OBJECT: for(;;)\n            {\n                $idx += $direction;\n                $idx = 0 if $idx > @{$this->{-focusorder}}-1;\n                $idx = @{$this->{-focusorder}}-1 if $idx < 0;\n                last if $idx == $start_idx;\n\n                my $test_id  = $this->{-focusorder}->[$idx];\n                my $test_obj = $this->{-id2object}->{$test_id};\n                \n                if ($test_obj->focusable)\n                {\n                    $new_id  = $test_id;\n                    $new_obj = $test_obj;\n                    last OBJECT \n                }\n\n            } \n        }\n\n        if ($forced or defined $new_obj and $new_obj ne $cur_obj)\n        {\n            my $idx = $this->draworder_id2idx($new_id);\n            my $move = splice(@{$this->{-draworder}}, $idx, 1);\n            push @{$this->{-draworder}}, $move;\n\n            unless ($new_obj->{-has_modal_focus}) {\n\t\t$cur_obj->event_onblur;\n            }\n\t    $new_obj->event_onfocus;\n        }\n    }\n   \n    $this->SUPER::focus();\n}\n\nsub event_onfocus()\n{\n    my $this = shift;\n\n    $this->SUPER::event_onfocus;\n\n    unless ($this->isa('Curses::UI::ContainerWidget')) {\n        my $focused_object = $this->getfocusobj;\n        if (defined $focused_object) {\n            $focused_object->event_onfocus;\n        }\n    }\n\n    return $this;\n}\n\nsub event_onblur()\n{\n    my $this = shift;\n\n\n    my $id = $this->{-draworder}->[-1];\n    return unless $id;\n\n    my $obj = $this->{-id2object}->{$id};\n    return unless $obj;\n\n    $obj->{-focus} = 0;\n    $obj->draw;\n\n    $this->SUPER::event_onblur();\n\n    return $this;\n}\n\n\nsub set_focusorder(@)\n{\n    my $this = shift;\n    my @order = @_;\n    $this->{-focusorder} = \\@order;\n    return $this;\n}\n\nsub set_draworder(@)\n{\n    my $this = shift;\n    my @order = @_;\n    $this->{-draworder} = \\@order;\n    return $this;\n}\n\nsub getobj($;)\n{\n    my $this = shift;\n    my $id = shift;\n    return $this->{-id2object}->{$id};\n}\n\nsub getfocusobj()\n{\n    my $this = shift;\n    my $id = $this->{-draworder}->[-1];\n    return (defined $id ? $this->getobj($id) : undef); \n}\n\n\nsub draworder_id2idx($;)   {shift()->base_id2idx('-draworder' , shift())}\nsub focusorder_id2idx($;)  {shift()->base_id2idx('-focusorder', shift())}\n\nsub base_id2idx($;)\n{\n    my $this = shift;\n    my $param = shift;\n    my $id = shift;\n    \n    my $idx;\n    my $i = 0;\n    foreach my $win_id (@{$this->{$param}}) \n    {\n        if ($win_id eq $id) { \n            $idx = $i; \n            last;\n        }\n        $i++;\n    }\n    return $idx;\n}",
      "file" : "/var/tmp/arv_wCyFVP/Curses-UI-0.9609/lib/Curses/UI/Container.pm",
      "package" : "Curses::UI::Container"
   }
]
