[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval\"no Mo::$_\",&{$M.$_.::e}($P,\\%e,\\%o,\\@_)for@_;return if$e{M};%e=(extends,sub{eval\"no $_[0]()\";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};@_=(default,@_)if!($#_%2);$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo.pm",
      "package" : "Mo"
   },
   {
      "PPI" : "PPI::Statement::Scheduled",
      "bad" : "BEGIN{package Attr::Trait;use Mouse::Role;around _process_options=>sub{my$orig=shift;my$c=shift;my($n,$o)=@_;$o->{is}||='rw';$o->{lazy}||=1 if defined$o->{default}or defined$o->{builder};$c->$orig(@_)};$INC{'Attr/Trait.pm'}=1}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/Mouse.pm",
      "package" : "Mo::Mouse"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.'xs::e'}=sub{my($P,$e,$o,$f)=@_;$P=~s/::$//;$e->{has}=sub{my($n,%a)=@_;Class::XSAccessor->import(class=>$P,accessors=>{$n=>$n})}if!grep!/^xs$/,@$f}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/xs.pm",
      "package" : "Mo::xs"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.'chain::e'}=sub{my($P,$e,$o)=@_;$o->{chain}=sub{my($m,$n,%a)=@_;$a{chain}or return$m;sub{$#_?($m->(@_),return$_[0]):$m->(@_)}}}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/chain.pm",
      "package" : "Mo::chain"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.'exporter::e'}=sub{my($P)=@_;if(defined@{$M.EXPORT}){*{$P.$_}=\\&{$M.$_}for@{$M.EXPORT}}}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/exporter.pm",
      "package" : "Mo::exporter"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.'is::e'}=sub{my($P,$e,$o)=@_;$o->{is}=sub{my($m,$n,%a)=@_;$a{is}or return$m;sub{$#_&&$a{is}eq'ro'&&caller ne'Mo::coerce'?die$n.' is ro':$m->(@_)}}}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/is.pm",
      "package" : "Mo::is"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.'coerce::e'}=sub{my($P,$e,$o)=@_;$o->{coerce}=sub{my($m,$n,%a)=@_;$a{coerce}or return$m;sub{$#_?$m->($_[0],$a{coerce}->($_[1])):$m->(@_)}};my$C=$e->{new}||*{$M.Object::new}{CODE};$e->{new}=sub{my$s=$C->(@_);$s->$_($s->{$_})for keys%$s;$s}}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/coerce.pm",
      "package" : "Mo::coerce"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.'option::e'}=sub{my($P,$e,$o)=@_;$o->{option}=sub{my($m,$n,%a)=@_;$a{option}or return$m;my$n2=$n;*{$P.\"read_$n2\"}=sub{$_[0]->{$n2}};sub{$#_?$m->(@_):$m->(@_,1);$_[0]}}}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/option.pm",
      "package" : "Mo::option"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub _finder_subs {\n    return (\n        comments => sub { $_[1]->isa( tok 'Comment' ) },\n\n        duplicate_whitespace => sub {\n            my ( $top, $current ) = @_;\n            return 0 if !$current->isa( tok 'Whitespace' );\n\n            $current->set_content(' ') if 1 < length $current->content;\n\n            return 0 if !$current->next_token;\n            return 0 if !$current->next_token->isa( tok 'Whitespace' );\n            return 1;\n        },\n\n        whitespace => sub {\n            my ( $top, $current ) = @_;\n            return 0 if !$current->isa( tok 'Whitespace' );\n            my $prev = $current->previous_token;\n            my $next = $current->next_token;\n\n            return 1 if $prev->isa( tok 'Number' ) and $next->isa( tok 'Operator' ) and $next->content =~ /^\\W/; \n            return 1 if $prev->isa( tok 'Word' )   and $next->isa( tok 'Operator' ) and $next->content =~ /^\\W/; \n\n            return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Quote::Single' ) and $next->content =~ /^\\W/; \n            return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Quote::Double' ) and $next->content =~ /^\\W/; \n            return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Symbol' )        and $next->content =~ /^\\W/; \n            return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Structure' )     and $next->content =~ /^\\W/; \n\n            return 1 if $prev->isa( tok 'Symbol' )     and $next->isa( tok 'Operator' );         \n            return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Symbol' );           \n            return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Structure' );        \n            return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Quote::Double' );    \n            return 1 if $prev->isa( tok 'Symbol' )     and $next->isa( tok 'Structure' );        \n            return 1 if $prev->isa( tok 'ArrayIndex' ) and $next->isa( tok 'Operator' );         \n            return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Cast' );             \n            return 0;\n        },\n\n        trailing_whitespace => sub {\n            my ( $top, $current ) = @_;\n            return 0 if !$current->isa( tok 'Whitespace' );\n            my $prev = $current->previous_token;\n\n            return 1 if $prev->isa( tok 'Structure' );                                           \n            return 1 if $prev->isa( tok 'Operator' ) and $prev->content =~ /\\W$/;                \n            return 1 if $prev->isa( tok 'Quote::Double' );                                       \n            return 1 if $prev->isa( tok 'Quote::Single' );                                       \n\n            return 0;\n        },\n\n        double_semicolon => sub {\n            my ( $top, $current ) = @_;\n            return 0 if !$current->isa( tok 'Structure' );\n            return 0 if $current->content ne ';';\n\n            my $prev = $current->previous_token;\n\n            return 0 if !$prev->isa( tok 'Structure' );\n            return 0 if $prev->content ne ';';\n\n            return 1;\n        },\n\n        del_last_semicolon_in_block => sub {\n            my ( $top, $current ) = @_;\n            return 0 if !$current->isa( 'PPI::Structure::Block' );\n\n            my $last = $current->last_token;\n\n            return 0 if !$last->isa( tok 'Structure' );\n            return 0 if $last->content ne '}';\n\n            my $maybe_semi = $last->previous_token;\n\n            return 0 if !$maybe_semi->isa( tok 'Structure' );\n            return 0 if $maybe_semi->content ne ';';\n\n            $maybe_semi->delete;\n\n            return 1;\n        },\n\n        del_superfluous_concat => sub {\n            my ( $top, $current ) = @_;\n            return 0 if !$current->isa( tok 'Operator' );\n\n            my $prev = $current->previous_token;\n            my $next = $current->next_token;\n\n            return 0 if $current->content ne '.';\n            return 0 if !$prev->isa( tok 'Quote::Double' );\n            return 0 if !$next->isa( tok 'Quote::Double' );\n\n            $current->delete;\n            $prev->set_content( $prev->{separator} . $prev->string . $next->string . $prev->{separator} );\n            $next->delete;\n\n            return 1;\n        },\n\n        separate_version => sub {\n            my ( $top, $current ) = @_;\n            return 0 if !$current->isa( 'PPI::Statement' );\n\n            my $first = $current->first_token;\n            return 0 if $first->content ne '$VERSION';\n\n            $current->$_( PPI::Token::Whitespace->new( \"\\n\" ) ) for qw( insert_before insert_after );\n\n            return 1;\n        },\n\n        shorten_var_names => sub {\n            my ( $top, $current ) = @_;\n            return 0 if !$current->isa( tok 'Symbol' );\n\n            my $long_name = $current->canonical;\n\n            return 1 if $hands_off{$long_name};\n            (my $name = $long_name) =~ s/^([\\$\\@\\%])// or die $long_name;\n            my $sigil = $1;\n            die \"variable $long_name conflicts with shortened var name\"\n                if grep {\n                    $name eq $_\n                } values %short_names;\n\n            my $short_name = $short_names{$name};\n            $current->set_content( \"$sigil$short_name\" ) if $short_name;\n\n            return 1;\n        },\n    );\n}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/Golf.pm",
      "package" : "Mo::Golf"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.'required::e'}=sub{my($P,$e,$o)=@_;$o->{required}=sub{my($m,$n,%a)=@_;if($a{required}){my$C=*{$P.\"new\"}{CODE}||*{$M.Object::new}{CODE};no warnings 'redefine';*{$P.\"new\"}=sub{my$s=$C->(@_);my%a=@_[1..$#_];die$n.\" required\"if!exists$a{$n};$s}}$m}}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/required.pm",
      "package" : "Mo::required"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/builder.pm",
      "package" : "Mo::builder"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.'build::e'}=sub{my($P,$e)=@_;$e->{new}=sub{$c=shift;my$s=bless{@_},$c;my@B;do{@B=($c.::BUILD,@B)}while($c)=@{$c.::ISA};exists&$_&&&$_($s)for@B;$s}}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/build.pm",
      "package" : "Mo::build"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.import}=sub{(@_==2 and not$_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/import.pm",
      "package" : "Mo::import"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;exists$a{default}or return$m;my($d,$r)=$a{default};my$g='HASH'eq($r=ref$d)?sub{+{%$d}}:'ARRAY'eq$r?sub{[@$d]}:'CODE'eq$r?$d:sub{$d};sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$g->(@_):$m->(@_)}}}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/default.pm",
      "package" : "Mo::default"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "*{$M.'importer::e'}=sub{my($P,$e,$o,$f)=@_;(my$pkg=$P)=~s/::$//;&{$P.'importer'}($pkg,@$f)if defined&{$P.'importer'}}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/importer.pm",
      "package" : "Mo::importer"
   },
   {
      "PPI" : "PPI::Statement::Scheduled",
      "bad" : "BEGIN{package Attr::Trait;use Moose::Role;around _process_options=>sub{my$orig=shift;my$c=shift;my($n,$o)=@_;$o->{is}||='rw';$o->{lazy}||=1 if defined$o->{default}or defined$o->{builder};$c->$orig(@_)};$INC{'Attr/Trait.pm'}=1}",
      "file" : "/var/tmp/arv_SMlcwM/Mo-0.33/lib/Mo/Moose.pm",
      "package" : "Mo::Moose"
   }
]
