[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "func validate_mason_version () {\n    die \"must be 1 or 2\" unless $_[0] =~ /^[12]$/;\n}\n\nmethod _build__is_mixed_block () {\n    return { map { ( $_, 1 ) } $self->mixed_block_names };\n}\n\nmethod _build__is_code_block () {\n    return { map { ( $_, 1 ) } $self->code_block_names };\n}\n\nmethod _build__open_block_regex () {\n    my $re = '<%(' . join( '|', $self->block_names ) . ')(\\s+[\\w\\._-]+)?>';\n    return qr/$re/;\n}\n\nmethod _build__subst_tag_regex () {\n    my $re = '<%(?!' . join( '|', $self->block_names, 'perl' ) . ')(.*?)%>';\n    return qr/$re/;\n}\n\nmethod block_names () {\n    return\n      qw(after args around attr augment before class cleanup def doc filter flags init method once override shared text);\n}\n\nmethod code_block_names () {\n    return qw(class init once shared);\n}\n\nmethod mixed_block_names () {\n    return qw(after augment around before def method override);\n}\n\nmethod tidy ($source) {\n    my $final = $self->tidy_method($source);\n    return $final;\n}\n\nmethod tidy_method ($source) {\n    return $source if $source !~ /\\S/;\n    my $final_newline = ( $source =~ /\\n$/ );\n\n    my $open_block_regex = $self->_open_block_regex;\n    my $marker_prefix    = $self->_marker_prefix;\n\n    while ( $source =~ s/($open_block_regex.*?<\\/%\\2>)/$self->replace_with_marker($1)/se ) { }\n\n    my $subst_tag_regex = $self->_subst_tag_regex;\n    $source =~ s/$subst_tag_regex/\"<% \" . $self->tidy_subst_expr($1) . \" %>\"/ge;\n\n    $source =~ s/(<&\\|?)(.*?)&>/\"$1 \" . $self->tidy_compcall_expr($2) . \" &>\"/ge;\n\n    while ( $source =~ s/($open_block_regex.*?<\\/%\\2>)/$self->replace_with_marker($1)/se )   { }\n    while ( $source =~ s/(<(%|&\\|?)(?![A-Za-z]+>).*?\\2>)/$self->replace_with_marker($1)/se ) { }\n\n    my @lines = split( /\\n/, $source, -1 );\n    pop(@lines) if @lines && $lines[-1] eq '';\n    my @elements = ();\n    my $add_element = sub { push( @elements, [@_] ) };\n\n    my $last_line = scalar(@lines) - 1;\n    my $mason1    = $self->mason_version == 1;\n    my $mason2    = $self->mason_version == 2;\n\n    for ( my $cur_line = 0 ; $cur_line <= $last_line ; $cur_line++ ) {\n        my $line = $lines[$cur_line];\n\n        if ( $mason2 && $line =~ /^%\\s*(.*)\\{\\{\\s*/ ) {\n            $add_element->( 'perl_line', \"given (__filter($1)) {\" );\n            next;\n        }\n\n        if ( $mason2 && $line =~ /^%\\s*\\}\\}\\s*/ ) {\n            $add_element->( 'perl_line', \"} # __end filter\" );\n            next;\n        }\n\n        if ( $line =~ /^%/ ) {\n            $add_element->( 'perl_line', substr( $line, 1 ) );\n            next;\n        }\n\n        if ( $line =~ /^\\s*<%perl>\\s*$/ ) {\n            my ($end_line) =\n              grep { $lines[$_] =~ /^\\s*<\\/%perl>\\s*$/ } ( $cur_line + 1 .. $last_line );\n            if ($end_line) {\n                $add_element->( 'begin_perl_block', '<%perl>' );\n                foreach my $line ( @lines[ $cur_line + 1 .. $end_line - 1 ] ) {\n                    $add_element->( 'perl_line', $line );\n                }\n                $add_element->( 'end_perl_block', '</%perl>' );\n                $cur_line = $end_line;\n                next;\n            }\n        }\n\n        $add_element->( 'text', $line );\n    }\n\n    my $untidied_perl = \"{\\n\"\n      . join( \"\\n\",\n        map { $_->[0] eq 'perl_line' ? trim( $_->[1] ) : $self->replace_with_perl_comment($_) }\n          @elements )\n      . \"\\n}\\n\";\n    $DB::single = 1;\n    $self->perltidy(\n        source      => \\$untidied_perl,\n        destination => \\my $tidied_perl,\n        argv        => $self->perltidy_line_argv . \" -fnl -fbl\",\n    );\n    $tidied_perl =~ s/^{\\n//;\n    $tidied_perl =~ s/}\\n$//;\n\n    my @tidied_lines = split( /\\n/, substr( $tidied_perl, 0, -1 ), -1 );\n    @tidied_lines = ('') if !@tidied_lines;\n    my @final_lines     = ();\n    my $perl_block_mode = 0;\n    my $standard_indent = $self->standard_line_indent();\n    foreach my $line (@tidied_lines) {\n        if ( my $marker = $self->marker_in_line($line) ) {\n            my ( $type, $contents ) = @{ $self->restore($marker) };\n            push( @final_lines, $contents );\n            if ( $type eq 'begin_perl_block' ) {\n                $perl_block_mode = 1;\n            }\n            elsif ( $type eq 'end_perl_block' ) {\n                $perl_block_mode = 0;\n            }\n        }\n        else {\n            if ($mason2) {\n                $line =~ s/given\\s*\\(\\s*__filter\\s*\\(\\s*(.*?)\\s*\\)\\s*\\)\\s*\\{/$1 \\{\\{/;\n                $line =~ s/\\}\\s*\\#\\s*__end filter/\\}\\}/;\n            }\n\n            $line =~ s/^\\}\\}/$standard_indent\\}\\}/;\n            if ($perl_block_mode) {\n                my $spacer = ( $line =~ /\\S/ ? scalar( ' ' x $self->indent_perl_block ) : '' );\n                $line =~ s/^$standard_indent/$spacer/;\n                push( @final_lines, $line );\n            }\n            else {\n                my $spacer = ( $line =~ /\\S/ ? ' ' : '' );\n                $line =~ s/^$standard_indent/$spacer/;\n                push( @final_lines, \"%$line\" );\n            }\n        }\n    }\n    my $final = join( \"\\n\", @final_lines ) . ( $final_newline ? \"\\n\" : \"\" );\n\n    while ( $final =~ s/(${marker_prefix}_\\d+)/$self->restore($1)/e ) { }\n\n    my @replacements;\n    undef pos($final);\n    while ( $final =~ /^(.*)$open_block_regex[\\t ]*\\n?/mg ) {\n        my ( $preceding, $block_type, $block_args ) = ( $1, $2, $3 );\n        next if length($preceding) > 0 && substr( $preceding, 0, 1 ) eq '%';\n        my $start_pos = pos($final) + length($preceding);\n        if ( $final =~ /(\\n?[\\t ]*<\\/%$block_type>)/g ) {\n            my $length = pos($final) - $start_pos - length($1);\n            my $untidied_block_contents = substr( $final, $start_pos, $length );\n            my $tidied_block_contents =\n              $self->handle_block( $block_type, $block_args, $untidied_block_contents );\n            push( @replacements,\n                [ $start_pos, $length, $untidied_block_contents, $tidied_block_contents ] );\n        }\n        else {\n            die sprintf( \"no matching end tag for '<%%%s%s>' at char %d\",\n                $block_type, $block_args || '', $start_pos );\n        }\n    }\n    my $offset = 0;\n    foreach my $replacement (@replacements) {\n        my ( $start_pos, $length, $untidied_block_contents, $tidied_block_contents ) =\n          @$replacement;\n        my $adjusted_start_pos = $start_pos + $offset;\n        my $actual = substr( $final, $adjusted_start_pos, $length );\n        unless ( $actual eq $untidied_block_contents ) {\n            die sprintf( \"assert failure: start pos %s, length %s - '%s' ne '%s'\",\n                $adjusted_start_pos, $length, $actual, $untidied_block_contents );\n        }\n        substr( $final, $adjusted_start_pos, $length ) = $tidied_block_contents;\n        $offset += length($tidied_block_contents) - length($untidied_block_contents);\n    }\n\n    return $final;\n}\n\nmethod tidy_subst_expr ($expr) {\n    $self->perltidy(\n        source      => \\$expr,\n        destination => \\my $tidied_expr,\n        argv        => $self->perltidy_tag_argv . \" -fnl -fbl\",\n    );\n    return trim($tidied_expr);\n}\n\nmethod tidy_compcall_expr ($expr) {\n    my $path;\n    if ( ($path) = ( $expr =~ /^(\\s*[\\w\\/\\.][^,]+)/ ) ) {\n        substr( $expr, 0, length($path) ) = \"'$path'\";\n    }\n    $self->perltidy(\n        source      => \\$expr,\n        destination => \\my $tidied_expr,\n        argv        => $self->perltidy_tag_argv . \" -fnl -fbl\",\n    );\n    if ($path) {\n        substr( $tidied_expr, 0, length($path) + 2 ) = $path;\n    }\n    return trim($tidied_expr);\n}\n\nmethod handle_block ($block_type, $block_args, $block_contents) {\n    if ( $self->_is_code_block->{$block_type}\n        || ( $block_type eq 'filter' && !defined($block_args) ) )\n    {\n        $block_contents = trim_lines($block_contents);\n        $self->perltidy(\n            source      => \\$block_contents,\n            destination => \\my $tidied_block_contents,\n            argv        => $self->perltidy_block_argv\n        );\n        $block_contents = trim($tidied_block_contents);\n        my $spacer = scalar( ' ' x $self->indent_block );\n        $block_contents =~ s/^/$spacer/mg;\n    }\n    elsif ( $self->_is_mixed_block->{$block_type}\n        || ( $block_type eq 'filter' && defined($block_args) ) )\n    {\n        $block_contents = $self->tidy_method($block_contents);\n    }\n    return $block_contents;\n}\n\nmethod replace_with_perl_comment ($obj) {\n    return \"# _LINE_\" . $self->replace_with_marker($obj);\n}\n\nmethod replace_with_marker ($obj) {\n    my $marker = join( \"_\", $self->_marker_prefix, $marker_count++ );\n    $self->{markers}->{$marker} = $obj;\n    return $marker;\n}\n\nmethod marker_in_line ($line) {\n    my $marker_prefix = $self->_marker_prefix;\n    if ( my ($marker) = ( $line =~ /\\s*_LINE_(${marker_prefix}_\\d+)/ ) ) {\n        return $marker;\n    }\n    return undef;\n}\n\nmethod restore ($marker) {\n    my $retval = $self->{markers}->{$marker};\n    return $retval;\n}\n\nmethod perltidy (%params) {\n    $params{argv} ||= '';\n    $params{argv} .= ' ' . $self->perltidy_argv;\n    my $errorfile;\n    Perl::Tidy::perltidy(\n        prefilter  => \\&perltidy_prefilter,\n        postfilter => \\&perltidy_postfilter,\n        errorfile  => \\$errorfile,\n        %params\n    );\n    die $errorfile if $errorfile;\n}\n\nmethod standard_line_indent () {\n    my $source = \"{\\nfoo();\\n}\\n\";\n    $self->perltidy(\n        source      => \\$source,\n        destination => \\my $destination,\n        argv        => $self->perltidy_line_argv . \" -fnl -fbl\"\n    );\n    my ($indent) = ( $destination =~ /^(\\s*)foo/m )\n      or die \"cannot determine standard indent\";\n    return $indent;\n}\n\nfunc perltidy_prefilter ($buf) {\n    $buf =~ s/\\$\\./\\$__SELF__->/g;\n    return $buf;\n}\n\nfunc perltidy_postfilter ($buf) {\n    $buf =~ s/\\$__SELF__->/\\$\\./g;\n    $buf =~ s/ *\\{ *\\{/ \\{\\{/g;\n    $buf =~ s/ *\\} *\\}/\\}\\}/g;\n    return $buf;\n}\n\nfunc trim ($str) {\n    for ($str) { s/^\\s+//; s/\\s+$// }\n    return $str;\n}\n\nfunc rtrim ($str) {\n    for ($str) { s/\\s+$// }\n    return $str;\n}\n\nfunc trim_lines ($str) {\n    for ($str) { s/^\\s+//m; s/\\s+$//m }\n    return $str;\n}\n\n1",
      "file" : "/var/tmp/arv_LDhwvq/Mason-Tidy-2.57/lib/Mason/Tidy.pm",
      "package" : "Mason::Tidy"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "func usage ($msg) {\n    my $full_msg = ( $msg ? \"$msg\\n\" : \"\" ) . $usage;\n    die $full_msg;\n}\n\nfunc version () {\n    my $version = $Mason::Tidy::VERSION || 'unknown';\n    print \"masontidy $version on perl $] built for $Config{archname}\\n\";\n    exit;\n}\n\nmethod run () {\n    my @argv = @ARGV;\n    if ( my $envvar = $ENV{MASONTIDY_OPT} ) {\n        push( @argv, split( /\\s+/, $envvar ) );\n    }\n    my $source = $_[0];\n    usage() if !@argv && !$source;\n\n    my ( %params, $help, $pipe, $replace, $version );\n    {\n        local @ARGV = @argv;\n        GetOptions(\n            'h|help'                => \\$help,\n            'm|mason-version=i'     => \\$params{mason_version},\n            'p|pipe'                => \\$pipe,\n            'r|replace'             => \\$replace,\n            'indent-block=i'        => \\$params{indent_block},\n            'indent-perl-block=i'   => \\$params{indent_perl_block},\n            'perltidy-argv=s'       => \\$params{perltidy_argv},\n            'perltidy-block-argv=s' => \\$params{perltidy_block_argv},\n            'perltidy-line-argv=s'  => \\$params{perltidy_line_argv},\n            'perltidy-tag-argv=s'   => \\$params{perltidy_tag_argv},\n            'version'               => \\$version,\n        ) or usage();\n        @argv = @ARGV;\n    }\n    %params = map { ( $_, $params{$_} ) } grep { defined( $params{$_} ) } keys(%params);\n\n    version() if $version;\n    usage()   if $help;\n    usage(\"-m|mason-version required (1 or 2)\") unless defined( $params{mason_version} );\n    usage(\"-m|mason-version must be 1 or 2\") unless $params{mason_version} =~ /^[12]$/;\n    usage(\"-p|--pipe not compatible with filenames\") if $pipe && @argv;\n    usage(\"must pass either filenames or -p|--pipe\") if !$pipe && !@argv && !defined($source);\n    usage(\"must pass -r/--replace with multiple filenames\") if @argv > 1 && !$replace;\n\n    my $mt = Mason::Tidy->new(%params);\n    if ( defined($source) ) {\n        return $mt->tidy($source);\n    }\n    elsif ($pipe) {\n        my $source = do { local $/; <STDIN> };\n        print $mt->tidy($source);\n    }\n    else {\n        foreach my $file (@argv) {\n            print \"$file\\n\" if @argv > 1;\n            my $source = read_file($file);\n            my $dest   = $mt->tidy($source);\n            if ($replace) {\n                write_file( $file, $dest );\n            }\n            else {\n                print $dest;\n            }\n        }\n    }\n}\n\n1",
      "file" : "/var/tmp/arv_LDhwvq/Mason-Tidy-2.57/lib/Mason/Tidy/App.pm",
      "package" : "Mason::Tidy::App"
   }
]
