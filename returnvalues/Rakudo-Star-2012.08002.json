[
   {
      "PPI" : "PPI::Statement::Variable",
      "bad" : "my class Pair { ... }\nmy class Whatever { ... }\nmy class WhateverCode { ... }\n\nmy role Positional { ... }\nmy role Associative { ... }\nmy role Callable { ... }\n\nmy class X::Inheritance::Unsupported { ... }\nmy class X::Export::NameClash        { ... }\nmy class X::Composition::NotComposable { ... }\nmy class X::Import::MissingSymbols   { ... }\nmy class X::Redeclaration { ... }\n\nproto trait_mod:<is>(|) { * }\nmulti trait_mod:<is>(Mu:U $child, Mu:U $parent) {\n    if $parent.HOW.archetypes.inheritable() {\n        $child.HOW.add_parent($child, $parent);\n    }\n    elsif $parent.HOW.archetypes.inheritalizable() {\n        $child.HOW.add_parent($child, $parent.HOW.inheritalize($parent))\n    }\n    else {\n        X::Inheritance::Unsupported.new(\n            :child-typename($child.HOW.name($child)),\n            :$parent,\n        ).throw;\n    }\n}\nmulti trait_mod:<is>(Mu:U $type, :$rw!) {\n    $type.HOW.set_rw($type);\n}\nmulti trait_mod:<is>(Mu:U $type, :$nativesize!) {\n    $type.HOW.set_nativesize($type, $nativesize);\n}\n\nmulti trait_mod:<is>(Attribute:D $attr, :$rw!) {\n    $attr.set_rw();\n}\nmulti trait_mod:<is>(Attribute:D $attr, :$readonly!) {\n    $attr.set_readonly();\n}\nmulti trait_mod:<is>(Attribute:D $attr, :$box_target!) {\n    $attr.set_box_target();\n}\n\nmulti trait_mod:<is>(Routine:D $r, :$rw!) {\n    $r.set_rw();\n}\nmulti trait_mod:<is>(Routine:D $r, :$default!) {\n    $r does role { method default() { True } }\n}\nmulti trait_mod:<is>(Routine:D $r, :$DEPRECATED!) {\n}\nmulti trait_mod:<is>(Routine:D $r, Mu :$inlinable!) {\n    $r.set_inline_info(nqp::p6decont($inlinable));\n}\n\nmulti trait_mod:<is>(Parameter:D $param, :$readonly!) {\n}\nmulti trait_mod:<is>(Parameter:D $param, :$rw!) {\n    $param.set_rw();\n}\nmulti trait_mod:<is>(Parameter:D $param, :$copy!) {\n    $param.set_copy();\n}\nmulti trait_mod:<is>(Parameter:D $param, :$required!) {\n    $param.set_required();\n}\nmulti trait_mod:<is>(Parameter:D $param, :$parcel!) {\n    $param.set_parcel();\n}\n\nsub EXPORT_SYMBOL(\\exp_name, @tags, Mu \\sym) {\n    my @export_packages = $*EXPORT;\n    for pir::perl6ize_type__PP(@*PACKAGES) {\n        unless .WHO.exists('EXPORT') {\n            .WHO<EXPORT> := Metamodel::PackageHOW.new_type(:name('EXPORT'));\n            .WHO<EXPORT>.^compose;\n        }\n        @export_packages.push: .WHO<EXPORT>;\n    }\n    for @export_packages -> $p {\n        for @tags -> $tag {\n            my $install_in;\n            if $p.WHO.exists($tag) {\n                $install_in := $p.WHO.{$tag};\n            }\n            else {\n                $install_in := $*W.pkg_create_mo($/, (package { }).HOW, :name($tag));\n                $*W.pkg_compose($install_in);\n                $*W.install_package_symbol($p, $tag, $install_in);\n            }\n            if $install_in.WHO.exists(exp_name) {\n                unless ($install_in.WHO){exp_name} =:= sym {\n                    X::Export::NameClash.new(symbol => exp_name).throw;\n                }\n            }\n            $*W.install_package_symbol($install_in, exp_name, sym);\n        }\n    }\n}\nmulti trait_mod:<is>(Routine:D \\r, :$export!) {\n    my $to_export := r.multi ?? r.dispatcher !! r;\n    my $exp_name  := '&' ~ r.name;\n    my @tags = 'ALL', ($export ~~ Pair ?? $export.key() !!\n                       $export ~~ Positional ?? @($export)>>.key !!\n                       'DEFAULT');\n    EXPORT_SYMBOL($exp_name, @tags, $to_export);\n}\nmulti trait_mod:<is>(Mu:U \\type, :$export!) {\n    my $exp_name := type.HOW.name(type);\n    my @tags = 'ALL', ($export ~~ Pair ?? $export.key !!\n                       $export ~~ Positional ?? @($export)>>.key !!\n                       'DEFAULT');\n    EXPORT_SYMBOL($exp_name, @tags, type);\n}\n\nmulti trait_mod:<is>(Mu:D $docee, :$docs!) {\n    $docee does role {\n        has $!WHY;\n        method WHY          { $!WHY      }\n        method set_docs($d) { $!WHY = $d }\n    }\n    $docee.set_docs($docs);\n    $docs.set_docee($docee);\n}\n\nmulti trait_mod:<is>(Mu:U $docee, :$docs!) {\n    $docee.HOW.set_docs($docs);\n    $docs.set_docee($docee);\n}\n\n\nproto trait_mod:<does>(|) { * }\nmulti trait_mod:<does>(Mu:U $doee, Mu:U $role) {\n    if $role.HOW.archetypes.composable() {\n        $doee.HOW.add_role($doee, $role)\n    }\n    elsif $role.HOW.archetypes.composalizable() {\n        $doee.HOW.add_role($doee, $role.HOW.composalize($role))\n    }\n    else {\n        X::Composition::NotComposable.new(\n            target-name => $doee.HOW.name($doee),\n            composer    => $role,\n        ).throw;\n    }\n}\n\nproto trait_mod:<of>(|) { * }\nmulti trait_mod:<of>(Mu:U $target, Mu:U $type) {\n    $target.HOW.set_of($target, $type);\n}\nmulti trait_mod:<of>(Routine:D $target, Mu:U $type) {\n    my $sig := $target.signature;\n    X::Redeclaration.new(what => 'return type for', symbol => $target,\n        postfix => \" (previous return type was {$sig.returns.^name})\").throw\n        if $sig.has_returns;\n    $sig.set_returns($type)\n}\n\nmulti trait_mod:<is>(Routine:D $r, :$hidden_from_backtrace!) {\n    $r.HOW.mixin($r, role {\n        method is_hidden_from_backtrace { True }\n    });\n}\n\n\nproto trait_mod:<returns>(|) { * }\nmulti trait_mod:<returns>(Routine:D $target, Mu:U $type) {\n    my $sig := $target.signature;\n    X::Redeclaration.new(what => 'return type for', symbol => $target,\n        postfix => \" (previous return type was {$sig.returns.^name})\").throw\n        if $sig.has_returns;\n    $sig.set_returns($type)\n}\n\nproto trait_mod:<as>(|) { * }\nmulti trait_mod:<as>(Parameter:D $param, $type) {\n    $param.set_coercion($type);\n}\n\nmy class Pair { ... }\nproto trait_mod:<handles>(|) { * }\nmulti trait_mod:<handles>(Attribute:D $target, $thunk) {\n    $target does role {\n        has $.handles;\n        \n        method set_handles($expr) {\n            $!handles := $expr;\n        }\n        \n        method add_delegator_method($attr: $pkg, $meth_name, $call_name) {\n            my $meth := method (|c) is rw {\n                $attr.get_value(self).\"$call_name\"(|c)\n            };\n            $meth.set_name($meth_name);\n            $pkg.HOW.add_method($pkg, $meth_name, $meth);\n        }\n        \n        method apply_handles($attr: Mu $pkg) {\n            sub applier($expr) {\n                if $expr.defined() {\n                    if $expr ~~ Str {\n                        self.add_delegator_method($pkg, $expr, $expr);\n                    }\n                    elsif $expr ~~ Pair {\n                        self.add_delegator_method($pkg, $expr.key, $expr.value);\n                    }\n                    elsif $expr ~~ Positional {\n                        for $expr.list {\n                            applier($_);\n                        }\n                    }\n                    else {\n                        $pkg.HOW.add_fallback($pkg,\n                            -> $obj, $name {\n                                ?($name ~~ $expr)\n                            },\n                            -> $obj, $name {\n                                -> $self, |c {\n                                    $attr.get_value($self).\"$name\"(|c)\n                                }\n                            });\n                    }\n                }\n                else {\n                    $pkg.HOW.add_fallback($pkg,\n                        -> $obj, $name {\n                            ?$expr.can($name)\n                        },\n                        -> $obj, $name {\n                            -> $self, |c {\n                                $attr.get_value($self).\"$name\"(|c)\n                            }\n                        });\n                }\n            }\n            applier($!handles);\n        }\n    };\n    $target.set_handles($thunk());\n}\n\nproto trait_mod:<will>(|) { * }\nmulti trait_mod:<will>(Attribute $attr, Block :$build!) {\n    $attr.set_build($build)\n}\n\nproto trait_mod:<trusts>(|) { * }\nmulti trait_mod:<trusts>(Mu:U $truster, Mu:U $trustee) {\n    $truster.HOW.add_trustee($truster, $trustee);\n}",
      "file" : "/var/tmp/arv_XDGRku/Rakudo-Star-2012.08002/rakudo-star/rakudo/src/core/traits.pm",
      "package" : "package"
   },
   {
      "PPI" : "PPI::Statement::Package",
      "bad" : "package URI::DefaultPort {\n\n    my %default_port = (\n        ftp     =>      21,\n        ssh     =>      22,\n        telnet  =>      23,\n        tn3270  =>      23,\n        gopher  =>      70,\n        http    =>      80,\n        pop     =>      110,\n        news    =>      119,\n        ldap    =>      389,\n        https   =>      443,\n        rlogin  =>      513,\n        rtsp    =>      554,\n        rtspu   =>      554,\n        snews   =>      563,\n        ldaps   =>      636,\n        rsync   =>      873,\n        mms     =>      1755,\n        sip     =>      5060,\n        sips    =>      5061\n    );\n    \n    our sub scheme_port(Str $scheme) {\n        return  %default_port{$scheme}.Int // Int;\n    }\n\n}",
      "file" : "/var/tmp/arv_XDGRku/Rakudo-Star-2012.08002/rakudo-star/modules/uri/lib/URI/DefaultPort.pm",
      "package" : "URI::DefaultPort"
   },
   {
      "PPI" : "PPI::Statement::Package",
      "bad" : "package URI::Escape {\n\n    use IETF::RFC_Grammar::URI;\n\n    my %escapes = (^256).map: {\n        ;\n        .chr => sprintf '%%%02X', $_\n    };\n\n\n\n    sub uri_escape($s, Bool :$no_utf8 = False) is export {\n        return $s unless defined $s;\n        $s.subst(:g, rx/<- [!*'()\\-._~A..Za..z0..9]>/,\n            {\n                ( $no_utf8 || ! 0x80 +& ord(.Str) ) ?? %escapes{ .Str } !!\n                    %escapes{.Str.encode.list>>.chr}.join;\n            }\n        );\n    }\n\n    # todo - automatic invalid UTF-8 detection\n    # see http://www.w3.org/International/questions/qa-forms-utf-8\n    #     find first sequence of %[89ABCDEF]<.xdigit>\n    #         use algorithm from url to determine if it's valid UTF-8\n    sub uri_unescape(*@to_unesc, Bool :$no_utf8 = False) is export {\n\n        my @rc = @to_unesc.map: {\n            .trans('+' => ' ')\\\n            .subst(:g, / '%' (<.xdigit> ** 2 ) /, -> $/ {\n                :16(~$0).chr;\n            })\n        }\n        @rc.=map(*.encode('latin-1').decode('UTF-8')) unless $no_utf8;\n        return do given @rc.elems { # this might be simplified some day\n            when 0 { Nil }\n            when 1 { @rc[0] }\n            default { @rc }\n        }\n    }\n}\n\n=begin pod\n\n=head NAME\n\nURI::Escape - Escape and unescape unsafe characters\n\n=head SYNOPSYS\n\n    use URI::Escape;\n    \n    my $escaped = uri_escape(\"10% is enough\\n\");\n    my $un_escaped = uri_unescape('10%25%20is%20enough%0A');\n\n=end pod\n\n# vim:ft=perl6\n",
      "file" : "/var/tmp/arv_XDGRku/Rakudo-Star-2012.08002/rakudo-star/modules/uri/lib/URI/Escape.pm",
      "package" : "URI::Escape"
   }
]
