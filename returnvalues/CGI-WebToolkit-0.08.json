[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "sub _\n{\n\tmy ($self, $phrase, $language) = __parse_args(@_);\n\treturn '' unless defined $phrase;\n\n\treturn $phrase\n\t\tif $self->{'phrasetable'} eq '';\n\n\t$language = $self->get('language') unless defined $language;\n\t$language = $self->{'defaultlanguage'} unless defined $language;\n\t\n\tmy $query\n\t\t= $self->find(\n\t\t\t-tables => [$self->{'phrasetable'}],\n\t\t\t-where  => {'name' => $phrase},\n\t\t);\n\t\t\n\tif (my $row = $query->fetchrow_hashref()) {\n\t\tif ($row->{'language'} eq $language) {\n\t\t\treturn $phrase;\n\t\t}\n\t\telse {\n\t\t\tmy $translation = __find_translation($row->{'translations'}, $language);\n\t\t\treturn (defined $translation ? $translation : $phrase);\n\t\t}\n\t}\n\telse {\n\t\treturn $phrase;\n\t}\n}\n\n\nsub lang\n{\n\tmy ($self, $language) = __parse_args(@_);\n\tif (defined $language) {\n\t\t$self->set($language);\n\t}\n\tmy $lang = $self->get('language');\n\treturn (defined $lang ? $lang : $self->{'defaultlanguage'});\n}\n\n\nsub translate\n{\n\tmy ($self, @pairs) = __parse_args(@_);\n\treturn 0\n\t\tif $self->{'phrasetable'} eq '';\n\t\n\t__die(\"translate() expects language/phrase pairs as parameters\")\n\t\tif scalar(@pairs) % 2 == 1 || scalar(@pairs) < 4;\n\n\tforeach my $p (0..$#pairs) {\n\t\t$pairs[$p] =~ s/[\\n\\r\\:]//g;\n\t}\n\t\n\tmy ($key_language, $key_phrase) = (shift(@pairs), shift(@pairs));\n\tmy %phrases;\n\tfor (my $i = 0; $i < scalar @pairs; $i += 2) {\n\t\t$phrases{$pairs[$i]} = $pairs[$i + 1];\n\t}\n\n\tmy $query \n\t\t= $self->find(\n\t\t\t-tables => [$self->{'phrasetable'}],\n\t\t\t-where  => {'name' => $key_phrase, 'language' => $key_language},\n\t\t);\n\n\tif (my $row = $query->fetchrow_hashref()) {\n\t\tmy $translations = __find_translation($row->{'translations'});\n\t\tforeach my $lang (keys %phrases) {\n\t\t\t$translations->{$lang} = $phrases{$lang};\n\t\t}\n\t\t$self->update(\n\t\t\t-table => $self->{'phrasetable'},\n\t\t\t-set => {\n\t\t\t\t'name' => $key_phrase,\n\t\t\t\t'language' => $key_language,\n\t\t\t\t'translations' => join(\"\\n\", map { $_.':'.$translations->{$_} } keys %{$translations}),\n\t\t\t},\n\t\t\t-where => {'name' => $key_phrase, 'language' => $key_language},\n\t\t);\t\n\t}\n\telse {\n\t\t$self->create(\n\t\t\t-table => $self->{'phrasetable'},\n\t\t\t-row => {\n\t\t\t\t'name' => $key_phrase,\n\t\t\t\t'language' => $key_language,\n\t\t\t\t'translations' => join(\"\\n\", map { $_.':'.$phrases{$_} } keys %phrases),\n\t\t\t},\n\t\t);\n\t}\n}\n\n\nsub find\n{\n\tmy ($self, %options) = __parse_args(@_);\n\tmy $opts = __parse_params( \\%options,\n\t\t{\n\t\t\ttables \t\t=> [],\n\t\t\twhere \t\t=> {},\n\t\t\twherelike \t=> {},\n\t\t\tgroup \t\t=> [],\n\t\t\torder \t\t=> [],\n\t\t\tlimit \t\t=> 0,\n\t\t\tdistinct \t=> 0,\n\t\t\tcolumns\t\t=> [],\n\t\t\tjoins\t\t=> {},\n\t\t\tsortdir\t\t=> 'asc', \n\t\t});\n\n\tmy @tables = map { $self->__quotename($_) } @{$opts->{'tables'}};\n\n\tmy @columns = map { $self->__quotename($_) } @{$opts->{'columns'}};\n\n\tmy @joins =\n\t\tmap {\n\t\t\t$self->__quotename($_).' = '.$self->__quotename($opts->{'joins'}->{$_});\n\t\t}\n\t\tkeys %{$opts->{'joins'}};\n\n\tmy @group = map { $self->__quotename($_) } @{$opts->{'group'}};\n\n\tmy @order = map { $self->__quotename($_) } @{$opts->{'order'}};\n\t\n\tmy $sql\n\t\t= 'SELECT'\n\t\t.(defined $opts->{'distinct'} ? ' DISTINCT' : '')\n\t\t.' '.(scalar @columns ? join(', ', @columns) : '*')\n\t\t.' FROM '.join(', ', @tables)\n\t\t.' WHERE '\n\t\t.(scalar keys %{$opts->{'where'}} ?\n\t\t\t$self->__make_sql_where_clause($opts->{'where'})\n\t\t\t: '1')\n\t\t.(scalar keys %{$opts->{'wherelike'}} ?\n\t\t\t' AND '.$self->__make_sql_where_clause($opts->{'wherelike'}, 1)\n\t\t\t: '')\n\t\t.(scalar @joins ? ' AND '.join(' AND ', @joins) : '')\n\t\t.(scalar @group ? ' GROUP BY '.join(', ', @group) : '')\n\t\t.(scalar @order ? ' ORDER BY '.join(', ', @order).' '.uc($opts->{'sortdir'}) : '')\n\t\t.($opts->{'limit'} > 0 ? ' LIMIT '.$opts->{'limit'} : '');\n\t\n\treturn $self->query($sql);\n}\n\nsub create\n{\n\tmy ($self, %options) = __parse_args(@_);\n\tmy $opts = __parse_params( \\%options,\n\t\t{\n\t\t\ttable => undef,\n\t\t\trow => {},\n\t\t});\n\n\tmy @columns;\n\tmy @values;\n\tmap {\n\t\tpush @columns, $self->__quotename($_);\n\t\tpush @values,  $self->__quote($opts->{'row'}->{$_});\n\t}\n\tkeys %{$opts->{'row'}};\n\n\tmy $sql\n\t\t= 'INSERT'\n\t\t\t.' INTO '.$self->__quotename($opts->{'table'})\n\t\t\t.' ('.join(', ', @columns).')'\n\t\t\t.' VALUES ('.join(', ', @values).')';\n\n\t$self->query($sql);\n\treturn $self->{'dbh'}->last_insert_id(undef, undef, $opts->{'table'}, 'id');\n}\n\nsub update\n{\n\tmy ($self, %options) = __parse_args(@_);\n\tmy $opts = __parse_params( \\%options,\n\t\t{\n\t\t\ttable => '',\n\t\t\tset => {},\n\t\t\twhere => {},\n\t\t\twherelike => {},\n\t\t});\n\n\tmy @sets =\n\t\tmap {\n\t\t\t$self->__quotename($_).' = '.$self->__quote($opts->{'set'}->{$_});\n\t\t}\n\t\tkeys %{$opts->{'set'}};\n\n\tmy $sql\n\t\t= 'UPDATE'\n\t\t\t.' '.$self->__quotename($opts->{'table'})\n\t\t\t.' SET '.join(', ', @sets)\n\t\t\t.' WHERE '\n\t\t\t.(scalar keys %{$opts->{'where'}} ?\n\t\t\t\t$self->__make_sql_where_clause($opts->{'where'})\n\t\t\t\t: '1')\n\t\t\t.(scalar keys %{$opts->{'wherelike'}} ?\n\t\t\t\t' AND '.$self->__make_sql_where_clause($opts->{'wherelike'}, 1)\n\t\t\t\t: '');\n\n\treturn $self->query($sql);\n}\n\nsub remove\n{\n\tmy ($self, %options) = __parse_args(@_);\n\tmy $opts = __parse_params( \\%options,\n\t\t{\n\t\t\ttable => '',\n\t\t\twhere => {},\n\t\t\twherelike => {},\n\t\t});\n\n\tmy $sql\n\t\t= 'DELETE'\n\t\t\t.' FROM '.$self->__quotename($opts->{'table'})\n\t\t\t.' WHERE '\n\t\t\t.(scalar keys %{$opts->{'where'}} ?\n\t\t\t\t$self->__make_sql_where_clause($opts->{'where'})\n\t\t\t\t: '1')\n\t\t\t.(scalar keys %{$opts->{'wherelike'}} ?\n\t\t\t\t' AND '.$self->__make_sql_where_clause($opts->{'wherelike'}, 1)\n\t\t\t\t: '');\n\n\treturn $self->query($sql);\n}\n\nsub load\n{\n\tmy ($self, $group, $recordset, $tablename) = __parse_args(@_);\n\t\n\tmy $records\t= __load_data_file($self->{'privatepath'}.'/data/'.$group.'/'.$recordset.'.txt');\n\t\n\tmy $inserted = 0;\n\tforeach my $record (@{$records}) {\n\t\t__die(\"record does not have an id field, in data file '$group/$recordset'\")\n\t\t\tunless exists $record->{'id'};\n\t\t\n\t\tmy $query\n\t\t\t= $self->find(\n\t\t\t\t-tables => [$tablename],\n\t\t\t\t-where  => {'id' => $record->{'id'}},\n\t\t\t\t-limit  => 1,\n\t\t\t);\n\t\t\t\n\t\tif (my $row = $query->fetchrow_hashref()) {\n\t\t}\n\t\telse {\n\t\t\t$self->create(\n\t\t\t\t-table => $tablename,\n\t\t\t\t-row   => $record,\n\t\t\t);\n\t\t\t$inserted ++;\t\n\t\t}\n\t}\n\treturn (scalar @{$records}, $inserted);\n}\n\nsub query\n{\n\tmy ($self, $sql) = __parse_args(@_);\n\t$self->__connect_to_db();\n\tmy $query = $self->{'dbh'}->prepare($sql);\n\t$query->execute()\n\t\tor __die('the query ['.$sql.'] failed: '.DBI->errstr());\n\treturn $query;\n}\n\n\nsub getparam\n{\n\tmy ($self, $name, $default, $regex) = __parse_args(@_);\n\t$regex = '.*' unless defined $regex;\n\tmy $value = param($name);\n\treturn (defined $value && $value =~ /$regex/ ? $value : $default);\n}\n\n\nsub login\n{\n\tmy ($self, $loginname, $password) = __parse_args(@_);\n\treturn 1 if $self->{'usertable'} eq '';\n\n\treturn 0 unless defined $loginname;\n\treturn 0 unless defined $password;\n\n\treturn 0 if $self->{'usertable'} eq '';\n\n\tmy $query\n\t\t= find(\n\t\t\t-tables => [$self->{'usertable'}],\n\t\t\t-where  => { \n\t\t\t\t'loginname' => $loginname,\n\t\t\t\t'password' => md5_hex($password),\n\t\t\t},\n\t\t\t-limit  => 1,\n\t\t);\n\n\tif (my $user = $query->fetchrow_hashref()) {\n\t\treturn 0 if $user->{'active'} == 0;\n\t\t\n\t\tset('user', $user);\n\t\t\n\t\t$self->set('language', $user->{'ui_language'})\n\t\t\tif $user->{'ui_language'} ne '';\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n\n\nsub logout\n{\n\tmy ($self) = __parse_args(@_);\n\treturn 1 if $self->{'usertable'} eq '';\n\n\t$self->unset('user');\n\treturn 1;\n}\n\n\nsub allowed\n{\n\tmy ($self,\n\t\t$function_name,\t\n\t\t$loginname,\t\t\n\t\t) = __parse_args(@_);\n\n\treturn 1 if $self->{'accessconfig'} eq '';\n\n\tmy $mappings\n\t\t= __load_config_file(\n\t\t\t$self->{'privatepath'}.'/accessconfigs/'.$self->{'accessconfig'}.'.txt');\n\n\tmy $has_access = 0;\n\tforeach my $rgx (keys %{$mappings}) {\n\t\tif ($function_name =~ /$rgx/) {\n\t\t\tmy $check_function_name = $mappings->{$rgx};\n\t\t\tmy $filename =\n\t\t\t\t$self->__get_external_function_filename(\n\t\t\t\t\t'accesschecks', $check_function_name);\n\n\t\t\t$self->{\"access_function_cache\"}->{$check_function_name}\n\t\t\t\t= __load_file_as_subref($filename)\n\t\t\t\t\tunless exists $self->{\"access_function_cache\"}->{$check_function_name};\n\n\t\t\tmy $check_function = $self->{\"access_function_cache\"}->{$check_function_name};\n\n\t\t\t$has_access = $has_access && $check_function->( $self, $function_name, $loginname );\n\t\t}\n\t}\n\t\n\treturn $has_access;\n}\n\n\nsub logmsg\n{\n\tmy ($self, $msg, $priority) = __parse_args(@_);\n\t\n\t$msg .= \"\\r\\n\" if $msg !~ /\\r?\\n$/;\n\t\n\t$priority = 'DEBUG'\n\t\tif !defined $priority\n\t\t|| !scalar\n\t\t\t\tgrep { $_ eq uc($priority) }\n\t\t\t\t\tqw(DEBUG INFO WARNING ERROR FATAL);\n\t\n\tmy $logfile = $self->{'privatepath'}.'/logs/'.uc($priority).'.txt';\n\t__file_append($logfile, $msg);\n\t\n\tif (defined $self->{'current_workflow_function'}) {\n\t\tmy $logfile2 = $self->{'privatepath'}.'/logs/'.uc($self->{'current_workflow_function'}).'.txt';\n\t\t__file_append($logfile2, $msg);\n\t}\n}\n\n\nsub fail\n{\n\tmy ($self, $msg) = __parse_args(@_);\n\t__die($msg);\n}\n\n\nsub upload\n{\n\tmy ($self, $paramname, $groupname) = __parse_args(@_);\n\t\n\tmy $file = $self->getparam($paramname, undef);\n\n\t__die(\"cannot retrieve upload via unknown parameter '$paramname'\")\n\t\tunless defined $file;\n\n\tmy $now = time();\n\n\tmy $upload_info = CGI::uploadInfo($file);\n\tmy $ending = $upload_info->{'Content-Disposition'};\n\t   $ending =~ s/^.*\\.//;\n\t   $ending =~ s/\\\"$//;\n\n\tmy $filepath = $self->{'publicpath'}.'/uploads/'.$groupname.'/'; \n\tmy $filename = $self->{'session_id'}.'_'.$now.'.'.$ending;\n\n\topen UPLOAD, '>'.$filepath.$filename\n\t\tor __die(\"failed to write upload to file '$filepath$filename': $!\");\n\n\tbinmode $file;\n\tbinmode UPLOAD;\n\n\tmy $info = {\n\t\t'status' => 1,\n\t\t'info'   => 'The file has been successfully saved.',\n\t};\n\n\tmy $data;\n\tmy $bytes_written = 0;\n\twhile (read $file, $data, 1024) {\n\t\tprint UPLOAD $data;\n\t\t$bytes_written += 1024;\n\t\tif ($bytes_written > $self->{'uploadmaxsize'}) {\n\t\t\t$info->{'status'} = 0;\n\t\t\t$info->{'info'} =\n\t\t\t\t'The filesize exceeded the maximum upload size. '.\n\t\t\t\t'Aborted after '.$bytes_written.' Bytes.';\n\t\t\tlast;\n\t\t}\n\t}\n\tclose UPLOAD;\n\t\n\tmy $mimetype = $upload_info->{'Content-Type'};\n\tmy $original_filename = $upload_info->{'Content-Disposition'};\n\t   $original_filename =~ s/^.*filename\\=\\\"(.*)\\\"$/$1/;\n\n\tif ($info->{'status'} == 1) {\n\t\t$info->{'path'}     = $filepath;\n\t\t$info->{'filename'} = $filename;\n\t\t$info->{'created'}  = $now;\n\t\t$info->{'mimetype'} = $mimetype;\n\t\t$info->{'original_filename'} = $original_filename;\n\t}\n\t\n\tpush @{$self->{'session'}->{'uploads'}}, $info;\n\t\n\treturn $info->{'status'};\n}\n\n\nsub AUTOLOAD\n{\n\tmy ($self, @args) = __parse_args(@_);\n\t\n\tmy $function_name = $CGI::WebToolkit::AUTOLOAD;\n\t   $function_name =~ s/.*\\://g;\n\t\n\tif ($function_name eq 'DESTROY') {\n\t\treturn SUPER::DESTROY(@args);\n\t}\n\telsif ($function_name =~ /^\\_[^\\_]/) {\n\t\t\n\t\t$function_name =~ s/^\\_//;\t\t\n\t\tforeach my $module (@{$self->{'modules'}}) {\n\t\t\tmy $is_sub = 0;\n\t\t\teval('$is_sub = (defined &CGI::WebToolkit::Modules::'.ucfirst($module).'::'.$function_name.')');\n\t\t\t__die(\"eval failed: $@\") if $@;\n\t\t\tif ($is_sub) {\n\t\t\t\tmy @result;\n\t\t\t\teval('@result = CGI::WebToolkit::Modules::'.ucfirst($module).'::'.$function_name.'($self, @args)');\n\t\t\t\t__die(\"eval for subroutine call failed: $@\") if $@;\n\t\t\t\treturn (wantarray ? @result : (scalar @result ? $result[0] : undef));\n\t\t\t}\n\t\t}\n\t\t__die(\"could not find subroutine named 'CGI::WebToolkit::Modules::*::\".$function_name.\"'\");\n\t}\n\telsif ($function_name =~ /^[A-Z]/) {\n\t\t\n\t\tmy ($theme, $template_name) = split /\\_/, $function_name;\n\t\tunless (defined $template_name) {\n\t\t\t$template_name = $theme;\t\n\t\t\t$theme = '';\n\t\t}\n\t\t$theme = lc $theme;\n\t\t\n\t    $template_name =~ s/([A-Z])/_$1/g;\n\t    $template_name =~ s/^\\_//g;\n\t    $template_name =~ s/\\_/./g;\n\t    $template_name = lc $template_name;\n\t\t\n\t\treturn\n\t\t\t$self->fill(\n\t\t\t\t(length $theme ? $theme.':' : '').$template_name,\n\t\t\t\t{ @args },\n\t\t\t);\n\t}\n\telse {\n\t\t__die(\"Unknown function/method called '$function_name'.\");\n\t}\n}\n\n\nsub __cleanup\n{\n\tmy ($self) = @_;\n\t\n\t$self->__save_session();\n\t$self->__disconnect_from_db();\n}\n\n\nsub __expand_macros\n{\n\tmy ($self, $stringref) = @_;\n\tmy $string = ${$stringref};\n\t\n\tmy $tokens = __tokenize_xml($string);\n\t\n\n\tmy $parsed = '';\n\tmy $t = 0; \n\tmy $abort = 0;\n\twhile (1) {\n\t\tlast if $t >= scalar @{$tokens};\n\n\t\tmy $token = $tokens->[$t];\n\t\n\t\tif (!ref $token) {\n\t\t\t$parsed .= $token;\n\t\t\t$t ++;\n\t\t}\n\t\telse {\n\t\t\tmy ($type, $name, $attribs) = @{$token};\n\t\t\tif ($type eq 'start' || $type eq 'single') {\n\t\t\t\t\n\t\t\t\tmy $data = __attribs_to_hash($attribs);\n\t\t\t\t$data->{'content'} = '';\n\t\t\t\t\n\t\t\t\tmy $t_span = 1; \n\t\t\t\tif ($type eq 'start') {\n\t\t\t\t\t$t_span = __get_token_span($tokens, $t);\n\t\t\t\t\tunless (defined $t_span) {\n\t\t\t\t\t\t$t_span = scalar(@{$tokens}) - $t;\n\t\t\t\t\t}\n\n\t\t\t\t\tmy @subtokens = splice @{$tokens}, $t, $t_span;\n\t\t\t\t\tshift @subtokens;\n\t\t\t\t\tpop @subtokens;\n\n\t\t\t\t\t$data->{'content'} = __render_tokens(\\@subtokens);\n\t\t\t\t}\n\t\t\t\telsif ($type eq 'single') {\n\t\t\t\t\tsplice @{$tokens}, $t, 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmy $filled = $self->fill($name, $data);\n\t\t\t\t\n\t\t\t\tmy $sub_tokens = __tokenize_xml($filled);\n\n\t\t\t\tsplice @{$tokens}, $t, 0, @{$sub_tokens};\n\t\t\t\t\n\t\t\t}\n\t\t\telsif ($type eq 'end') {\n\t\t\t\t$t ++;\n\t\t\t}\n\t\t}\n\t\t$abort ++;\n\t\t__die(\"macro expansion ran into endless loop.\") if $abort == 100;\n\t}\n\n\t${$stringref} = $parsed;\n\treturn 1;\t\n}\n\nsub __render_tokens\n{\n\tmy ($tokens) = @_;\n\tmy $string = '';\n\tforeach my $token (@{$tokens}) {\n\t\tif (ref $token) {\n\t\t\t$string .=\n\t\t\t\t'<'.($token->[0] eq 'end' ? '/' : '').\n\t\t\t\t$token->[1].($token->[0] eq 'end' ? '' : ' '.$token->[2]).\n\t\t\t\t($token->[0] eq 'single' ? '/' : '').'>';\n\t\t}\n\t\telse {\n\t\t\t$string .= $token;\n\t\t}\n\t}\n\treturn $string;\n}\n\nsub __attribs_to_hash\n{\n\tmy ($attribs) = @_;\n\tmy %hash;\n\tmy @pairs = split /[\\s\\t]+/, $attribs;\n\tforeach my $pair (@pairs) {\n\t\tmy ($key, $value) = split /\\=/, $pair;\n\t\t$value =~ s/^[\\\"\\']?//;\n\t\t$value =~ s/[\\\"\\']?$//;\n\t\t$hash{$key} = $value;\n\t}\n\treturn \\%hash;\n}\n\nsub __get_token_span\n{\n\tmy ($tokens, $t) = @_;\n\tmy $found = 0;\n\tmy $open = 0; \n\tmy $s;\n\tforeach my $i ($t+1..scalar(@{$tokens})-1) {\n\t\t$s = $i;\n\t\tnext unless ref $tokens->[$s];\n\t\tif ($tokens->[$s]->[1] eq $tokens->[$t]->[1]) {\n\t\t\tif ($tokens->[$s]->[0] eq 'start') {\n\t\t\t\t$open ++;\n\t\t\t}\n\t\t\telsif ($tokens->[$s]->[0] eq 'end') {\n\t\t\t\tif ($open <= 0) {\n\t\t\t\t\t$found = 1;\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$open --;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmy $span = ($found ? ($s - $t + 1) : undef);\n\treturn $span;\n}\n\nsub __dump_tokens\n{\n\tmy ($tokens) = @_;\n\tmy $s = \"[\\n\";\n\tmy $i = 0;\n\tmap {\n\t\tif (!ref $_) {\n\t\t\t$s .= \"  [\".sprintf('%0d',$i).\"] ...\\n\";\t\t\t\n\t\t}\n\t\telsif ($_->[0] eq 'start') {\n\t\t\t$s .= \"  [\".sprintf('%0d',$i).\"] <\".$_->[1].\">\\n\";\n\t\t}\n\t\telsif ($_->[0] eq 'end') {\n\t\t\t$s .= \"  [\".sprintf('%0d',$i).\"] </\".$_->[1].\">\\n\";\n\t\t}\n\t\telsif ($_->[0] eq 'single') {\n\t\t\t$s .= \"  [\".sprintf('%0d',$i).\"] <\".$_->[1].\"/>\\n\";\n\t\t}\n\t\t$i ++;\n\t} @{$tokens};\n\treturn $s.\"]\\n\";\n}\n\nsub __tokenize_xml\n{\n\tmy ($string) = @_;\n\t\n\t$string =~ s/<!(?:--(?:[^-]*|-[^-]+)*--\\s*)>//sg;\n\t\n\tmy $tagregex = '^(\\/?)([a-zA-Z0-9\\:\\_\\.]+)([\\s\\t\\n\\r]*)([^\\>]*[^\\/])?(\\/?)>(.*)$';\n\t\n\n\tmy @tokens = ('');\n\tforeach my $tag (split /</s, $string) {\n\t\t\n\t\tif ($tag =~ /$tagregex/s) {\n\t\t\tmy ($is_end, $tagname, $space, $attribs, $is_single, $rest)\n\t\t\t\t= $tag =~ /$tagregex/s;\n\t\t\n\t\t\t$space     = '' unless defined $space;\n\t\t\t$attribs   = '' unless defined $attribs;\n\t\t\t$is_single = '' unless defined $is_single;\n\t\t\t$rest      = '' unless defined $rest;\n\t\t\n\t\t\tif (scalar grep { $tagname eq $_ } @XHTML_TAGS) {\n\t\t\t\tref $tokens[-1] ? push(@tokens,'<'.$tag) : ($tokens[-1] .= '<'.$tag);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (length $is_end) {\n\t\t\t\t\tpush @tokens, ['end', $tagname];\n\t\t\t\t}\n\t\t\t\telsif (length $is_single) {\n\t\t\t\t\tpush @tokens, ['single', $tagname, $attribs];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpush @tokens, ['start', $tagname, $attribs];\n\t\t\t\t}\n\t\t\t\tref $tokens[-1] ? push(@tokens,$rest) : ($tokens[-1] .= $rest);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tref $tokens[-1] ? push(@tokens,$tag) : ($tokens[-1] .= $tag);\n\t\t}\n\t}\n\n\treturn \\@tokens;\n}\n\nsub __load_data_file\n{\n\tmy ($datafilename) = @_;\n\t\n\tif (-f $datafilename && -r $datafilename) {\n\t\topen DATAFILE, '<'.$datafilename\n\t\t\tor _die(\"failed to open file '$datafilename': $!\");\n\t\t\t\n\t\tmy @records;\n\t\tmy $current_id     = undef;\n\t\tmy $current_field  = undef;\n\t\tmy $current_record = {};\n\t\tforeach my $line (<DATAFILE>) {\n\t\t\t\t\t\n\t\t\tif (defined $current_id && defined $current_field && $line =~ /^[\\s\\t]/) {\n\t\t\t\t$line =~ s/^[\\s\\t]//;\n\t\t\t\t$current_record->{$current_field} .= $line;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ($line =~ /^\\[(\\d+)\\][\\s\\t\\n\\r]*$/) {\n\t\t\t\t\tif (defined $current_id) {\n\t\t\t\t\t\tpush @records, $current_record;\n\t\t\t\t\t}\n\t\t\t\t\t$current_id = $line;\n\t\t\t\t\t$current_id =~ s/^\\[(\\d+)\\][\\s\\t\\n\\r]*$/$1/;\n\t\t\t\t\t$current_record = { 'id' => $current_id };\n\t\t\t\t}\n\t\t\t\telsif ($line =~ /^(\\w+)[\\s\\t]*([\\:\\.])(.*)\\n\\r?$/) {\n\t\t\t\t\tmy ($fieldname, $type, $value)\n\t\t\t\t\t\t= $line =~ /^(\\w+)[\\s\\t]*([\\:\\.])(.*)\\n\\r?$/;\n\t\t\t\t\tif ($type eq ':') {\n\t\t\t\t\t\t$current_record->{$fieldname} = $value;\n\t\t\t\t\t\t$current_field = undef;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$current_record->{$fieldname} = '';\n\t\t\t\t\t\t$current_field = $fieldname;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (defined $current_id) {\n\t\t\tpush @records, $current_record;\n\t\t}\t\t\n\t\treturn \\@records;\n\t}\n\telse {\n\t\t__die(\"failed to open file '$datafilename': no file or not readable\");\n\t}\n}\n\nsub __parse_translations\n{\n\tmy ($translations) = @_;\n\tmy %phrases;\n\tforeach my $translation (split /\\n/, @{$translations}) {\n\t\tmy ($language, $phrase) =~ /^([^\\:]+)\\:(.*)$/;\n\t\t$phrases{$language} = $phrase;\n\t}\n\treturn \\%phrases;\n}\n\nsub __find_translation\n{\n\tmy ($translations, $find_language) = @_;\n\tforeach my $translation (split /\\n\\r?/, $translations) {\n\t\tmy ($language, $phrase) = $translation =~ /^([^\\:]+)\\:(.*)$/;\n\t\treturn $phrase\n\t\t\tif $language eq $find_language;\n\t}\n\treturn undef;\n}\n\nsub __get_cache_hash\n{\n\tmy ($self, $function_name, @args) = @_;\n\n\tmy $string = '';\n\t\n\tmy $cfgfile = $self->{'privatepath'}.'/cacheconfigs/'.$function_name.'.txt';\t\n\tif (-f $cfgfile) {\n\t\tmy $cfg\n\t\t\t= __read_config_file($cfgfile, {\n\t\t\t\t\t'session'  => [],\n\t\t\t\t\t'params'   => [],\n\t\t\t\t\t'lifetime' => 3600,\n\t\t\t\t});\n\t\t\t\t\n\t\tmap { $string .= __serialize($self->get($_)) } @{$cfg->{'session'}};\n\t\tmap { $string .= __serialize(param($_))      } @{$cfg->{'params'}};\n\t\t$string .= __serialize(\\@args);\n\t}\n\telse {\n\t\t\n\t\t\n\t\tmap {\n\t\t\t$string .=\n\t\t\t\t($_ eq $self->{'idparam'} || $_ eq $self->{'clearcacheparam'} ?\n\t\t\t\t\t'' : __serialize(param($_)));\n\t\t} param();\n\t\t$string .= __serialize(\\@args);\n\t}\n\t\n\treturn md5_hex($string);\n}\n\nsub __load_cache\n{\n\tmy ($self, $cachehash) = @_;\n\tmy $query\n\t\t= $self->find(\n\t\t\t-tables => [$self->{'cachetable'}],\n\t\t\t-where  => {'hash' => $cachehash},\n\t\t\t-limit  => 1,\n\t\t);\n\t\t\n\tif (my $entry = $query->fetchrow_hashref()) {\n\t\treturn __deserialize($entry->{'content'});\n\t}\n\telse {\n\t\treturn undef;\n\t}\n}\n\nsub __save_cache\n{\n\tmy ($self, $cachehash, $data) = @_;\n\t\n\t$self->create(\n\t\t-table => $self->{'cachetable'},\n\t\t-row   => {\n\t\t\t'content' \t  => __serialize($data),\n\t\t\t'hash' \t\t  => $cachehash,\n\t\t\t'last_update' => time(),\n\t\t},\n\t);\n\t\n\treturn 1;\n}\n\nsub __clear_cache\n{\n\tmy ($self) = @_;\n\treturn 1 if $self->{'cachetable'} eq '';\n\t$self->remove( -table => $self->{'cachetable'} );\n}\n\nsub __file_append\n{\n\tmy ($filename, $text) = @_;\n\topen OUTFILE, '>>'.$filename or __die(\"failed to open file '$filename': $!\");\n\tprint OUTFILE $text;\n\tclose OUTFILE;\n\treturn 1;\n}\n\nsub __parse_args\n{\n\tif (scalar @_ && ref($_[0]) eq 'CGI::WebToolkit') {\n\t\treturn @_;\n\t} else {\n\t\treturn ($WTK, @_);\n\t}\n}\n\nsub __replace_placeholders\n{\n\tmy ($stringref, $hash) = @_;\n\tforeach my $key (keys %{$hash}) {\n\t\tmy $cleankey = $key;\n\t\t   $cleankey =~ s/[^a-zA-Z0-9\\_]//g;\n\t\t${$stringref} =~ s/\\{$cleankey[^\\}]*\\}/$hash->{$key}/mig;\n\t}\n\treturn undef;\n}\n\nsub __make_sql_where_clause\n{\n\tmy ($self, $where, $use_like) = @_;\n\t$use_like = 0 unless defined $use_like;\n\t\n\tmy @parts =\n\t\tmap {\n\t\t\tmy $fieldname  = $self->__quotename($_);\n\t\t\tmy $fieldvalue = $self->__quote($where->{$_});\n\t\t\t\n\t\t\tmy $s  = $fieldname;\n\t\t\t   $s .= ($use_like == 1 ? ' LIKE ' : ' = ');\n\t\t\t   $s .= ''.$fieldvalue;\n\t\t\t$s;\n\t\t}\n\t\tkeys %{$where};\n\t\n\treturn join(' AND ', @parts);\n}\n\nsub __quote\n{\n\tmy ($self, @args) = @_;\n\t$self->__connect_to_db();\n\t\n\treturn $self->{'dbh'}->quote(@args)\n\t\tor __die('quote failed: '.DBI->errstr());\n}\n\nsub __quotename\n{\n\tmy ($self, $fieldname) = @_;\n\t$self->__connect_to_db();\n\n\tmy @parts = split /\\./, $fieldname;\n\t\n\tmy $quoted;\n\tif (scalar @parts == 1) {\n\t\t$quoted = '`'.$parts[0].'`';\n\t}\n\telse {\n\t\t$quoted = '`'.$parts[0].'`'.'.'.'`'.$parts[1].'`';\n\t}\n\treturn $quoted;\n}\n\nsub __get_external_function_filename\n{\n\tmy ($self,\n\t\t$type,\t\n\t\t$name,\t\n\t\t)\n\t\t= @_;\n\t\n\t$name =~ s/^(([a-z\\_]+)(\\.([a-z\\_]+))*).*$/$1/;\n\n\tmy $filename = __identifier_to_filename(\n\t\t\t\t\t\t$self->{'privatepath'}.'/'.$type.'/', $name, '.pl');\n\n\tif (-f $filename) {\n\t\treturn $filename;\n\t} else {\n\t\treturn undef;\n\t}\n}\n\nsub __identifier_to_filename\n{\n\tmy ($prefix, $identifier, $suffix) = @_;\n\t$suffix = '' unless defined $suffix;\n\t\n\tmy $filename = $identifier;\n\t   $filename =~ s#\\.#/#g;\n\t   \n\treturn $prefix.$filename.$suffix;\n}\n\nsub __load_file_as_subref\n{\n\tmy ($filename) = @_;\n\t\n\t__die(\"cannot load file '$filename': does not exist.\")  unless -f $filename;\n\t__die(\"cannot load file '$filename': is not readable.\") unless -r $filename;\n\t\n\tmy $subref = undef;\n\topen PERLFILE, '<'.$filename or __die(\"failed to open file '$filename': $!\");\n\tmy $code = join '', <PERLFILE>;\n\t   $code =~ /^(.*).*$/sm; \n\t   $code = \"$1\";\n\t   $code = '$subref = sub { my ($wtk, @args) = @_;'.\"\\n\".$code.\"\\n\".'}';\n\tclose PERLFILE;\n\teval($code);\n\t__die(\"function (file '$filename') failed to load with error: $@\") if $@;\n\t\n\treturn $subref;\n}\n\nsub __load_session\n{\n\tmy ($self) = @_;\n\treturn 1 if $self->{'sessiontable'} eq '';\n\t\n\t$self->{'session_id'} =\n\t\t$self->getparam( $self->{'idparam'}, undef, '^[a-zA-Z0-9]{32}$' );\n\n\t$self->{'session_id'} = md5_hex( time() )\n\t\tunless defined $self->{'session_id'};\n\n\tmy $query =\n\t\t$self->find(\n\t\t\t-tables => [ $self->{'sessiontable'} ],\n\t\t\t-where => { 'session_id' => $self->{'session_id'} },\n\t\t);\n\t\n\tmy $sessionstart = 0;\n\tif (my $session = $query->fetchrow_hashref()) {\n\t\tif (time() - $session->{'last_update'} < $self->{'sessiontimeout'}) {\n\t\t\t$self->{'session'} = __deserialize($session->{'content'});\n\t\t} else {\n\t\t\t$self->{'session_id'} = md5_hex( time() ); \n\t\t\t$self->{'session'} = {};\n\t\t\t\n\t\t\t$self->set('session_timed_out', 1);\n\t\t\t\n\t\t\t$sessionstart = 1;\n\t\t}\n\t}\n\telse {\n\t\t$self->{'session'} = {};\n\t\t\n\t\t$sessionstart = 1;\n\t}\n\t\n\t$self->call($self->{'onsessionstart'})\n\t\tif $sessionstart && $self->{'onsessionstart'} ne '';\n}\n\nsub __save_session\n{\n\tmy ($self) = @_;\n\treturn 1 if $self->{'sessiontable'} eq '';\n\t\n\tmy $query =\n\t\t$self->find(\n\t\t\t-tables => [ $self->{'sessiontable'} ],\n\t\t\t-where => { 'session_id' => $self->{'session_id'} },\n\t\t);\n\t\t\n\tif (my $session = $query->fetchrow_hashref()) {\n\t\t$self->update(\n\t\t\t-table => $self->{'sessiontable'},\n\t\t\t-set => {\n\t\t\t\t'content' => __serialize($self->{'session'}),\n\t\t\t\t'last_update' => time(),\n\t\t\t},\n\t\t\t-where => {\t'session_id' => $self->{'session_id'} },\n\t\t);\n\t}\n\telse {\n\t\t$self->create(\n\t\t\t-table => $self->{'sessiontable'},\n\t\t\t-row => { \n\t\t\t\t'session_id' => $self->{'session_id'},\n\t\t\t\t'content' => __serialize($self->{'session'}),\n\t\t\t\t'last_update' => time(),\n\t\t\t},\n\t\t);\n\t}\n}\n\nsub __serialize\n{\n\tmy ($structure) = @_;\n\treturn dump($structure);\n}\n\nsub __deserialize\n{\n\tmy ($string) = @_;\n\treturn {} unless length $string;\n\tmy $structure = undef;\n\teval('$structure = '.$string);\n\t__die(\"deserialization of string failed: $@\") if $@;\n\treturn $structure;\n}\n\nsub __connect_to_db\n{\n    my ($self) = @_;\n\treturn 1 if defined $self->{'dbh'}; \n    \n    $self->{'dbh'}\n        = DBI->connect(\n            \"DBI:\".$self->{'engine'}.\":\".$self->{'name'}.\":\".$self->{'host'},\n            $self->{'user'}, $self->{'password'},\n            {\n\t\t\t})\n\t    or __die(\"Could not connect to database\");\n    \n    return 1;\n}\n\nsub __disconnect_from_db\n{\n\tmy ($self) = @_;\n\t\n\treturn $self->{'dbh'}->disconnect();\n}\n\nsub __init\n{\n\tmy ($self, %options) = @_;\n\t\n\tmy $optdefaults =\n\t\t{\n\t\t\tpublicpath => '',\n\t\t\tpublicurl => '',\n\t\t\tprivatepath => '',\n\t\t\tcgipath => '',\n\t\t\tcgiurl => '',\n\n\t\t\tconfig => \"\",\n\t\t\n\t\t\tengine => \"mysql\",\n\t\t\tuser => \"guest\",\n\t\t\tname => \"\",\n\t\t\tpassword => \"\",\n\t\t\thost => \"localhost\",\n\t\t\tport => \"\",\n\t\t\n\t\t\ttemplatefallbacks => ['core'],\n\t\t\tallowmacros => 1,\n\t\t\t\n\t\t\n\t\t\tidparam => 'sid',\n\t\t\tsessiontable => '',\n\t\t\tsessiontimeout => 1800,\n\t\t\t\n\t\t\tusertable => '',\n\t\t\tcheckrights => 0,\n\t\t\t\n\t\t\tcachetable => '',\n\t\t\tallowclearcache => 1,\n\t\t\tclearcacheparam => 'clearcache',\n\t\t\t\n\t\t\tphrasetable =>'',\n\t\t\tdefaultlanguage => 'en_GB',\n\t\t\t\n\t\t\tworkflowparam => 'to',\n\t\t\tentryaction => 'core.default',\n\t\t\tmodules => [],\n\t\t\t\n\t\t\tcssfiles => [],\n\t\t\tjsfiles => [],\n\t\t\t\n\t\t\tonsessionstart => '',\n\t\t\tonsessionoutofdate => '',\n\t\t\t\n\t\t\tuploadmaxsize => (1024 * 1024 * 6), \n\t\t};\n\n\tmy $cfgopts = $optdefaults;\n\tforeach my $key (keys %options) {\n\t\tmy $name = lc $key;\n\t\t   $name =~ s/^\\-*//;\n\t\tif ($name eq 'config') {\n\t\t\t$cfgopts = __load_config_file( $options{$key}, $optdefaults );\n\t\t}\n\t}\n\t\n\tmy $opts = __parse_params( \\%options, $cfgopts );\n\tmap { $self->{$_} = $opts->{$_} } keys %{$opts};\n\t\n\tpush @{$self->{'templatefallbacks'}}, 'core'\n\t\tif !scalar @{$self->{'templatefallbacks'}}\n\t\t\t|| $self->{'templatefallbacks'}->[-1] ne 'core';\n\t\n\t$self->{'dbh'} = undef;\n\t$self->{'session'} = undef;\n\t$self->{'session_id'} = undef;\n\t\n\t$self->{'workflow_function_cache'} = {};\n\t$self->{\"template_function_cache\"} = {};\n\t$self->{\"access_function_cache\"}   = {};\n\t\n\t$self->__load_session();\n\t\n\t$self->{'common_placeholders'} = {\n\t\t'script_url' \t => (exists $ENV{'SCRIPT_NAME'} ? $ENV{'SCRIPT_NAME'} : '?'),\n\t\t'public_url' \t => $self->{'publicurl'},\n\t\t'clear'\t\t\t => '<div class=\"clear\"></div>',\n\t\t'session_id'\t => $self->{'session_id'},\n\t\t'do_nothing_url' => 'javascript:void(1);',\n\t\t'javascript_url' => (exists $ENV{'SCRIPT_NAME'} ? $ENV{'SCRIPT_NAME'} : '').'?to=core.combine.javascript',\n\t\t'css_url' \t\t => (exists $ENV{'SCRIPT_NAME'} ? $ENV{'SCRIPT_NAME'} : '').'?to=core.combine.css',\n\t};\n\t\n\t$self->{'current_workflow_function'} = undef;\n\t\n\t$self->set('language', $self->{'defaultlanguage'});\n\t\n\t$self->{'session'}->{'uploads'} = [];\n\t\n\t$WTK = $self;\n\t\n\treturn $self;\n}\n\nsub __load_config_file\n{\n\tmy ($filename, $defaults) = @_;\n\t\n\topen CFGFILE, '<'.$filename\n\t\tor _die(\"failed to load config file '$filename': $!\");\n\tmy $options = {};\n\tif (defined $defaults) {\n\t\tmap { $options->{$_} = $defaults->{$_} } keys %{$defaults};\n\t}\n\twhile (<CFGFILE>) {\n\t\tchomp;\n\t\ts/^(.*)\\#.*$/$1/g;\n\t\tnext if /^[\\s\\t\\n\\r]*$/;\n\t\ts/^[\\s\\t\\n\\r]*//g;\n\t\ts/[\\s\\t\\n\\r]*$//g;\n\t\tmy $rgx =\n\t\t\t(defined $defaults ?\n\t\t\t\t'^([a-zA-Z0-9\\_]+)[\\s\\t]*\\:[\\s\\t]*(.*)$' :\n\t\t\t\t'^([^\\:]+)[\\s\\t]*\\:[\\s\\t]*(.*)$');\n\t\tif (/$rgx/) {\n\t\t\tmy ($key, $value) = $_ =~ /$rgx/;\n\t\t\t$key = lc $key;\n\t\t\t$key =~ s/^\\-*//g;\n\t\t\t\n\t\t\tif (defined $defaults) {\n\t\t\t\tif (ref $defaults->{$key} eq 'ARRAY') {\n\t\t\t\t\t$options->{$key} = [ split(/\\s*\\,\\s*/, $value) ]\n\t\t\t\t\t\tif exists $defaults->{$key};\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$options->{$key} = $value\n\t\t\t\t\t\tif exists $defaults->{$key};\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$options->{$key} = $value;\n\t\t\t}\n\t\t}\n\t}\n\tclose CFGFILE;\n\treturn $options;\n}\n\nsub __dd\n{\n\tprint header();\n\tprint '<pre>'.dump($_[0]).'</pre><br/>';\n}\n\nsub __parse_params\n{\n\tmy ($params, $defaults) = @_;\n\tmy $values = {};\n\tforeach my $key (keys %{$defaults}) {\n\t\t$values->{$key} = $defaults->{$key};\n\t}\n\tforeach my $key (keys %{$params}) {\n\t\tmy $cleankey = lc $key;\n\t\t   $cleankey =~ s/^\\-//;\n\t\t$values->{$cleankey} = $params->{$key}\n\t\t\tif exists $defaults->{$cleankey};\n\t}\n\treturn $values;\n}\n\nsub __die\n{\n\tmy ($msg) = @_;\n\tprint header();\n\tprint\n\t\t'<html></head><title>Lowlevel Error</title></head><body>'.\n\t\t\t'<span style=\"color:red\">Lowlevel Error: <b>'.$msg.'</b></span>'.\n\t\t'</body></html>';\n\texit;\n}\n\n1",
      "file" : "/var/tmp/arv_gyuFWM/CGI-WebToolkit-0.08/lib/CGI/WebToolkit.pm",
      "package" : "CGI::WebToolkit"
   }
]
