[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub tense {\n\t\tmy $word_hash = shift;\n\t\tmy $word = shift;\n\t\tmy $tense = shift;\n\t\tmy $server = $word_hash->{_}->{'.server'};\n\t\tif($server) {\n\t\t\tprint $server \"DICT-TENSE:$word\", EOL; flush $server;\n\t\t\tmy $str;while(chomp($_=<$server>)){s/\\r//g;;last if!$_;$str.=$_}\n\t\t\tmy $return = eval($str);\n\t\t\twarn \"Error in database server query: $@\\n\" if $@;\n\t\t\treturn $return;\n\t\t}\n\t\tif($tense) {\n\t\t\treturn 1 if $word_hash->tense($word) eq $tense;\n\t\t\treturn undef;\n\t\t}\n\t\tmy ($w,$info);\n\t\twhile(($w,$info) = each %{$word_hash}) {\n\t\t\tif($info->{type} eq 'verb) {\n\t\t\t\treturn 'past'       if $info->{past}   eq $word;\n\t\t\t\treturn 'part'       if $info->{part}   eq $word;\n\t\t\t\treturn 'third'      if $info->{third}  eq $word;\n\t\t\t\treturn 'gerund'     if $info->{gerund} eq $word;\n\t\t\t\treturn 'infinitive' if $w eq $word;\n\t\t\t}\n\t\t}\n\t\treturn undef;\n\t}\n\t\n\tsub syns {\n\t\tmy $word_hash = shift;\n\t\tmy $word = shift;\n\t\tmy @words;\n\t\t$word_hash->type($word);\n\t\tforeach my $link (@{$word_hash->{$word}->{links}}) {\n\t\t\tpush @words, $link->{word} if $link->{relation} eq 'synonym';\n\t\t}\n\t\treturn \\@words;\n\t}\n\t\n\tsub opps {\n\t\tmy $word_hash = shift;\n\t\tmy $word = shift;\n\t\tmy @words;\n\t\t$word_hash->type($word);\n\t\tforeach my $link (@{$word_hash->{$word}->{links}}) {\n\t\t\tpush @words, $link->{word} if $link->{relation} eq 'opposite';\n\t\t}\n\t\treturn \\@words;\n\t}\n1;\n\n=begin\n\n=head1 NAME\n\t\nLingua::EN::Dict - BETA Version of XML english dictionary storage.\t\n\n=head1 SYNOPSIS\n\n\tuse Lingua::EN::Dict;\n\t\n\tmy $dict = Lingua::EN::Dict->new('words.xml');\n\tmy $part_of_speech = $dict->type('abash');\n\tmy $verb_tense = $dict->tense('zoomed');\n\tmy $flag1 = $dict->is_verb('utilizes');\n\tmy $flag2 = $dict->is_verb('utilized');\n\tmy $flag3 = $dict->is_verb('utilizing');\n\tmy @synonyms = $dict->syns('dictate');\n\tmy @antonyms = $dict->opps('valid');\n\tmy $defenition = $dict->defn('vindicate');\n\t\n\tundef $dict;\n\t$dict = Lingua::EN::Dict->new(\n\t\tserver\t\t=>\te.tdcj.com\n\t\tport\t\t=>\t7778,\n\t}\n\t# defaults to local file 'words.xml' if it \n\t# cannot reach server.\n\t# everything in first paragraph works here too\n\t\n\tundef $dict;\n\t$dict = Lingua::EN::Dict->new(\n\t\tserver\t\t=>\tlocalhost\n\t\tport\t\t=>\t7778,\n\t}\n\t# everything in first paragraph works here too\n\t\n\tundef $dict;\n\t$dict = Lingua::EN::Dict->new;\n    # same as above consructor, defaults to local file\n    # 'words.xml' if it cannot reach server.\n\t# everything in first paragraph works here too\n\t\n=head1 DESCRIPTION\n\nNote: BETA VERSION.                 \n\nSee main reason for release of this module, three paragraphs down.\n\n=item Description\n\nThis is a small module I came up with to use as a storage format for\nmy humble attempt at a natural language parser (or a subset of natural\nlanguage - english that is). This is a seperate module that stores\nthe words in an xml-format file. With the distribution file, you \nshould have received an XML file called 'words.xml' that contains almost\n3000 words consiting of several hundred verbs (not counting the seperate\nforms of each of the verbs), as well as several hundred nouns, and \nadjectives, articles, and modals.\n\nThis module was created for the storage and retrieval of words from \nthe XML file. It parses the XML file with XML::Parser and stores the\nwords in a blessed hash refrence which is returned from the new constructor.\nThis means that after you have loaded the dictionary, assuming you used\nthe default XML file, you can access the properties of the word 'abash' with\nthis:\n\tmy $info = $dict->{'abash'};\n$info will now contain a hash refrence to a structure of information about\nthe word 'abash'. $info will always have at least one key, 'type'. 'type' indicates\nthe part of speech that the word is. What keys $info contains depends on the type \nof word 'abash' is. If it is a verb, $info will contain the keys 'third', 'past',\n'part', and 'gerund', and possible, 'defn'. If it is a modal, it will have a key\nnamed 'modal_type'. Since this is a beta version, I wont go into too much more\ndetail here. Experiment and enjoy. Look at the default 'words.xml' file\nfor an idea of the structure. Each tag inside a <record></record> pair is\nstored under that tags name as a key in $info, with a few exceptions, of course.\n\n\n=item Reason for Release\n\nThe main reason for the beta relerase of this module is this: I would like\nany and all feedback on the TCP server setup that I have added to this module.\n\nI often got fed-up with having to wait 20 - 40 seconds for the new() constructor\nto load and parse the entire 590k of words just to run a simple 2 line test script.\nAnd since I like to tweek and run, tweek and run (the life of a Perl programmer, eh? :-),\nit was really annoying to have to wait 30 seconds for each test to run, when the \nactual test script took less than 50ms to run.  Sooooo... I added a simple TCP transfer\nsetup for the dictionary.\n\nTo invovke a server process for the dictionary, simply use this one-liner:\n\n% perl -MLingua::EN::Dict -e daemon\n\ndaemon() is a function automatically exported by this module for just this purpose. It\nbinds a TCP server to port 7778, accepting input from any IP address and loads the file\n'words.xml' into a dictionary object for serving.\n\nTo create a client for this server, simply use:\n\n\tmy $dict = new Lingua::EN::Dict;\n\nThis automatically tries to connect to the server on port 7778 of 'localhost'. If it cannot\nconnect to the server, it emits a warning and proceeds to try to load the default file 'words.xml'.\n\nThere are other options for the new constructor, as well as other options to the daemon() function.\nFor both, see below.\n\nThe reason I released this beta version was to get input from those of you who \nmight have some idea of how to make sure I don't leave any security holes in the TCP server\nportion. Because, for example, it is possible:\n\n\tmy $dict = new Lingua::EN::Dict(\n\t\tserver\t=>\tremote.server.system.com,\n\t\tport\t=>\t7778\n\t);\n\t\nThe new constructor allows you to specify the server name and port\nto connect to. This would allow a central dictionary server to be setup\non some server (I have a server I am setting up for that purpose) and that\nwould allow other users of this module to access a much larger database\nwhich can be updated by many people, instead of each user having to \nmaintain his own copy of the words database. (Yes, I know I'll need to \nadd forking to the daemon(), but this is just development, I'll keep it simple for\nnow. Future release I'll add forking.)\n\nSince it does allow remote users the ability to TCP into the daemon, I know\nthat security checks need to be added to plug any potential holes. What I don't\nknow is exactly what holes exist and how to plug them.\n\nHELP, I<PLEASE>! Anyone who does know anything about TCP or security of such, I<please>\ntake a look at the daemon() function code and let me know anything that I need to\ndo to make it secure. \n\n\n",
      "file" : "/var/tmp/arv_aCjNXS/Dict.pm",
      "package" : "Lingua::EN::Dict"
   }
]
