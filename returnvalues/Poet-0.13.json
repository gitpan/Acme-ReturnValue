[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method import ($class:) {\n    my $poet = Poet::Environment->current_env\n      or die \"environment has not been initialized!\";\n    $poet->importer->export_to_level( 1, @_ );\n}\n\n1",
      "file" : "/var/tmp/arv_EILHGQ/Poet-0.13/lib/Poet.pm",
      "package" : "Poet"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method initialize_caching () {\n    my $default_config =\n      { defaults => { driver => 'File', root_dir => $poet->data_path(\"cache\") } };\n    my $config = $conf->get_hash( 'cache' => $default_config );\n    __PACKAGE__->config($config);\n}\n\n1",
      "file" : "/var/tmp/arv_EILHGQ/Poet-0.13/lib/Poet/Cache.pm",
      "package" : "Poet::Cache"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method load_startup_modules () {\n    return if $loaded_startup_modules++;\n    foreach my $module ( @{ $conf->get_list('server.load_modules') } ) {\n        Class::MOP::load_class($module);\n    }\n}\n\n1",
      "file" : "/var/tmp/arv_EILHGQ/Poet-0.13/lib/Poet/Server.pm",
      "package" : "Poet::Server"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method import ($pkg:) {\n    unless ( Poet::Environment->current_env ) {\n        my $root_dir = determine_root_dir();\n        my $poet     = initialize_with_root_dir($root_dir);\n    }\n    Poet::Environment->current_env->importer->export_to_level( 1, @_ );\n}\n\nfunc initialize_with_root_dir ($root_dir) {\n    my ($app_name) = ( read_file(\"$root_dir/.poet_root\") =~ /app_name: (.*)/ )\n      or die \"cannot find app_name in $root_dir/.poet_root\";\n\n    return Poet::Environment->initialize_current_environment(\n        root_dir => $root_dir,\n        app_name => $app_name\n    );\n}\n\nfunc determine_root_dir () {\n\n    my $path1    = dirname( rel2abs($0) );\n    my $path2    = dirname( realpath($0) );\n    my $root_dir = search_upward($path1) || search_upward($path2);\n    unless ( defined $root_dir ) {\n        die sprintf( \"could not find .poet_root upwards from %s\",\n            ( $path1 eq $path2 ) ? \"'$path1'\" : \"'$path1' or '$path2'\" );\n    }\n    return $root_dir;\n}\n\nfunc search_upward ($path) {\n    my $count = 0;\n    while ( realpath($path) ne '/' && $count++ < 10 ) {\n        if ( -f \"$path/.poet_root\" ) {\n            return realpath($path);\n            last;\n        }\n        $path = dirname($path);\n    }\n    return undef;\n}\n\n1",
      "file" : "/var/tmp/arv_EILHGQ/Poet-0.13/lib/Poet/Script.pm",
      "package" : "Poet::Script"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method instance ($class:) {\n    $instance ||= $class->new();\n    $instance;\n}\n\nmethod new ($class:) {\n    return $class->SUPER::new( $class->get_options, @_ );\n}\n\nmethod get_options ($class:) {\n    my %defaults = (\n        cache_root_class => $poet->app_class('Cache'),\n        comp_root        => $poet->comps_dir,\n        data_dir         => $poet->data_dir,\n        plugins          => [ $class->get_plugins ],\n    );\n    my %configured    = %{ $conf->get_hash(\"mason\") };\n    my $extra_plugins = $conf->get_list(\"mason.extra_plugins\");\n    delete( $configured{extra_plugins} );\n    my %options = ( %defaults, %configured );\n    $options{plugins} = [ uniq( @{ $options{plugins} }, '+Poet::Mason::Plugin', @$extra_plugins ) ];\n    return %options;\n}\n\nmethod get_plugins ($class:) {\n    return ( 'HTMLFilters', 'RouterSimple', 'Cache' );\n}\n\nmethod handle_psgi ($class: $psgi_env) {\n    my $req      = $poet->app_class('Plack::Request')->new($psgi_env);\n    my $res      = $poet->app_class('Plack::Response')->new();\n    my $response = try {\n        my $interp = $poet->app_class('Mason')->instance;\n        my $m = $interp->_make_request( req => $req, res => $res );\n        $m->run( $class->_psgi_comp_path($req), $class->_psgi_parameters($req) );\n        $m->res;\n    }\n    catch {\n        my $err = $_;\n        if ( blessed($err) && $err->isa('Mason::Exception::TopLevelNotFound') ) {\n            $poet->app_class('Plack::Response')->new(404);\n        }\n        else {\n\n            local $SIG{__DIE__} = undef;\n            die $err;\n        }\n    };\n    return $response->finalize;\n}\n\nmethod _psgi_comp_path ($class: $req) {\n    my $comp_path = $req->path;\n    $comp_path = \"/$comp_path\" if substr( $comp_path, 0, 1 ) ne '/';\n    return $comp_path;\n}\n\nmethod _psgi_parameters ($class: $req) {\n    return $req->parameters;\n}\n\n1",
      "file" : "/var/tmp/arv_EILHGQ/Poet-0.13/lib/Poet/Mason.pm",
      "package" : "Poet::Mason"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method get_logger ($class: %params) {\n    my $category = $params{category} || caller();\n    return Log::Any->get_logger( category => $category );\n}\n\nmethod initialize_logging ($class:) {\n    if (   can_load('Log::Log4perl')\n        && can_load('Log::Any::Adapter')\n        && can_load('Log::Any::Adapter::Log4perl') )\n    {\n        unless ( Log::Log4perl->initialized() ) {\n            my $config_string = $class->generate_log4perl_config();\n            Log::Log4perl->init( \\$config_string );\n        }\n        Log::Any::Adapter->set('Log4perl');\n    }\n    else {\n        write_file(\n            $poet->logs_path(\"poet.log.ERROR\"),\n            sprintf(\n                \"[%s] Could not load Log::Log4perl or Log::Any::Adapter::Log4perl. Install them to enable logging, or modify logging for your application (see Poet::Manual::Subclassing).\\n\",\n                scalar(localtime) )\n        );\n    }\n}\n\nmethod generate_log4perl_config ($class:) {\n    my %log_config = %{ $conf->get_hash('log') };\n    if ( my $log4perl_conf = $log_config{log4perl_conf} ) {\n        $log4perl_conf = rel2abs( $log4perl_conf, $poet->conf_dir );\n        return read_file($log4perl_conf);\n    }\n\n    my %defaults = (\n        level  => 'info',\n        output => 'poet.log',\n        layout => '%d{dd/MMM/yyyy:HH:mm:ss.SS} [%p] %c - %m - %F:%L - %P%n',\n        %{ $log_config{'defaults'} || {} }\n    );\n    my %classes = %{ $log_config{'class'} || {} };\n\n    foreach my $set ( values(%classes) ) {\n        foreach my $key (qw(level output layout)) {\n            $set->{$key} = $defaults{$key} if !exists( $set->{$key} );\n        }\n    }\n    foreach my $set ( \\%defaults, values(%classes) ) {\n        if ( $set->{output} =~ /^(?:stderr|stdout)$/ ) {\n            $set->{appender_class} = \"Log::Log4perl::Appender::Screen\";\n            $set->{stderr} = 0 if $set->{output} eq 'stdout';\n        }\n        else {\n            $set->{appender_class} = \"Log::Log4perl::Appender::File\";\n            $set->{filename} = rel2abs( $set->{output}, $poet->logs_dir );\n            mkpath( dirname( $set->{filename} ), 0, 0775 );\n        }\n    }\n    return join(\n        \"\\n\",\n        $class->_generate_lines( 'log4perl.logger', 'default', \\%defaults ),\n        map {\n            $class->_generate_lines( \"log4perl.logger.$_\", $class->_flatten_class_name($_),\n                $classes{$_} )\n        } sort( keys(%classes) ),\n    );\n}\n\nmethod _generate_lines ($class: $logger, $appender, $set) {\n    my $full_appender = \"log4perl.appender.$appender\";\n    my @pairs         = (\n        [ $logger        => join( \", \", uc( $set->{level} ), $appender ) ],\n        [ $full_appender => $set->{appender_class} ],\n        [ \"$full_appender.layout\"                   => 'Log::Log4perl::Layout::PatternLayout' ],\n        [ \"$full_appender.layout.ConversionPattern\" => $set->{layout} ]\n    );\n    foreach my $key (qw(filename stderr)) {\n        if ( exists( $set->{$key} ) ) {\n            push( @pairs, [ \"$full_appender.$key\" => $set->{$key} ] );\n        }\n    }\n\n    my $lines = join( \"\\n\", map { join( \" = \", @$_ ) } @pairs ) . \"\\n\";\n    return $lines;\n}\n\nmethod _flatten_class_name ($class: $class_name) {\n    $class_name =~ s/(::|\\.)/_/g;\n    return $class_name;\n}\n\n1",
      "file" : "/var/tmp/arv_EILHGQ/Poet-0.13/lib/Poet/Log.pm",
      "package" : "Poet::Log"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method _build_valid_vars () {\n    my @provide_methods = grep { /^provide_var_/ } $self->meta->get_method_list;\n    return [ sort( map { substr( $_, 12 ) } @provide_methods ) ];\n}\n\nmethod _build_default_tags () {\n    return ['debug'];\n}\n\nmethod export_to_level ($level, @params) {\n    my ($caller) = caller($level);\n    $self->export_to_class($caller);\n    foreach my $param (@params) {\n        if ( substr( $param, 0, 1 ) eq '$' ) {\n            $self->export_var_to_level( substr( $param, 1 ), $level + 1 );\n        }\n        elsif ( substr( $param, 0, 1 ) eq ':' ) {\n            $self->export_tag_to_level( substr( $param, 1 ), $level + 1 );\n        }\n    }\n    foreach my $tag ( @{ $self->default_tags } ) {\n        $self->export_tag_to_level( $tag, $level + 1 );\n    }\n}\n\nmethod export_to_class ($class) {\n}\n\nmethod export_var_to_level ($var, $level) {\n    my $provide_method = \"provide_var_\" . $var;\n    if ( $self->can($provide_method) ) {\n        my ($caller) = caller($level);\n        my $value = $self->$provide_method($caller);\n        no strict 'refs';\n        *{ $caller . \"\\::$var\" } = \\$value;\n    }\n    else {\n        croak sprintf( \"unknown import var '\\$$var': valid import vars are %s\",\n            join( \", \", map { \"'\\$$_'\" } grep { $_ ne 'env' } @{ $self->valid_vars } ) );\n    }\n}\n\nmethod export_tag_to_level ($tag, $level) {\n    my $util_class;\n    try {\n        $util_class = $self->env->app_class( \"Util::\" . ucfirst($tag) );\n    }\n    catch {\n        croak \"problem with import tag ':$tag' ($_)\";\n    };\n    $util_class->export_to_level( $level + 1, $util_class, ':all' );\n}\n\nmethod provide_var_cache ($caller) {\n    $self->env->app_class('Cache')->new( namespace => $caller );\n}\n\nmethod provide_var_conf ($caller) {\n    $self->env->conf();\n}\n\nmethod provide_var_env ($caller) {\n    $self->env;\n}\n\nmethod provide_var_log ($caller) {\n    $self->env->app_class('Log')->get_logger( category => $caller );\n}\n\nmethod provide_var_poet ($caller) {\n    $self->env;\n}\n\n1",
      "file" : "/var/tmp/arv_EILHGQ/Poet-0.13/lib/Poet/Import.pm",
      "package" : "Poet::Import"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method redirect () {\n    $self->res->redirect(@_);\n    $self->clear_and_abort();\n}\n\nmethod not_found () {\n    $self->clear_and_abort(404);\n}\n\nmethod session () {\n    $self->req->session;\n}\n\nmethod send_json ($data) {\n    $self->clear_buffer;\n    $self->print( JSON::XS::encode_json($data) );\n    $self->res->content_type(\"application/json\");\n    $self->abort();\n}\n\n1",
      "file" : "/var/tmp/arv_EILHGQ/Poet-0.13/lib/Poet/Mason/Plugin/Request.pm",
      "package" : "Poet::Mason::Plugin::Request"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method abstract ()    { \"Create a new Poet installation\" }\nmethod description () { $description }\nmethod usage_desc ()  { \"poet new [-d dir] [-q] <AppName>\" }\n\nmethod _build_dir () {\n    return $self->app_name_to_dir( $self->app_name );\n}\n\nmethod app_name_to_dir ($app_name) {\n    my $dir;\n    if ( $app_name =~ /^[A-Z]+$/ ) {\n        $dir = lc($app_name);\n    }\n    else {\n        $dir = lcfirst($app_name);\n        $dir =~ s/([A-Z])/\"_\" . lc($1)/ge;\n    }\n    return $dir;\n}\n\nmethod execute ($opt, $args) {\n    $self->usage_error(\"takes one argument (app name)\") unless @$args == 1;\n\n    my $app_name = ucfirst( $args->[0] );\n    $app_name =~ s/_([a-z])/uc($1)/ge;\n    $self->app_name($app_name);\n\n    require Poet::Environment::Generator;\n    Poet::Environment::Generator->generate_environment_directory(\n        root_dir => $self->dir,\n        app_name => $self->app_name,\n        quiet    => $self->quiet\n    );\n}\n\n1",
      "file" : "/var/tmp/arv_EILHGQ/Poet-0.13/lib/Poet/App/Command/new.pm",
      "package" : "Poet::App::Command::new"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method abstract () {\n    \"Create a Poet script\";\n}\n\nmethod usage_desc () {\n    return \"poet script <script-name>\";\n}\n\nmethod execute ($opt, $args) {\n    $self->usage_error(\"takes one argument (script name)\") unless @$args == 1;\n    my ($path) = @$args;\n    my $poet = $self->initialize_environment();\n    $path =~ s|^bin/||;\n    $path = rel2abs( $path, $poet->bin_dir() );\n    die \"'$path' already exists, will not overwrite\" if -e $path;\n    write_file( $path, $self->script_template() );\n    chmod( 0775, $path );\n    print \"$path\\n\";\n}\n\nmethod script_template () {\n    '#!/usr/local/bin/perl\nuse Poet::Script qw($conf $poet);\nuse strict;\nuse warnings;\n\n';\n}\n\n1",
      "file" : "/var/tmp/arv_EILHGQ/Poet-0.13/lib/Poet/App/Command/script.pm",
      "package" : "Poet::App::Command::script"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method generate_environment_directory ($class: %params) {\n    my $root_dir = $params{root_dir} or die \"must specify root_dir\";\n    my $app_name = $params{app_name} || basename($root_dir);\n    my $quiet    = $params{quiet};\n    my $style    = $params{style} || 'standard';\n    my $msg      = sub {\n        print \"$_[0]\\n\" unless $quiet;\n    };\n\n    die \"invalid app_name '$app_name' - must be a valid Perl identifier\"\n      unless $app_name =~ qr/[[:alpha:]_]\\w*/;\n    die \"cannot generate environment in $root_dir - directory exists and is non-empty\"\n      if ( -d $root_dir && @{ read_dir($root_dir) } );\n\n    my $share_dir = realpath( $ENV{POET_SHARE_DIR} || File::ShareDir::dist_dir('Poet') );\n    die \"cannot find Poet share dir '$share_dir'\" unless -d $share_dir;\n    my $comp_root = \"$share_dir/generate.skel\";\n    my $interp    = Mason->new(\n        comp_root               => $comp_root,\n        autoextend_request_path => 0,\n        top_level_regex         => qr/./,\n        allow_globals           => [qw($app_name $root_dir)],\n    );\n    $interp->set_global( '$app_name' => $app_name );\n    $interp->set_global( '$root_dir' => $root_dir );\n\n    my @paths = $interp->all_paths()\n      or die \"could not find template components\";\n\n    foreach my $path (@paths) {\n        next if $path =~ m{/\\.};    \n        my $output = trim( $interp->run($path)->output );\n        ( my $dest = $path ) =~ s{/DOT_}{/.}g;\n        $dest = $root_dir . $dest;\n        $dest =~ s|$root_dir/lib/MyApp|$root_dir/lib/$app_name|;\n        mkpath( dirname($dest), 0, 0775 );\n        if ( $path =~ /EMPTY$/ ) {\n            $msg->( dirname($dest) );\n        }\n        else {\n            $msg->($dest);\n            write_file( $dest, $output );\n        }\n    }\n\n    find( sub { chmod( 0775, $_ ) if /\\.pl$/ }, $root_dir );\n    $msg->(\"\\nNow run '$root_dir/bin/run.pl' to start your server.\");\n\n    return $root_dir;\n}\n\n1",
      "file" : "/var/tmp/arv_EILHGQ/Poet-0.13/lib/Poet/Environment/Generator.pm",
      "package" : "Poet::Environment::Generator"
   }
]
