[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp with ETLp::Role::Config {\n    use FindBin qw($Bin);\n    use Config::General qw(ParseConfig);\n    use ETLp::Exception;\n    use Try::Tiny;\n    use Modern::Perl;\n    use ETLp::Config;\n    use ETLp::Schema;\n    use ETLp::Audit::Job;\n    use ETLp::ItemBuilder;\n    use ETLp::Execute::Iteration;\n    use ETLp::Execute::Serial;\n    use Cwd 'abs_path';\n    use DBI;\n    use Log::Log4perl qw();\n    use Data::Dumper;\n    use UNIVERSAL::require;\n    use File::LocalizeNewlines;\n    use DBI::Const::GetInfoType;\n\n    our $VERSION = '0.04';\n    \n    has 'app_config_file'  => (is => 'ro', isa => 'Str', required => 1);\n    has 'env_config_file'  => (is => 'ro', isa => 'Str', required => 1);\n    has 'section'          => (is => 'ro', isa => 'Str', required => 1);\n    has 'config_directory' => (is => 'ro', isa => 'Str', required => 0);\n    has 'localize' => (is => 'ro', isa => 'Bool', required => 0, default => 0);\n\n    has 'registered_plugins' => (\n        is       => 'rw',\n        isa      => 'HashRef',\n        required => 0,\n        lazy     => 1,\n        default  => sub { {} }\n    );\n\n    has 'env_conf' => (\n        is       => 'rw',\n        isa      => 'HashRef',\n        required => 0,\n        lazy     => 1,\n        default  => sub { {} }\n    );\n    \n    has 'config' => (\n        is       => 'rw',\n        isa      => 'HashRef',\n        required => 0,\n        lazy     => 1,\n        default  => sub { {} }\n    );\n    \n    has 'app_root' => (\n        is => 'rw',\n        isa => 'Str',\n        required => 0,\n        default => abs_path(\"$Bin/..\")\n    );\n    has 'log_dir' => (\n        is       => 'ro',\n        isa      => 'Str',\n        required => 0,\n        default  => abs_path(\"$Bin/../log\")\n    );\n    has 'config_directory' => (\n        is       => 'ro',\n        isa      => 'Str',\n        required => 0,\n        default  => abs_path(\"$Bin/../conf\")\n    );\n    \n    method _build_pipeline {\n        my $env_conf = ($self->env_conf->{allow_env_vars}) ?\n            $self->env_conf :\n            {};\n        \n        my $item_builder = ETLp::ItemBuilder->new(\n            plugins        => $self->registered_plugins,\n            pipeline_type  => $self->config->{type},\n            allow_env_vars => $self->env_conf->{allow_env_vars},\n            env_conf       => $env_conf,\n            app_root       => $self->app_root,\n            config         => $self->config, \n        );\n        \n        my $pipeline = $item_builder->build_pipeline;\n        \n        return $pipeline;\n    }\n\n    method _build_app_config(Str $app_config_file, Str $section) {\n        ETLpException->throw(error =>\n            \"No such application configuration file $app_config_file\")\n            unless -f $app_config_file;\n\n        if ($self->localize) {\n            my $localize      = File::LocalizeNewlines->new;\n            my $num_localized = $localize->localize($app_config_file);\n\n            my $label;\n        }\n\n        my %config;\n\n        try {\n            %config = ParseConfig(-ConfigFile => $app_config_file);\n        }\n        catch {\n            ETLpException->throw(error => \"Cannot parse $app_config_file: $_\");\n        };\n\n        my $job = $config{$section};\n\n        ETLpException->throw(error => \"No section \" . $section .\n            \" in \" . $app_config_file) unless ref($job) eq 'HASH';\n\n        ETLpException->throw(error => \"No type for \" . $self->section)\n            unless $job->{type};\n\n        ETLpException->throw(error => \"Invalid type \" . $job->{type})\n            unless (($job->{type} eq 'iterative') || ($job->{type} eq 'serial'));\n          \n        if (defined $job->{config}) {\n            foreach my $dir (qw/incoming_dir fail_dir archive_dir\n                               controlfile_dir/) {\n                if (defined $job->{config}->{$dir}) {\n                    if (substr($job->{config}->{$dir}, 0, 1) ne '/') {\n                        $job->{config}->{$dir} = $self->app_root . '/' .\n                            $job->{config}->{$dir}\n                    }\n                }\n            }\n        }\n\n        foreach my $phase (qw/pre_process process post_process/) {\n            if (exists $job->{$phase}) {\n                if (defined $job->{$phase}->{item}) {\n                    if (ref $job->{$phase}->{item} eq 'HASH') {\n                        $job->{$phase}->{item} = [$job->{$phase}->{item}];\n                    }\n                }\n            }\n        }\n\n        return $job;\n    }\n\n    method _parse_env_conf(Str $env_config) {\n        my %conf;\n          try {\n            if ($self->localize) {\n                my $localize      = File::LocalizeNewlines->new;\n                my $num_localized = $localize->localize($env_config);\n            }\n\n            %conf = ParseConfig(-ConfigFile => $env_config,);\n        }\n        catch {\n            ETLpException->throw(error => \"Cannot parse $env_config: $_\");\n        };\n\n        return \\%conf;\n    }\n\n    method _create_dbh {\n        my $env = $self->env_conf;\n        my $dbh;\n\n        try {\n            $dbh =\n              DBI->connect($env->{'dsn'}, $env->{user}, $env->{password},\n                {RaiseError => 1, AutoCommit => 1, PrintError => 0});\n        }\n        catch {\n            ETLpException->throw(error => \"Unable to connect to database: $_\");\n        };\n\n        return $dbh;\n    }\n\n    method _create_logger() {\n        my $log_dir = $self->log_dir;\n        my $name  = $self->app_config_file . '_' . $self->section;\n        unless (-d $log_dir) {\n            ETLpException->throw(error => \"No such log directory $log_dir\");\n        }\n\n        my $layout_pattern = $self->env_conf->{logger_layout_pattern}\n          || '%d %l %p> %m%n';\n          my $logger_level = $self->env_conf->{logger_level} || 'DEBUG';\n          my $admin_email  = $self->env_conf->{admin_email};\n          my $email_sender = $self->env_conf->{email_sender};\n          my $environment  = $self->env_conf->{environment}\n          || '<unkown environment>';\n          my $log_conf;\n\n          $admin_email =~ s/@/\\@/ if $admin_email;\n        $email_sender =~ s/@/\\@/ if $email_sender;\n\n        if ($admin_email && $email_sender) {\n            $log_conf = qq{\n                log4perl.rootLogger=$logger_level,LOGFILE,Mailer\n            };\n        } else {\n            $log_conf = qq{\n                log4perl.rootLogger=$logger_level,LOGFILE\n            };\n        }\n\n        $log_conf .= qq!\n            log4perl.appender.LOGFILE=Log::Dispatch::FileRotate\n            log4perl.appender.LOGFILE.filename = $log_dir/${name}.log\n            log4perl.appender.LOGFILE.mode=append\n            log4perl.appender.LOGFILE.max      = 5\n            log4perl.appender.LOGFILE.size     = 10000000\n        \n            log4perl.appender.LOGFILE.layout = PatternLayout\n            log4perl.appender.LOGFILE.layout.ConversionPattern = $layout_pattern\n        !;\n\n          if ($admin_email && $email_sender) {\n            $log_conf .= qq{\n                log4perl.appender.Mailer           = Log::Dispatch::Email::MailSendmail\n                log4perl.appender.Mailer.from      = $email_sender\n                log4perl.appender.Mailer.to        = $admin_email\n                log4perl.appender.Mailer.subject   = [$environment] ETLp Error: $name\n                log4perl.appender.Mailer.layout    = SimpleLayout\n                log4perl.appender.Mailer.Threshold = WARN\n            }\n        }\n\n        Log::Log4perl::init(\\$log_conf);\n        my $logger = Log::Log4perl::get_logger(\"DW_${name}\");\n\n        return $logger;\n\n    }\n\n    method _register_plugins(Str $job_type) {\n        my $plugin = 'Module::Pluggable';\n        my @plugin_ns;\n\n        if ($job_type eq 'serial') {\n            push @plugin_ns, 'ETLp::Plugin::Serial';\n            push @plugin_ns, $self->env_conf->{'serial_plugin_ns'}\n              if defined $self->env_conf->{'serial_plugin_ns'};\n        } else {\n            push @plugin_ns, 'ETLp::Plugin::Iterative';\n            push @plugin_ns, $self->env_conf->{'iterative_plugin_ns'}\n              if defined $self->env_conf->{'iterative_plugin_ns'};\n        }\n\n        my $module = \"Module::Pluggable\";\n        $module->require;\n        $module->import(search_path => \\@plugin_ns, require => 1);\n        \n        my %plugin_type;\n        \n        foreach my $plugin ($self->plugins) {\n            my $class = $plugin->meta->name;\n            my $type;\n            \n            unless ($plugin->can('type')) {\n                ETLpException->throw(error => \"plugin  $class has no type\");\n            }\n            $type = $plugin->type;\n            \n            if (exists $plugin_type{$type}) {\n                ETLpException->throw(error =>\n                    \"cannot add plugin $class because $type \".\n                   \"is already managed by \" . $plugin_type{$type});\n            }\n            \n            $plugin_type{$type} = $class;\n        }\n        \n        return \\%plugin_type;\n    }\n\n\n    method run {\n        my $runner;\n        my $pipeline = $self->{pipeline};\n        \n        \n        my $audit = ETLp::Audit::Job->new(\n            name => $self->app_config_file,\n            section => $self->section,\n            config  => $self->config,\n        );\n        \n        ETLp::Config->audit($audit);\n        \n        my $audit_record = ETLp::Config->schema->resultset('EtlpJob')->find($audit->id);\n        \n        ETLp::Config->logger->info(\"Config name: \" .$audit_record->section->config->config_name);\n        \n        if ($self->config->{type} eq 'iterative') {\n            $runner = ETLp::Execute::Iteration->new(\n                pipeline => $pipeline,\n                config   => $self->config,\n            );\n        } else {\n            $runner = ETLp::Execute::Serial->new(\n                pipeline => $pipeline,\n                config   => $self->config,\n            );\n        }\n        \n        ETLp::Config->logger->debug(Dumper $runner);\n        \n        try {\n            $runner->run\n        } catch {\n            $_->rethrow if ref $_;\n            ETLpException->throw(error => $_);\n        };\n        \n        return 1;\n    }\n    \n    method pipeline {\n        return $self->{pipeline};\n    }\n    \n    method BUILD {\n        my $app_config_file = $self->app_config_file;\n        my $env_config_file = $self->env_config_file;\n\n        $app_config_file .= '.conf' unless $app_config_file =~ /\\.conf$/;\n        $env_config_file .= '.conf' unless $env_config_file =~ /\\.conf$/;\n\n        if ($self->config_directory) {\n            $app_config_file = $self->config_directory . '/' . $app_config_file;\n            $env_config_file = $self->config_directory . '/' . $env_config_file;\n        }\n\n        my $app_config =\n          $self->_build_app_config($app_config_file, $self->section);\n\n        $self->env_conf($self->_parse_env_conf($env_config_file));\n        \n        my $logger = $self->_create_logger;\n        my $dbh    = $self->_create_dbh;\n        my $schema_dbh = $self->_create_dbh;\n        \n        if ($schema_dbh->get_info($GetInfoType{SQL_DBMS_NAME}) &&\n            lc $schema_dbh->get_info($GetInfoType{SQL_DBMS_NAME}) eq 'oracle') {\n            $schema_dbh->{LongReadLen} = 1000000;\n            $schema_dbh->{LongTruncOk} = 1;\n        }\n        \n        my $schema = ETLp::Schema->connect(sub { $schema_dbh },\n                {on_connect_call => 'datetime_setup'});\n        \n        $logger->info(\"DBH's AutoCommit: \" . $dbh->{AutoCommit});\n        $schema->storage->dbh->{AutoCommit} = 1;\n        $dbh->{AutoCommit} = 0;\n\n        my $config = ETLp::Config->instance;\n        ETLp::Config->dbh($dbh);\n        ETLp::Config->logger($logger);\n        ETLp::Config->schema($schema);\n        $self->config($app_config);\n\n        $self->registered_plugins(\n            $self->_register_plugins($app_config->{type}));\n        \n        $self->{pipeline} = $self->_build_pipeline();\n        \n        my $checkpoint;\n        \n    };\n}\n\n\n1",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp.pm",
      "package" : "ETLp"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin with ETLp::Role::Config {\n    use ETLp::Exception;\n    \n    has 'config'        => (is => 'ro', isa => 'HashRef', required => 1);\n    has 'item'          => (is => 'ro', isa => 'HashRef', required => 1);\n    has 'original_item' => (is => 'ro', isa => 'HashRef', required => 1);\n    has 'env_conf'      => (is => 'ro', isa => 'HashRef', required => 1);\n\n    sub type {\n        ETLpException->throw(error => \"Abstract method 'type'\");\n    }\n\n    method run {\n        ETLpException->throw(error => \"Abstract method 'run'\");\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin.pm",
      "package" : "ETLp::Plugin"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Exception {\n    use Exception::Class (\n        'ETLpException'\n    );\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Exception.pm",
      "package" : "ETLp::Exception"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Types {\n    use Moose::Util::TypeConstraints;\n    \n    class_type('DateTime');\n    class_type('ETLp::Schema::Result::EtlpJob');\n    class_type('ETLp::Schema::Result::EtlpItem');\n    class_type('ETLp::Schema::Result::EtlpFileProcess');\n\n    subtype 'SQLLoaderMode'\n        => as 'Str'\n        => where { /^(?:append|truncate|insert|replace)$/i };\n       \n    subtype 'PositiveInt'\n        => as 'Int'\n        => where { $_ > 0 }\n        => message { \"The number you provided, $_, was not a positive number\" };\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Types.pm",
      "package" : "ETLp::Types"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::ItemBuilder with ETLp::Role::Config {\n    use ETLp::Exception;\n    use Data::Dumper;\n    use UNIVERSAL::require;\n    use Try::Tiny;\n    use Clone qw(clone);\n    use File::Basename;\n\n    has 'plugins'       => (is => 'ro', isa => 'HashRef', required => 1);\n    has 'pipeline_type' => (is => 'ro', isa => 'Str',     required => 1);\n    has 'allow_env_vars' =>\n      (is => 'ro', isa => 'Bool', required => 0, default => 0);\n    has 'env_conf' =>\n      (is => 'ro', isa => 'HashRef', required => 0, default => sub { {} });\n    has 'app_root' => (is => 'ro', isa => 'Maybe[Str]', required => 1);\n    has 'config'   => (is => 'ro', isa => 'HashRef',    required => 1);\n\n    \n    method _parse_item(HashRef $config, $item, Maybe [Str] $filename) {\n        my $app_root = $self->app_root;\n        my %master_config = (%{$self->env_conf}, %{$config->{config}});\n        $self->logger->debug(\"Master config: \" . Dumper(\\%master_config));\n        if (ref $item eq 'HASH') {\n            foreach my $item_key (keys %$item) {\n                if (!ref $item->{$item_key}) {\n                    if ($item->{$item_key} =~ /%app_root%/) {\n                        $item->{$item_key} =~ s/%app_root%/$app_root/g;\n                    }\n                    \n                    if ($filename) {\n                        if ($item->{$item_key} =~ /%filename%/) {\n                            $item->{$item_key} =~ s/%filename%/$filename/g;\n                        }\n                        \n                        if ($item->{$item_key} =~ /%basename\\(filename\\)%/) {\n                            my $base_filename = basename($filename);\n                            $item->{$item_key} =~\n                                s/%basename\\(filename\\)%/$base_filename/g;\n                        }\n                    }\n                    foreach my $config_key (keys %master_config) {\n                        if ($item->{$item_key} =~ /%$config_key%/) {\n                            my $env_value = $master_config{$config_key};\n                            $item->{$item_key} =~ s/%$config_key%/$env_value/g;\n                        }\n                    }\n                } else {\n                    $self->_parse_item($config, $item->{$item_key}, $filename);\n                }\n            }\n        } elsif (ref $item eq 'ARRAY') {\n            for (my $j = 0 ; $j < @$item ; $j++) {\n                $self->_parse_item($config, $item->[$j], $filename);\n            }\n        }\n    \n        return $item;\n    }\n\n    method _parse_config(HashRef $config, Maybe [Str] $filename){\n        my $app_root = $self->app_root;\n\n        foreach my $config_key (keys %{$config->{config}}) {\n\n            if ($config->{config}->{$config_key} =~ /%app_root%/) {\n                $config->{config}->{$config_key} =~ s/%app_root%/$app_root/g;\n            }\n\n            foreach my $env_config_key (keys %{$self->env_conf}) {\n                if ($config->{config}->{$config_key} =~ /%$env_config_key%/)\n                {\n                    my $env_value = $self->env_conf->{$env_config_key};\n                    $config->{config}->{$config_key} =~\n                      s/%$env_config_key%/$env_value/g;\n                }\n            }\n        }\n        \n        return $config;\n    }\n\n\n    method build_pipeline {\n        my $app_config = clone($self->config);\n        my @items;\n        foreach my $phase (qw/pre_process process post_process/) {\n            if (exists($app_config->{$phase}->{item})) {\n                foreach my $item (@{$app_config->{$phase}->{item}}) {\n                    my $name = delete $item->{name}\n                      || ETLpException->throw(error => \"Item has no name: \" .\n                            Dumper($item));\n                    my $type = delete $item->{type}\n                      || ETLpException->throw(error => \"Item has no type: \" .\n                            Dumper($item));\n                    my $plugin = $self->plugins->{$type}\n                      || ETLpException->throw(error =>\n                        \"No such plugin for type $type: \" .\n                            Dumper($item));\n\n                    my $sub = sub {\n                        my $filename = shift;\n\n                        my $parsed_config =\n                            $self->_parse_config(clone($app_config), $filename);\n                          \n                        my $parsed_item = $self->_parse_item(\n                            $parsed_config, clone($item), $filename\n                        );\n\n                        \n                        $self->logger->debug(\"$name item:\" . Dumper($item));\n                        $self->logger->debug(\"$name config:\" . Dumper($app_config));\n                        \n                        $self->logger->debug(\n                            \"Parsed $name item:\" . Dumper($parsed_item));\n                        $self->logger->debug(\n                            \"Parsed $name config:\" . Dumper($parsed_config));\n\n                        $plugin->require;\n                        my $etlp_obj = $plugin->new(\n                            item          => $parsed_item,\n                            config        => $parsed_config,\n                            original_item => $item,\n                            env_conf      => $self->env_conf,\n                        );\n\n                        if ($filename) {\n                            my $file_proc =\n                              $self->audit->item->create_file_process(\n                                basename($filename));\n                              \n                            try {\n                                $filename = $etlp_obj->run($filename);\n                            }\n                            catch {\n                                my $error = $_;\n                                $file_proc->update_message(''.$error);\n                                $file_proc->update_status('failed');\n                                $error->rethrow if (ref $error);\n                                ETLpException->throw(error =>\n                                    \"Processing of file: $filename failed: $_\");\n                            };\n                            \n                            unless ($file_proc->details->status->status_name eq\n                                    'warning') {\n                                $file_proc->update_status('succeeded');\n                            }\n                            return $filename;\n                        } else {\n                            $etlp_obj->run;\n                        }\n                    };\n\n                    push @items,\n                      {\n                        'name'   => $name,\n                        'type'   => $type,\n                        'plugin' => $plugin,\n                        'runner' => $sub,\n                        'item'   => $item,\n                        'phase'  => $phase\n                      };\n                }\n            }\n        }\n        return \\@items;\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/ItemBuilder.pm",
      "package" : "ETLp::ItemBuilder"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Config {\n    use MooseX::Singleton;\n    has 'dbh'    => (is => 'rw', isa => 'DBI::db');\n    has 'logger' => (is => 'rw', isa => 'Log::Log4perl::Logger');\n    has 'schema' => (is => 'rw', isa => 'ETLp::Schema');\n    has 'audit'  => (is => 'rw', isa => 'ETLp::Audit::Job');\n}\n\n\n1",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Config.pm",
      "package" : "ETLp::Config"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Execute::Serial with ETLp::Role::Config {\n    use Try::Tiny;\n    use Carp;\n    use ETLp::Exception;\n    use Data::Dumper;\n    \n    has 'pipeline' => (is => 'ro', isa => 'ArrayRef', required => 1);\n    has 'config'   => (is => 'ro', isa => 'HashRef', required => 1);\n    \n    method run {\n        my $warning = 0;\n        \n        try {\n            ITEM_LOOP: foreach my $item (@{$self->pipeline}) {\n                $self->logger->debug(\"Item: \" . Dumper($item));\n    \n                my $audit_item = $self->audit->create_item(\n                    name  => $item->{name},\n                    type  => $item->{type},\n                    phase => $item->{phase},\n                );\n    \n                my $on_error = (defined $item->{item}->{on_error}) ?\n                    $item->{item}->{on_error} :\n                    $self->config->{config}->{on_error} || 'die';\n                \n                my $run_ok = 1;\n                try {\n                    my $res = $item->{runner}();\n                }\n                catch {\n                    my $error = $_;\n                    \n                    $audit_item->update_message(''.$error);\n                    $audit_item->update_status('failed');\n                    \n                    if ($on_error ne 'ignore') {\n                        $error->rethrow if ref $error;\n                        ETLpException->throw(error => $error);\n                    }\n    \n                    $self->logger->error(''.$error);\n                    $run_ok = 0;\n                    $warning = 1;\n                };\n    \n                $audit_item->update_status('succeeded') if $run_ok;\n            }\n        }\n        catch {\n            my $error = $_;\n            $self->audit->update_message(''.$error);\n            $self->audit->update_status('failed');\n            ETLpException->throw(error => ''.$error);\n        };\n    \n        if ($warning) {\n            $self->audit->update_status('warning');\n        } else {\n            $self->audit->update_status('succeeded');\n        }\n    }    \n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Execute/Serial.pm",
      "package" : "ETLp::Execute::Serial"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Execute::Iteration with ETLp::Role::Config {\n    use Try::Tiny;\n    use Data::Dumper;\n    use File::LocalizeNewlines;\n    use File::Basename;\n    use File::Copy;\n    use Carp;\n    use ETLp::Exception;\n    \n    has 'pipeline' => (is => 'ro', isa => 'ArrayRef', required => 1);\n    has 'config'   => (is => 'ro', isa => 'HashRef',  required => 1);\n    \n    $Data::Dumper::Deparse = 1;\n    \n    method run {\n        my $warning = 0;\n        \n        try {\n            FILE_LOOP: foreach my $filename ($self->_get_source_files) {\n                ITEM_LOOP:\n                foreach my $item (@{$self->pipeline}) {\n                    $self->logger->debug(\"Item: \" . Dumper($item));\n    \n                    my $audit_item = $self->audit->create_item(\n                        name  => $item->{name},\n                        type  => $item->{type},\n                        phase => $item->{phase},\n                    );\n    \n                    my $on_error = $item->{on_error}\n                        || $self->config->{config}->{on_error}\n                        || 'die';\n                        \n                    $self->logger->debug(\"On error: $on_error\");\n                        \n                    if ($item->{localize}) {\n                        my $f = File::LocalizeNewlines->new();\n                        my $count = $f->localize($filename);\n                    }\n    \n                    my $next_file_loop = 0;\n                    my $next_item_loop = 0;\n                    \n                    try {\n                        $self->logger->debug(\"Processing file: $filename\");\n                        $filename = $item->{runner}($filename);\n                        $self->logger->debug(\"New file name: $filename\");\n                    } catch {\n                        my $error = \"Error processing $filename: $_\";\n                        my $fail_dir = $self->config->{config}->{fail_dir};\n                        \n                        move $filename, $fail_dir ||\n                            ETLpException->throw(error =>\n                                \"Cannot move $filename to $fail_dir: $!\");\n                            \n                        $filename = $fail_dir .'/' . basename($filename);\n                        \n                        $audit_item->update_message(''.$error);\n                        $audit_item->update_status('failed');\n                        \n                        if ($on_error eq 'die') {\n                            ETLpException->throw(error => $error);\n                        }\n                        $warning = 1;\n                        \n                        $self->logger->error($error);\n                        \n                        $next_file_loop = 1 if ($on_error eq 'skip');\n                        $next_item_loop = 1 if ($on_error eq 'ignore');\n                    };\n                    \n                    next FILE_LOOP if $next_file_loop;\n                    next ITEM_LOOP if $next_item_loop;\n                    \n                    $audit_item->update_status('succeeded');\n                }\n            }            \n        } catch {\n            my $error = $_;\n            if (ref $error eq 'ETLpException') {                \n                $self->logger->error($error->error);\n                $self->audit->update_message($error->error);\n            } else {                \n                $self->logger->error($error);\n                $self->audit->update_message($error);\n            }\n            $self->audit->update_status('failed');\n            $error->rethrow;\n        };\n        \n        if ($warning) {\n            $self->audit->update_status('warning');\n        } else {\n            $self->audit->update_status('succeeded');\n        }\n    }\n    \n    method _get_source_files {\n        my $incoming_dir = $self->config->{config}->{incoming_dir} ||\n            ETLpException->throw(error =>\"incoming_dir is not defined\");\n        my $filename_format = $self->config->{config}->{filename_format} ||\n            ETLpException->throw(error => \"filename_format is not defined\");\n            \n        $filename_format = '\\/' . $filename_format\n            unless (substr($filename_format, 0, 2) eq '\\/');\n            \n        $self->logger->debug('Getting the source files');\n        $self->logger->debug(\"Incoming dir: $incoming_dir\");\n        $self->logger->debug(\"filename format: $filename_format\");\n        \n        my @all_sources_files = glob(\"$incoming_dir/*\");\n    \n        $self->logger->debug(\"All files: \" . Dumper(\\@all_sources_files));\n        my @files =\n            grep(/$filename_format/, @all_sources_files);\n    \n        $self->logger->debug(\"File to load: \" . Dumper(\\@files));\n    \n        return @files;\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Execute/Iteration.pm",
      "package" : "ETLp::Execute::Iteration"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Audit::Job with (ETLp::Role::Config, ETLp::Role::Schema,\n                             ETLp::Role::Audit) {\n    use Try::Tiny;\n    use DateTime;\n    use ETLp::Types;\n    use ETLp::Audit::Item;\n    \n    \n    has 'session_id' => (is => 'rw', isa => 'Int', required => 0);   \n    has 'id' => (is => 'rw', isa => 'Int', required => 0);\n    has 'name' => (is => 'ro', isa => 'Str', required => 1);\n    has 'section' => (is => 'ro', isa => 'Str', required => 1);\n    has 'config'  => (is => 'ro', isa => 'HashRef', required => 1);\n    \n    \n    method create_item(Str :$name, Str :$type, Str :$phase) {    \n        my $item = ETLp::Audit::Item->new(\n            name       => $name,\n            type       => $type,\n            phase      => $phase,\n            job        => $self,\n            config     => $self->config\n        );\n        $self->{item} = $item;\n        return $item;\n    }\n    \n    method item {\n        return $self->{item};\n    }\n    \n    method _start_audit {\n        my $now = $self->now;\n        try {\n            $self->schema->txn_do(\n                sub {\n                    my $config = $self->EtlpConfiguration->find_or_create(\n                        {\n                            config_name => $self->name,\n                            date_created => $now,\n                            date_updated => $now\n                        },                                                                                               \n                        {key => 'etlp_configuration_u1'}\n                    );\n                    \n                    my $section = $self->EtlpSection->find_or_create(\n                        {\n                            config_id    => $config->config_id,\n                            section_name => $self->section,\n                            date_created => $now,\n                            date_updated => $now\n                        },\n                        {key => 'etlp_section_u1'}\n                    );\n                    \n                    my $job = $self->EtlpJob->create(\n                        {\n                            section_id    => $section->section_id,\n                            status_id     => $self->get_status_id('running'),\n                            session_id    => $self->session_id,\n                            process_id    => $$,\n                            date_created  => $now,\n                            date_updated  => $now\n                        }\n                    );\n                    \n                    $self->id($job->job_id);\n                }\n            )\n            \n        } catch {\n            $self->logger->logdie(\"Cannot create job audit record: $_\");\n        };\n    }    \n    \n\n    method update_status(Str $status_name) {\n        my $job  = $self->EtlpJob->find($self->id);\n        $job->status_id($self->get_status_id($status_name));\n        $self->update($job, $self->now);\n    }\n    \n    \n    method update_message(Str $message)  {\n        my $job = $self->EtlpJob->find($self->id);\n        $job->message($message);\n        $self->update($job, $self->now);\n    }\n    \n    \n    method update(ETLp::Schema::Result::EtlpJob $job,\n                       Maybe[DateTime] $date) {\n        $date = $self->now unless $date;\n        try {\n            $self->schema->txn_do(\n                sub {\n                    $job->date_updated($date);\n                    $job->update;\n                }\n            )\n        }\n        catch {\n            $self->logger->logdie(\"Cannot update job record: $_\");\n        };\n    }\n    \n    method _get_session_id {\n        my $driver = $self->get_driver;\n        my $session_id;\n\n        if ($driver eq 'Oracle') {\n            my $sql = q{\n                select sid from v$mystat where rownum = 1\n            };\n\n            ($session_id) =\n              $self->dbh->selectrow_array($sql);\n        } else {\n            $session_id = 1;\n        }\n        \n        return $session_id;\n    }\n    \n    method BUILD {\n        $self->session_id($self->_get_session_id);\n        $self->_start_audit;\n    }\n    \n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Audit/Job.pm",
      "package" : "ETLp::Audit::Job"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Audit::Item with (ETLp::Role::Config, ETLp::Role::Schema,\n                              ETLp::Role::Audit)  {\n\n    use DateTime;\n    use Try::Tiny;\n    use ETLp::Types;\n    use ETLp::Audit::FileProcess;\n    use DateTime;\n    \n    has 'job' =>\n      (is => 'ro', isa => 'ETLp::Audit::Job', required => 1, weak_ref => 1);\n    has 'name'   => (is => 'ro', isa => 'Str',     required => 1);\n    has 'phase'  => (is => 'ro', isa => 'Str',     required => 1);\n    has 'type'   => (is => 'ro', isa => 'Str',     required => 1);\n    has 'config' => (is => 'ro', isa => 'HashRef', required => 1);\n    \n    method id {\n        return $self->{id};\n    }\n    \n\n    method update_message(Str $message) {\n        my $item = $self->EtlpItem()->find($self->id);\n        $item->message($message);\n        $self->update($item, $self->now);\n    }\n    \n    \n    method update_status(Str $status_name) {\n        my $item = $self->EtlpItem()->find($self->id);\n        $item->status_id($self->get_status_id($status_name));\n        $self->update($item, $self->now);\n    }\n    \n\n    method update(ETLp::Schema::Result::EtlpItem $item,\n                  DateTime $date) {\n        $item->date_updated($date);\n        my $job  = $self->EtlpJob->find($self->job->id);\n        try {\n            $self->schema->txn_do(\n                sub {\n                    $item->update;\n                    $self->job->update($job, $date);\n                }\n            )\n        }\n        catch {\n            $self->logger->logdie(\"Cannot update job item record: $_\");\n        };\n    }\n    \n\n    method create_file_process(Str $filename) {\n        my $file_process = ETLp::Audit::FileProcess->new(\n            filename => $filename,\n            item     => $self,\n            config   => $self->config,\n        );\n        $self->{file_process} = $file_process;\n        return $file_process;\n    }\n\n\n    method file_process {\n        return $self->{file_process};\n    }\n    \n    method _create {\n        my $now  = $self->now;\n    \n        try {\n            $self->schema->txn_do(\n                sub {\n                    my $process_item = $self->EtlpItem()->create(\n                        {\n                            item_type    => $self->type,\n                            phase_id     => $self->get_phase_id($self->phase),\n                            status_id    => $self->get_status_id('running'),\n                            job_id       => $self->job->id,\n                            item_name    => $self->name,\n                            date_created => $now,\n                            date_updated => $now,\n                        }\n                    );\n    \n                    $self->{id} = $process_item->item_id;\n                }\n            );\n        }\n        catch {\n            $self->logger->logdie(\"Cannot create job item record: $_\");\n        };\n    }\n    \n    method _protected_attributes {\n        return [qw/item_id job_id phase_id type_id date_created date_updated/];\n    }\n    \n    method BUILD {\n        $self->_create;\n    }\n    \n}\n                              \n\n1",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Audit/Item.pm",
      "package" : "ETLp::Audit::Item"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Audit::Browser::Model::Job with \n    (ETLp::Role::Config, ETLp::Role::Schema, ETLp::Role::Audit,\n     ETLp::Role::Browser) {\n    use DateTime;\n    use DateTime::Format::Strptime;\n    \n   method get_jobs(Maybe[Int] :$page?, Maybe[Str] :$section_name?, Maybe[Int] :$config_id?, Maybe[Int ]:$status_id?, Maybe[Str] :$minimum_date?, Maybe[Str] :$maximum_date?) {\n        my ($criteria, $jobs, $join);\n    \n        my $strp = DateTime::Format::Strptime->new(pattern => '%d/%m/%Y');\n    \n        if ($section_name) {\n            $criteria->{'section_name'} = $section_name;\n            $join++;\n        }\n    \n        if ($config_id) {\n            $criteria->{'config_id'} = $config_id;\n            $join++;\n        }\n        \n        if ($status_id) {\n            $criteria->{'me.status_id'} = $status_id;\n        }\n    \n        if ($minimum_date && $maximum_date) {\n            $criteria->{'me.date_created'} = {\n                '>=' => $self->db_time($strp->parse_datetime($minimum_date)),\n                '<'  => $self->db_time($strp->parse_datetime($maximum_date))\n            };\n        } elsif ($minimum_date) {\n            $criteria->{'me.date_created'} =\n              {'>=' => $self->db_time($strp->parse_datetime($minimum_date))\n              };\n        } elsif ($maximum_date) {\n            $criteria->{'me.date_created'} =\n              {'<' => $self->db_time($strp->parse_datetime($maximum_date))};\n        }\n    \n        my $attributes = {\n            page     => $page,\n            rows     => $self->pagesize,\n            order_by => 'me.date_updated desc'\n        };\n    \n        if ($join) {\n            $attributes->{join} = 'section';\n        }\n    \n        $jobs = $self->EtlpJob()->search($criteria, $attributes);\n    \n        return $jobs;\n    }\n    \n    method get_config_list(Maybe[Str] $section_name?) {\n        my $criteria;\n        my $attributes = {order_by => 'config_name'};\n    \n        if ($section_name) {\n            $criteria->{section_name} = $section_name;\n            $attributes->{join}       = 'etlp_section';\n        }\n    \n        return $self->EtlpConfiguration()->search($criteria, $attributes);\n    }\n    \n    method get_section_list(Maybe[Int] $config_id?) {\n        my $attributes = {\n            select   => 'section_name',\n            distinct => '1',\n            order_by => 'section_name',\n        };\n    \n        my $criteria;\n    \n        if ($config_id) {\n            $criteria->{config_id} = $config_id;\n        }\n    \n        return $self->EtlpSection()->search($criteria, $attributes);\n    }\n    \n    method get_config_section_options(Maybe[Int] $config_id?) {\n        my $option_text = '<option value=\"\"/>';\n        my $criteria;\n    \n        $criteria = {config_id => $config_id} if $config_id;\n    \n        my $section_rs =\n          $self->EtlpSection()->search($criteria, {order_by => 'section_name',});\n    \n        while (my $section = $section_rs->next) {\n            $option_text .=\n                '<option value =\"'\n              . $section->section_name . '\">'\n              . $section->section_name\n              . '</option>';\n        }\n    \n        return $option_text;\n    }\n    \n    method get_section_config_options(Maybe[Str] $section_name?) {\n        my $option_text  = '<option value=\"\"/>';\n        my $criteria;\n    \n        $criteria = {section_name => $section_name} if $section_name;\n    \n        my $config_rs = $self->EtlppConfig->search(\n            $criteria,\n            {\n                join     => 'sections',\n                order_by => 'config_name'\n            }\n        );\n    \n        while (my $config = $config_rs->next) {\n            $option_text .=\n                '<option value =\"'\n              . $config->config_id . '\">'\n              . $config->config_name\n              . '</option>';\n        }\n    \n        return $option_text;\n    \n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Audit/Browser/Model/Job.pm",
      "package" : "ETLp::Audit::Browser::Model::Job"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Audit::Browser::Model::Schedule with\n    (ETLp::Role::Config, ETLp::Role::Schema, ETLp::Role::Audit,\n     ETLp::Role::Browser) {        \n    \n    use Data::Dumper;\n    use Try::Tiny;\n    use Text::Wrapper;\n    use Config::General qw(ParseConfig);\n    use File::Copy;\n    use File::Basename;\n    use DateTime;\n    \n\n    method get_schedules(HashRef $args) {\n        my $page     = $args->{page} || 1;\n        my $criteria = {};\n        my $filter   = {\n            join     => {'section' => ['config']},\n            prefetch => {'section' => ['config']},\n            order_by => ['config_name', 'section_name'],\n        };\n    \n        unless ($args->{no_paging}) {\n            $filter->{page} = $page;\n            $filter->{rows} = 10;\n        }\n    \n        if ($args->{config_name}) {\n            $criteria->{'config_name'} = $args->{config_name};\n        }\n    \n        if ($args->{section_name}) {\n            $criteria->{'section_name'} = $args->{section_name};\n        }\n    \n        if (defined($args->{status}) && ($args->{status} ne '')) {\n            $criteria->{status} = $args->{status};\n        }\n    \n        my $schedules = $self->EtlpSchedule->search($criteria, $filter);\n        return $schedules;\n    }\n\n\n    method get_schedule_details(HashRef $args) {\n        my $schedule_details;\n        my @schedules;\n        my $schedules = $self->get_schedules($args);\n    \n        while (my $schedule = $schedules->next) {\n            my $schedule_id = $schedule->schedule_id;\n            my $minutes     = $self->get_contracted_minutes($schedule_id);\n            my $hours       = $self->get_contracted_hours($schedule_id);\n            my $doms        = $self->get_contracted_doms($schedule_id);\n            my $day_ids     = $self->get_contracted_cron_dows($schedule_id);\n            my $days      = join(', ', @{$self->get_day_names($schedule_id)}) || '';\n            my $month_rec = $self->get_schedule_month($schedule_id) || '';\n            my $month     = ($month_rec) ? $month_rec->ep_month->month_name : '';\n            my $month_id  = ($month_rec) ? $month_rec->month_id : '';\n    \n            push @schedules,\n              {\n                schedule_id  => $schedule_id,\n                minutes      => $minutes,\n                hours        => $hours,\n                doms         => $doms,\n                day_ids      => $day_ids,\n                days         => $days,\n                month        => $month,\n                month_id     => $month_id,\n                description  => $schedule->schedule_description,\n                comment      => $schedule->schedule_comment,\n                status       => $schedule->status,\n                config_name  => $schedule->ep_section->ep_config->config_name,\n                section_name => $schedule->ep_section->section_name,\n              };\n        }\n    \n        $self->logger->debug(Dumper(\\@schedules));\n        return \\@schedules;\n    }\n   \n\n    method get_day_names(Int $schedule_id) {\n        my @days;\n    \n        foreach my $day (\n            $self->EtlpDayOfWeek->search(\n                {schedule_id => $schedule_id},\n                {\n                    join     => 'ep_schedule_day_of_weeks',\n                    order_by => 'dow_id'\n                }\n            )->all\n          )\n        {\n            ;\n            push @days, $day->day_name;\n        }\n    \n        return \\@days;\n    }\n\n\n    method get_schedule(Maybe[Int] $schedule_id?) {\n        return $self->EtlpSchedule->find($schedule_id);\n    }\n    \n\n    method get_months {\n        my @months = $self->EtlpMonth->search(undef, {order_by => 'month_id'})->all;\n        unshift @months, {month_id => undef, month_name => undef};\n        return \\@months;\n    }\n    \n\n    method get_dows {\n        return $self->EtlpDayOfWeek->search(undef, {order_by => 'dow_id'});\n    }\n    \n    \n    method get_schedule_month(Maybe[Int] $schedule_id?) {\n        return $self->EtlpScheduleMonth->search({schedule_id => $schedule_id},\n            {order_by => 'month_id'})->first;\n    }\n    \n    \n    method get_schedule_dows(Maybe[Int] $schedule_id?) {\n        my %dow;\n    \n        my $dow_rs =\n          $self->EtlpScheduleDayOfWeek->search({schedule_id => $schedule_id},\n            {order_by => 'dow_id'});\n    \n        while (my $dow_row = $dow_rs->next) {\n            my $dow_id = $dow_row->dow_id;\n            $dow{$dow_id}++;\n        }\n    \n        return \\%dow;\n    }\n    \n\n    method get_schedule_cron_dows(Maybe[Int] $schedule_id?) {\n        my %dow;\n    \n        my $dow_rs = $self->EtlpScheduleDayOfWeek->search(\n            {schedule_id => $schedule_id},\n            {\n                join     => 'ep_day_of_week',\n                order_by => 'cron_day_id'\n            }\n        );\n    \n        while (my $dow_row = $dow_rs->next) {\n            my $dow_id = $dow_row->ep_day_of_week->cron_day_id;\n            $dow{$dow_id}++;\n        }\n    \n        return \\%dow;\n    }\n\n\n    method get_schedule_doms(Maybe[Int] $schedule_id?) {\n        return $self->EtlpScheduleDayOfMonth->search({schedule_id => $schedule_id},\n            {order_by => 'schedule_dom'});\n    }\n    \n\n    method get_schedule_minutes(Maybe[Int] $schedule_id?) {\n        return $self->EtlpScheduleMinute->search({schedule_id => $schedule_id},\n            {order_by => 'schedule_minute'});\n    }\n    \n\n    method get_schedule_hours(Maybe[Int] $schedule_id?) {\n        return $self->EtlpScheduleHour->search({schedule_id => $schedule_id},\n            {order_by => 'schedule_hour'});\n    }\n\n\n    sub expand_entries {\n        my $entries = shift;\n        $entries =~ s/\\s+//g;\n        my @entries = split /,/, $entries;\n        my @entry_list;\n    \n        foreach my $entry (@entries) {\n            if ($entry =~ /^(\\d{1,2})-(\\d{1,2})$/) {\n                my ($lower, $upper) = ($1, $2);\n    \n                if ($lower < $upper) {\n                    for my $counter ($lower .. $upper) {\n                        push @entry_list, $counter;\n                    }\n                } else {\n                    push @entry_list, $entry;\n                }\n            } else {\n                push @entry_list, $entry;\n            }\n        }\n    \n        return @entry_list;\n    }\n    \n\n    sub expand_days_of_week {\n        my @entry_list = expand_entries(shift);\n    \n        foreach my $entry (@entry_list) {\n            $entry-- if ($entry =~ /^\\d+$/);\n        }\n    \n        return @entry_list;\n    }\n\n\n    sub validate_entries {\n        my $entries     = shift || die 'No entries to validate';\n        my $upper_limit = shift || die 'No upper limit';\n    \n        my $zero_allowed = shift || 0;\n        my $lower_value = -1;\n    \n        my @expanded_entries = @$entries;\n        foreach my $entry (@expanded_entries) {\n            if ($entry =~ /^(\\d{1,2})$/) {\n                my $entry = $1;\n    \n                if (($entry == 0) && (!$zero_allowed)) {\n                    return 0;\n                }\n    \n                if ($entry > $lower_value) {\n                    $lower_value = $entry;\n                } else {\n                    return 0;\n                }\n    \n                if ($entry > $upper_limit) {\n                    return 0;\n                }\n            } else {\n                return 0;\n            }\n        }\n    \n        return 1;\n    }\n\n\n    method validate_hours(Str $hours) {\n        return validate_entries([expand_entries($hours)], 23, 1);\n    }\n\n\n    method validate_minutes(Str $minutes) {\n        return validate_entries([expand_entries($minutes)], 59, 1);\n    }\n\n\n    method validate_days_of_week(Str $dow) {\n        return validate_entries([expand_days_of_week($dow)], 6, 1);\n    }\n\n\n    method validate_days_of_month(Str $dom) {\n        return validate_entries([expand_entries($dom)], 31);\n    }\n\n\n    method validate_months(Str $months) {\n        return validate_entries([expand_entries($months)], 12);\n    }\n\n\n    sub contract_entries {\n        my $entries = shift || die \"No entries to concatenate\";\n        my $low_value;\n        my @new_entries;\n        my $grouping = 0;\n    \n        foreach my $idx (0 .. @$entries - 1) {\n            if ($grouping) {\n                if ($entries->[$idx] != ($entries->[$idx - 1] + 1)) {\n                    $grouping = 0;\n                    push @new_entries, $low_value . '-' . $entries->[$idx - 1];\n                    $low_value = undef;\n                }\n            }\n    \n            if ($idx <= @$entries - 2) {\n                if (!$grouping) {\n                    if (($entries->[$idx] + 1) == $entries->[$idx + 1]) {\n                        $grouping  = 1;\n                        $low_value = $entries->[$idx];\n                    } else {\n                        push @new_entries, $entries->[$idx] if !$grouping;\n                    }\n                }\n            } elsif ($idx == @$entries - 1) {\n                if ($grouping) {\n                    push @new_entries, $low_value . '-' . $entries->[$idx];\n                } else {\n                    push @new_entries, $entries->[$idx];\n                }\n            }\n        }\n    \n        return join(',', @new_entries);\n    }\n\n\n    method get_contracted_doms(Maybe[Int] $schedule_id?) {\n        my $doms_rs     = $self->get_schedule_doms($schedule_id);\n        my (@schedule_doms, $dom_ids);\n    \n        while (my $dom = $doms_rs->next) {\n            push @schedule_doms, $dom->schedule_dom;\n        }\n    \n        $self->logger->debug(Dumper(\\@schedule_doms));\n    \n        return contract_entries(\\@schedule_doms);\n    }\n\n\n    method get_contracted_cron_dows(Maybe[Int] $schedule_id?) {\n        my $dows = [sort keys %{$self->get_schedule_cron_dows($schedule_id)}];\n        return contract_entries($dows);\n    }\n    \n\n    method get_contracted_hours(Maybe[Int] $schedule_id?) {\n        my $hours_rs    = $self->get_schedule_hours($schedule_id);\n        my (@schedule_hours, $hour_ids);\n    \n        while (my $hour = $hours_rs->next) {\n            push @schedule_hours, $hour->schedule_hour;\n        }\n    \n        $self->logger->debug(Dumper(\\@schedule_hours));\n    \n        return contract_entries(\\@schedule_hours);\n    }\n\n\n    method get_contracted_minutes(Maybe[Int] $schedule_id?) {\n        my $minutes_rs  = $self->get_schedule_minutes($schedule_id);\n        my (@schedule_minutes, $minute_ids);\n    \n        while (my $minute = $minutes_rs->next) {\n            push @schedule_minutes, $minute->schedule_minute;\n        }\n    \n        $self->logger->debug(Dumper(\\@schedule_minutes));\n    \n        return contract_entries(\\@schedule_minutes);\n    }\n    \n\n    method save (HashRef $params) {\n        my $schedule;\n    \n        $self->logger->debug(Dumper($params));\n        $params->{status} = 0 unless $params->{status};\n    \n        $self->logger->debug(\"Getting the date\");\n        my $date = $self->now;\n        $self->logger->debug(\"Got the date\");\n        \n        $self->logger->debug('schema: ' . ref($self->schema));\n    \n        try{\n            $self->schema->txn_do(\n                sub {\n        \n                    $self->logger->debug('Getting config record');\n        \n                    my $config = $self->EtlpConfiguration->single(\n                        {config_name => $params->{config_file}});\n        \n                    $self->logger->debug('Got config record or a null');\n        \n                    unless ($config) {\n                        $self->logger->debug('Creating a config record');\n                        $config = $self->EtlpConfiguration->create(\n                            {\n                                config_name  => $params->{config_file},\n                                date_created => $date,\n                                date_updated => $date,\n                            }\n                        );\n                        $self->logger->debug('Created a config record');\n                    }\n        \n                    $self->logger->debug(\"Config: \" . $config->config_id);\n        \n                    my $section = $self->EtlpSection->single(\n                        {\n                            section_name => $params->{section},\n                            config_id    => $config->config_id\n                        }\n                    );\n        \n                    unless ($section) {\n                        $section = $self->EtlpSection->create(\n                            {\n                                section_name => $params->{section},\n                                config_id    => $config->config_id,\n                                date_created => $date,\n                                date_updated => $date,\n                            }\n                        );\n                    }\n        \n                    my $section_id = $section->section_id;\n                    $self->logger->debug(\"Section: \" . $section_id);\n        \n                    if ($params->{schedule_id}) {\n                        $self->logger->debug(\n                            'Updating the schedule ' . $params->{schedule_id});\n                        $schedule = $self->EtlpSchedule->single(\n                            {schedule_id => $params->{schedule_id}});\n        \n                        $schedule->update(\n                            {\n                                'schedule_description' =>\n                                  $params->{schedule_description},\n                                'schedule_comment' => $params->{schedule_comment},\n                                'status'           => $params->{status},\n                                'user_updated'     => $params->{user_id},\n                                'date_updated'     => $date,\n                                'section_id'       => $section_id,\n                            }\n                        );\n                        $self->logger->debug('Schedule updated');\n                    } else {\n                        $self->logger->debug('Creating a new schedule');\n                        $schedule = $self->EtlpSchedule->create(\n                            {\n                                schedule_description => $params->{schedule_description},\n                                schedule_comment     => $params->{schedule_comment},\n                                status               => $params->{status},\n                                user_created         => $params->{'user_id'},\n                                user_updated         => $params->{'user_id'},\n                                date_created         => $date,\n                                date_updated         => $date,\n                                section_id           => $section->section_id,\n                            }\n                        );\n                    }\n        \n                    my $schedule_id = $schedule->schedule_id;\n                    my $minutes = $self->EtlpScheduleMinute->search(\n                        {schedule_id => $schedule->schedule_id});\n                    $minutes->delete_all;\n        \n                    $self->EtlpScheduleMinute->populate(\n                        [\n                            [qw/schedule_id schedule_minute/],\n                            map { [$schedule_id, $_] }\n                              expand_entries($params->{schedule_minutes})\n                        ]\n                    ) if defined $params->{schedule_minutes};\n        \n                    my $hours = $self->EtlpScheduleHour->search(\n                        {schedule_id => $schedule->schedule_id});\n                    $hours->delete_all;\n                    $self->EtlpScheduleHour->populate(\n                        [\n                            [qw/schedule_id schedule_hour/],\n                            map { [$schedule_id, $_] }\n                              expand_entries($params->{schedule_hours})\n                        ]\n                    ) if defined $params->{schedule_hours};\n        \n                    my $doms = $self->EtlpScheduleDayOfMonth->search(\n                        {schedule_id => $schedule->schedule_id});\n                    $doms->delete_all;\n                    $self->EtlpScheduleDayOfMonth->populate(\n                        [\n                            [qw/schedule_id schedule_dom/],\n                            map { [$schedule_id, $_] }\n                              expand_entries($params->{schedule_doms})\n                        ]\n                    ) if defined $params->{schedule_doms};\n        \n                    my $month = $self->EtlpScheduleMonth->search(\n                        {schedule_id => $schedule->schedule_id})->first;\n        \n                    if (defined $params->{month_id}) {\n                        if (defined $month) {\n                            $month->month_id($params->{month_id});\n                            $month->update;\n                        }\n                        else {\n                            $month = $self->EtlpScheduleMonth->create(\n                                {\n                                    schedule_id => $schedule_id,\n                                    month_id    => $params->{month_id}\n                                }\n                            );\n                        }\n                    }\n                    else {\n                        $self->EtlpScheduleMonth->search(\n                            {schedule_id => $schedule->schedule_id})->delete_all();\n                    }\n        \n                    if (ref $params->{dow_id} ne 'ARRAY') {\n                        $params->{dow_id} = [$params->{dow_id}];\n                    }\n        \n                    $self->logger->debug('dow_id: ', Dumper($params->{dow_id}));\n        \n                    $self->EtlpScheduleDayOfWeek->search(\n                        {schedule_id => $schedule->schedule_id})->delete_all();\n        \n                    if (defined $params->{dow_id}->[0]) {\n                        $self->EtlpScheduleDayOfWeek->populate(\n                            [\n                                [qw/schedule_id dow_id/],\n                                map { [$schedule_id, $_] } @{$params->{dow_id}}\n                            ]\n                        );\n                    }\n        \n                }\n            );\n        } catch {\n            $self->logger->logdie($_);\n        };\n        return $schedule->schedule_id;\n    }\n    \n\n    method get_scheduler_status {\n        return $self->EtlpAppConfig->single({'parameter' => 'scheduler status'});\n    }\n    \n\n    method generate_crontab($pipeline_script) {\n        my $wrapper         = Text::Wrapper->new(columns => 70);\n    \n        my $schedule_status = $self->get_scheduler_status();\n    \n        my $crontab = <<EOT;\n    \n        foreach my $schedule (@{$self->get_schedule_details({no_paging => 1})}) {\n            if ($schedule->{description}) {\n                my @descriptions = split /\\n/, $schedule->{description};\n    \n                foreach my $description (@descriptions) {\n                    $description = $wrapper->wrap($description);\n                    $description =~ s/^/# /mg;\n                }\n    \n                $schedule->{description} = join(\"\\n\", @descriptions);\n                $schedule->{description} =~ s/\\n+/\\n/g;\n                $crontab .= $schedule->{description};\n            }\n    \n            $crontab .= '#' unless ($schedule_status->value() eq 'enabled');\n            $crontab .= '#' unless $schedule->{status};\n            $schedule->{minutes}  = '*' unless $schedule->{minutes}  =~ /\\d/;\n            $schedule->{hours}    = '*' unless $schedule->{hours}    =~ /\\d/;\n            $schedule->{doms}     = '*' unless $schedule->{doms}     =~ /\\d/;\n            $schedule->{month_id} = '*' unless $schedule->{month_id} =~ /\\d/;\n            $schedule->{day_ids}  = '*' unless $schedule->{day_ids}  =~ /\\d/;\n    \n            $crontab .= sprintf(\n                \"%s %s %s %s %s $pipeline_script %s %s\\n\",\n                $schedule->{minutes}, $schedule->{hours},\n                $schedule->{doms},    $schedule->{month_id},\n                $schedule->{day_ids}, $schedule->{config_name},\n                $schedule->{section_name}\n            );\n        }\n    \n        return $crontab;\n    \n    }\n    \n\n    method get_config_files (Maybe[Str] $config_dir?) {\n        my @configuration_files;\n    \n        opendir(my $dir, $config_dir)\n          || $self->logger->logdie(\"Cannot open $config_dir\");\n    \n        while (defined(my $file = readdir($dir))) {\n            next unless -f $config_dir . '/' . $file;\n            next if $file eq 'env.conf';\n            if ($file =~ /^(.*)\\.conf$/) {\n                push @configuration_files, $1;\n            }\n        }\n    \n        return [sort @configuration_files];\n    }\n\n\n    method set_scheduler_status(Str $status) {\n        my $schedule_status = $self->get_scheduler_status;\n        $schedule_status->update({value => $status});\n    }\n\n\n    method get_sections(Str $configuration_file) {\n        $configuration_file .= '.conf';\n    \n        my %config = ParseConfig(-ConfigFile => $configuration_file,);\n        return [sort(keys %config)];\n    }\n\n\n    method get_job($schedule) {\n        return ($schedule->section->ep_config->config_name,\n            $schedule->section->section_name);\n    }\n\n\n    method get_section_options(HashRef $args) {\n        my $app_conf_dir = $args->{app_conf_dir};\n        my $config_file  = $args->{config_file};\n        my $show_blank   = $args->{show_blank};\n        my $sections     = $self->get_sections($app_conf_dir . '/' . $config_file);\n        my $options;\n    \n        my $counter = 1;\n    \n        if ($show_blank) {\n            $options = '<option selected=\"selected\"></option>';\n        }\n    \n        foreach my $section (@$sections) {\n            if (($counter++ == 1) && !($show_blank)) {\n                $options .=\n    qq{<option value=\"$section\" selected=\"selected\">$section</option>};\n            } else {\n                $options .= qq{<option value=\"$section\">$section</option>};\n            }\n        }\n    \n        return $options;\n    }\n\n\n    method config_exists(Str $config_file) {\n        return (-f $config_file . '.conf') ? 1 : 0;\n    }\n\n\n    method delete(Int $schedule_id) {\n        my $schedule_rs = $self->EtlpSchedule->search(schedule_id => $schedule_id);\n        my $minutes_rs =\n          $self->EtlpScheduleMinute->search({schedule_id => $schedule_id});\n        my $hours_rs = $self->EtlpScheduleHour->search({schedule_id => $schedule_id});\n        my $dow_rs =\n          $self->EtlpScheduleDayOfWeek->search({schedule_id => $schedule_id});\n        my $dom_rs =\n          $self->EtlpScheduleDayOfMonth->search({schedule_id => $schedule_id});\n        my $month_rs =\n          $self->EtlpScheduleMonth->search({schedule_id => $schedule_id});\n    \n        $self->schema->txn_do(\n            sub {\n                $month_rs->delete_all;\n                $dom_rs->delete_all;\n                $dow_rs->delete_all;\n                $hours_rs->delete_all;\n                $minutes_rs->delete_all;\n                $schedule_rs->delete_all;\n            }\n        );\n    }\n\n\n    method get_dependencies(Str :$config_dir, Str :$config_file, Str :$section) {\n        my @dependencies;\n    \n        $config_file .= '.conf' unless $config_file =~ /\\.conf$/;\n        $config_file = $config_dir . '/' . $config_file;\n    \n        my %config = ParseConfig(-ConfigFile => $config_file,);\n        if ($config{$section}->{config}->{next}) {\n            my ($new_config_file, $new_section) = split /\\s+/,\n              $config{$section}->{config}->{next};\n            push @dependencies, $config{$section}->{config}->{next},\n              $self->get_dependencies(\n                    config_dir  => $config_dir,\n                    config_file => $new_config_file,\n                    section     => $new_section\n              );\n        }\n    \n        return @dependencies;\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Audit/Browser/Model/Schedule.pm",
      "package" : "ETLp::Audit::Browser::Model::Schedule"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Audit::Browser::Model::User with(ETLp::Role::Config, ETLp::Role::Schema, ETLp::Role::Audit,     ETLp::Role::Browser) {\n        \n    use Crypt::PasswdMD5 'unix_md5_crypt';\n    use Data::Dumper;\n        \n    method get_user_by_username(Str $username) {\n        return $self->EtlpUser->single({username => $username});\n    }\n        \n    method get_user(Maybe[Int] $user_id?) {\n        return $self->EtlpUser->find($user_id);\n    }\n    \n    method get_users(Int :$page = 1) {\n        return $self->EtlpUser->search(\n            undef,\n            {\n                page     => $page,\n                order_by => 'first_name, last_name',\n                rows     => $self->pagesize,\n            }\n        );\n    }\n    \n    method save(HashRef $params) {    \n        delete $params->{password2} if $params->{password2};\n        $params->{password} = $self->encrypt_password($params->{password})\n          if $params->{password};\n    \n        $params->{admin}  = 0 unless $params->{admin};\n        $params->{active} = 0 unless $params->{active};\n    \n        $self->logger->debug('Paramters to save: ' . Dumper($params));\n        return $self->EtlpUser->update_or_create($params);\n    }\n    \n    method generate_salt {\n        my @chars = ('.', '/', 0 .. 9, 'A' .. 'Z', 'a' .. 'z');\n        my $length = rand(8);\n        my $salt;\n    \n        $salt .= (@chars)[rand @chars] for (1 .. $length);\n    \n        return $salt;\n    }\n    \n    method encrypt_password(Str $password) {\n        return unix_md5_crypt($password, $self->generate_salt);\n    }\n    \n    method check_password(Str $plaintext_password, Str $encrypted_password) {    \n        my $salt = (split(/\\$/, $encrypted_password))[2];    \n        return (unix_md5_crypt($plaintext_password, $salt) eq\n                $encrypted_password);\n    }\n    \n    method update_password(Str $password, Int $user_id) {\n        my $user     = $self->EtlpUser->find($user_id);\n        $user->password($self->encrypt_password($password));\n        $user->update;\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Audit/Browser/Model/User.pm",
      "package" : "ETLp::Audit::Browser::Model::User"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Audit::Browser::Model::Item with\n    (ETLp::Role::Config, ETLp::Role::Schema, ETLp::Role::Audit,\n     ETLp::Role::Browser) {\n        \n    \n    use Data::Dumper\n    \n    method get_items (Maybe[Int] :$page?, Maybe[Int] :$item_id?, Maybe[Int] :$job_id?, Maybe[Int] :$status_id?, Maybe[Str] :$item_name?, Maybe[Str] :$filename?) {\n        my $criteria = {};\n        my $attributes = {};\n    \n        $criteria->{job_id}    = $job_id    if ($job_id);\n        $criteria->{item_id}   = $item_id   if ($item_id);\n        $criteria->{status_id} = $status_id if $status_id;\n        $criteria->{item_name} = $item_name if $item_name;\n    \n        if ($filename) {\n            $criteria->{'etlp_file_process.filename'} = $filename;\n            $attributes->{join} = 'etlp_file_process';\n        }\n    \n        $attributes->{page}     = $page;\n        $attributes->{rows}     = $self->pagesize;\n        $attributes->{order_by} = 'date_updated desc, item_id desc';\n    \n        my $items = $self->EtlpItem()->search($criteria, $attributes);\n        return $items;\n    }\n    \n    method get_item_name_list(Maybe[Int] $job_id?) {        \n        return $self->EtlpItem()->search(\n            {\n                job_id => $job_id\n            },\n            {\n                select => {distinct => 'item_name'},\n                as => 'item_name'\n            }\n        )\n    }   \n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Audit/Browser/Model/Item.pm",
      "package" : "ETLp::Audit::Browser::Model::Item"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Audit::Browser::Model::FileProcess with\n    (ETLp::Role::Config, ETLp::Role::Schema, ETLp::Role::Audit,\n     ETLp::Role::Browser) {\n        \n    method get_file_processes(Maybe[Int] :$page?, Maybe[Int] :$item_id?, Maybe[Int] :$file_id?) {\n    \n        my $criteria = {};\n        $criteria->{item_id} = $item_id if ($item_id);\n        $criteria->{file_id} = $file_id if ($file_id);\n    \n        my $processes = $self->EtlpFileProcess()->search(\n            $criteria,\n            {\n                page     => $page,\n                rows     => $self->pagesize,\n                order_by => 'date_updated desc, file_proc_id desc'\n            }\n        );\n        return $processes;\n    }\n\n    method get_canonical_file(Int $file_id) {\n        return $self->EtlpFile()->find($file_id);\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Audit/Browser/Model/FileProcess.pm",
      "package" : "ETLp::Audit::Browser::Model::FileProcess"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Utility::Command {\n    use Data::Dumper;\n    use IPC::Cmd;\n    use Exception::Class ('CommandError');\n    \n    has 'errstr'   => (is => 'rw', isa => 'Str', required => 0, default => '');\n    has 'time_out' => (is => 'rw', isa => 'Int', required => 0, default => 0);\n\n\n\n    method run (Str $command) {\n        \n        $self->errstr('');\n    \n        my ($success, $error_code, $full_buf, $stdout_buf, $stderr_buf) =\n            IPC::Cmd::run(\n                command => $command,\n                timeout => $self->time_out\n            );\n    \n        if ($error_code && $error_code =~ / exited with value (\\d+)/) {\n            $error_code = $1;\n            if ($^O eq \"MSWin32\") {\n                $error_code = $error_code >> 8;\n            }\n        }\n            \n        unless ($success) {\n            $self->errstr(join(\"\", @$stderr_buf));\n        }\n    \n        if (wantarray) {\n            return (join(\"\", @$stdout_buf), $error_code);\n        } else {\n            return $error_code;\n        }\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Utility/Command.pm",
      "package" : "ETLp::Utility::Command"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "role ETLp::Role::Schema {\n    \n    use ETLp::Config;\n    \n    method schema {\n        return ETLp::Config->schema;\n    }\n    \n    method EtlpAppConfig {\n        return $self->schema->resultset('EtlpAppConfig');\n    }\n    \n    method EtlpConfiguration {\n        return $self->schema->resultset('EtlpConfiguration');\n    }    \n    \n    method EtlpDayOfWeek {\n        return $self->schema->resultset('EtlpDayOfWeek');\n    }\n    \n    method EtlpFile {\n        return $self->schema->resultset('EtlpFile');\n    }    \n    \n    method EtlpFileProcess {\n        return $self->schema->resultset('EtlpFileProcess');\n    }    \n    \n    method EtlpItem {\n        return $self->schema->resultset('EtlpItem');\n    }\n    \n    method EtlpJob {\n        return $self->schema->resultset('EtlpJob');\n    }\n    \n    method EtlpMonth {\n        return $self->schema->resultset('EtlpMonth');\n    }  \n    \n    method EtlpPhase {\n        return $self->schema->resultset('EtlpPhase');\n    }\n    \n    method EtlpSchedule {\n        return $self->schema->resultset('EtlpSchedule');\n    }\n    \n    method EtlpScheduleDayOfMonth{\n        return $self->schema->resultset('EtlpScheduleDayOfMonth');\n    }\n    \n    method EtlpScheduleDayOfWeek {\n        return $self->schema->resultset('EtlpScheduleDayOfWeek');\n    }\n    \n    method EtlpScheduleHour {\n        return $self->schema->resultset('EtlpScheduleHour');\n    }\n    \n    method EtlpScheduleMinute {\n        return $self->schema->resultset('EtlpScheduleMinute');\n    }\n    \n    method EtlpScheduleMonth {\n        return $self->schema->resultset('EtlpScheduleMonth');\n    }\n    \n    method EtlpSection {\n        return $self->schema->resultset('EtlpSection');\n    }\n    \n    method EtlpStatus {\n        return $self->schema->resultset('EtlpStatus');\n    }\n    \n    method EtlpUser {\n        return $self->schema->resultset('EtlpUser');\n    }\n}\n\n\n1",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Role/Schema.pm",
      "package" : "ETLp::Role::Schema"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Loader::CSV with ETLp::Role::Config {\n    \n    use ETLp::File::Read::CSV;\n    use Data::Dumper;\n    use File::Basename;\n    use Convert::NLS_DATE_FORMAT qw(posix2oracle);\n    use DBI::Const::GetInfoType;\n    use ETLp::Exception;\n    use Try::Tiny;\n    \n    has 'directory' => (is => 'ro', isa => 'Str');\n    has 'table'     => (is => 'ro', isa => 'Str', required => 1);\n    has 'columns'   => (is => 'ro', isa => 'ArrayRef', required => 1);\n    has 'rules'     => (is => 'ro', isa => 'HashRef', required => 0);\n    has 'localize'  => (is => 'ro', isa => 'Int', default => 0);\n    has 'error'     => (is => 'rw', isa => 'Str');\n    has 'file_id'   => (is => 'ro', isa => 'Int', required => 1);\n    has 'skip'      => (is => 'ro', isa => 'Int', required => 0, default => 0);\n    has 'ignore_field_count' => (is => 'ro', isa => 'Bool', default => 0);\n    has 'csv_options' => (is => 'ro', isa => 'HashRef', required => 0,\n                          default => sub{{allow_whitespace => 1}});\n    \n\n    method load (Str $filename) {\n        my @columns  = @{$self->columns};\n\n        $self->{_rows_loaded} = 0;\n        $self->error('');\n        \n        my $error_flag = 1;\n\n        try {\n            my $directory = $self->directory;\n\n            unless ($directory) {\n                $directory = dirname($filename);\n                $filename  = basename($filename);\n            };\n\n            my $csv = ETLp::File::Read::CSV->new(\n                directory   => $directory,\n                filename    => $filename,\n                localize    => $self->localize,\n                fields      => $self->columns,\n                skip        => $self->skip,\n                ignore_field_count => $self->ignore_field_count,\n                csv_options => $self->csv_options,\n            );\n\n            $self->logger->debug(\"SQL: $self->{_sql}\");\n            $self->logger->debug(\"Columns: \" . Dumper(\\@columns));\n\n            my $sth = $self->dbh->prepare($self->{_sql});\n\n            my $row_counter = 0;\n\n            while (my $fields = $csv->get_fields) {\n                my @vals = map($fields->{$_}, @columns);\n                $sth->execute(@vals);\n                $self->{_rows_loaded}++;\n            }\n\n            $sth->finish;\n\n            $self->dbh->commit;\n        } catch {\n            my $error = $_;\n            $self->dbh->rollback;\n\n            $self->{_rows_loaded} = 0;\n            $self->error($error);\n            $error_flag = 0;\n        };\n\n        return $error_flag;\n    }\n    \n\n    method rows_loaded {\n        return $self->{_rows_loaded};\n    }\n    \n    method _construct_sql {\n    \n        my @columns      = @{$self->columns};\n        my $column_rules = $self->rules;\n        my $placeholders;\n        \n    \n        if ($column_rules) {\n    \n            my @placeholders;\n            $self->logger->debug(\"Columns: \" . Dumper(\\@columns));\n            foreach my $column (@columns) {\n                $self->logger->debug(\"Column: $column\");\n                my $date_flag = 0;\n                my $rules     = $column_rules->{$column}->{rule};\n                $rules = [$rules] unless ref $rules eq 'ARRAY';\n                foreach my $rule (@$rules) {\n                    if ($rule =~ /^date\\('?(.*)'?\\)$/i) {\n                        my $posix_pattern = $1;\n                        $self->logger->debug(\"Date pattern: $posix_pattern\");\n                        my $db_date_pattern =\n                          $self->_get_db_date_formatter($posix_pattern);\n                        $self->logger->debug(\"DB Conversion: \" .\n                            $db_date_pattern);\n                        push @placeholders, $db_date_pattern;\n                        $date_flag = 1;\n                    }\n                }\n                push @placeholders, '?' unless $date_flag;\n            }\n    \n            $self->logger->debug(\"Placeholders: \" . Dumper(\\@placeholders));\n            $placeholders = join(',', @placeholders);\n        } else {\n            $placeholders = join(', ', split(//, '?' x @columns));\n        }\n    \n        return\n            'insert into '\n          . $self->table . '('\n          . join(', ', @columns, 'file_id')\n          . ') values ('\n          . $placeholders . ', '. $self->file_id.')';\n    }\n    \n    method _get_db_date_formatter(Str $posix_pattern) {    \n        $self->logger->debug('POSIX Pattern: ' . $posix_pattern);\n    \n        my $driver = lc $self->dbh->get_info($GetInfoType{SQL_DBMS_NAME});\n    \n        if (($driver eq 'oracle') || ($driver eq 'postgresql')){\n            return \"TO_DATE(?, '\" . posix2oracle($posix_pattern) . \"')\";\n        } elsif ($driver eq 'mysql') {\n            return \"STR_TO_DATE(?,'$posix_pattern')\";\n        } elsif ($driver eq 'sqlite') {\n            return '?'\n        }\n        ETLpException->throw(error => \"Unknown Database Driver: $driver\");\n    }\n        \n    method BUILD {\n        $self->{_sql}         = $self->_construct_sql;\n        $self->{_rows_loaded} = 0;\n        $self->logger->debug(\"Rules \" . Dumper($self->rules));\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Loader/CSV.pm",
      "package" : "ETLp::Loader::CSV"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Loader::OracleSQLLoader with ETLp::Role::Config {\n    use ETLp::Exception;\n    use ETLp::Types;\n    \n    has 'userid'           => (is => 'ro', isa => 'Str',  required => 1);\n    has 'controlfile'      => (is => 'ro', isa => 'Str',  required => 1);\n    has 'table'            => (is => 'ro', isa => 'Str',  required => 1);\n    has 'filename'         => (is => 'ro', isa => 'Str',  required => 1);\n    has 'specification'    => (is => 'ro', isa => 'Str',  required => 1);\n    has 'logfile'          => (is => 'ro', isa => 'Maybe[Str]');\n    has 'badfile'          => (is => 'ro', isa => 'Maybe[Str]');\n    has 'discardfile'      => (is => 'ro', isa => 'Maybe[Str]');\n    has 'keep_controlfile' => (is => 'ro', isa => 'Bool', default  => 0);\n    has 'keep_logfile'     => (is => 'ro', isa => 'Bool', default  => 1);\n    has 'keep_badfile'     => (is => 'ro', isa => 'Bool', default  => 1);\n    has 'keep_discardfile' => (is => 'ro', isa => 'Bool', default  => 1);\n    has 'parameters'       => (is => 'ro', isa => 'Maybe[HashRef]');\n    has 'localize'         => (is => 'ro', isa => 'Bool', default  => 0);\n    has 'mode' => (is => 'ro', isa => 'SQLLoaderMode', default => 'append');\n    \n    our @keywords = qw/\n        discardmax\n        skip\n        load\n        errors\n        rows\n        bindsize\n        silent\n        direct\n        parfile\n        parallel\n        file\n        skip_unusable_indexes\n        skip_index_maintenance\n        readsize\n        external_table\n        columnarrayrows\n        streamsize\n        multithreading\n        resumable\n        resumable_name\n        resumable_timeout\n    /;\n    \n    \n    method run {    \n        open my $cf, '>', $self->controlfile;\n        print $cf $self->controlfile_content;\n        close $cf;\n    \n        my $command = \"sqlldr userid=\" . $self->userid;\n        $command .= join(\" \", @{$self->command});\n        \n        $self->{exe} = $command;\n    \n        my $sqlldr = ETLp::Utility::Command->new();\n        my ($stdout, $retcode) = $sqlldr->run($command);\n        \n        $retcode = 0 unless defined $retcode;\n    \n        $self->{_output} = $stdout;\n        $self->{_error}  = $sqlldr->errstr;\n    \n        $self->_cleanup;\n    \n        $self->logger->debug(\"Retcode: \" . $retcode);\n        return $retcode;\n    }\n    \n\n    method command {\n        return $self->{_command};\n    }\n\n\n    method controlfile_content {\n        return $self->{_controlfile_content};\n    }\n\n\n    method error {\n        return $self->{_error};\n    }\n\n\n    method output {\n        return $self->{_output};\n        }\n    \n    method _cleanup {\n        foreach my $filetype (qw/controlfile logfile badfile discardfile/) {\n            my $keep = 'keep_' . $filetype;\n            unless ($self->$keep) {\n                $self->logger->debug(\"removing \". $self->$filetype);\n                unlink $self->$filetype\n                  || ETLpException->throw(error => \"Cannot remove \" .\n                                          $self->filetype . \": $!\");\n            }\n        }\n    }\n\n    method _build_controlfile {\n        $self->{_controlfile_content} = \n            \"LOAD DATA\\n\".\n            \"INFILE '\".$self->filename.\"'\\n\".\n            \"INTO TABLE \".$self->table.\"\\n\".\n            $self->mode.\"\\n\".\n            $self->specification;\n    }\n\n    method _build_command {\n        my @command = \" control=\" . $self->controlfile;\n    \n        push @command, \"log=\" . $self->logfile         if $self->logfile;\n        push @command, \"bad=\" . $self->badfile         if $self->badfile;\n        push @command, \"discard=\" . $self->discardfile if $self->discardfile;\n    \n        if ($self->parameters) {\n            foreach my $sqlldr_keyword (sort keys %{$self->parameters}) {\n                unless (grep /^$sqlldr_keyword$/i, @keywords) {\n                    ETLpException->throw(\"Invalid keyword: $sqlldr_keyword\");\n                }\n                push @command,\n                  \"$sqlldr_keyword = \" . $self->parameters->{$sqlldr_keyword};\n            }\n        }\n    \n        $self->{_command} = \\@command;\n    }\n    \n    method BUILD {\n        if ($self->localize) {\n            my $l = File::LocalizeNewlines->new;\n            $l->localize($self->filename);\n        }\n            \n        $self->_build_command;\n        $self->_build_controlfile;\n    }\n\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Loader/OracleSQLLoader.pm",
      "package" : "ETLp::Loader::OracleSQLLoader"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Serial::OS extends ETLp::Plugin {\n    use Data::Dumper;\n    \n    sub type {\n        return 'os';\n    }\n    \n    method run {\n        my $item    = $self->item;\n        my $command = $item->{command};\n        my $timeout = $item->{timeout} || 20;\n        \n        $self->logger->debug(Dumper($self->config));\n\n        my $message;\n\n        $self->logger->debug(\"Raw command:\\n$command\");\n        $self->logger->debug(\"Timeout:\\n$timeout\");\n\n        my $audit_item = $self->audit->item;\n\n        if ($item->{hide_command}) {\n            $message = $self->original_item->{command};\n        } else {\n            $message = $command;\n        }\n\n        $audit_item->update_message($message);\n\n        my $cmd = ETLp::Utility::Command->new(time_out => $timeout);\n\n        my ($output, $retcode) = $cmd->run($command);\n\n        if ($retcode || $cmd->errstr) {\n            $self->logger->error(\"OS execution error:\\n\" . $cmd->errstr);\n            ETLpException->throw(error => \"Error running:\\n$message:\\n\" .\n                \"$output\\n\".                 $cmd->errstr);\n        }\n\n        $audit_item->update_message($message . \"\\n\" . $output);\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Serial/OS.pm",
      "package" : "ETLp::Plugin::Iterative::OS"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Serial::PLSQL extends ETLp::Plugin::Iterative::PLSQL {\n    sub type {\n        return 'plsql';\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Serial/PLSQL.pm",
      "package" : "ETLp::Plugin::Serial::Perl"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Serial::Watch extends ETLp::Plugin {\n    use ETLp::File::Watch;\n    use Data::Dumper;\n    \n    sub type {\n        return 'watch';\n    }\n    \n    method run {\n        my $item = $self->item;\n        my $directory = $self->config->{config}->{directory} ||\n            ETLpException->throw(\"Directory not defined\");\n            \n        $self->logger->debug(\"Directory: $directory\");\n\n        my $fw = ETLp::File::Watch->new(\n            directory         => $directory,\n            file_pattern      => $item->{file_pattern},\n            call              => $self->config->{config}->{call},\n            wait_time         => $item->{wait_time} || 1,\n            duration          => $item->{duration},\n            raise_no_file_error  => $item->{no_file_error} || 0,\n            exit_on_detection => $item->{exit_on_detection}|| 0,\n        );\n\n        my $res = $fw->watch;\n        \n        if ($res == 1) {\n            $self->audit->item->update_message('File(s) detected');\n        } else {\n            $self->audit->item->update_message('No file(s) detected');\n        }\n    }\n    \n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Serial/Watch.pm",
      "package" : "ETLp::Plugin::Serial::Watch"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Serial::Perl extends ETLp::Plugin {\n    use autodie;\n    use UNIVERSAL::require;\n    use Try::Tiny;\n    \n    sub type {\n        return 'perl';\n    }\n    \n    method run {\n        my $item = $self->item;\n        my $package  = $item->{package};\n        my $sub      = $item->{sub};\n        my $params   = $item->{params};\n        my $interim_params;\n        \n        my $call = \"${package}::$sub($params)\";\n        $self->logger->debug(\"Call: $call\");\n        \n        $self->audit->item->update_message($call);\n        \n        try {\n            $package->require;\n            eval \"$call\" ||\n                ETLpException->throw(error =>\"Unable to run $call: $!\");\n        } catch {\n            my $error = $_;\n            $self->logger->error($error);\n            my $error_message = $call . ' ' . $error;\n            ETLpException->throw(error => $error_message);\n        };\n    }\n    \n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Serial/Perl.pm",
      "package" : "ETLp::Plugin::Serial::Perl"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Iterative::Gzip extends ETLp::Plugin {\n    use IO::Compress::Gzip qw($GzipError);\n    \n\n    sub type {\n        return 'gzip';\n    }\n    \n\n    method run (Str $filename) {\n        my $file_process = $self->audit->item->file_process;\n        \n        if ($filename =~ /\\.gz$/) {\n            $file_process->update_message(\"file already gzipped\");\n            return $filename;\n        }\n    \n        my $output = $filename . '.gz';\n    \n        unless (IO::Compress::Gzip::gzip $filename => $output) {\n            unlink $output;\n            ETLpException->throw(error => $GzipError);\n        };\n    \n        unlink $filename;\n        $file_process->update_message(\"file gzipped\");\n        return $output;\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Iterative/Gzip.pm",
      "package" : "ETLp::Plugin::Iterative::Gzip"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Iterative::OS extends ETLp::Plugin {\n    use File::Basename;\n    use ETLp::Utility::Command;\n    use Data::Dumper;\n\n\n    sub type {\n        return 'os';\n    }\n\n\n    method run(Str $filename) {\n        my $item    = $self->item;\n        my $command = $item->{command};\n        my $timeout = $item->{timeout} || 20;\n        \n        $self->logger->debug(Dumper($self->config));\n\n        my $message;\n\n        $self->logger->debug(\"Raw command:\\n$command\");\n        $self->logger->debug(\"Timeout:\\n$timeout\");\n\n        my $aud_file_process = $self->audit->item->file_process;\n\n        if ($item->{hide_command}) {\n            $message = $item->{command};\n        } else {\n            $message = $command;\n        }\n\n        $aud_file_process->update_message($message);\n\n        my $cmd = ETLp::Utility::Command->new(time_out => $timeout);\n\n        my ($output, $retcode) = $cmd->run($command);\n\n        if ($retcode || $cmd->errstr) {\n            ETLpException->throw(error => \"Error running:\\n$message:\\n\" .\n                                 $cmd->errstr .\"\\n\" . $retcode);\n        }\n\n        $self->audit->item->update_message($message . \"\\n\" . $output);\n        $aud_file_process->update_status('succeeded');\n        return $filename;\n    };\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Iterative/OS.pm",
      "package" : "ETLp::Plugin::Iterative::OS"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Iterative::PLSQL extends ETLp::Plugin {\n    \n    use DBI;\n    use Data::Dumper;\n    use Try::Tiny;\n\n    method _parse_params (HashRef $config, ArrayRef $params, Str $filename) {\n        my $parsed_params;\n        \n        return $parsed_params;\n    }\n\n    sub type {\n        return 'plsql';\n    }\n    \n    method run (Str $filename?) {\n        my $config = $self->config->{config};\n        my $item = $self->item;\n        my $params = $item->{parameters};\n        my $sql = \"BEGIN\\n\" . $item->{call};\n        my $message;\n        \n        $params = [$params]\n            unless (ref($params) eq 'ARRAY' || !defined($item->{parameters}));\n        my $aud_file_process =  $self->audit->item->file_process;\n            \n        $self->logger->debug(Dumper($params));\n        \n        if ($params) {\n            $sql .= '(';\n            my $param_counter = 0;\n            foreach my $param (@$params) {\n                unless($param->{name} && $param->{value}) {\n                    ETLpException->throw(\n                        error => 'parameter requires a name and a value'\n                    );\n                }\n                \n                if ($param_counter++ > 0) {\n                    $sql .= \",\\n\\t\";\n                } else {\n                    $sql .= \"\\n\\t\"\n                }\n                $sql .= $param->{name}.' => :'.$param->{name};\n            }\n            $sql .= \");\\nEND;\";\n        } else {\n            $sql .= \";\\nEND;\";\n        }\n        \n        $self->logger->debug(\"pl/sql block:\\n$sql\");\n        \n        my $sth = $self->dbh->prepare($sql);\n        \n        if($params) {\n            foreach my $param (@$params) {\n                if ($param->{value} eq '%message%') {\n                    $sth->bind_param_inout(':'.$param->{name}, \\$message,\n                        4000);\n                } else {\n                    $sth->bind_param(':'. $param->{name}, $param->{value});\n                }\n            }\n        }        \n    \n        $sth->execute || ETLpException->throw(error => DBI::errstr);\n        \n        if ($message) {\n            $self->audit->item->update_message($message);\n        };\n        \n        return $filename;\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Iterative/PLSQL.pm",
      "package" : "ETLp::Plugin::Iterative::PLSQL"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Iterative::Validate extends ETLp::Plugin {\n    use Try::Tiny;\n    use ETLp::File::Validate;\n    use File::Basename;\n    use Mail::Sendmail;\n    use Data::Dumper;\n    \n    sub type {\n        return 'validate';\n    }\n    \n    method run (Str $filename) {\n        my $item = $self->item;\n        my $app_config = $self->config->{config};\n        my $aud_file_process = $self->audit->item->file_process;\n\n        $self->logger->debug(\"file proc id: \" . $aud_file_process->id);\n\n        my $skip = $item->{skip} || '0';\n        my $on_error = $item->{on_error} || $app_config->{on_error} || 'die';\n        \n        $aud_file_process->update_message('validating file');\n    \n        my $validator;\n    \n        unless (-s $filename == 0) {\n            my $localize = $item->{localize} || $app_config->{localize} || 0;\n            \n            $self->logger->debug(\"CSV Options: \" . Dumper($item->{csv_options}));\n            \n            $validator = ETLp::File::Validate->new(\n                file_config_directory => $app_config->{controlfile_dir},\n                file_definition       => $app_config->{controlfile},\n                type                  => $item->{file_type},\n                skip                  => $skip,\n                ignore_field_count    => $item->{ignore_field_count},\n                localize              => $localize,\n                csv_options           => $item->{csv_options} || {}\n            );\n\n            unless ($validator->validate($filename)) {\n                $self->logger->debug(Dumper($validator->get_errors));\n                my @errors;\n\n                foreach my $error (@{$validator->get_errors})  {\n                    push @errors,\n                        \"Line number: \"    . $error->{line_number}\n                      . \"\\n\\tfield name:\"  . $error->{field_name}\n                      . \"\\n\\tfield value:\" . $error->{field_value}\n                      . \"\\n\\terror:\"       . $error->{message};\n                }\n\n                if ($item->{email_alerts}) {\n                    my %email = (\n                        To      => $item->{email_alerts},\n                        From    => $self->env_config->{email_sender},\n                        Subject => \"Error Validating \" . basename($filename),\n                        Message => join(\"\\n\", @errors)\n                    );\n\n                    sendmail(%email) || $self->logger->error(\n                        \"Problem sending validation error to \"\n                          . $item->{email_alerts} . \"\\n\"\n                          . $Mail::Sendmail::error\n                    );\n\n                    $self->logger->debug(\"Validation email sent\");\n                }\n\n                my $error = basename($filename) .\n                        \" failed validation:\\n\" . join(\"\\n\", @errors);\n                        \n                $aud_file_process->update_status('failed');\n                $aud_file_process->update_message($error);\n\n                ETLpException->throw(error => $error);\n            }\n                   \n            $aud_file_process->update_status('succeeded');\n            return $filename;\n        }\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Iterative/Validate.pm",
      "package" : "ETLp::Plugin::Iterative::Validate"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Iterative::CSVLoader extends ETLp::Plugin {\n    use ETLp::File::Config;\n    use File::Copy;\n    use Try::Tiny;\n    use File::Basename;\n    use ETLp::Loader::CSV;\n\n    sub type {\n        return 'csv_loader';\n    }\n\n    method run(Str $filename) {\n        my $app_config = $self->config->{config};\n        my $item     = $self->item;\n\n        my $rule_conf = ETLp::File::Config->new(\n            directory  => $app_config->{controlfile_dir},\n            definition => $app_config->{controlfile}\n        );\n\n        my $aud_file_process =  $self->audit->item->file_process;\n        \n        my $file_id = $aud_file_process->get_canonical_id;\n\n        unless (-s $filename == 0) {\n            my $skip = $item->{skip} || '0';\n\n            $aud_file_process->update_message('loading the file');\n            \n            my $csv_options = $item->{csv_options};\n\n            my $loader = ETLp::Loader::CSV->new(\n                table              => $app_config->{table_name},\n                columns            => $rule_conf->fields,\n                rules              => $rule_conf->rules,\n                logger             => $self->logger,\n                file_id            => $file_id,\n                skip               => $skip,\n                ignore_field_count => $item->{ignore_field_count},\n                csv_options        => $csv_options || {},\n                localize => $item->{localize} || $app_config->{localize} || 0,\n            );\n\n            unless ($loader->load($filename)) {\n                $aud_file_process->update_status('failed');\n                $aud_file_process->update_message($loader->error);\n                ETLpException->throw(error => $loader->error);\n            }\n\n            $aud_file_process->record_count($loader->rows_loaded);\n        } else {\n            $aud_file_process->record_count(0);\n        }\n        \n        $aud_file_process->update_status('succeeded');\n\n        move($filename, $app_config->{archive_dir}) ||\n            ETLpException->throw( error => \"Unable to move $filename to \"\n              . $app_config->{archive_dir} . \": \"\n              . $!);\n        \n        return $app_config->{archive_dir} . '/' . basename($filename);\n    }\n\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Iterative/CSVLoader.pm",
      "package" : "ETLp::Plugin::Iterative::CSVLoader"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Iterative::Gunzip extends ETLp::Plugin {\n    use IO::Uncompress::Gunzip qw($GunzipError);\n    \n\n    sub type {\n        return 'gunzip';\n    }\n    \n\n    method run (Str $filename) {\n        my $file_process = $self->audit->item->file_process;\n        my $output; \n    \n        if ($filename =~ /(.*)\\.gz$/) {\n            $output = $1;\n        } else {\n            $self->logger->debug(\"$filename is not gzipped\");\n            $file_process->update_message(\"file is not gzipped\");\n            return $filename;\n        }\n    \n        unless (IO::Uncompress::Gunzip::gunzip $filename => $output) {\n            unlink $output if -f $output;\n            ETLpException->throw(error => $GunzipError);\n        };\n    \n        unlink $filename;\n        $file_process->update_message(\"file gunzipped\");\n        return $output;\n        \n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Iterative/Gunzip.pm",
      "package" : "ETLp::Plugin::Iterative::Gunzip"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Iterative::OracleSQLLoader extends ETLp::Plugin {\n    use ETLp::Loader::OracleSQLLoader;\n    use Try::Tiny;\n    use File::Basename;\n    use DBI::Const::GetInfoType;\n    use File::Copy;\n    \n\n    sub type {\n        return 'sql_loader';\n    }\n    \n    method run (Str $filename) {\n        my $base_filename = basename($filename);\n        my $userid;\n        my $item = $self->item;\n        my $app_config = $self->config->{config};\n        \n        my $on_error = $item->{on_error} || $app_config->{on_error} || 'die';\n\n        my %sqlldr_retcodes = (\n            0 => 'EX_SUCC',\n            1 => 'EX_FAIL',\n            2 => 'EX_WARN',\n            3 => 'EX_FTL'\n        );\n\n        my $aud_file_process = $self->audit->item->file_process;        \n        my $file_id = $aud_file_process->get_canonical_id;\n        $self->logger->debug(\"file proc id: \" . $aud_file_process->id);\n        $self->logger->debug(\"file audit rec: $file_id\");\n\n        if ($item->{user_id}) {\n            $userid = $item->{user_id};\n        } else {\n            my $db = $self->dbh->get_info($GetInfoType{SQL_SERVER_NAME});\n            $userid = $self->env_conf->{user} . '/' .\n                $self->env_conf->{password};\n            $userid .= '@' . $db if $db;\n        }\n\n        my ($retcode, $sqlldr);\n        \n        $item->{specification} =~ s/%file_id%/$file_id/;\n\n        try {\n            $sqlldr = ETLp::Loader::OracleSQLLoader->new(\n                userid           => $userid,\n                filename         => $filename,\n                controlfile      => $item->{controlfile},\n                table            => $item->{table},\n                mode             => $item->{mode},\n                specification    => $item->{specification},\n                controlfile      => $item->{controlfile},\n                logfile          => $item->{logfile},\n                badfile          => $item->{badfile},\n                discardfile      => $item->{discardfile},\n                keep_controlfile => $item->{keep_controlfile},\n                keep_badfile     => $item->{keep_badfile},\n                keep_logfile     => $item->{keep_logfile},\n                keep_discardfile => $item->{keep_discardfile},\n                parameters       => $item->{parameters},\n                localize         => $item->{localize},\n            );\n\n            $retcode = $sqlldr->run;\n        } catch {\n            $aud_file_process->update_status('failed');\n            \n            if ($on_error eq 'ignore') {\n                return;\n            }\n            \n            ETLpException->throw(error => $_);\n        };\n\n        $self->logger->debug(\"Controlfile: \" . $sqlldr->controlfile_content);\n        $self->logger->debug(\"Command: \" . join(' ', @{$sqlldr->command}));\n\n        $aud_file_process->update_message(join(' ', @{$sqlldr->command}));\n\n        if ($sqlldr_retcodes{$retcode} eq 'EX_SUCC') {\n            $aud_file_process->update_status('succeeded');\n        } elsif ($sqlldr_retcodes{$retcode} =~ /^(?:EX_FAIL|EX_FTL)$/)  {\n            $aud_file_process->update_status('failed');\n            $aud_file_process->update_message(\"Command: \"\n                  . $sqlldr->command\n                  . \"\\nError: \"\n                  . $sqlldr->error);\n            ETLpException->throw(error => $sqlldr->error);\n        } elsif ($sqlldr_retcodes{$retcode} eq 'EX_WARN') {\n            my $log_message = 'SQL*Loader returned a warning';\n            $log_message .= \"\\n\\tFile: $filename\";\n            $log_message .= \"\\n\\tError: \" . $sqlldr->error\n              if $sqlldr->error;\n            $log_message .=\n              \"\\n\\n\" . join(\" \", @{$sqlldr->command});\n\n            if ($sqlldr->error) {\n                $aud_file_process->update_message(\"Command: \"\n                    . join(\" \", @{$sqlldr->command})\n                    . \"\\nError: \"\n                    . $sqlldr->error);\n            }\n\n            if ($item->{is_warning_error}) {\n                $aud_file_process->update_status('failed');\n                ETLpException->throw(error => $log_message);\n            } else {\n                $aud_file_process->update_status('warning');\n                $self->logger->warn($log_message);\n            }\n        }\n        \n        move($filename, $app_config->{archive_dir}) ||\n                ETLpException->throw(error => \"Unable to move $filename to \"\n                  . $app_config->{archive_dir} . \": $|\");\n\n        return $app_config->{archive_dir} . '/' . basename($filename);\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Iterative/OracleSQLLoader.pm",
      "package" : "ETLp::Plugin::Iterative::OracleSQLLoader"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Iterative::Perl extends ETLp::Plugin {\n    use File::Basename;\n    use UNIVERSAL::require;\n    use Try::Tiny;\n    \n\n    sub type {\n        return 'perl';\n    }\n    \n    method run (Str $filename) {\n        my $item = $self->item;\n        my $package  = $item->{package};\n        my $sub      = $item->{sub};\n        my $params   = $item->{params};\n        my $interim_params;\n        \n        my $call = \"\\$filename = ${package}::$sub($params)\";\n        $self->logger->debug(\"Call: $call\");\n        \n        my $file_process = $self->audit->item->file_process;\n        \n        try {\n            $package->require;\n            eval \"$call\" ||\n                ETLpException->throw(error =>\"Unable to run $call: $!\");\n        } catch {\n            my $error = $_;\n            \n            if (ref $error) {\n                my $message = $call . ' ' . $error->error;\n                $file_process->update_message($message);\n                $file_process->update_status('failed');\n                $error->rethrow;\n            }\n            \n            my $message = $call . ' ' . $error;\n            \n            $file_process->update_message($message);\n            $file_process->update_status('failed');\n                \n            $self->logger->debug(\"Not an ETLpException\");\n            ETLpException->throw(error => $error);\n        };\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Iterative/Perl.pm",
      "package" : "ETLp::Plugin::Iterative::Perl"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::Plugin::Iterative::SteadyStateCheck extends ETLp::Plugin {\n\n    sub type {\n        return 'steady_state_check';\n    }\n\n    method run (Str $filename) {\n        my $interval = $self->item->{interval} || 5;\n        \n        my $curr_size = -s $filename;\n        sleep $interval;\n\n        while ((-s $filename) != $curr_size) {\n            $curr_size = -s $filename;\n            sleep $interval;\n        }\n        \n        return $filename;\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/Plugin/Iterative/SteadyStateCheck.pm",
      "package" : "ETLp::Plugin::Iterative::PLSQL"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::File::Watch with ETLp::Role::Config {\n    use Moose;\n    use DateTime;\n    use FindBin qw($Bin);\n    use Fcntl ':flock';\n    use ETLp::Utility::Command;\n    use ETLp::Types;\n    use ETLp::Exception;\n    use Try::Tiny;\n\n    has 'directory'    => (is => 'ro', isa => 'Str');\n    has 'file_pattern' => (is => 'rw', isa => 'Str', required => 1);\n    has 'call'         => (is => 'ro', isa => 'Str', required => 1);\n    has 'wait_time'    =>\n        (is => 'ro', isa => 'PositiveInt', required => 0, default => 1);\n    has 'duration' => (is => 'ro', isa => 'Str', required => 1);\n    has 'raise_no_file_error' =>\n        (is => 'ro', isa => 'Bool', required => 0, default => 0);\n    has 'exit_on_detection' =>\n        (is => 'ro', isa => 'Bool', required => 0, default => 0);\n    \n    use constant UNIT_MAP => {\n        s => 'seconds',\n        m => 'minutes',\n        h => 'hours',\n        d => 'days'\n    };\n    \n    method watch {\n        my $file_pattern = $self->{_file_pattern};\n        my $file_found   = 0;\n    \n        $self->logger->info(\"Waiting for file: $file_pattern\");\n    \n        my $dt = DateTime->now;\n    \n        if ($self->duration =~ /^\\s*(\\d+)\\s*(s|m|h|d)\\s*$/) {\n            my $measure = $1;\n            my $unit    = $2;\n    \n            $dt->add(UNIT_MAP->{$unit} => $measure);\n        } else {\n            ETLpException->throw(\n                error => \"Invalid duration: \" . $self->duration\n            );\n        }\n    \n        my $expire_time = $dt->epoch;\n    \n        while (time < $expire_time) {\n    \n            my @files = glob($file_pattern);\n    \n            if (scalar(@files) ==1) {\n                if (-f $files[0]) {\n                     $file_found = 1;\n                     $self->_run_command;\n                }\n            }\n    \n            if (scalar(@files) > 1) {\n                $file_found = 1;\n                $self->_run_command;\n            }\n           \n            last if ($self->exit_on_detection && $file_found);\n    \n            sleep $self->wait_time;\n        }\n    \n        if ($file_found == 0) {\n            if ($self->raise_no_file_error) {\n                ETLpException->throw(error => \"No file found\");\n            }\n            return 0;\n        }\n    \n        $self->logger->info('Exiting file watcher');\n        return 1;\n    }\n    \n    method _run_command {\n        my $command = \"$0 \" . $self->call;\n        my $os      = ETLp::Utility::Command->new();\n        \n        try {\n            $os->run($command)\n        } catch {\n            ETLpException->throw($_)\n        }\n    }\n    \n    method BUILD {\n        $self->{_file_pattern} = $self->file_pattern;\n    \n        if ($self->directory) {\n            $self->{_file_pattern} = $self->directory . '/' .\n                $self->{_file_pattern};\n        }\n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/File/Watch.pm",
      "package" : "ETLp::File::Watch"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::File::Validate {\n    use Time::Piece;\n    use ETLp::Exception;\n    use ETLp::File::Config;\n\n    has 'data_directory'        => (is => 'ro', isa => 'Str');\n    has 'file_config_directory' => (is => 'ro', isa => 'Str');\n    has 'file_definition' => => (is => 'ro', isa => 'Str', required => 1);\n    has 'type'     => (is => 'ro', isa => 'Str',  required => 1);\n    has 'localize' => (is => 'ro', isa => 'Bool', default  => 0);\n    has 'skip'     => (is => 'ro', isa => 'Int', default  => 0);\n    has 'csv_options' => (is => 'ro', isa => 'HashRef', required => 0, default => sub{{}});\n\n    our @errors;\n\n\n    method validate(Str $filename) {\n\n        @errors = ();\n\n        if ($self->data_directory) {\n            $filename = $self->data_directory . \"/$filename\";\n        }\n\n        if ($self->type eq 'csv') {\n            return $self->_validate_csv($filename);\n        } else {\n            ETLpException->throw(error => \"Unknown file type: \" . $self->type);\n        }\n    }\n\n    method _validate_csv(Str $filename) {\n\n        require ETLp::File::Read::CSV;\n\n        my $csv = ETLp::File::Read::CSV->new(\n            filename    => $filename,\n            fields      => $self->config->fields,\n            csv_options => $self->csv_options,\n            localize    => $self->localize,\n            skip        => $self->skip\n        );\n\n        my $line_counter = 1;\n        while (my $fields = $csv->get_fields) {\n            $self->_validate_record($line_counter++, $fields);\n        }\n\n        my $ret_status = (@errors > 0) ? 0 : 1;\n          return $ret_status;\n    }\n\n\n    method _validate_record(Int $line_counter, HashRef $fields) {\n        my $rules = $self->config->rules;\n\n        LOOP:\n        foreach my $field_name (@{$self->config->fields}) {\n            my $value    = $fields->{$field_name};\n            my $nullable = $rules->{$field_name}->{nullable};\n            my @rules =\n              (ref $rules->{$field_name}->{rule} eq 'ARRAY')\n              ? @{$rules->{$field_name}->{rule}}\n              : ($rules->{$field_name}->{rule});\n\n            if (   (uc $rules->{$field_name}->{nullable} eq 'N')\n                && ($value =~ /^$/))\n            {\n                _add_error(\n                    line_number => $line_counter,\n                    field_name  => $field_name,\n                    field_value => $value,\n                    message     => 'Mandatory field missing value',\n                );\n\n                next LOOP;\n            }\n\n            next LOOP unless $value;\n\n            for (my $j = 0 ; $j < @rules ; $j++) {\n                if ($rules[$j] =~ /^range\\(.*\\)$/i) {\n\n                    unless (_is_number($value)) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message     => \"Value must be an a number\",\n                        );\n\n                        next LOOP;\n                    }\n\n                    unless ($value =~ /^[-+]?\\d*\\.?\\d*$/) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message     => 'Must be a number',\n                        );\n\n                        next LOOP;\n                    }\n                }\n                if ($rules[$j] =~ /^range\\(\\s*([-+]?\\d+),\\s*([-+]?\\d+)\\s*\\)$/i)\n                {\n                    my $lower = $1;\n                    my $upper = $2;\n\n                    unless (_is_number($value)) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message     => \"Value must be an a number\",\n                        );\n\n                        next LOOP;\n                    }\n\n                    unless (($value >= $lower) && ($value <= $upper)) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message => 'Value outside of range: ' . $rules[$j],\n                        );\n\n                        next LOOP;\n                    }\n                }\n                elsif ($rules[$j] =~ /^range\\(\\s*,\\s*([-+]?\\d+)\\s*\\)$/i) {\n                    my $upper = $1;\n\n                    unless (_is_number($value)) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message     => \"Value must be an a number\",\n                        );\n\n                        next LOOP;\n                    }\n\n                    unless ($value <= $upper) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message     => \"Value must be <= $upper\",\n                        );\n                    }\n                }\n                elsif ($rules[$j] =~ /^range\\(\\s*([-+]?\\d+)\\s*,\\s*\\)$/i) {\n                    my $lower = $1;\n\n                    unless (_is_number($value)) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message     => \"Value must be an a number\",\n                        );\n\n                        next LOOP;\n                    }\n\n                    unless ($value >= $lower) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message     => \"Value must_be >= $lower\",\n                        );\n                    }\n                }\n                elsif ($rules[$j] =~ /^varchar\\((\\d+)\\)$/i) {\n                    my $max_length   = $1;\n                    my $value_length = length($value);\n\n                    unless ($value_length <= $max_length) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message => \"Length must be less than or equal to \"\n                              . $max_length\n                              . \" characters\",\n                        );\n                    }\n                }\n                elsif (uc $rules[$j] eq 'INTEGER') {\n                    unless ($value =~ /^[-+]?\\d+$/) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message     => \"Value must be an integer\",\n                        );\n                    }\n                }\n                elsif (uc $rules[$j] eq 'FLOAT') {\n                    unless (_is_number($value)) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message     => \"Value must be a floating number\",\n                        );\n                    }\n                }\n                elsif ($rules[$j] =~ /^date\\('?(.*)'?\\)$/i) {\n                    my $pattern = $1;\n\n                    eval { Time::Piece->strptime($value, $pattern); };\n\n                    if ($@) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message     => \"Invalid date for pattern: $pattern\",\n                        );\n                    }\n                }\n                elsif ($rules[$j] =~ /^qr\\/.*\\//i) {\n                    my $regex = eval($rules[$j]);\n                    if ($value !~ $regex) {\n                        _add_error(\n                            line_number => $line_counter,\n                            field_name  => $field_name,\n                            field_value => $value,\n                            message     => \"Value does not match pattern \"\n                              . $rules[$j],\n                        );\n                    }\n                } else {\n                    _add_error(\n                        line_number => $line_counter,\n                        field_name  => $field_name,\n                        field_value => $fields->{field_name},\n                        message     => \"Unknown pattern \" . $rules[$j],\n                    );\n                }\n            }\n        }\n    };\n    \n    sub _add_error {\n        my %args = @_;\n        push @errors, \\%args;\n    }\n    \n    sub _is_number {\n        my $value = shift;\n        return $value =~ /^[-+]?\\d*\\.?\\d*$/;\n    }\n\n\n    sub get_errors {\n        return \\@errors;\n    }\n\n\n    method config {\n        return $self->{_config};\n    }\n    \n    method BUILD {    \n        $self->{_config} = ETLp::File::Config->new(\n            directory  => $self->file_config_directory,\n            definition => $self->file_definition,\n        );    \n    }\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/File/Validate.pm",
      "package" : "ETLp::File::Validate"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::File::Read with ETLp::Role::Config {\n    use ETLp::Exception;\n    use File::LocalizeNewlines;\n    has 'filename'  => (is => 'ro', isa => 'Str',  required => 1);\n    has 'directory' => (is => 'ro', isa => 'Str',  required => 0);\n    has 'localize'  => (is => 'ro', isa => 'Bool', required => 0, default => 0);\n    has 'skip'      => (is => 'ro', isa => 'Int', required => 0, default => 0);\n\n\n    method line_counter {\n        return $self->{_line_counter};\n    }\n\n\n    method get_line {\n        my $fh   = $self->{_fh};\n        my $line = <$fh>;\n        if ($line) {\n            chomp $line;\n            $self->{_line_counter}++;\n        } else {\n            return;\n        }\n\n        if ($self->line_counter <= $self->skip) {\n            $self->logger->debug(\n                'Skipping line. Counter now ' . $self->line_counter);\n            return $self->get_line;\n        }\n\n        return $line;\n    }\n    \n    method BUILD {\n    \n        my $filename = $self->filename;\n    \n        if ($self->directory) {\n            $filename = $self->directory . '/' . $filename;\n        }\n        \n        $self->logger->debug(\"Filename: $filename\");\n    \n        if ($self->localize) {\n            my $localize      = File::LocalizeNewlines->new;\n            my $num_localized = $localize->localize($filename);\n        }\n        \n        $self->logger->debug(\"Skip: \". $self->skip);\n        \n        open(my $fh, \"<\", $filename)\n          || ETLpException->throw(error => \"Cannot open $filename: $!\");\n        $self->{_fh}           = $fh;\n        $self->{_line_counter} = 0;\n    \n    }\n\n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/File/Read.pm",
      "package" : "ETLp::File::Read"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class ETLp::File::Config  with ETLp::Role::Config {\n    use Text::CSV;\n    use ETLp::Exception;\n    use Data::Dumper;\n    \n    has 'directory'  => (is => 'ro', isa => 'Str', required => 0);\n    has 'definition' => (is => 'ro', isa => 'Str', required => 1);\n    has 'fields'     => (is => 'rw', isa => 'ArrayRef');\n    has 'rules'      => (is => 'rw', isa => 'HashRef');\n    \n    method _check_rule(Str $rule) {\n        ETLpException->throw(error => \"unknown rule $rule\")\n          unless (($rule =~ /^qr\\/.*\\/$/)\n            or ($rule =~ /^varchar\\((\\d+)\\)$/i)\n            or (lc $rule eq 'integer')\n            or ($rule =~ /date\\(\\s*'?.*\\'?\\s*\\)/i)\n            or (lc $rule eq 'float')\n            or ($rule =~ /^range\\(\\s*\\d*\\s*,\\s*\\d*\\s*\\)$/i));\n    }\n    \n    method _parse_config(Str $definition) {\n        my (@fields, %fields);\n    \n        open(my $fh, '<', $definition) ||\n            ETLpException->throw(error => \"Unable to open $definition: $!\");\n    \n        my $csv = Text::CSV->new({sep_char => ';', allow_whitespace => 1});\n    \n        while (my $line = <$fh>) {\n            my $parsed_line = $line;\n            $parsed_line =~ s/#.*$//;\n            next if $parsed_line =~ /^$/;\n    \n            my $parsed_rule;\n            my ($field, $nullable, $rule) =\n              ($parsed_line =~ /^\\s*(\\S+)\\s+(\\S+)\\s+(\\S.*?)\\s*$/);\n    \n            unless ($field && $nullable && $rule) {\n                ETLpException->throw(error => \"Config file must provide \"\n                      . \"the field name, nullable flag and validation rule.\\n\"\n                      . \"line: $line\");\n            }\n    \n            if ($rule =~ /;/) {\n                my $status = $csv->parse($rule);\n                unless ($status) {\n                    ETLpException->throw(error =>\n                        sprintf(\"error: %s\\nvalue: %s\\nline: %s\",\n                        \"\" . $csv->error_diag(), $rule, $line));\n                }\n                my @rules = $csv->fields;\n                $rule = \\@rules if (@rules > 1);\n            }\n    \n            if (ref $rule eq 'ARRAY') {\n                $self->_check_rule($_) foreach @$rule;\n            } else {\n                $self->_check_rule($rule);\n            }\n    \n            if ($nullable !~ /^[YyNn]$/) {\n                ETLpException->throw(error =>\n                    sprintf(\"Nullable must be Y or N\\nvalue: %s\\nline: %s\",\n                    $nullable, $line));\n            }\n    \n            push @fields, $field;\n    \n            $fields{$field} = {\n                nullable => uc $nullable,\n                rule     => $rule,\n            };\n        }\n        \n        $self->logger->debug(\"Rules: \" . Dumper(\\%fields));\n    \n        $self->fields(\\@fields);\n        $self->rules(\\%fields);\n    }\n    \n    method BUILD {\n        my $definition = $self->definition;\n    \n        if ($self->directory) {\n            $definition = $self->directory . \"/$definition\";\n        }\n    \n        $self->_parse_config($definition);\n    }\n    \n}",
      "file" : "/var/tmp/arv_SzqDBZ/ETLp-0.04/lib/ETLp/File/Config.pm",
      "package" : "ETLp::File::Config"
   }
]
