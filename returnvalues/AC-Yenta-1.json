[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub update {\n    my $class = shift;\n    my $id    = shift;\t\n    my $up    = shift;\n\n    return unless $class->_env_ok($id, $up);\n\n    return unless $up->{timestamp} > $^T - $KEEPLOST;\n\n    $up->{id} = $id;\n    my $previnfo = $DATA->{allpeer}{$id};\n    verbose(\"discovered new peer: $id ($up->{hostname})\") unless $previnfo;\n\n    return if $previnfo && $up->{timestamp} <= $previnfo->{timestamp};\n\n    $up->{path} .= ' ' . my_server_id();\n\n    debug(\"updating $id => $up->{status}\");\n\n    $DATA->{allpeer}{$id} = $up;\n\n    if( $up->{status} != 200 ){\n        _maybe_remove( $id );\n        return ;\n    }\n\n    unless( $DATA->{datacenter}{$up->{datacenter}}{$id} ){\n        my $pdc = $previnfo->{datacenter};\n        delete $DATA->{datacenter}{$pdc}{$id} if $pdc;\n        $DATA->{datacenter}{$up->{datacenter}}{$id} = $id;\n    }\n\n    unless( $DATA->{peertype}{$up->{subsystem}}{$id} ){\n        my $ss = $previnfo->{subsystem};\n        delete $DATA->{peertype}{$ss}{$id} if $ss;\n        $DATA->{peertype}{$up->{subsystem}}{$id} = $id;\n    }\n\n    $DATA->{peermap}{$id} ||= [];\n    $up->{map} ||= [];\n    my @curmap = @{$DATA->{peermap}{$id}};\n    my @newmap = sort @{$up->{map}};\n\n    return if \"@curmap\" eq \"@newmap\";\t\t\n\n    my (%remove, %add);\n    @remove{@curmap} = @curmap;\n    @add{@newmap}    = @newmap;\n    delete $remove{$_} for @newmap;\n    delete $add{$_}    for @curmap;\n\n    for my $map (keys %remove){\n        debug(\"removing $map from $id\");\n        delete $DATA->{mappeer}{$map}{$id};\n    }\n    for my $map (keys %add){\n        debug(\"adding $map to $id\");\n        $DATA->{mappeer}{$map}{$id} = $id;\n    }\n    $DATA->{peermap}{$id} = \\@newmap;\n}",
      "file" : "/var/tmp/arv_pBpGmM/AC-Yenta-1/lib/AC/Yenta/Status.pm",
      "package" : "AC::Yenta::Status"
   }
]
