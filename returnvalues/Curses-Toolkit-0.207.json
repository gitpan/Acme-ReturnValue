[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "DESTROY {\n    my ($obj) = @_;\n\n    ref($obj) eq 'Curses::Toolkit'\n        and Curses::endwin;\n}\n\n\n\nsub get_theme_name {\n    my ($self) = @_;\n    return $self->{theme_name};\n}\n\n\n\nsub add_event_listener {\n    my $self = shift;\n    my ($listener) = validate_pos( @_, { isa => 'Curses::Toolkit::EventListener' } );\n    push @{ $self->{event_listeners} }, $listener;\n    return $self;\n}\n\n\nsub get_event_listeners {\n    my ($self) = @_;\n    return @{ $self->{event_listeners} };\n}\n\n\nsub get_focused_widget {\n    my ($self) = @_;\n    my $window = $self->get_focused_window();\n    defined $window or return;\n    return $window->get_focused_widget();\n}\n\n\nsub get_focused_window {\n    my ($self) = @_;\n    my @windows = $self->get_windows();\n    @windows or return;\n    my $window =\n        ( sort { $b->get_property( window => 'stack' ) <=> $a->get_property( window => 'stack' ) } @windows )[0];\n    return $window;\n}\n\n\n\n\nsub set_mainloop {\n    my $self = shift;\n    my ($mainloop) = validate_pos( @_, { optional => 0 } );\n    $self->{mainloop} = $mainloop;\n    return $self;\n}\n\n\nsub get_mainloop {\n    my ($self) = @_;\n    return $self->{mainloop};\n}\n\n\nsub get_shape {\n    my ($self) = @_;\n    return $self->{shape};\n}\n\n\nsub add_window {\n    my $self = shift;\n    my ($window) = validate_pos( @_, { isa => 'Curses::Toolkit::Widget::Window' } );\n    $window->_set_curses_handler( $self->{curses_handler} );\n    $window->set_theme_name( $self->{theme_name} );\n    $window->set_root_window($self);\n    $self->bring_window_to_front($window);\n\n    $window->rebuild_all_coordinates();\n    push @{ $self->{windows} }, $window;\n    $self->{window_iterator} ||= $self->{windows}->forward_from();\n    $self->needs_redraw();\n    return $self;\n}\n\n\nsub bring_window_to_front {\n    my $self = shift;\n    my ($window) = validate_pos( @_, { isa => 'Curses::Toolkit::Widget::Window' } );\n    $self->{last_stack}++;\n    $window->set_property( window => 'stack', $self->{last_stack} );\n    my $last_stack = $self->{last_stack};\n    $last_stack % 5 == 0\n        and $self->{last_stack} = $self->_cleanup_windows_stacks();\n\n    $self->needs_redraw();\n    return $self;\n}\n\nsub _cleanup_windows_stacks {\n    my ($self) = @_;\n\n    my @sorted_windows =\n        sort { $a->get_property( window => 'stack' ) <=> $b->get_property( window => 'stack' ) } $self->get_windows();\n\n    foreach my $idx ( 0 .. @sorted_windows - 1 ) {\n        $sorted_windows[$idx]->set_property( window => 'stack', $idx );\n    }\n    return @sorted_windows - 1;\n}\n\n\nsub needs_redraw {\n    my ($self) = @_;\n    my $mainloop = $self->get_mainloop();\n    defined $mainloop or return $self;\n    $mainloop->needs_redraw();\n    return $self;\n}\n\n\nsub get_windows {\n    my ($self) = @_;\n    return @{ $self->{windows} };\n}\n\n\nsub set_modal_widget {\n    my $self = shift;\n    my ($widget) = validate_pos( @_, { isa => 'Curses::Toolkit::Widget' } );\n    $self->{_modal_widget} = $widget;\n    return $self;\n}\n\n\nsub unset_modal_widget {\n    my $self = shift;\n    $self->{_modal_widget} = undef;\n    return;\n}\n\n\nsub get_modal_widget {\n    my ($self) = @_;\n\n    my $modal_widget = $self->{_modal_widget};\n    defined $modal_widget or return;\n    return $modal_widget;\n}\n\n\nsub show_all {\n    my ($self) = @_;\n    foreach my $window ( $self->get_windows() ) {\n        $window->show_all();\n    }\n    return $self;\n}\n\n\n\n\nsub render {\n    my ($self) = @_;\n\n    $self->{test_environment}\n      or $self->{curses_handler}->erase();\n\n    if (!defined $self->{_root_theme}) {\n        $self->{_root_theme} = $self->get_theme_name->new(Curses::Toolkit::Widget::Window->new());\n        $self->{_root_theme}->_set_colors($self->{_root_theme}->ROOT_COLOR, $self->{_root_theme}->ROOT_COLOR);\n    }\n    my $root_theme = $self->{_root_theme};\n\n    my $c = $self->{shape};\n    my $str = ' ' x ($c->get_x2() - $c->get_x1());\n    $self->{curses_handler}->attron($root_theme->_get_color_pair);\n    foreach my $y ( $c->get_y1() .. $c->get_y2() - 1 ) {\n        $self->{curses_handler}->addstr( $y, $c->get_x1(), $str );\n    }\n    \n    foreach my $window ( sort { $a->get_property( window => 'stack' ) <=> $b->get_property( window => 'stack' ) }\n        $self->get_windows() )\n    {\n        $window->render();\n    }\n    return $self;\n}\n\n\nsub display {\n    my ($self) = @_;\n    $self->{curses_handler}->refresh();\n    return $self;\n}\n\n\nsub dispatch_event {\n    my $self = shift;\n    my ( $event, $widget ) = validate_pos(\n        @_, { isa => 'Curses::Toolkit::Event' },\n        { isa => 'Curses::Toolkit::Widget', optional => 1 },\n    );\n\n    if ( !defined $widget ) {\n        $widget = $self->get_modal_widget();\n        defined $widget and $self->unset_modal_widget();\n    }\n    $widget ||= $event->get_matching_widget();\n    defined $widget or return;\n\n    while (1) {\n        foreach my $listener ( grep { $_->is_enabled() } $widget->get_event_listeners() ) {\n            if ( $listener->can_handle($event) ) {\n                $listener->send_event( $event, $widget );\n                $event->can_propagate()\n                    or return 1;\n            }\n        }\n        $event->restricted_to_widget()\n            and return;\n        if ( $widget->isa('Curses::Toolkit::Widget::Window') ) {\n            $widget = $widget->get_root_window();\n        } elsif ( $widget->isa('Curses::Toolkit::Widget') ) {\n            $widget = $widget->get_parent();\n        } else {\n            return;\n        }\n        defined $widget or return;\n    }\n    return;\n}\n\n\nsub fire_event {\n    my $self = shift;\n    my ( $event, $widget ) = validate_pos(\n        @_, { isa => 'Curses::Toolkit::Event' },\n        { isa => 'Curses::Toolkit::Widget', optional => 1 },\n    );\n    my $mainloop = $self->get_mainloop();\n    defined $mainloop or return $self;\n    $mainloop->stack_event( $event, $widget );\n    return $self;\n}\n\n\nsub add_delay {\n    my $self     = shift;\n    my $mainloop = $self->get_mainloop();\n    defined $mainloop or return;\n    $mainloop->add_delay(@_);\n    return;\n}\n\n\n\n\nsub _event_shape_change {\n    my ($self) = @_;\n\n    my ( $screen_h, $screen_w );\n    $self->_recompute_shape();\n\n    foreach my $window ( $self->get_windows() ) {\n        $window->rebuild_all_coordinates();\n    }\n\n\n    return 1;\n\n}\n\nsub _recompute_shape {\n    my ($self) = @_;\n    use Curses::Toolkit::Object::Coordinates;\n    my ( $screen_h, $screen_w );\n    use Curses;\n    if ($self->{test_environment}) {\n        $screen_h = $self->{test_environment}->{screen_h};\n        $screen_w = $self->{test_environment}->{screen_w};\n    } else {\n        endwin;\n        $self->{curses_handler}->getmaxyx( $screen_h, $screen_w );\n    }\n    use Curses::Toolkit::Object::Shape;\n    $self->{shape} ||= Curses::Toolkit::Object::Shape->new_zero();\n    $self->{shape}->_set(\n        x2 => $screen_w,\n        y2 => $screen_h,\n    );\n    return $self;\n}\n\nsub _rebuild_all {\n    my ($self) = @_;\n    foreach my $window ( $self->get_windows() ) {\n        $window->rebuild_all_coordinates();\n    }\n    return $self;\n}\n\n1",
      "file" : "/var/tmp/arv_WYHHfD/Curses-Toolkit-0.207/lib/Curses/Toolkit.pm",
      "package" : "Curses::Toolkit"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "DESTROY {\n    my ($self) = @_;\n    $self->is_attached() and $self->detach();\n}\n\n1",
      "file" : "/var/tmp/arv_WYHHfD/Curses-Toolkit-0.207/lib/Curses/Toolkit/EventListener.pm",
      "package" : "Curses::Toolkit::EventListener"
   }
]
