[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "FILTER {\n    my $script = $_;\n    $script =~ s/\\r\\n/\\n/g if $^O =~ /win32/i;\n\n    my $peer_host = \"localhost\";\n    my $peer_port = 10008;         \n    my $verbose   = 0;\n    my $syntax    = 0;\n    my $include   = '';\n\n    Getopt::Long::Configure(\"bundling\");\n    GetOptions( \"server|s=s\" => \\$peer_host,    \n                \"port|p=i\"   => \\$peer_port,    \n                \"verbose|v\"  => \\$verbose,      \n                \"check|c\"    => \\$syntax,       \n                \"include=s\"  => \\$include,      \n              );\n\n    my $scheme = Text::Template::fill_in_string(\n        $script,\n        PACKAGE    => 'PERL_FRAGMENTS',\n        BROKEN_ARG => $include || $0,\n        BROKEN     => sub {\n            my %args = @_;\n            $args{error} =~ s/at template line/at $args{arg} line/;\n            print STDERR \"ERROR: Perl fragment: \", $args{error};\n            exit 1;                     \n        }\n    );\n    if ($include) {\n        unshift @ARGV, $scheme;\n        return;\n    }\n    print $scheme if $verbose;\n    my $length = length($scheme);\n    die \"ERROR: script is too long for one server request: $length > 65535\\n\" if $length > 65535;\n    if ($syntax) {\n        print STDERR \"$0 syntax check done\\n\";\n        exit 0;\n    }\n\n    my $gimp = IO::Socket::INET->new( Proto    => \"tcp\",\n                                      PeerHost => $peer_host,\n                                      PeerPort => $peer_port,\n                                    ) or die \"ERROR: can't connect to server at $peer_host:$peer_port\\n\";\n\n    my $header = pack( 'an', 'G', $length );\n    syswrite( $gimp, $_ ) for ( $header, $scheme );\n\n    my $rin = '';\n    vec( $rin, fileno($gimp), 1 ) = 1;\n    select( $rin,  undef, undef, undef );    \n    select( undef, undef, undef, .1 );       \n\n    $length = sysread( $gimp, $header, 4 ) or die \"INVALID RESPONSE: empty response\\n\";\n    ( $length == 4 and $header =~ /^G/ ) or die \"INVALID RESPONSE: bad header\\n\";\n    my $status;\n    ( $status, $length ) = unpack( 'xCn', $header );\n    my $response;\n    ( sysread( $gimp, $response, $length ) == $length ) or die \"INCOMPLETE RESPONSE: $response\\n\";\n\n    if ( $status and $response =~ /^Error: Success\\n/i ) {\n        $response =~ s/^Error: Success\\n//i;\n        $status = 0;\n    }\n    print $response;\n    exit $status;\n\n    package PERL_FRAGMENTS;\n\n\n    sub sexp_from_list {\n        \"(\" . join( \" \", map { qq(\"$_\") } @_ ) . \")\";\n    }\n\n    sub set_argv {\n        \"(set! argv '\" . sexp_from_list(@ARGV) . \")\";\n    }\n\n    sub expand_files {\n        my @pats = @_;\n        @pats = map { /^[^\"].* / ? \"\\\"$_\\\"\" : $_ } @pats\n          if $^O =~ /win32/i;    \n        return map { $_ = Cwd::realpath($_); s|\\\\|/|g if $^O =~ /win32/i; $_ } glob \"@pats\";\n    }\n\n    sub include_script {\n        my @save_argv = @ARGV;\n        my $file      = shift;\n        @ARGV = ( '--include', $file, '--', @_ );\n        do $file;\n        my $included = shift @ARGV;\n        @ARGV = @save_argv;\n        return $included;\n    }\n}",
      "file" : "/var/tmp/arv_PFEL51/Gimp-ScriptFu-Client-1.01/lib/Gimp/ScriptFu/Client.pm",
      "package" : "Gimp::ScriptFu::Client"
   }
]
