[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub XmlDeviceQuery\n{\n    my $ret = nvmlInit();\n    if ($ret != $NVML_SUCCESS)\n    {\n        return \"nvmlInit(): \" . nvmlErrorString($ret);\n    }\n\n    my $strResult = \"\";\n    $strResult .= \"<?xml version=\\\"1.0\\\" ?>\\n\";\n    $strResult .= \"<!DOCTYPE nvidia_smi_log SYSTEM \\\"nvsmi_device_v4.dtd\\\">\\n\";\n    $strResult .= \"<nvidia_smi_log>\\n\";\n\n    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();\n    $year += 1900;\n    $strResult .= \"  <timestamp>$wdays[$wday] $months[$mon] $mday $hour:$min:$sec $year</timestamp>\\n\";\n    $strResult .= \"  <driver_version>\" . handleOutput(nvmlSystemGetDriverVersion()) . \"</driver_version>\\n\";\n    my $count;\n    \n    ($ret, $count) = nvmlDeviceGetCount();\n    $strResult .= \"  <attached_gpus>\" . handleOutput($ret, $count) . \"</attached_gpus>\\n\";\n\n    for (my $i = 0; $i < $count; $i++)\n    {\n        my $handle;\n        ($ret, $handle) = nvmlDeviceGetHandleByIndex($i);\n        if ($ret != $NVML_SUCCESS)\n        {\n            return \"Error: nvmlDeviceGetHandleByIndex: \" . nvmlErrorString($ret);\n        }\n        \n        my $info;\n        ($ret, $info) = nvmlDeviceGetPciInfo($handle);\n        \n        $strResult .= \"  <gpu id=\\\"\" . handleOutput($ret, $info->{'busId'}) . \"\\\">\\n\";\n        \n        $strResult .= \"    <product_name>\" . handleOutput(nvmlDeviceGetName($handle)) . \"</product_name>\\n\";\n        \n        my $mode;\n        ($ret, $mode) = nvmlDeviceGetDisplayMode($handle);\n        $strResult .= \"    <display_mode>\" . handleOutput($ret, $mode, strings=>\\@enableStr) . \"</display_mode>\\n\";\n        \n        ($ret, $mode) = nvmlDeviceGetPersistenceMode($handle);\n        $strResult .= \"    <persistence_mode>\" . handleOutput($ret, $mode, strings=>\\@enableStr) . \"</persistence_mode>\\n\";\n        \n        $strResult .= \"    <driver_model>\\n\";\n        my $current;\n        my $pending;\n        ($ret, $current, $pending) = nvmlDeviceGetDriverModel($handle);\n        $strResult .= \"      <current_dm>\" . handleOutput($ret, $current) . \"</current_dm>\\n\";\n        $strResult .= \"      <pending_dm>\" . handleOutput($ret, $pending) . \"</pending_dm>\\n\";\n        $strResult .= \"    </driver_model>\\n\";\n        \n        $strResult .= \"    <serial>\" . handleOutput(nvmlDeviceGetSerial($handle)) . \"</serial>\\n\";\n        \n        $strResult .= \"    <uuid>\" . handleOutput(nvmlDeviceGetUUID($handle)) . \"</uuid>\\n\";\n        \n        $strResult .= \"    <vbios_version>\" . handleOutput(nvmlDeviceGetVbiosVersion($handle)) . \"</vbios_version>\\n\";\n        \n        $strResult .= \"    <inforom_version>\\n\";\n        my $str;\n        ($ret, $str) = nvmlDeviceGetInforomImageVersion($handle);\n        $strResult .= \"        <img_version>\" . handleOutput($ret, $str) . \"</img_version>\\n\";\n        ($ret, $str) = nvmlDeviceGetInforomVersion($handle, $NVML_INFOROM_OEM);\n        $strResult .= \"        <oem_object>\" . handleOutput($ret, $str) . \"</oem_object>\\n\";\n        ($ret, $str) = nvmlDeviceGetInforomVersion($handle, $NVML_INFOROM_ECC);\n        $strResult .= \"        <ecc_object>\" . handleOutput($ret, $str) . \"</ecc_object>\\n\";\n        ($ret, $str) = nvmlDeviceGetInforomVersion($handle, $NVML_INFOROM_POWER);\n        $strResult .= \"        <pwr_object>\" . handleOutput($ret, $str) . \"</pwr_object>\\n\";\n        $strResult .= \"    </inforom_version>\\n\";\n        \n        $strResult .= \"    <gpu_operation_mode>\\n\";\n        ($ret, $current, $pending) = nvmlDeviceGetGpuOperationMode($handle);\n        $strResult .= \"      <current_gom>\" . handleOutput($ret, $current, strings=>\\@goms) . \"</current_gom>\\n\";\n        $strResult .= \"      <pending_gom>\" . handleOutput($ret, $pending, strings=>\\@goms) . \"</pending_gom>\\n\";\n        $strResult .= \"    </gpu_operation_mode>\\n\";\n        \n        $strResult .= \"    <pci>\\n\";\n        ($ret, $info) = nvmlDeviceGetPciInfo($handle);\n        $strResult .= sprintf(\"      <pci_bus>%02X</pci_bus>\\n\", handleOutput($ret, $info->{\"bus\"}));\n        $strResult .= sprintf(\"      <pci_device>%02X</pci_device>\\n\", handleOutput($ret, $info->{\"device\"}));\n        $strResult .= sprintf(\"      <pci_domain>%04X</pci_domain>\\n\", handleOutput($ret, $info->{\"domain\"}));\n        $strResult .= sprintf(\"      <pci_device_id>%08X</pci_device_id>\\n\", (handleOutput($ret, $info->{\"pciDeviceId\"})));\n        $strResult .=  \"      <pci_bus_id>\" . handleOutput($ret, $info->{\"busId\"}) . \"</pci_bus_id>\\n\";\n        $strResult .= sprintf(\"      <pci_sub_system_id>%08X</pci_sub_system_id>\\n\", (handleOutput($ret, $info->{\"pciSubSystemId\"})));\n        $strResult .=  \"      <pci_gpu_link_info>\\n\";\n        $strResult .=  \"        <pcie_gen>\\n\";\n        $strResult .=  \"          <max_link_gen>\" . handleOutput(nvmlDeviceGetMaxPcieLinkGeneration($handle)) . \"</max_link_gen>\\n\";\n        $strResult .=  \"          <current_link_gen>\" . handleOutput(nvmlDeviceGetCurrPcieLinkGeneration($handle)) . \"</current_link_gen>\\n\";\n        $strResult .=  \"        </pcie_gen>\\n\";\n        $strResult .=  \"        <link_widths>\\n\";\n        $strResult .=  \"          <max_link_width>\" . handleOutput(nvmlDeviceGetMaxPcieLinkWidth($handle), postfix=>'x') . \"</max_link_width>\\n\";\n        $strResult .=  \"          <current_link_width>\" . handleOutput(nvmlDeviceGetCurrPcieLinkWidth($handle), postfix=>'x') . \"</current_link_width>\\n\";\n        $strResult .=  \"        </link_widths>\\n\";\n        $strResult .=  \"      </pci_gpu_link_info>\\n\";\n        $strResult .=  \"    </pci>\\n\";\n        \n        $strResult .= \"    <fan_speed>\" . handleOutput(nvmlDeviceGetFanSpeed($handle), postfix=>' %') . \"</fan_speed>\\n\";\n        \n        $strResult .= \"    <performance_state>\" . handleOutput(nvmlDeviceGetPerformanceState($handle), prefix=>'P') . \"</performance_state>\\n\";\n        \n        my $supportedClocksThrottleReasons;\n        my $clocksThrottleReasons;\n        ($ret, $supportedClocksThrottleReasons) = nvmlDeviceGetSupportedClocksThrottleReasons($handle);\n        if ($ret == $NVML_SUCCESS)\n        {\n            ($ret, $clocksThrottleReasons) = nvmlDeviceGetCurrentClocksThrottleReasons($handle);\n        }\n        \n        if ($ret == $NVML_SUCCESS)\n        {\n            $strResult .= \"    <clocks_throttle_reasons>\\n\";\n            foreach (@throttleReasons)\n            {\n                my $mask = @$_[0];\n                my $xmlName = @$_[1];\n                $strResult .= \"      <$xmlName>\";\n                if ($ret == $NVML_SUCCESS)\n                {\n                    if ($mask & $supportedClocksThrottleReasons)\n                    {\n                        $strResult .= ($mask & $clocksThrottleReasons) ? \"Active\" : \"Not Active\"; \n                    }\n                    else\n                    {\n                        $strResult .= handleOutput($NVML_ERROR_NOT_SUPPORTED);\n                    }\n                }\n                else\n                {\n                    $strResult .= handleOutput($ret);\n                }\n                $strResult .= \"</$xmlName>\\n\";\n            }\n            $strResult .= \"    </clocks_throttle_reasons>\\n\";\n        }\n        else\n        {\n            $strResult .= \"    <clocks_throttle_reasons>\" . handleOutput($ret) . \"</clocks_throttle_reasons>\\n\";\n        }\n        \n        $strResult .= \"    <memory_usage>\\n\";\n        ($ret, $info) = nvmlDeviceGetMemoryInfo($handle);\n        $strResult .= \"      <total>\" . handleOutput($ret, int($info->{'total'}) / 1024 / 1024, format=>'%d', postfix=>' MB') . \"</total>\\n\";\n        $strResult .= \"      <used>\" . handleOutput($ret, int($info->{'used'}) / 1024 / 1024, format=>'%d', postfix=>' MB') . \"</used>\\n\";\n        $strResult .= \"      <free>\" . handleOutput($ret, int($info->{'total'} / 1024 / 1024) - int($info->{'used'} / 1024 / 1024), format=>'%d', postfix=>' MB') . \"</free>\\n\";\n        $strResult .= \"    </memory_usage>\\n\";\n\n        ($ret, $mode) = nvmlDeviceGetComputeMode($handle);\n        $strResult .= \"    <compute_mode>\" . handleOutput($ret, $mode, strings=>\\@computeModes) . \"</compute_mode>\\n\";\n        \n        $strResult .= \"    <utilization>\\n\";\n        ($ret, $info) = nvmlDeviceGetUtilizationRates($handle);\n        $strResult .= \"      <gpu_util>\" . handleOutput($ret, $info->{'gpu'}, postfix=>' %') . \"</gpu_util>\\n\";\n        $strResult .= \"      <memory_util>\" . handleOutput($ret, $info->{'memory'}, postfix=>' %') . \"</memory_util>\\n\";\n        $strResult .= \"    </utilization>\\n\";\n        \n        $strResult .= \"    <ecc_mode>\\n\";\n        ($ret, $current, $pending) = nvmlDeviceGetEccMode($handle);\n        $strResult .= \"      <current_ecc>\" . handleOutput($ret, $current, strings=>\\@enableStr) . \"</current_ecc>\\n\";\n        $strResult .= \"      <pending_ecc>\" . handleOutput($ret, $pending, strings=>\\@enableStr) . \"</pending_ecc>\\n\";\n        $strResult .= \"    </ecc_mode>\\n\";\n        \n        $strResult .= \"    <ecc_errors>\\n\";\n        my @errorTypes = qw(single_bit double_bit);\n        my @counterTypes = qw(volatile aggregate);\n        \n        for (my $c = 0; $c < @counterTypes; $c++)\n        {\n            my $counter = $counterTypes[$c];\n            $strResult .= \"      <$counter>\\n\";\n            for (my $e = 0; $e < @errorTypes; $e++)\n            {\n                my $type = $errorTypes[$e];\n                $strResult .= \"        <$type>\\n\";\n                \n                $strResult .= \"          <device_memory>\" . \n                              handleOutput(nvmlDeviceGetMemoryErrorCounter($handle, $e, $c, $NVML_MEMORY_LOCATION_DEVICE_MEMORY)) .\n                              \"</device_memory>\\n\";\n                \n                $strResult .= \"          <register_file>\" .\n                              handleOutput(nvmlDeviceGetMemoryErrorCounter($handle, $e, $c, $NVML_MEMORY_LOCATION_REGISTER_FILE)) .\n                              \"</register_file>\\n\";\n                \n                $strResult .= \"          <l1_cache>\" .\n                              handleOutput(nvmlDeviceGetMemoryErrorCounter($handle, $e, $c, $NVML_MEMORY_LOCATION_L1_CACHE )) .\n                              \"</l1_cache>\\n\";\n                \n                $strResult .= \"          <l2_cache>\" .\n                              handleOutput(nvmlDeviceGetMemoryErrorCounter($handle, $e, $c, $NVML_MEMORY_LOCATION_L2_CACHE)) .\n                              \"</l2_cache>\\n\";\n                \n                $strResult .= \"          <texture_memory>\" .\n                              handleOutput(nvmlDeviceGetMemoryErrorCounter($handle, $e, $c, $NVML_MEMORY_LOCATION_TEXTURE_MEMORY)) .\n                              \"</texture_memory>\\n\";\n                \n                my ($retTotal, $total) = nvmlDeviceGetTotalEccErrors($handle, $e, $c);\n                $strResult .= \"          <total>\" . handleOutput($retTotal, $total) . \"</total>\\n\";\n                \n                $strResult .= \"        </$type>\\n\";\n            }\n            $strResult .= \"      </$counter>\\n\";\n        }\n        $strResult .= \"    </ecc_errors>\\n\";\n        \n        $strResult .= \"    <temperature>\\n\";\n        $strResult .= \"      <gpu_temp>\" . handleOutput(nvmlDeviceGetTemperature($handle, $NVML_TEMPERATURE_GPU), postfix=>' C') . \"</gpu_temp>\\n\";\n        $strResult .= \"    </temperature>\\n\";\n\n        $strResult .= \"    <power_readings>\\n\";\n        $strResult .= \"      <power_state>\" . handleOutput(nvmlDeviceGetPowerState($handle), prefix=>'P') . \"</power_state>\\n\";\n        $strResult .= \"      <power_management>\" . handleOutput(nvmlDeviceGetPowerManagementMode($handle), strings=>\\@supportedStr) . \"</power_management>\\n\";\n        $strResult .= \"      <power_draw>\" . handleOutput(nvmlDeviceGetPowerUsage($handle), scale=>(1 / 1000), postfix=>' W', format=>'%.2f') . \"</power_draw>\\n\";\n        $strResult .= \"      <power_limit>\" . handleOutput(nvmlDeviceGetPowerManagementLimit($handle), scale=>(1 / 1000), postfix=>' W', format=>'%.2f') . \"</power_limit>\\n\";\n        $strResult .= \"      <default_power_limit>\" . handleOutput(nvmlDeviceGetPowerManagementDefaultLimit($handle), scale=>(1 / 1000), postfix=>' W', format=>'%.2f') . \"</default_power_limit>\\n\";\n        \n        my $minPower;\n        my $maxPower;\n        ($ret, $minPower, $maxPower) = nvmlDeviceGetPowerManagementLimitConstraints($handle);\n        $strResult .= \"      <min_power_limit>\" . handleOutput($ret, $minPower, scale=>(1 / 1000), postfix=>' W', format=>'%.2f') . \"</min_power_limit>\\n\";\n        $strResult .= \"      <max_power_limit>\" . handleOutput($ret, $maxPower, scale=>(1 / 1000), postfix=>' W', format=>'%.2f') . \"</max_power_limit>\\n\";\n        $strResult .= \"    </power_readings>\\n\";\n\n        $strResult .= \"    <clocks>\\n\";\n        $strResult .= \"      <graphics_clock>\" . handleOutput(nvmlDeviceGetClockInfo($handle, $NVML_CLOCK_GRAPHICS), postfix=>' MHz') . \"</graphics_clock>\\n\";\n        $strResult .= \"      <sm_clock>\" . handleOutput(nvmlDeviceGetClockInfo($handle, $NVML_CLOCK_SM), postfix=>' MHz') . \"</sm_clock>\\n\";\n        $strResult .= \"      <mem_clock>\" . handleOutput(nvmlDeviceGetClockInfo($handle, $NVML_CLOCK_MEM), postfix=>' MHz') . \"</mem_clock>\\n\";\n        $strResult .= \"    </clocks>\\n\";\n        \n        $strResult .= \"    <applications_clocks>\\n\";\n        $strResult .= \"      <graphics_clock>\" . handleOutput(nvmlDeviceGetApplicationsClock($handle, $NVML_CLOCK_GRAPHICS), postfix=>' MHz') . \"</graphics_clock>\\n\";\n        $strResult .= \"      <mem_clock>\" . handleOutput(nvmlDeviceGetApplicationsClock($handle, $NVML_CLOCK_MEM), postfix=>' MHz') . \"</mem_clock>\\n\";\n        $strResult .= \"    </applications_clocks>\\n\";\n\n        $strResult .= \"    <max_clocks>\\n\";\n        $strResult .= \"      <graphics_clock>\" . handleOutput(nvmlDeviceGetMaxClockInfo($handle, $NVML_CLOCK_GRAPHICS), postfix=>' MHz') . \"</graphics_clock>\\n\";\n        $strResult .= \"      <sm_clock>\" . handleOutput(nvmlDeviceGetMaxClockInfo($handle, $NVML_CLOCK_SM), postfix=>' MHz') . \"</sm_clock>\\n\";\n        $strResult .= \"      <mem_clock>\" . handleOutput(nvmlDeviceGetMaxClockInfo($handle, $NVML_CLOCK_MEM), postfix=>' MHz') . \"</mem_clock>\\n\";\n        $strResult .= \"    </max_clocks>\\n\";\n        \n        my $memClocks;\n        ($ret, $memClocks) = nvmlDeviceGetSupportedMemoryClocks($handle);\n\n        if ($ret != $NVML_SUCCESS)\n        {\n            $strResult .= \"    <supported_clocks>\" . handleOutput($ret) . \"</supported_clocks>\\n\";\n        }\n        else\n        {\n            $strResult .= \"    <supported_clocks>\\n\";\n            foreach (@$memClocks)\n            {\n                my $m = $_;\n                my $graphicsClocks;\n\n                $strResult .= \"      <supported_mem_clock>\\n\";\n                $strResult .= sprintf(\"        <value>%d MHz</value>\\n\", $m);\n\n                ($ret, $graphicsClocks) = nvmlDeviceGetSupportedGraphicsClocks($handle, $m);\n                if ($ret != $NVML_SUCCESS)\n                {\n                    $strResult .= \"        <supported_graphics_clock>\" . handleOutput($ret) . \"</supported_graphics_clock>\\n\";\n                }\n                else\n                {\n                    foreach (@$graphicsClocks)\n                    {\n                        $strResult .= sprintf(\"        <supported_graphics_clock>%d MHz</supported_graphics_clock>\\n\", $_);\n                    }\n                }\n\n                $strResult .= \"      </supported_mem_clock>\\n\";\n            }\n            $strResult .= \"    </supported_clocks>\\n\";\n        }\n        \n        my $procs;\n        ($ret, $procs) = nvmlDeviceGetComputeRunningProcesses($handle);\n\n        if ($ret != $NVML_SUCCESS)\n        {\n            $strResult .= \"    <compute_processes>\" . handleOutput($ret) . \"</compute_processes>\\n\";\n        }\n        else\n        {\n            $strResult .= \"    <compute_processes>\\n\";\n            foreach (@$procs)\n            {\n                my $p = $_;\n                my $name;\n                \n                ($ret, $name) = nvmlSystemGetProcessName($p->{'pid'});\n                if ($ret == $NVML_ERROR_NOT_FOUND)\n                {\n                    next;\n                }\n                elsif ($ret != $NVML_SUCCESS)\n                {\n                    $name = handleError($ret);\n                }\n                \n                $strResult .= \"    <process_info>\\n\";\n                $strResult .= \"      <pid>\" . $p->{'pid'} . \"</pid>\\n\";\n                $strResult .= \"      <process_name>\" . $name . \"</process_name>\\n\";\n                $strResult .= \"      <used_memory>\";\n                if ($p->{'usedGpuMemory'} == undef)\n                {\n                    $strResult .= 'N\\A';\n                }\n                else\n                {\n                    $strResult .= ($p->{'usedGpuMemory'} / 1024 / 1024) . \" MB\";\n                }\n                $strResult .= \"</used_memory>\\n\";\n                $strResult .= \"    </process_info>\\n\";\n            }\n            $strResult .= \"    </compute_processes>\\n\";\n        }\n        \n        $strResult .= \"  </gpu>\\n\";\n        $strResult .= \"\\n\";\n    }\n\n    $strResult .= \"</nvidia_smi_log>\\n\";\n    \n    nvmlShutdown();\n    \n    return $strResult;\n}",
      "file" : "/var/tmp/arv_SEEzTw/nvidia-ml/lib/nvidia/smi.pm",
      "package" : "nvidia::smi"
   }
]
