[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class Tie::MooseObject {\n    use MooseX::Has::Sugar 0.0405;\n    use MooseX::Types::Moose 0.12 qw( Bool Str HashRef CodeRef Object );\n    use Moose::Util::TypeConstraints 1.03 qw( enum );\n    use List::Util 1.23 qw( first );\n    use Carp qw( croak );\n\n\n    has '_reader' => ( isa => HashRef[CodeRef], ro, lazy_build );\n    has '_writer' => ( isa => HashRef[CodeRef], ro, lazy_build );\n    has '_predicate' => ( isa => HashRef[CodeRef], ro, lazy_build );\n\n\n    has 'is' => ( isa => enum( [ qw(ro rw) ] ), default => 'ro', rw );\n\n\n    has 'write_loop' => ( isa => Bool, default => 0, rw );\n\n\n    has 'object' => ( isa => Object, ro, required );\n\n\n    method BUILD {\n        $self->TIEHASH;\n    }\n\n    method TIEHASH(ClassName|Object $self: @args )  {\n        $self = $self->new( @args )\n            unless ref $self;\n        return $self;\n    }\n\n    method _build__reader() {\n        return $self->_build_rw( 'read' );\n    }\n\n    method _build__writer() {\n        return $self->_build_rw( 'write' );\n    }\n\n    method _build__predicate() {\n        my $object = $self->object;\n        my $meta = Class::MOP::Class->initialize( ref $object );\n        my ( %predicate );\n        for ( $meta->get_method_list ) {\n            my $method = $meta->get_method( $_ );\n            next unless $method->can( 'associated_attribute' );\n            my $attr = $method->associated_attribute;\n            my ( $predicate ) = ref( $attr->predicate ) ? %{ $attr->predicate } : $attr->predicate;\n            if ( $predicate and $method->name eq $predicate ) {\n                $predicate{ $predicate } = $method->body;\n            }\n        }\n        return \\%predicate;\n    }\n\n    method _build_rw( Str $type ) {\n        my ( $has, $get ) = $type eq 'read'\n            ? qw( has_read_method get_read_method )\n            : qw( has_write_method get_write_method );\n        my $meta = Class::MOP::Class->initialize( ref $self->object );\n        my %return;\n        for ( $meta->get_method_list ) {\n            my $method = $meta->get_method( $_ );\n            next unless $method->can( 'associated_attribute' );\n            my $attr = $method->associated_attribute;\n            if ( $attr->$has() && $method->name eq $attr->$get() ) {\n                $return{ $method->name } = $method->body;\n            }\n        }\n        return \\%return;\n    }\n\n\n    method STORE( Str $key, Any $value ) {\n        croak \"Attempt to modify a readonly Moose tied hash\"\n            if $self->is eq 'ro';\n\n        if ( exists $self->_writer->{$key} ) {\n            $self->_writer->{$key}->( $self->object, $value );\n            return $value;\n        }\n        else {\n            croak \"Invalid attempt to call write method $key on $self->object for Moose tied hash\";\n        }\n    }\n\n\n    method FETCH( Str $key ) {\n        if ( exists $self->_reader->{$key} ) {\n            return $self->_reader->{$key}->( $self->object );\n        }\n        croak \"Invalid attempt to call read method $key on $self->object for Moose tied hash\";\n    }\n\n\n    method FIRSTKEY {\n        my $h = $self->_get_loop_hashref;\n        my $a = scalar keys %{ $h };\n        if ( wantarray ) {\n            my ( $k, $v ) = each %{ $h };\n            return ( $k, $v->( $self->object ) );\n        }\n        return each %{ $h };\n    }\n\n    method NEXTKEY {\n        my $h = $self->_get_loop_hashref;\n        if ( wantarray ) {\n            my ( $k, $v ) = each %{ $h };\n            return ( $k, $v->( $self->object ) );\n        }\n        return each %{ $h };\n    }\n\n\n    method SCALAR {\n        return scalar( keys( %{ $self->_get_loop_hashref } ) );\n    }\n\n\n    method EXISTS( Str $key ) {\n        return $self->_predicate->{$key}->( $self->object ) if exists $self->_predicate->{$key};\n        return exists $self->_reader->{$key} if exists $self->_reader->{$key};\n        return exists $self->_writer->{$key} if $self->is eq 'rw';\n        return;\n    }\n\n\n    method DELETE( Str $key ) {\n        croak \"$self->DELETE not implemented\";\n    }\n\n    method CLEAR  {\n        croak \"$self->CLEAR not implemented\";\n    }\n\n    method _get_loop_hashref {\n        return $self->write_loop\n            ? $self->_writer\n            : $self->_reader;\n    }\n}\n\n1",
      "file" : "/var/tmp/arv_LCFNC4/Tie-MooseObject-0.0001/lib/Tie/MooseObject.pm",
      "package" : "Tie::MooseObject"
   }
]
