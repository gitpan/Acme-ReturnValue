[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub at_stage ($$&) {\n\tmy $self = shift;\n\tmy ($this_stage, $code) = @_;\n\n\tcroak(\"undefined stage\") unless defined $this_stage;\n\n\treturn unless $self->{'initialised'};\n\tif (my $stage = $self->stage()) {\n\t\treturn unless defined $this_stage && $this_stage eq $stage;\n\t} else {\n\t\t$self->next_stage($this_stage);\n\t}\n\n\tTRACE(sprintf'Running stage:%s for job %s', $this_stage, $self->id);\n\n\twhile (1) {\n\t\tlast if ( $self->is_done() || $this_stage ne $self->stage() );\n\t\tmy $iterate = $self->{'iterations'};\n\t\tlast if $iterate && $self->{'this_iteration'} >= $iterate;\n\t\t$self->{'this_iteration'}++;\n\t\t$self->token()->{count}++;\n\n\t\teval {$self->return_value($code->($self))}; #Trap any exceptions\n\t\tif (my $error = $@) {\n\t\t\t$self->abort($error); #Record error message\n\t\t\tdie $error; #Re-throw exception\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nsub at_end ($&) {\n\tmy $self = shift;\n\tmy ($code) = @_;\n\treturn unless $self->{'initialised'};\n\treturn unless $self->is_done;\n\tTRACE(sprintf 'Running at_end for job %s', $self->id);\n\n\teval {$self->return_value($code->($self))};\n\tif (my $error = $@) {\n\t\t$self->abort($error);\n\t\tdie $error;\n\t}\n\n\treturn $self->return_value;\n}\n\n\n#############################################################################\n# Private Functions\n\nsub _create_job {\n\tmy ($id, $options) = @_;\n\n\tmy $iterations = $options->{iterations};\n\t$iterations = 1 unless defined $iterations;\n\n\tmy ($fh, $token, %job);\n\tDUMP('Sub::Slice storage options', $options->{storage_options});\n\t$job{'storage_options'} = $options->{storage_options};\n\t$job{'storage_options'}->{path} ||= File::Spec::Functions::tmpdir();    \n\t$job{'iterations'} = $iterations;\n\t$job{'token'} = Sub::Slice::Token->new($id, $options->{pin_length});\n\t$job{'blob_threshold'} = $options->{auto_blob_threshold};\n\n\treturn \\%job;\n}\n\n# Log::Trace stubs\nsub TRACE {}\nsub DUMP  {}\n\n#############################################################################\n# Sub::Slice::Token\n#############################################################################\npackage Sub::Slice::Token;\n\nuse constant DEFAULT_PIN_LENGTH => 1e9;\nuse vars '$AUTOLOAD';\nuse Carp;\nuse POSIX qw(log10 ceil);\n\nsub rebless { \n\tmy ($class, $token) = @_;\n\t$class = ref $class || $class;\n\tbless $token, $class if (ref $token eq \"HASH\");\n\treturn $token;\n}\n\nsub new {\n\tmy $class = shift;\n\tmy ($id, $pin_length) = @_;\n\t$pin_length = DEFAULT_PIN_LENGTH unless($pin_length);\n\n\tmy $self = bless { \n\t\tid => $id,\n\t\testimate => 0,\n\t\tcount => 0,\n\t\tdone => 0,\n\t\tabort => \"\",\n\t\terror => \"\",\n\t\tstage => \"\",\n\t\tpin => $class->random_pin($pin_length),\n\t}, $class;\n\treturn $self;\n}\n\nsub random_pin {\n\tmy ($self, $pin_length) = @_;\n\tmy $figs = ceil(log10($pin_length));\n\treturn sprintf(\"%0${figs}d\", int(rand($pin_length))); #Fixed length random number padded with zeros\n}\n\nsub clean {\n\tmy $self = shift;\n\t$self->{$_} = \"\" for qw( abort error status );\n\treturn $self;\n}\n\nsub DESTROY {};\n\nsub AUTOLOAD {\n\tmy $self = shift;\n\t(my $name = $AUTOLOAD) =~ s/.*://;\n\tif (!exists $self->{$name}) {\n\t\tcroak(\"undefined method: $name\");\n\t} else {\n\t\treturn $self->{$name}\n\t}\n}\n\n1;\n\n\n=head1 NAME\n\nSub::Slice - split long-running tasks into manageable chunks\n\n=head1 SYNOPSIS\n\n\t# Client\n\t# Assume methods in the Server:: package are magically remoted\n\tmy $token = Server::create_token();\n\tfor(1 .. MAX_ITERATIONS) {\n\t\tServer::do_work($token);\n\t\tlast if $token->{done};\n\t}\n\n\t# Server\n\t# Imagine this is on a remote machine\n\tpackage Server;\n\tuse Sub::Slice;\n\n\tsub create_token {\n\t\t# create a new job:\n\t\tmy $job = new Sub::Slice(\n\t\t\tbackend         => 'Filesystem',\n\t\t\tstorage_options => {\n\t\t\t\tpath  => '/var/tmp/myproject/',\n\t\t\t}\n\t\t);\n\t\treturn $job->token;\n\t}\n\n\tsub do_work {\n\t\t# loading an existing job:\n\t\tmy $job = new Sub::Slice(\n\t\t\ttoken           => $token\n\t\t\tbackend         => 'Filesystem',\n\t\t\tstorage_options => {\n\t\t\t\tpath  => '/var/tmp/myproject/',\n\t\t\t}\n\t\t);\n\n\t\tat_start $job\n\t\t\tsub {\n\t\t\t\t$job->store('foo', '1');\n\t\t\t\t$job->store('bar', { abc = > 'def' });\n\t\t\t\t# store data, initialise\n\t\t\t\t$job->set_estimate(10); # estimate number of steps\n\t\t\t\treturn ( $job->fetch('foo') );\n\t\t\t};\n\n\t\tmy $foo = $job->fetch('foo');\n\n\t\tat_stage $job \"stage_one\",\n\t\t\tsub {\n\t\t\t\tmy $bar = $job->fetch('bar');\n\t\t\t\t# do stuff\n\t\t\t\t$job->next_stage('stage_two') if $some_condition;\n\t\t\t};\n\n\t\tat_stage $job \"stage_two\",\n\t\t\tsub {\n\t\t\t\t# ...do more stuff...\n\t\t\t\t# mark job as ready to be deleted\n\t\t\t\t$job->done() if $job->count() == $job->estimate();\n\t\t\t};\n\n\t\treturn $job->return_value(); #Pass back any return value from coderefs\n\t}\n\n=head1 DESCRIPTION\n\nSub::Slice breaks up a long process into smaller chunks that can be executed\none at a time over a stateless protocol such as HTTP/SOAP so that progress may\nbe reported.  This means that the client can display progress or cancel the\noperation part-way through.\n\nIt works by the client requesting a token from the server, and passing the\ntoken back to the server on each iteration.  The token passed to the client\ncontains status information which the client can use to determine if the job\nhas completed/failed and to display status/error messages.\n\nWithin the routine called on each iteration, the server defines a set of\ncoderefs, one of which will be called for a given iteration.  In addition the\nserver may define coderefs to be called at the start and end of the job.  The\nserver may provide the client with an estimate of the number of iterations the\njob is likely to take.\n\nIt is possible to balance performance/usability by modifying the number of\niterations that will be executed before returning progress to the client.\n\n=head1 METHODS\n\n=over 4\n\n=item new( %options )\n\nCreate a new job object. Valid options are:\n\n=over 4\n\n=item token\n\nA token for an existing job (optional)\n\n=item iterations\n\nThe number of chunks to execute before saving the state and returning. Defaults to '1'.\nThis value may be overridden later on by setting the value in the token.\nSet to 0 for unlimited.\n\n=item backend\n\nThe storage backend.\nThis should either be a fully qualified package name or if no namespace is included it's assumed to be in the \nSub::Slice::Backend namespace (e.g. Database would be interpreted as Sub::Slice::Backend::Database).\nDefaults to Sub::Slice::Backend::Filesystem.\n\n",
      "file" : "/var/tmp/arv_A015vL/Sub-Slice-1.048/lib/Sub/Slice.pm",
      "package" : "Sub::Slice"
   }
]
