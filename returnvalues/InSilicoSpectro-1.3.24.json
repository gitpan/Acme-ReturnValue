[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub print\n{\n  my ($this, $out) = @_;\n\n  my $fdOut = defined($out) ? (new SelectSaver(InSilicoSpectro::Utils::io->getFD($out) || croak(\"cannot open [$out]: $!\"))) : \\*STDOUT;\n  print $fdOut $this->toString(), \"\\n\";\n  print $fdOut \"\".(InSilicoSpectro::InSilico::MassCalculator::modifToString($this->modif())).\"\\n\" if (defined($this->modif()));\n  print $fdOut $this->nmc(), \" missed cleavage(s)\\n\" if (defined($this->nmc()));\n  print $fdOut \"Starts at \", $this->start(), \"\\n\" if (defined($this->start()));\n  print $fdOut \"Ends at \", $this->end(), \"\\n\" if (defined($this->end()));\n  print $fdOut \"C-terminal peptide\\n\" if ($this->cTerm());\n  print $fdOut \"N-terminal peptide\\n\" if ($this->nTerm());\n  print $fdOut \"Enzymatic: \", $this->enzymatic(), \"\\n\" if ($this->enzymatic());\n  my $massType = InSilicoSpectro::InSilico::MassCalculator::getMassType();\n  InSilicoSpectro::InSilico::MassCalculator::setMassType(0);\n  print $fdOut \"Monoisotopic mass=\", $this->getMass();\n  InSilicoSpectro::InSilico::MassCalculator::setMassType(1);\n  print $fdOut \" Da, average mass=\", $this->getMass(), \" Da\\n\";\n  InSilicoSpectro::InSilico::MassCalculator::setMassType($massType);\n}",
      "file" : "/var/tmp/arv_u4r2Lc/InSilicoSpectro-1.3.24/lib/InSilicoSpectro/InSilico/Peptide.pm",
      "package" : "InSilicoSpectro::InSilico::Peptide"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub twig_addEnzyme{\n  my ($twig, $el)=@_;\n\n  my $ce=InSilicoSpectro::InSilico::CleavEnzyme->new();\n\n  $ce->name($el->atts->{name} || $el->first_child('name')->text); \n  if (my $gel=$el->first_child('CTermGain')){\n    $ce->CTermGain($gel->text);\n  }else{\n    $ce->CTermGain('OH');\n  }\n  if (my $gel=$el->first_child('NTermGain')){\n    $ce->NTermGain($gel->text);\n  }else{\n    $ce->NTermGain('H');\n  }\n  if (my $mel=$el->first_child('CTermModif')){\n    $ce->CTermModif($mel->text);\n  }\n  if (my $mel=$el->first_child('NTermModif')){\n    $ce->NTermModif($mel->text);\n  }\n  if(my $tel=$el->first_child('cleavSite')){\n    my $re=\"(?<=\".$tel->text.\")\";\n    $ce->{cleavSite}=$tel->text;\n    if($tel=$el->first_child('notBefore')){\n      $re.=\"(?=\".$tel->text.\")\";\n      $ce->{adjacentSite}=$tel->text;\n    }else{\n      $ce->{adjacentSite}='.';\n    }\n    $ce->regexp($re);\n    $ce->terminus('C');\n  }elsif($tel=$el->first_child('site')){\n    my $t=$tel->first_child('terminus')->text;\n    $ce->terminus($t);\n    my $site=$tel->first_child('cleavSite')->text || '.';\n    my $adj=$tel->first_child('adjacentSite')->text || '.';\n    my $adjre=($adj eq '.')?'.':\"[$adj]\";\n    my $sitere=($site eq '.')?'.':\"[$site]\";\n    $ce->regexp(($t eq 'C')?(\"(?<=$sitere)(?=$adjre)\"):(\"(?<=$adjre)(?=$sitere)\"));\n  }elsif($tel=$el->first_child('siteRegexp')){\n    $ce->{regexpStr}=$tel->text;\n    $ce->regexp($ce->{regexpStr});\n  }else{\n    croak \"no way of reading CleavEnzyme from xml node\\n\".$el->print.\"\\n\";\n  }\n}",
      "file" : "/var/tmp/arv_u4r2Lc/InSilicoSpectro-1.3.24/lib/InSilicoSpectro/InSilico/CleavEnzyme.pm",
      "package" : "InSilicoSpectro::InSilico::CleavEnzyme"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub new\n{\n  my $pkg = shift;\n\n  my $iis;\n  my $class = ref($pkg) || $pkg;\n\n  if (ref($_[0]) && $_[0]->isa('InSilicoSpectro::InSilico::IonSeries')){\n    $iis = new InSilicoSpectro::InSilico::IonSeries(@_);\n    bless($iis, $class);\n  }\n  elsif (ref($_[0]) && $_[0]->isa('InSilicoSpectro::InSilico::InternIonSeries')){\n    $iis = {};\n    %$iis = %{$_[0]};\n    bless($iis, $class);\n  }\n  else{\n    $iis = new InSilicoSpectro::InSilico::IonSeries(@_);\n    bless($iis, $class);\n    if (!ref($_[0])){\n      my %h = @_;\n      foreach (keys(%h)){\n\t$iis->$_($h{$_}) if ($visibleAttr{$_});\n      }\n    }\n  }\n  return $iis;\n\n}",
      "file" : "/var/tmp/arv_u4r2Lc/InSilicoSpectro-1.3.24/lib/InSilicoSpectro/InSilico/InternIonSeries.pm",
      "package" : "InSilicoSpectro::InSilico::InternIonSeries"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub getUnmatchedPeptides\n{\n  my ($this, $tol, $minTol) = @_;\n\n  return undef if (!defined($this->match()) || !defined($this->digestResult()) || !defined($this->expSpectrum()));\n\n  $minTol = $minTol || 0.1;\n  my $massIndex = $this->expSpectrum()->peakDescriptor()->getFieldIndex('mass');\n\n  my @unmatched;\n  my @match = @{$this->match()};\n  for (my $i = 0; $i < @match; $i++){\n    if (!$match[$i]){\n      push(@unmatched, $this->{digestResult}[$i]);\n    }\n    elsif (defined($tol)){\n      my $theoMass = $this->{digestResult}[$i]->getMass();\n      my $expMass = $match[$i][$massIndex];\n      if ((abs($theoMass-$expMass)/($theoMass+$expMass)*2e+6 > $tol) && (abs($theoMass-$expMass) > $minTol)){\n\tpush(@unmatched, $this->{digestResult}[$i]);\n      }\n    }\n  }\n  @unmatched = sort {$a->getMass() <=> $b->getMass()} @unmatched;\n  return @unmatched;\n\n}",
      "file" : "/var/tmp/arv_u4r2Lc/InSilicoSpectro-1.3.24/lib/InSilicoSpectro/InSilico/PMFMatch.pm",
      "package" : "InSilicoSpectro::InSilico::PMFMatch"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub plotLegendOnly\n{\n  my (%h) = @_;\n  my ($fname, $fhandle, $fontChoice, $intSel, $colorScale, $format, $inCellBorder, $lineColor) = ($h{fname}, $h{fhandle}, $h{fontChoice}, $h{intSel}, $h{colorScale}, $h{format}, $h{inCellBorder}, $h{lineColor});\n\n  if (defined($format)){\n    if (($format ne 'png') && ($format ne 'xbm') && ($format ne 'gif') && ($format ne 'gdf') && ($format ne 'bmp') && ($format ne 'sgi') && ($format ne 'pcx') && ($format ne 'jpeg') && ($format ne 'tiff')){\n      croak(\"Wrong file format [$format]\");\n    }\n  }\n\n  $fontChoice = $fontChoice || 'default:Large';\n  $inCellBorder = $inCellBorder || 1;\n\n  my ($fontWidth, $fontHeight, $font, $fontName, $fontPoint, $ttHShift, $ttVShift);\n  my ($class, $size) = split(/:/, $fontChoice);\n  if ($class eq 'default'){\n    if ($size eq 'Tiny'){\n      $fontWidth = gdTinyFont->width;\n      $fontHeight = gdTinyFont->height;\n      eval '$font = gdTinyFont';\n    }\n    elsif ($size eq 'Small'){\n      $fontWidth = gdSmallFont->width;\n      $fontHeight = gdSmallFont->height;\n      eval '$font = gdSmallFont';\n    }\n    elsif ($size eq 'MediumBold'){\n      $fontWidth = gdMediumBoldFont->width;\n      $fontHeight = gdMediumBoldFont->height;\n      eval '$font = gdMediumBoldFont';\n    }\n    elsif ($size eq 'Large'){\n      $fontWidth = gdLargeFont->width;\n      $fontHeight = gdLargeFont->height;\n      eval '$font = gdLargeFont';\n    }\n    elsif ($size eq 'Giant'){\n      $fontWidth = gdGiantFont->width;\n      $fontHeight = gdGiantFont->height;\n      eval '$font = gdGiantFont';\n    }\n    else{\n      croak(\"Unknown size [$size] for font class [$class]\");\n    }\n  }\n  else{\n    if (-e $class){\n      $fontName = $class;\n      $fontPoint = $size;\n      my @coord = $tmpim->stringFT($tmpWhite, $fontName, $fontPoint, 0, 10, 180, 'AFGHKMPQRSWYbyz*#Â°');\n      $fontHeight = $coord[1]-$coord[7];\n      $ttHShift = 10-$coord[0];\n      $ttVShift = 180-$coord[1];\n    }\n    else{\n      croak(\"Unknown font class [$class]\");\n    }\n  }\n\n  my $cellHeight = $fontHeight+2*$inCellBorder+1;\n  $ttVShift += $cellHeight;\n  my ($legendHeight, $legendWidth, @legend, @intThres);\n\n  if (defined($colorScale)){\n    for (my $i = 0; $i < @$colorScale; $i += 8){\n      push(@intThres, $colorScale->[$i]);\n      push(@legend, $colorScale->[$i+4]);\n    }\n  }\n  elsif ($intSel eq 'order'){\n    @intThres = (0, 0.3, 0.5, 0.7, 0.9);\n    @legend = ('0 %', '30 %', '50 %', '70 %', '90 %');\n  }\n  elsif ($intSel eq 'relative'){\n    @intThres = (0, 0.1, 0.2, 0.3, 0.5);\n    @legend = ('0 %', '10 %', '20 %', '30 %', '50 %');\n  }\n  elsif ($intSel eq 'log'){\n    @intThres = (0, 4.6, 6.2, 7.6, 9.2);\n    @legend = ('1', '100', '500', '2000', '10000');\n  }\n  elsif ($intSel eq 'original'){\n    @intThres = (0, 100, 500, 2000, 10000);\n    @legend = ('0', '100', '500', '2000', '10000');\n  }\n  else{\n    croak(\"Unknown intSel value [$intSel]\");\n  }\n\n  $legendHeight = scalar(@legend)*$cellHeight+1;\n  if (defined($font)){\n    my $maxLen;\n    foreach (@legend){\n      $maxLen = length($_) if (length($_) > $maxLen);\n    }\n    $legendWidth = $maxLen*$fontWidth+2*$inCellBorder+2;\n  }\n  else{\n    my @coord;\n    foreach (@legend){\n      @coord = $tmpim->stringFT($tmpWhite, $fontName, $fontPoint, 0, 10, 180, $_);\n      if ($legendWidth < $coord[2]-$coord[0]){\n\t$legendWidth = $coord[2]-$coord[0];\n      }\n    }\n    $legendWidth += 2*$inCellBorder+2;\n  }\n\n  my $im = new GD::Image($legendWidth, $legendHeight);\n  my $white = $im->colorAllocate(255,255,255);\n  my $black = $im->colorAllocate(0,0,0);\n  my $blue= $im->colorAllocate(0,72,223);\n  my $red = $im->colorAllocate(255,16,0);\n  my $green = $im->colorAllocate(19,232,0);\n  my $yellow = $im->colorAllocate(255,255,80);\n  my $orange = $im->colorAllocate(255,180,0);\n\n  $lineColor = defined($lineColor) ? $im->colorAllocate(@$lineColor) : $black;\n\n  my (@color, @legendColor);\n  if (defined($colorScale)){\n    for (my $i = 0; $i < @$colorScale; $i += 8){\n      push(@color, $im->colorAllocate($colorScale->[$i+1], $colorScale->[$i+2], $colorScale->[$i+3]));\n      push(@legendColor, $im->colorAllocate($colorScale->[$i+5], $colorScale->[$i+6], $colorScale->[$i+7]));\n    }\n  }\n  elsif ($intSel eq 'order'){\n    @color = ($blue, $red, $orange, $yellow, $green);\n    @legendColor = ($white, $white, $black, $black, $black);\n  }\n  elsif ($intSel eq 'relative'){\n    @color = ($blue, $red, $orange, $yellow, $green);\n    @legendColor = ($white, $white, $black, $black, $black);\n  }\n  elsif ($intSel eq 'log'){\n    @color = ($blue, $red, $orange, $yellow, $green);\n    @legendColor = ($white, $white, $black, $black, $black);\n  }\n  elsif ($intSel eq 'original'){\n    @color = ($blue, $red, $orange, $yellow, $green);\n    @legendColor = ($white, $white, $black, $black, $black);\n  }\n  else{\n    croak(\"Unknown intSel value [$intSel]\");\n  }\n\n  $im->rectangle(0, 0, $legendWidth-1, $legendHeight-1, $lineColor);\n  for (my $i = 1; $i < @legend; $i++){\n    $im->line(0, $i*$cellHeight, $legendWidth-1, $i*$cellHeight, $lineColor);\n  }\n  my $n = scalar(@legend)-1;\n  my @coord;\n  for (my $i = 0; $i < @legend; $i++){\n    $im->filledRectangle(1, $i*$cellHeight+1, $legendWidth-2, ($i+1)*$cellHeight-1, $color[$n-$i]);\n    if (defined($font)){\n      $im->string($font, $legendWidth-$inCellBorder-1-length($legend[$n-$i])*$fontWidth, $i*$cellHeight+$inCellBorder+1, $legend[$n-$i], $legendColor[$n-$i]);\n    }\n    else{\n      @coord = $tmpim->stringFT($tmpWhite, $fontName, $fontPoint, 0, $inCellBorder+1+$ttHShift, $inCellBorder+1+$ttVShift, $legend[$n-$i]);\n      my $length = $coord[2]-$coord[0];\n      $im->stringFT($legendColor[$n-$i], $fontName, $fontPoint, 0, $legendWidth-$inCellBorder-2-$length+$ttHShift, $i*$cellHeight+$inCellBorder+1+$ttVShift, $legend[$n-$i]);\n    }\n  }\n\n  if (defined($format)){\n    if ($fhandle){\n      binmode $fhandle;\n      print $fhandle $im->$format;\n    }\n    else{\n      $fname =~ s/\\.$format$//;\n      open(FGD, \">$fname.$format\")|| croak(\"Cannot open file [$fname.$format]: $!\");\n      binmode FGD;\n      print FGD $im->$format;\n      close(FGD);\n    }\n  }\n  else{\n    return $im;\n  }\n\n}",
      "file" : "/var/tmp/arv_u4r2Lc/InSilicoSpectro-1.3.24/lib/InSilicoSpectro/InSilico/MSMSOutput.pm",
      "package" : "InSilicoSpectro::InSilico::MSMSOutput"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub terminus\n{\n  my ($this, $t) = @_;\n\n  if (defined($t)){\n    $t = uc($t);\n    if (($t eq 'C') || ($t eq 'N')){\n      $this->{terminus} = $t;\n    }\n    else{\n      croak(\"Illegal value for terminus [$t]\");\n    }\n  }\n  return $this->{terminus};\n\n}",
      "file" : "/var/tmp/arv_u4r2Lc/InSilicoSpectro-1.3.24/lib/InSilicoSpectro/InSilico/TermIonSeries.pm",
      "package" : "InSilicoSpectro::InSilico::TermIonSeries"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub twigAddModRes\n{\n  my ($twig, $el) = @_;\n\n  my $name = $el->atts->{id} || $el->atts->{name};\n  my $rel = $el->first_child('residues') or return;\n  my $residues = $rel->atts->{aa};\n  my $residuesAfter = $rel->atts->{aaAfter} || '.';\n  my $terminus = defined($rel->atts->{nterm}) ? 'N' : (defined($rel->atts->{cterm}) ? 'C' : '-');\n  my $del = $el->first_child('delta');\n  my $mono = $del->atts->{monoisotopic};\n  my $avg = $del->atts->{average};\n  setModif($name, $mono, $avg, $residues, $residuesAfter, $terminus);\n\n}",
      "file" : "/var/tmp/arv_u4r2Lc/InSilicoSpectro-1.3.24/lib/InSilicoSpectro/InSilico/MassCalculator.pm",
      "package" : "InSilicoSpectro::InSilico::MassCalculator"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub getInternIons\n{\n  my $this = shift;\n\n  my $tol = $this->tol();\n  my $minTol = $this->minTol() || 0.2;\n  my @internIons;\n  my %spectrum = %{$this->{theoSpectrum}};\n  my $massIndex = $spectrum{intensityIndex};\n  foreach my $frag (keys(%{$spectrum{mass}{intern}})){\n    my $ionType =  $spectrum{ionType}{$frag}[0];\n    my (@masses, @names, @matches);\n    foreach my $aa (sort keys(%{$spectrum{mass}{intern}{$frag}})){\n      push(@names, $aa);\n      push(@masses, $spectrum{mass}{intern}{$frag}{$aa});\n      if (defined($spectrum{match}{intern}{$frag}{$aa})){\n\tif (defined($tol)){\n\t  my $theoMass = $spectrum{mass}{intern}{$frag}{$aa};\n\t  my $expMass = $spectrum{match}{intern}{$frag}{$aa}[$massIndex];\n\t  my $error = $expMass-$theoMass;\n\t  if ((abs($error)/($theoMass+$expMass)*2e+6 <= $tol) || (abs($error) <= $minTol)){\n\t    push(@matches, $spectrum{match}{intern}{$frag}{$aa});\n\t  }\n\t  else{\n\t    push(@matches, undef);\n\t  }\n\t}\n\telse{\n\t  push(@matches, $spectrum{match}{intern}{$frag}{$aa});\n\t}\n      }\n      else{\n\tpush(@matches, undef);\n      }\n    }\n    push(@internIons, new InSilicoSpectro::InSilico::InternIonSeries(ionType=>$ionType, charge=>1, names=>[@names], masses=>[@masses], massType=>$this->massType(), massIndex=>$massIndex, intensityIndex=>$spectrum{intensityIndex}, matches=>(defined($spectrum{match}) ? [@matches] : undef)));\n  }\n\n  @internIons = sort {InSilicoSpectro::InSilico::MSMSOutput::cmpFragTypes($a->ionType(), $b->ionType())} @internIons;\n  return @internIons;\n\n}",
      "file" : "/var/tmp/arv_u4r2Lc/InSilicoSpectro-1.3.24/lib/InSilicoSpectro/InSilico/MSMSTheoSpectrum.pm",
      "package" : "InSilicoSpectro::InSilico::MSMSTheoSpectrum"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub toString\n{\n  my $this = shift;\n\n  my $string = $this->ionType().\": \";\n  my @names = @{$this->names()};\n  my @masses = @{$this->masses()};\n  my @matches = defined($this->matches()) ? @{$this->matches()} : ();\n  for (my $i = 0; $i < @masses; $i++){\n    if (defined($names[$i])){\n      $string .= $names[$i].':'.$masses[$i];\n      if (defined($matches[$i])){\n\t$string .= \"-match($matches[$i][0])\";\n      }\n      $string .= \"\\t\";\n    }\n  }\n  $string .= '(z='.$this->charge().', '.($this->massType()==0 ? 'mono' : 'avg').')';\n  return $string;\n\n}",
      "file" : "/var/tmp/arv_u4r2Lc/InSilicoSpectro-1.3.24/lib/InSilicoSpectro/InSilico/IonSeries.pm",
      "package" : "InSilicoSpectro::InSilico::IonSeries"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub getMass\n{\n  my $this = shift;\n\n  return $this->{mass} if (defined($this->{mass}) && ($this->{massType} == InSilicoSpectro::InSilico::MassCalculator::getMassType()));\n\n  return undef if (!defined($this->{sequence}));\n\n  my @list;\n  foreach (@{$this->{modif}}){\n    if (length($_) > 0){\n      return undef if (index($_, '(*)') != -1);\n      push(@list, $_);\n    }\n  }\n\n  my $mass = InSilicoSpectro::InSilico::MassCalculator::getPeptideMass(pept=>$this->{sequence}, modif=>\\@list);\n;\n  $this->{mass} = $mass;\n  $this->{massType} = InSilicoSpectro::InSilico::MassCalculator::getMassType();\n  return $mass;\n\n}",
      "file" : "/var/tmp/arv_u4r2Lc/InSilicoSpectro-1.3.24/lib/InSilicoSpectro/InSilico/AASequence.pm",
      "package" : "InSilicoSpectro::InSilico::AASequence"
   }
]
