[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "AUTOLOAD {\n    my $sub = $AUTOLOAD;\n    autoload_sub($sub);\n    goto &$sub;\n}\n\nsub autoload_sub {\n    my $sub = shift;\n\n    my $filename = AutoLoader::find_filename( $sub );\n\n    my $save = $@;\n    local $!; \n    eval { local $SIG{__DIE__}; require $filename };\n    if ($@) {\n\tif (substr($sub,-9) eq '::DESTROY') {\n\t    no strict 'refs';\n\t    *$sub = sub {};\n\t    $@ = undef;\n\t} elsif ($@ =~ /^Can't locate/) {\n\t    if ($filename =~ s/(\\w{12,})\\.al$/substr($1,0,11).\".al\"/e){\n\t\teval { local $SIG{__DIE__}; require $filename };\n\t    }\n\t}\n\tif ($@){\n\t    $@ =~ s/ at .*\\n//;\n\t    my $error = $@;\n\t    require Carp;\n\t    Carp::croak($error);\n\t}\n    }\n    $@ = $save;\n\n    return 1;\n}\n\nsub find_filename {\n    my $sub = shift;\n    my $filename;\n    {\n\n\tmy ($pkg,$func) = ($sub =~ /(.*)::([^:]+)$/);\n\t$pkg =~ s#::#/#g;\n\tif (defined($filename = $INC{\"$pkg.pm\"})) {\n\t    if ($is_macos) {\n\t\t$pkg =~ tr#/#:#;\n\t\t$filename = undef\n\t\t  unless $filename =~ s#^(.*)$pkg\\.pm\\z#$1auto:$pkg:$func.al#s;\n\t    } else {\n\t\t$filename = undef\n\t\t  unless $filename =~ s#^(.*)$pkg\\.pm\\z#$1auto/$pkg/$func.al#s;\n\t    }\n\n\n\t    if (defined $filename and -r $filename) {\n\t\tunless ($filename =~ m|^/|s) {\n\t\t    if ($is_dosish) {\n\t\t\tunless ($filename =~ m{^([a-z]:)?[\\\\/]}is) {\n\t\t\t    if ($^O ne 'NetWare') {\n\t\t\t\t$filename = \"./$filename\";\n\t\t\t    } else {\n\t\t\t\t$filename = \"$filename\";\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    elsif ($is_epoc) {\n\t\t\tunless ($filename =~ m{^([a-z?]:)?[\\\\/]}is) {\n\t\t\t     $filename = \"./$filename\";\n\t\t\t}\n\t\t    }\n\t\t    elsif ($is_vms) {\n\t\t\t$filename = \"./$filename\";\n\t\t    }\n\t\t    elsif (!$is_macos) {\n\t\t\t$filename = \"./$filename\";\n\t\t    }\n\t\t}\n\t    }\n\t    else {\n\t\t$filename = undef;\n\t    }\n\t}\n\tunless (defined $filename) {\n\t    $filename = \"auto/$sub.al\";\n\t    $filename =~ s#::#/#g;\n\t}\n    }\n    return $filename;\n}\n\nsub import {\n    my $pkg = shift;\n    my $callpkg = caller;\n\n\n    if ($pkg eq 'AutoLoader') {\n\tif ( @_ and $_[0] =~ /^&?AUTOLOAD$/ ) {\n\t    no strict 'refs';\n\t    *{ $callpkg . '::AUTOLOAD' } = \\&AUTOLOAD;\n\t}\n    }\n\n\n    (my $calldir = $callpkg) =~ s#::#/#g;\n    my $path = $INC{$calldir . '.pm'};\n    if (defined($path)) {\n\tmy $replaced_okay;\n\tif ($is_macos) {\n\t    (my $malldir = $calldir) =~ tr#/#:#;\n\t    $replaced_okay = ($path =~ s#^(.*)$malldir\\.pm\\z#$1auto:$malldir:autosplit.ix#s);\n\t} else {\n\t    $replaced_okay = ($path =~ s#^(.*)$calldir\\.pm\\z#$1auto/$calldir/autosplit.ix#);\n\t}\n\n\teval { require $path; } if $replaced_okay;\n\tif (!$replaced_okay or $@) {\n\t    $path =\"auto/$calldir/autosplit.ix\";\n\t    eval { require $path; };\n\t}\n\tif ($@) {\n\t    my $error = $@;\n\t    require Carp;\n\t    Carp::carp($error);\n\t}\n    } \n}\n\nsub unimport {\n    my $callpkg = caller;\n\n    no strict 'refs';\n\n    for my $exported (qw( AUTOLOAD )) {\n\tmy $symname = $callpkg . '::' . $exported;\n\tundef *{ $symname } if \\&{ $symname } == \\&{ $exported };\n\t*{ $symname } = \\&{ $symname };\n    }\n}\n\n1",
      "file" : "/var/tmp/arv_qlLUXK/AutoLoader-5.73/lib/AutoLoader.pm",
      "package" : "AutoLoader"
   }
]
