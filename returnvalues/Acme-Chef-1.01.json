[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub liquify {\n   my $self = shift;\n\n   $self->{type} = 'liquid';\n\n   return $self;\n}",
      "file" : "/var/tmp/arv_PWvo88/Acme-Chef-1.01/lib/Acme/Chef/Ingredient.pm",
      "package" : "Acme::Chef::Ingredient"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub _fisher_yates_shuffle {\n    my $array = shift;\n    my $i;\n    for ($i = @$array; --$i; ) {\n        my $j = int rand ($i+1);\n        @$array[$i,$j] = @$array[$j,$i];\n    }\n}",
      "file" : "/var/tmp/arv_PWvo88/Acme-Chef-1.01/lib/Acme/Chef/Container.pm",
      "package" : "Acme::Chef::Container"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub compile {\n   my $self = shift;\n\n   return 0 if $self->{compiled};\n\n   my @ingredients = split /\\n/, $self->{ingredients};\n\n   shift @ingredients; \n\n   @ingredients or croak \"Failed compiling recipe. No ingredients specified.\";\n\n   my %ingredients;\n   my $ingredient_no = 0;\n\n   foreach (@ingredients) {\n      $ingredient_no++;\n\n      my $value;\n      if (s/^[ ]*(\\d+)[ ]//) {\n         $value = $1;\n      } else {\n         $value = undef;\n      }\n\n      my $measure_type = '';\n      foreach my $type ( keys %Acme::Chef::Ingredient::MeasureTypes ) {\n         if ( s/^\\Q$type\\E[ ]// ) {\n            $measure_type = $type;\n            last;\n         }\n      }\n\n      my $measure = '';\n      foreach my $meas ( keys %Acme::Chef::Ingredient::Measures ) {\n         next if $meas eq '';\n\n         if ( s/^\\Q$meas\\E[ ]// ) {\n            $measure = $meas;\n            last;\n         }\n      }\n\n      /[ ]*([\\-\\w][\\- \\w]*)[ ]*$/\n        or croak \"Invalid ingredient specification (ingredient no. $ingredient_no, name).\";\n\n      my $ingredient_name = $1;\n\n      my $ingredient = Acme::Chef::Ingredient->new(\n        name         => $ingredient_name,\n        value        => $value,\n        measure      => $measure,\n        measure_type => $measure_type,\n      );\n\n      $ingredients{$ingredient_name} = $ingredient;\n   }\n\n   $self->{ingredients} = \\%ingredients;\n\n   $self->{method} =~ s/\\s+/ /g;\n\n   my @steps = split /\\s*\\.\\s*/, $self->{method};\n\n   shift @steps; \n\n   my $step_no = 0;\n   foreach my $step (@steps) {\n      $step_no++;\n\n      foreach my $grammar (@GrammarOrder) {\n         my @res = $Grammars{$grammar}->($self, $step);\n         @res or next;\n\n         if ( $res[0] eq 'verb' ) {\n            my $verb = $res[1];\n            my $ingr = $res[2];\n\n            $self->{loops}->{$verb} = {start => ($step_no-1), test => $ingr};\n         } elsif ( $res[0] eq 'until_verbed' ) {\n            my $verb = $res[1];\n            exists $self->{loops}->{$verb}\n              or croak \"Loop end without loop start '$verb'.\";\n\n            $self->{loops}->{$verb}->{end} = $step_no - 1;\n         }\n\n         $step = [@res];\n         last;\n      }\n\n      croak \"Invalid method step (step no. $step_no): '$step'.\"\n        if not ref $step eq 'ARRAY';\n   }\n\n   if ( grep { not exists $self->{loops}{$_}{end} } keys %{$self->{loops}} ) {\n      croak \"Not all loop starting points have matching ends.\";\n   }\n\n   $self->{method} = \\@steps;\n\n   $self->{compiled} = 1;\n\n   return $self;\n}",
      "file" : "/var/tmp/arv_PWvo88/Acme-Chef-1.01/lib/Acme/Chef/Recipe.pm",
      "package" : "Acme::Chef::Recipe"
   }
]
