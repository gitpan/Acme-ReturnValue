[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "DESTROY\n  {\n   my $self=shift;\n   SDL::sdlpl::sdl_fini();\n  }\n\nsub init_mode\n  {\n   my $self=shift;\n   $self->video_mode($self->{width},\n\t\t     $self->{height},\n\t\t     $self->{depth},\n\t\t     $self->{flags},\n\t\t    );\n  }\n\n\n\n\nsub title \n  {\n   my $self = shift;\n   my $title = shift;\n   my $icon_title  = shift || $title;\n   \n   SDL::sdlpl::sdl_wm_set_caption($title,$icon_title) if $title;\n   return SDL::sdlpl::sdl_wm_get_caption();\n}\n\nsub icon\n  {\n   my $self=shift;\n   my $icon_file=shift;\n   if ($icon_file and -e $icon_file)\n     {\n      my $icon = new SDL::Surface( -name => $icon_file);\n      SDL::sdlpl::sdl_wm_set_icon($icon->{-surface});\t   \n     }    \n  }\n\n\nsub delay {\n\tmy $self = shift;\n\tmy $delay = shift;\n\tSDL::sdlpl::sdl_delay($delay);\n}\n\n\nsub ticks {\n\treturn SDL::sdlpl::sdl_get_ticks();\n}\n\n\t\nsub error {\n\treturn SDL::sdlpl::sdl_get_error();\n}\n\nsub clear_error {\n\treturn SDL::sdlpl::sdl_clear_error();\n}\n\n\nsub prep_keystate\n  {\n   SDL::sdlpl::sdl_prep_key_state();\n  }\n\nsub keystate\n  {\n   my $self=shift;\n   my $k=shift;\n   SDL::sdlpl::sdl_key_state($k);\n  }\n\n\n\nsub warp {\n\tmy $self = shift;\n\tmy $x = shift;\n\tmy $y = shift;\n\tSDL::sdlpl::sdl_warp_mouse($x,$y);\n}\n\nsub SDL_TEXTWIDTH {\n carp \"this is deprecated, use 'SDL::Font::text_width' instead \";\n return SDL::sdlpl::sdl_sfont_text_width(join('',@_));\n}\n\n\nsub toggle_fullscreen\n  {\n   my $self=shift;\n   SDL::sdlpl::sdl_wm_toggle_fullscreen($self->{-surface});\n  }\n\nsub video_mode_ok\n  {\n   shift @_ if(ref($_[0]) eq  __PACKAGE__); \n   my ($width,$height,$bpp,$flags)= @_;\n\n   return SDL::sdlpl::sdl_video_mode_ok($width,$height,$bpp,$flags);\n  }\n\nsub video_mode\n  {\n   my $self=shift;\n   my ($width,$height,$bpp,$flags)= @_;\n\n   SDL::sdlpl::sdl_free_surface($self->{-surface}) if exists($self->{-surface});\n   $self->{-surface} =SDL::sdlpl::sdl_set_video_mode($width,$height,$bpp,$flags) or die SDL::sdlpl::sdl_get_error();\n\n   return;\n  }\n\nsub compile_info\n  {\n   return (SDL::sdlpl::sdl_compiled_version_minor,\n\t   SDL::sdlpl::sdl_compiled_version_major,\n\t   SDL::sdlpl::sdl_compiled_version_patch,\n\t  )\n  }\n\nsub link_info\n  {\n   return (SDL::sdlpl::sdl_linked_version_minor,\n\t   SDL::sdlpl::sdl_linked_version_major,\n\t   SDL::sdlpl::sdl_linked_version_patch,\n\t  );\n  }\n\nsub endianess\n  {\n   return SDL::sdlpl::sdl_endianess() ? \"big\": \"little\";\n\t   \n  }\n\n1",
      "file" : "/var/tmp/arv_G7sNZc/SDL-sdlpl-1.08/lib/SDL/App.pm",
      "package" : "SDL::App"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "DESTROY\n  {\n   my $self=shift;\n  }\n\n\n\n\nsub add_startup_parameter\n  {\n   my $self=shift;\n   my %param_info=@_;\n\n   my $name    =$param_info{NAME};\n   my $type    =$param_info{TYPE};\n   my $var_ref =$param_info{VAR};\n   my $help_str=$param_info{HELP};\n\n   $self->{START_UP_PARAMS}{\"$name$type\"}=$var_ref;\n   $self->{START_UP_HELP}{$name}=$help_str;\n\n  }\n\n\n\nsub add_runtime_help\n  {\n   my $self=shift;\n   my %param_info=@_;\n\n   my $key     =$param_info{KEY};\n   my $help_str=$param_info{HELP};\n\n   $self->{RUNTIME_HELP}{$key}=$help_str;\n\n  }\n\n\n\n\nsub register_handler\n  {\n   my $self=shift;\n   my %handlers = @_;\n\n   foreach my $handler (keys %handlers)\n     {\n      my $sub_ref=$handlers{$handler};\n      my $ref_type=ref($sub_ref) || \"NOT_A_REF\";\n\n      if ($ref_type eq \"CODE\")\n\t{\n\t $self->{HANDLER}{$handler}=$sub_ref;\t \n\t}\n      else\n\t{\n\t croak \"register_handler was not passed a valid subroutine ref (passed a '$ref_type' for '$handler')\";\n\t}\n     }   \n  }\n\n\n\nsub run\n  {        \n   my $self=shift;\n   my $once=shift || 0;\n   my $done_once=$self->{DONE_ONCE};\n\n   $self->_get_startup_options() unless $done_once;   \n\n   my $app  =$self->{SDL_APP};\n   my $gl   =$self->{SDL_GL};\n   my $event=$self->{SDL_EVENT};\n\n   $self->_init() unless $done_once;\n   \n   $self->_reshape($app, $gl) unless $done_once;\n   \n   my $continue = SDL_GL_APP_CONTINUE;\n   while ( ($continue=$self->_events($event)) != SDL_GL_APP_QUIT ) \n     {\n      $self->_draw($app, $gl);\n      $self->_idle($app, $gl);\n      last if $once;\n    }\n   \n   return $continue;\n  }\n\n\nsub pump\n  {\n   my $self=shift;\n   my $continue=$self->run(1);\n   $self->{DONE_ONCE}=1;\n   return $continue;\n  }\n\nsub pointer_show\n  {\n   my $self=shift;\n   my $val=shift || 0;\n   print \"mouse $val\\n\";\n   $self->{sdl_mouse_show}=$val;\n  }\n\nsub ___mouse_off\n  {\n   my $self=shift;\n   if (exists($self->{DONE_ONCE}))\n     {\n      SDL::Cursor::show(0);         \n     } \n   else\n     {\n      carp \"SDL as not been initialised\";\n     }\n  }\n\nsub ___mouse_on\n  {\n   my $self=shift;\n   if (exists($self->{DONE_ONCE}))\n     {      \n      SDL::Cursor::show(1);   \n     } \n   else\n     {\n      carp \"SDL as not been initialised\";\n     }\n  }\n\n\nforeach my $app_attr (keys %$sdl_gl_app_defaults)\n  {\n   my $code= '\n   sub '.lc($app_attr).'\n     {\n      my $self=shift;      \n      @_ ? $self->{SDL_GL_APP}{'.$app_attr.'}=shift     \n      : $self->{SDL_GL_APP}{'.$app_attr.'};                  \n     }';\n   eval $code;  \n  }\n\n\n\nforeach my $gl_attr (keys %$sdl_gl_attr_defaults)\n  {\n   my $code= '\n  sub gl_attr_'.lc($gl_attr).'\n    {\n   my $self=shift;   \n   @_ ? $self->{SDL_GL_ATTR}{'.$gl_attr.'}=shift     \n     : $self->{SDL_GL_ATTR}{'.$gl_attr.'};            \n  }';\n    eval $code;\n }\n \n\n\n\n \nsub _get_startup_options\n  {\n   my $self=shift;\n   \n   GetOptions(\n\t      %{$self->{START_UP_PARAMS}},\n\t     ) or $self->_usage() ;\n  }\n \n \n\n\nsub _init\n  {\n   my $self=shift;\n\n   $self->video_flags(SDL_RESIZABLE | SDL_OPENGL | ($self->fullscreen?SDL_FULLSCREEN:0));\n   \n   my $app = new SDL::App ( -title  => $self->app_name,\n\t\t\t    -flags  => $self->video_flags,\n\t\t\t    -width  => $self->screen_width,\n\t\t\t    -height => $self->screen_height, \n\t\t\t    -bpp    => $self->bpp,\n\t\t\t    -postpone_init_mode => 1  \n\t\t\t  );    \n\n   my $gl    = new SDL::OpenGL;\n   \n   $gl->set_attribute( SDL_GL_RED_SIZE,     $self->gl_attr_red_size);\n   $gl->set_attribute( SDL_GL_GREEN_SIZE,   $self->gl_attr_green_size);\n   $gl->set_attribute( SDL_GL_BLUE_SIZE,    $self->gl_attr_blue_size);\n   \n   $gl->set_attribute( SDL_GL_DEPTH_SIZE,   $self->gl_attr_depth_size);\n   $gl->set_attribute( SDL_GL_DOUBLEBUFFER, $self->gl_attr_doublebuffer);\n\n   $app->init_mode();\n\n\n   if ($self->{sdl_mouse_show} ==1)\n     {\n     }\n   else\n     {\n      SDL::Cursor::show(0);    \n     }\n   \n   my $event = new SDL::Event;\n   $event->set(SDL_SYSWMEVENT,SDL_IGNORE);\n   \n   \n   \n   \n   if ($self->glinfo)\n     {\n      my $exts=\" \".OpenGL::glGetString(GL_EXTENSIONS);\n      $exts =~ s!\\s!\\n\\t!g;\n      print \"Vendor     : \". OpenGL::glGetString( GL_VENDOR)   .\"\\n\";\n      print \"Renderer   : \". OpenGL::glGetString( GL_RENDERER) .\"\\n\";\n      print \"Version    : \". OpenGL::glGetString( GL_VERSION)  .\"\\n\";\n      print \"Extensions : \". $exts .\"\\n\";      \n\n      print Dumper $gl->get_attributes();\n     }\n   \n   $self->{SDL_APP}=$app;\n   $self->{SDL_GL}=$gl;\n   $self->{SDL_EVENT}=$event;\n\n   &{$self->{HANDLER}{init}};  \n   \n  }\n\n\nsub _reshape\n  {\n   my $self=shift;\n\n   my $h=$self->{HANDLER}{reshape};\n   &$h($self->screen_width, $self->screen_height);\n  }\n\n\nsub _idle\n  {\n   my $self=shift;\n\n   my $app=$self->{SDL_APP};\n   \n   if ($self->fps)\n     {\n      my $present_ticks = $app->ticks(); \n      $frames++;\n\n      if ($present_ticks - $previous_ticks >= 5000) \n\t{\n\t my $seconds = ($present_ticks - $previous_ticks) / 1000;\n\t my $fps     = $frames / $seconds;\n\t print \"$frames frames in $seconds seconds = $fps FPS\\n\";\n\t ($frames, $previous_ticks) = (0, $present_ticks);\n\t}\n      \n     }\n   \n   \n   &{$self->{HANDLER}{idle}};  \n  }\n\n\nsub _draw\n  {\n   my $self=shift;\n\n   my $gl=$self->{SDL_GL};\n   my $h=$self->{HANDLER}{draw};\n\n   &$h(); \n\n   $gl->swap_buffers();   \n  }\n\n\nsub _events\n  {\n   my $self=shift;\n   my $event=$self->{SDL_EVENT};\n   $event->pump;\n\n\n   $event->poll;\n     {\n      my $type=$event->type;      \n      return SDL_GL_APP_QUIT if ($type == SDL_QUIT );  \n\n      my $user_reshape_handler   =$self->{HANDLER}{reshape};\n      if ($type == SDL_VIDEORESIZE)\n\t{\n\t my ($w, $h)= ($event->resize_width,\n\t\t       $event->resize_height);\n\t $self->screen_width($w);\n\t $self->screen_height($h);\n\t $self->{SDL_APP}->video_mode($self->screen_width,\n\t\t\t\t     $self->screen_height, \n\t\t\t\t     $self->bpp,\n\t\t\t\t     $self->video_flags\n\t\t\t\t    );\n\n\t &$user_reshape_handler($w,$h);\n\t}\n      my $user_event_handler   =$self->{HANDLER}{events};\n      my $user_rc=&$user_event_handler($event); \n\n      \n      return SDL_GL_APP_CONTINUE if ($user_rc==SDL_GL_APP_SKIP_BUILTIN_EVENTS);          \n\n      my $keysym=$event->key_sym;\n      my $keymod=$event->key_mod;\n\n      if( $type       == SDL_KEYDOWN \n\t  and $keysym == SDLK_RETURN \n\t  and $keymod &  KMOD_ALT ) \n\t{\n\t $self->{SDL_APP}->toggle_fullscreen() \n\t}\n\n      return SDL_GL_APP_QUIT if ( $keysym == SDLK_ESCAPE );      \n      \n      return SDL_GL_APP_CONTINUE if ($user_rc==SDL_GL_APP_SKIP_USER_EVENTS);          \n\n      my $user_keyboard_handler=$self->{HANDLER}{keyboard};\n      my $user_mouse_handler   =$self->{HANDLER}{mouse};\n      my $user_motion_handler  =$self->{HANDLER}{motion};\n\n      if ( $type == SDL_KEYDOWN ) \n\t{      \n\t \n\t &$user_keyboard_handler ({\n\t\t\t\t   KEY_NAME => $event->key_name,\n\t\t\t\t   MOUSE_X => $self->{sdl_mouse_x},\n\t\t\t\t   MOUSE_Y => $self->{sdl_mouse_y},\n\t\t\t\t   \n\t\t\t\t  });\n\t return SDL_GL_APP_CONTINUE;\t \t \n\t}\n      \n      if ($type == SDL_MOUSEBUTTONDOWN or  $type == SDL_MOUSEBUTTONUP ) \n\t{\n\t &$user_motion_handler(\n\t\t\t       {\n\t\t\t\tMOUSE_X      => $event->button_x,\n\t\t\t\tMOUSE_Y      => $event->button_y,\n\t\t\t\tMOUSE_BUTTON => $event->button,\n\t\t\t\tMOUSE_STATE  => $event->button_state,\n\t\t\t       });\n\t return SDL_GL_APP_CONTINUE;\n\t}\n\n      if ($type == SDL_MOUSEMOTION ) \n\t{\n\t my $mx=$self->{sdl_mouse_x}=$event->motion_x;\n\t my $my=$self->{sdl_mouse_y}=$event->motion_y;\n\t &$user_motion_handler(\n\t\t\t       {\n\t\t\t\tMOUSE_X => $mx,\n\t\t\t\tMOUSE_Y => $my,\n\t\t\t\tMOUSE_X_REL => $event->motion_xrel,\n\t\t\t\tMOUSE_Y_REL => $event->motion_yrel,\n\t\t\t       });\n\t return SDL_GL_APP_CONTINUE;\n\t \n\t}\n     }\n   return SDL_GL_APP_CONTINUE;\n  }\n\n\n\nsub _usage\n  {\n   my $self=shift;\n\n   my $format=\"%-20s%-60s\\n\";\n   my $hr=\"=\" x 60 .\"\\n\";\n   print $hr;\n\n   print \"Start-up options:\\n\\n\";\n   \n   my $startup_help=$self->{START_UP_HELP};\n\n   foreach my $name (sort keys %$startup_help)\n    {\n      my $help = $startup_help->{$name};\n      print sprintf($format,$name,$help);\n    }\n\n\n   print \"\\nRuntime keys:\\n\\n\";\n\n   my $runtime_help=$self->{RUNTIME_HELP};\n\n   foreach my $name (sort keys %$runtime_help)\n     {\n      my $help = $runtime_help->{$name};\n      print sprintf($format,$name,$help);\n     }\n\n   print \"\\n$hr\\n\";\n  }\n\n\n\nsub  default_init\n  {\n   my $logo= rle_dec(_get_logo());\n   my $logo_tex = read_texture(FILE_DATA=> $logo);\n   \n   my (       \n       $w,$h,$image,\n       $gl_internal_format,\n       $gl_format,\n       $gl_type,\n       $level, $border,) = (\n\t\t\t    $logo_tex->{WIDTH},\n\t\t\t    $logo_tex->{HEIGHT},\n\t\t\t    $logo_tex->{DATA},\n\t\t\t    $logo_tex->{FORMAT},\n\t\t\t    $logo_tex->{INTERNAL_FORMAT},\n\t\t\t    $logo_tex->{TYPE},\n\t\t\t    0, 0,\n\t\t     );\n\n   glClearColor(0,0,0,1);\n   glColor3f (1.0, 1.0, 1.0);\n   \n   glShadeModel (GL_FLAT);\n   glEnable(GL_DEPTH_TEST);\n   glDepthFunc(GL_LESS);\n\n   glTexImage2D(GL_TEXTURE_2D, \n\t\t$level, $gl_format, $w,$h, $border, \n\t\t$gl_internal_format, $gl_type, $image);\n\n   glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\n   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);\n   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);\n   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);\n   glEnable(GL_TEXTURE_2D);\n\n  }\n\n\n\n\nsub  default_reshape\n  {\n   my ($width, $height)=@_;   \n   my $h = $height / $width;\n   glViewport(0, 0, $width, $height);\n   \n   glMatrixMode(GL_PROJECTION);\n   glLoadIdentity();\n   gluPerspective(60.0, 1.0 , 1.0, 30.0);   \n   glMatrixMode(GL_MODELVIEW);\n   glLoadIdentity();\n\n  }\n\n\nsub  default_draw\n  {\n   my $rad=3.14159/180;\n\n   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n   glLoadIdentity ();\n   glTranslatef(0.0, 0.0, -2 *sin ($rad*$spin) -5);\n   glPushMatrix();\n   glRotatef(360*sin($rad*$spin   ),1,0,0);\n   glRotatef(360*cos($rad*$spin*.5),0,1,0);\n   glRotatef(360*sin($rad*$spin*.25),0,0,1);\n   {\n    glBegin(GL_QUADS);\n    glTexCoord2f(0.0, 1.0); glVertex3f(-1.0, -1.0, 0.0);\n    glTexCoord2f(0.0, 0.0); glVertex3f(-1.0, 1.0, 0.0);\n    glTexCoord2f(1.0, 0.0); glVertex3f(1.0, 1.0, 0.0);\n    glTexCoord2f(1.0, 1.0); glVertex3f(1.0, -1.0, 0.0);\n    glEnd();\n   }\n   glPopMatrix();\n   glFlush();\n   $spin++\n  }\n\nsub  default_idle\n  {\n  }\n\nsub default_events\n  {\n   return SDL_GL_APP_CONTINUE;\n  }\n\n\n\n\nsub screendump\n   {\n    my $self=shift;\n    my %args= (\n\t       FILE_NAME    => undef,\n\t       FORMAT       => \"PPM\",    \n\t       SUB_FORMAT   => \"RAW\",    \n\t       GL_FORMAT    => GL_RGB,\n\t       GL_TYPE      => GL_UNSIGNED_BYTE,\n\t       @_,\n\t      );\n    my ($x, $y, $width,$height)= ( 0,0,\n\t\t\t\t   $self->screen_width,  $self->screen_height,\n\t\t\t\t );\n    my $size=$width*$height*3;\n    my $pixels=chr(0) x $size;  \n\n    OpenGL::glReadPixels_s($x,$y, \n\t\t\t   $width, $height,\n\t\t\t   $args{GL_FORMAT},\n\t\t\t   $args{GL_TYPE},\n\t\t\t   $pixels,\n\t\t\t  );\n    my $fh= new IO::File $args{FILE_NAME} ,\"w\" or croak \"opening for write, $!\";\n    binmode $fh;  \n    \n    print $fh \"P6\\n\";\n    print $fh \"# Generated by 'SDL::OpenGL::App' for '\".$self->app_name.\"', \".scalar(localtime).\"\\n\";\n    print $fh \"$width $height\\n\";\n    print $fh \"255\\n\";\n    print $fh $pixels;\n\n    undef $fh;\n   }\n\nsub read_texture\n   {\n    my %args= (\n\t       FILE_HANDLE  => undef,\n\t       FILE_NAME    => undef,\n\t       FILE_DATA    => undef,\n\t       FORMAT       => \"PPM\",    \n\t       SUB_FORMAT   => \"RAW\",    \n\t       PIXEL_FORMAT => \"RGB\",    \n\t       \n\t       @_,\n\t      );\n    my ($width, $height, $data) = (0,0,\"\");\n    \n    my $file_name=$args{FILE_NAME};\n    my $file_handle=$args{FILE_HANDLE};\n    my $file_data=$args{FILE_DATA};\n    \n\n  SWITCH:\n    {\n     $file_name\n     && $args{SUB_FORMAT} eq \"ASCII\"\n       && do \n\t {\n\t  ($width, $height, $data)= _read_ascii_ppm($file_name);\n\t  last SWITCH;\n\t };\n\n     $args{SUB_FORMAT} eq \"RAW\"\n       && do \n\t {\n\t  ($width, $height, $data)= _decode_ppm_raw($file_data);\n\t  last SWITCH;\n\t }\n\n    }\n\n    return {\n\t    WIDTH  => $width,\n\t    HEIGHT => $height,\n\t    DATA   => $data,           \n\t    INTERNAL_FORMAT =>  3,      \n\t    FORMAT => GL_RGB,           \n\t    TYPE   => GL_UNSIGNED_BYTE, \n\t   };\n   }\n\n\n\nsub _decode_ppm_raw\n   {\n    my $file_data=shift;\n    my (\n     $width, \n     $height,\n     $depth,\n     $data) = $file_data =~  \n       /^\n\t [^\\n]*\\n                      #skip  format id\n\t [^\\n]*\\n                      #skip coment\n\t (\\d+)\\s+(\\d+)\\n         #width, height\n\t (\\d+)\\n                 #depth\n\t (.*)$                   #data\n       /xmgs;     \n    \n    my $size=$width*$height*3;\n    print length $data;\n    print \"\\n$size\\n\\n\";\n    ($width>=64 && $height>=64 && $width<10000 && $height<10000) || croak \"strange sizes $width,$height\";\n    ($depth =~ /255/) or croak \"Depth should be 255\";\n    \n    \n    return ($width,$height,$data);\n   }\n\nsub _read_ascii_ppm\n  {\n   my($file) = @_;\n   my($w,$h,$image);\n   my @image=();\n   open(PPM,\"<$file\") || croak \"cant open $file\";\n   binmode PPM;\n   (<PPM>);\t\t\t\t\t\t\t\n   (<PPM>);\t\t\t\t\t\t\t\n   ($_=<PPM>);\t\t\t\t\t\t\t\n   m/(\\d+)\\s+(\\d+)/; \n   $w=$1 ; $h=$2 ;\n   ($w>=64 && $h>=64 && $w<10000 && $h<10000) || croak \"strange sizes $w,$h\";\n   ($_=<PPM>);\t\t\t\t\t\t\t\n   (/255/) || croak \" improper depth $_\";\n   \n   $image=\"\";\n\n   while(<PPM>) \n     {\n      chop;\n      $image .= $_ . \" \";\n     }\n\n   @image=split(/\\s+/,$image);\n   my $size=$w*$h*3;\n   ($size == $#image +1) || croak \"array length $#image +1  differs from expected size $size\" ; \n   $image=pack(\"C$size\",@image);\n   close(PPM);\n   return ($w,$h,$image);\n}\n\n\nsub rle_enc_file\n   {\n    my $file=shift;\n    my $fh= new IO::File $file, \"r\" or croak \"open, $!\";\n    local $/;\n    undef $/;\n    my $data=<$fh>;\n    return rle_enc($data);\n   }\n\n\nsub rle_dec\n   {\n    my $squished=shift;\n    my $unsquished=$squished;\n    \n    $unsquished =~ s/\\G(..)(..)/\n      chr(hex($1)) x hex($2)\n      /gex;\n\n    return $unsquished;\n   }\n\n\nsub rle_enc\n   {\n    my $data=shift;\n    my $squished=\"\";\n\n    my $pos=0;\n    while ($pos < length $data)\n      {\n       my $rep=1;\n       my $char=substr ($data, $pos, 1);\n\n       $squished.= sprintf (\"%02x\", ord $char);\n       \n       for (\n\t    ;\n\t    (substr($data, $pos+$rep, 1) eq $char) \n\t    && ($rep < 255)\n\t    && ($pos+$rep < length $data)\n\t    ; \n\t    $rep++\n\t   )\n\t {\n\t }\n       $squished.=sprintf (\"%02x\", $rep);\n       \n       $pos+=$rep;\n      }\n    return $squished;\n   \n   }\n\n\n\nsub _get_logo\n   {\nreturn\n\"500136010a0123012001430152014501410154014f0152013a0120015401680165012001470149014d01500127017301200150014e014d012001460169016c017401650172012001560165017201730169016f016e01200131012e0130010a01360134012001360134010a01320135020a0100ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00c302012801ce015301ff2005016901ff01008a010117018401ff4200020101006f010112015301ff5402012801a50100601201ff3e8401ff024101ff023301ff022801ff02ce01ff1a005504011201ff2d2801ff02000107011e01002b0101040105018401ff0d004bce01ff29000105011701004304011201a501ff050045ff2403013301ce010096ff2100010a012801005802010a013301ff0204015301ff0100392801ff2600514101ff14000d01010501ff06001eff1bce01ff023301ff0b0001010107010048ff1b000103010a01000601012801a501ff06001bff1b000d01010401ff0600451201ff0b000901011e018401ff09000601012801a501ff06001bff1800020201001001010701ff060042ff0900110201ff09000301012801a501ff06001a0301ff180015ff0600410201ff060015ce01ff08000301012801a501ff060018010112015301ff150001040112010015ff1800080101ff0c000304015301ff100002010100010a012801ff0600190501170101010a013301000301012801a501ff06001804015301ff160018ff0f000402010701ff060003ff0600050201ff0607018401ff070006ff0607018401ff07000c05018401ff0105018401ff0105018401ff0105018401ff0105018401ff010a01ce01ff01000301012801a501ff06001904011201ff15a501ff020015ff0c000b0101ff031701ff05000cff09000cff0c00091201ff14000301012801a501ff06001bff180015ff0c000cff1e000cff0c5301ff0200070a012801ff12000301012801a501ff06001bff1b000fff06000107011e01ff06000cff09000c5301ff08000cff0f000103010d01000fff09000301012801a501ff06001b03014101ff1c000702010a01ff090003ff0603013301ce010006ff06000101010501ff031e01ff0200064101ff054101ff05000cff060003ff0f3301ff11000301012801a501ff18000cff271701ff020006ff1200010301120100035301ff0e03013301ff0105015301ff04000cff0600050101ff1502013301ce01ff06000301012801a501ff1b000b0101ff21000cff060001010103012801ff0203015301ff01000e01011701ff020a01ce01ff01000701010701ff03000c8401ff021701ff02000905018401ff0a1e01ff020006ff06000405011e01ff18000103010d01000c010117015301ff211e01ff020006ff0600910a012801ff2d0096ff2d01010d0141010037040112010a01ce01ff011e01ff0503013301ff01004e05018401ff373301ff02010112014101000103010a01000e01010001010107010a01a501ff16005a05018401ff5b0a01ff02006801014101ff4a0a01a501ff01007c05011e02ff2f4101ff0201011201530100ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00e7\";\n}\n 1",
      "file" : "/var/tmp/arv_G7sNZc/SDL-sdlpl-1.08/lib/SDL/OpenGL/App.pm",
      "package" : "SDL::OpenGL::App"
   }
]
