[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "sub _ {gettext(@_)}\n\nsub gettext {\n    defined $I18N->{'__'}{$_[0]} ? $I18N->{'__'}{$_[0]} : $_[0];\n}\n\n{   \n    local $^W = 0;\n    eval \"sub x_ {_check_gettext('__', \\@_);}\";\n}\n\nsub S_ { _check_gettext('__S', @_)}\n\nsub D_ { _check_gettext('__D', @_)}\n\nsub _check_gettext {\n    my ($key, $text, $depth) = @_;\n\n    $depth ||= 1;\n    if (defined $I18N->{$key}{$text}) {\n        return $I18N->{$key}{$text};\n    } else {\n        if ($I18N->{$key}{'__SAVE_MISSING'}) {\n            my $called_at = \n                basename((caller $depth)[1]). \":\".(caller $depth)[2];\n            unless ($I18N->{$key}{'__MISSING_STRINGS'}{$text} && \n                $I18N->{$key}{'__MISSING_STRINGS'}{$text} =~ / $called_at /) {\n                $I18N->{$key}{'__MISSING_STRINGS'}{$text} .= \" $called_at \";\n            }\n        }\n        return $text;\n    }\n}\n\nsub start_checking_gettext_strings {\n    my ($class, $key, $file) = @_;\n\n    $I18N->{($key || '__')}{'__SAVE_MISSING'} = ($file || \"&STDOUT\");\n}\n\nsub stop_checking_gettext_strings {\n    my ($class, $key) = @_;\n\n    undef $I18N->{($key || '__')}{'__SAVE_MISSING'};\n}\n\nsub write_missing_gettext_strings {\n    my ($class, $key, $file, $no_header, $copy_to) = @_;\n\n    $key ||= \"__\";\n    my ($string, $called_at);\n    my $me = __PACKAGE__.\"->write_translatable_strings\";\n    my $saved = $I18N->{$key}{'__MISSING_STRINGS'};\n    $key  ||= \"__\";\n    $file ||= $I18N->{$key}{'__SAVE_MISSING'};\n    return unless keys %$saved;\n    open POT, \">$file\" or \n        die sprintf((\"error %s - can't open file '%s' for output\"),\n                $me, $file);\n    my $date = `date +\"%Y-%m-%d %H:%M%z\"`; chomp $date;\n    my $year = `date +\"%Y\"`; chomp $year;\n    print POT \"# \".sprintf(S_(\"These are strings that had no gettext translation in '%s'\"), $key).\"\\n\";\n    print POT \"# \".sprintf(S_(\"Automatically generated by %s\"),__PACKAGE__).\"\\n\";\n    print POT \"# \".S_(\"Date\").\" \".`date`;\n    print POT \"# \".sprintf(S_(\"Run from class %s in file %s\"), $class->PACKAGE, (caller 0)[1]).\"\\n\";\n    unless ($no_header && $no_header eq \"NO_HEADER\") {\n        print POT \"\n# SOME DESCRIPTIVE TITLE.\n# Copyright (C) $year ORGANISATION\n# \".$class->AUTHOR.\",\n#\n# , fuzzy\nmsgid \\\"\\\"\nmsgstr \\\"\\\"\n\\\"Project-Id-Version:  \".$class->PACKAGE.\" \".$class->VERSION.\"\\\\n\\\"\n\\\"POT-Creation-Date: $date\\\\n\\\"\n\\\"PO-Revision-Date:  YEAR-MO-DA HO:MI+ZONE\\\\n\\\"\n\\\"Last-Translator:  \".$class->AUTHOR.\"\\\\n\\\"\n\\\"Language-Team:  LANGUAGE \\<LL\".'@li.org'.\"\\>\\\\n\\\"\n\\\"MIME-Version:  1.0\\\\n\\\"\n\\\"Content-Type: text/plain; charset=CHARSET\\\\n\\\"\n\\\"Content-Transfer-Encoding:  ENCODING\\\\n\\\"\n\n#: Generic replacement\nmsgid \\\"\\%s\\\"\nmsgstr \\\"\\%s\\\"\n\n\";  }\n\n    foreach $string (%$saved) {\n        next unless $string and $saved->{$string};\n        print POT wrap(\"#\", \"#\",$saved->{$string}), \"\\n\";\n        if ($string =~ s/\\n/\\\\n\\\"\\n\\\"/g) {$string = \"\\\"\\n\\\"\".$string}\n        print POT \"msgid \\\"$string\\\"\\n\";\n        if ($copy_to && $copy_to eq 'COPY_TO') {\n            print POT \"msgstr \\\"$string\\\"\\n\\n\";\n        } else {\n            print POT \"msgstr \\\"\\\"\\n\\n\";\n        }\n    }\n    close POT;\n}\n\nsub load_translations {\n    my ($class, $domain, $language, $locale_dir, $file, $key, $merge) = @_;\n\n    my $catalog_filename = $file;\n    $key ||= '__';\n    $I18N->{$key} = {} unless $merge and $merge eq \"MERGE\";;\n\n    $language ||= $ENV{\"LANG\"};\n    return unless $language;\n    $locale_dir ||= \"/usr/local/share/locale\";\n    $domain     ||= \"Glade-Perl\";\n\n    for $catalog_filename ( $file || \n        (\"/usr/local/share/locale/$language/LC_MESSAGES/$domain.mo\",\n        \"/usr/share/locale/$language/LC_MESSAGES/$domain.mo\")) {\n        if ($catalog_filename and (-f $catalog_filename)) {\n            $class->load_mo($catalog_filename, $key);\n            last;\n        }\n    }\n}\n\nsub load_mo {\n    my ($class, $catalog, $key) = @_;\n\n    my ($reverse, $buffer);\n    my ($magic, $revision, $nstrings);\n    my ($orig_tab_offset, $orig_length, $orig_pointer);\n    my ($trans_length, $trans_pointer, $trans_tab_offset);\n\n    my $save = $/;\n    open CATALOG, $catalog or return;\n    undef $/; \n    $buffer = <CATALOG>; \n    close CATALOG;\n    $/ = $save;\n    \n    $magic = unpack (\"I\", $buffer);\n    if (sprintf (\"%x\", $magic) eq \"de120495\") {\n    \t$reverse = 1;\n\n    } elsif (sprintf (\"%x\", $magic) ne \"950412de\") {\n    \tprint STDERR \"'$catalog' \"._(\"is not a catalog file\").\"\\n\";\n        return;\n    }\n\n    $revision = &mo_format_value (4, $reverse, $buffer);\n    $nstrings = &mo_format_value (8, $reverse, $buffer);\n    $orig_tab_offset = &mo_format_value (12, $reverse, $buffer);\n    $trans_tab_offset = &mo_format_value (16, $reverse, $buffer);\n\n    while ($nstrings-- > 0) {\n\t    $orig_length = &mo_format_value ($orig_tab_offset, $reverse, $buffer);\n\t    $orig_pointer = &mo_format_value ($orig_tab_offset + 4, $reverse, $buffer);\n\t    $orig_tab_offset += 8;\n\n\t    $trans_length = &mo_format_value ($trans_tab_offset, $reverse, $buffer);\n\t    $trans_pointer = &mo_format_value ($trans_tab_offset + 4,$reverse, $buffer);\n\t    $trans_tab_offset += 8;\n\n    \t$I18N->{$key}{substr ($buffer, $orig_pointer, $orig_length)}\n\t        = substr ($buffer, $trans_pointer, $trans_length);\n    }\n\n    $I18N->{$key}{'__MO_HEADER_INFO'} = $I18N->{$key}{''};\n    $I18N->{$key}{''} = '';\n}\n\nsub mo_format_value {\n    my ($string, $reverse, $buffer) = @_;\n\n    unpack (\"i\",\n\t    $reverse\n\t    ? pack (\"c4\", reverse unpack (\"c4\", substr ($buffer, $string, 4)))\n\t    : substr ($buffer, $string, 4));\n}\n\nsub WH {\n    my ($class, $new) = @_; \n    if ($new) {\n        return $class->FORM->{'__WH'} = $new;\n    } else {\n      return $class->FORM->{'__WH'};\n    }\n}\n\nsub CH {\n    my ($class, $new) = @_;\n    if ($new) {\n      return $class->FORM->{'__CH'} = $new;\n    } else {\n      return $class->FORM->{'__CH'};\n    }\n}\n\nsub W {\n    my ($class, $proto, $new) = @_;\n    if ($new) {\n      return $proto->{'__W'} = $new;\n    } else {\n      return $proto->{'__W'};\n    }\n}\n\nsub C {\n    my ($class, $proto, @new) = @_;\n    if ($#new) {\n      return push @{$proto->{'__C'}}, @new;\n    } else {\n      return $proto->{'__C'};\n    }\n}\n\n\n\nsub create_pixmap {\n    my ($class, $widget, $filename, $pixmap_dirs) = @_;\n    my $me = \"$class->create_pixmap\";\n\n\n    my ($work, $gdk_pixmap, $gdk_mask, $testfile, $found_filename, $dir);\n    if (-f $filename) {\n        $found_filename = $testfile;\n\n    } else {\n        foreach $dir (@{$pixmap_dirs}, $Glade::PerlRun::pixmaps_directory, cwd) {\n            $testfile = $class->full_Path($filename, $dir);\n        \tif (-f $testfile) {\n                $found_filename = $testfile;\n                last;\n        \t}\n        }\n    }\n    unless ($found_filename) {\n    \tif (-f $filename) {\n            $found_filename = $filename;\n    \t} else {\n            print STDERR sprintf(_(\n                \"error Pixmap file '%s' does not exist in %s\\n\"),\n                $filename, $me);\n            return undef;\n    \t}\n    }\n    if (Gtk::Gdk::Pixmap->can('colormap_create_from_xpm')) {\n        my $colormap = $widget->get_colormap;\n        return new Gtk::Pixmap(\n            Gtk::Gdk::Pixmap->colormap_create_from_xpm (\n                undef, $colormap, undef, $found_filename));\n\n    } else {\n        $work->{'window'} \t    = $widget->get_toplevel->window\t ;\n        $work->{'style'} = Gtk::Widget->get_default_style->bg('normal')\t ;\n        unless ($work->{'window'}) {\n    \t    print STDOUT sprintf(_(\n                \"error Couldn't get_toplevel_window to construct pixmap from '%s' in %s\\n\"),\n                $filename, $me);\n        \t$work->{'window'} = $widget->window\t ;\n        }\n        return new Gtk::Pixmap(\n            Gtk::Gdk::Pixmap->create_from_xpm(\n                $work->{'window'}, $work->{'style'}, $found_filename ) );\n    }\n}\n\nsub create_image {\n    my ($class, $filename, $pixmap_dirs) = @_;\n    my $me = \"$class->create_image\";\n\n\n    my ($work, $testfile, $found_filename, $dir);\n    if (-f $filename) {\n        $found_filename = $testfile;\n\n    } else {\n        foreach $dir (@{$pixmap_dirs}, $Glade::PerlRun::pixmaps_directory, cwd) {\n            $testfile = $class->full_Path($filename, $dir);\n        \tif (-f $testfile) {\n                $found_filename = $testfile;\n                last;\n        \t}\n        }\n    }\n    unless ($found_filename) {\n    \tif (-f $filename) {\n            $found_filename = $filename;\n    \t} else {\n            print STDERR sprintf(_(\n                \"error ImlibImage file '%s' does not exist in %s\\n\"),\n                $filename, $me);\n            return undef;\n    \t}\n    }\n\n    return Gtk::Gdk::ImlibImage->load_image ($found_filename);\n}\n\nsub missing_handler {\n    my ($class, $widgetname, $signal, $handler, $pixmap) = @_;\n    my $me = __PACKAGE__.\"->missing_handler\";\n\n    print STDOUT sprintf(_(\"%s- %s - called with args ('%s')\"),\n        $indent, $me, join(\"', '\", @_)), \"\\n\";\n    my $message = sprintf(\"\\n\"._(\"%s has been called because\\n\".\n                    \"a signal (%s) was caused by widget (%s).\\n\".\n                    \"When Perl::Generate writes the Perl source to a file \\n\".\n                    \"an AUTOLOADed signal handler sub called '%s'\\n\".\n                    \"will be specified in the ProjectSIGS class file. You can write a sub with\\n\".\n                    \"the same name in another module and it will automatically be called instead.\\n\"),\n                    $me, $signal, $widgetname, $handler) ;\n    my $widget = __PACKAGE__->message_box($message, \n        _(\"Missing handler\").\" '$handler' \"._(\"called\"), \n        [_(\"Dismiss\"), _(\"Quit\").\" PerlGenerate\"], 1, $pixmap);\n    \n    $class->signal_emit_stop($signal);\n    return $widget;\n}\n\nsub show_skeleton_message {\n    my ($class, $caller, $data, $package, $pixmap) = @_;\n\n    $pixmap  ||= \"$Glade::PerlRun::pixmaps_directory/Logo.xpm\";\n    $package ||= (caller);\n    $data    ||= ['unknown args'];\n\n    $class->message_box(sprintf(_(\"\nA signal handler has just been triggered.\n\n%s was\ncalled with parameters ('%s')\n\nUntil the sub is fleshed out, I will show you \nthis box to prove that I have been called\n\"), $caller, join(\"', '\", @$data)), \n    $caller, \n    [_('Dismiss'), _(\"Quit\").\" Program\"], \n    1, \n    $pixmap);\n}\n\nsub message_box {\n    my ($class, $text, $title, $buttons, $default, \n        $pixmapfile, $just, $handlers, $entry) = @_;\n\n    my ($i, $ilimit);\n    my $justify = $just || 'center';\n    my $mbno = 1;\n    while (defined $widgets->{\"MessageBox-$mbno\"}) {$mbno++;}\n    $widgets->{\"MessageBox-$mbno\"} = new Gtk::Window('toplevel');\n    $widgets->{\"MessageBox-$mbno\"}->set_title($title);\n    $widgets->{\"MessageBox-$mbno\"}->position('mouse');\n    $widgets->{\"MessageBox-$mbno\"}->set_policy('1', '1', '0');\n    $widgets->{\"MessageBox-$mbno\"}->border_width('6');\n    $widgets->{\"MessageBox-$mbno\"}->set_modal('1');\n    $widgets->{\"MessageBox-$mbno\"}->realize;\n    $widgets->{\"MessageBox-$mbno\"}{'tooltips'} = new Gtk::Tooltips;\n        $widgets->{\"MessageBox-$mbno\"}{'vbox1'} = new Gtk::VBox(0, 0);\n        $widgets->{\"MessageBox-$mbno\"}{'vbox1'}->border_width(0);\n        $widgets->{\"MessageBox-$mbno\"}->add($widgets->{\"MessageBox-$mbno\"}{'vbox1'});\n        $widgets->{\"MessageBox-$mbno\"}{'vbox1'}->show();\n            $widgets->{\"MessageBox-$mbno\"}{'hbox1'} = new Gtk::HBox('0', '0');\n            $widgets->{\"MessageBox-$mbno\"}{'hbox1'}->border_width('0');\n            $widgets->{\"MessageBox-$mbno\"}{'vbox1'}->add($widgets->{\"MessageBox-$mbno\"}{'hbox1'});\n            $widgets->{\"MessageBox-$mbno\"}{'hbox1'}->show();\n\n    \t\tif ($pixmapfile) { \n    \t\t\t$widgets->{\"MessageBox-$mbno\"}{'pixmap1'} = $class->create_pixmap($widgets->{\"MessageBox-$mbno\"}{'hbox1'}, $pixmapfile);\n    \t\t\tif ($widgets->{\"MessageBox-$mbno\"}{'pixmap1'}) {\n                    $widgets->{\"MessageBox-$mbno\"}{'pixmap1'}->set_alignment('0.5', '0.5');\n    \t            $widgets->{\"MessageBox-$mbno\"}{'pixmap1'}->set_padding('0', '0');\n        \t        $widgets->{\"MessageBox-$mbno\"}{'hbox1'}->add($widgets->{\"MessageBox-$mbno\"}{'pixmap1'});\n            \t    $widgets->{\"MessageBox-$mbno\"}{'pixmap1'}->show();\n    \t            $widgets->{\"MessageBox-$mbno\"}{'hbox1'}->set_child_packing($widgets->{\"MessageBox-$mbno\"}{'pixmap1'}, '0', '0', '0', 'start');\n    \t\t\t}\n    \t\t}\n\n                $widgets->{\"MessageBox-$mbno\"}{'label1'} = new Gtk::Label($text);\n                $widgets->{\"MessageBox-$mbno\"}{'label1'}->set_justify($justify);\n                $widgets->{\"MessageBox-$mbno\"}{'label1'}->set_alignment('0.5', '0.5');\n                $widgets->{\"MessageBox-$mbno\"}{'label1'}->set_padding('0', '0');\n                $widgets->{\"MessageBox-$mbno\"}{'hbox1'}->add($widgets->{\"MessageBox-$mbno\"}{'label1'});\n                $widgets->{\"MessageBox-$mbno\"}{'label1'}->show();\n    \t        $widgets->{\"MessageBox-$mbno\"}{'hbox1'}->set_child_packing($widgets->{\"MessageBox-$mbno\"}{'label1'}, '1', '1', '10', 'start');\n        \t$widgets->{\"MessageBox-$mbno\"}{'vbox1'}->set_child_packing($widgets->{\"MessageBox-$mbno\"}{'hbox1'}, '1', '1', '0', 'start');\n            $widgets->{\"MessageBox-$mbno\"}{'action_area1'} = new Gtk::HBox('1', '5');\n            $widgets->{\"MessageBox-$mbno\"}{'action_area1'}->border_width('10');\n            $widgets->{\"MessageBox-$mbno\"}{'vbox1'}->add($widgets->{\"MessageBox-$mbno\"}{'action_area1'});\n            $widgets->{\"MessageBox-$mbno\"}{'action_area1'}->show();\n                if ($entry) {\n                    $widgets->{\"MessageBox-$mbno\"}{'entry'} = new Gtk::Entry;\n                    $widgets->{\"MessageBox-$mbno\"}{'vbox1'}->add($widgets->{\"MessageBox-$mbno\"}{'entry'});\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->show( );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->set_usize('160', '0' );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->can_focus('1' );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->set_text('' );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->set_max_length('0' );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->set_visibility('1' );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->set_editable('1' );\n\t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'entry'}->grab_focus();\n                }\n                $widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'} = new Gtk::HButtonBox;\n                $widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'}->set_layout('default_style');\n                $widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'}->set_spacing('10');\n                $widgets->{\"MessageBox-$mbno\"}{'action_area1'}->add($widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'});\n                $widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'}->show();\n    \t\t\t$ilimit = scalar(@$buttons);\n    \t\t\tfor ($i = 0; $i < $ilimit; $i++) {\n                    $widgets->{\"MessageBox-$mbno\"}{'button'.$i} = new Gtk::Button($buttons->[$i]);\n                    $widgets->{\"MessageBox-$mbno\"}{'button'.$i}->can_focus('1');\n    \t\t\t\tif ($handlers->[$i]) {\n    \t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'button'.$i}->signal_connect('clicked', $handlers->[$i], $mbno, $buttons->[$i]);\n    \t\t\t\t} else {\n    \t\t\t\t\t$widgets->{\"MessageBox-$mbno\"}{'button'.$i}->signal_connect('clicked', __PACKAGE__.\"::message_box_close\", $mbno, $buttons->[$i]);\n    \t\t\t\t}\n                    $widgets->{\"MessageBox-$mbno\"}{'button'.$i}->border_width('0');\n                    $widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'}->add($widgets->{\"MessageBox-$mbno\"}{'button'.$i});\n    \t\t\t\tif ($i == ($default-1)) {\n                        $widgets->{\"MessageBox-$mbno\"}{'button'.$i}->can_default('1');\n    \t                $widgets->{\"MessageBox-$mbno\"}{'button'.$i}->grab_default();\n    \t\t\t\t}\n                    $widgets->{\"MessageBox-$mbno\"}{'button'.$i}->show();\n                }\n    \t\t\t$widgets->{\"MessageBox-$mbno\"}{'action_area1'}->set_child_packing($widgets->{\"MessageBox-$mbno\"}{'hbuttonbox1'}, '1', '1', '0', 'start');\n    \t    $widgets->{\"MessageBox-$mbno\"}{'vbox1'}->set_child_packing($widgets->{\"MessageBox-$mbno\"}{'action_area1'}, '0', '1', '0', 'end');\n    $widgets->{\"MessageBox-$mbno\"}->show();\n    return $widgets->{\"MessageBox-$mbno\"};\n}\n\nsub message_box_close {\n    my ($class, $mbno, $button_label) = @_;\n\n    $widgets->{\"MessageBox-$mbno\"}->get_toplevel->destroy;\n    undef $widgets->{\"MessageBox-$mbno\"};\n    if (_(\"*Quit Program*Quit PerlGenerate*Quit UI Build*Close Form*\") =~ m/\\*$button_label\\*/) {\n        Gtk->main_quit;\n    }\n    return $data;\n}\n\nsub destroy_all_forms {\n    my $class = shift;\n    my $hashref = shift || $__PACKAGE__::all_forms;\n    my $myform;\n    foreach $myform (keys %$hashref) {\n        $hashref->{$myform}->get_toplevel->destroy;\n        undef $hashref->{$myform};\n    }\n}\n\n\n\nsub get_time {\n    my $time = `date`;\n    chomp $time;\n    return $time\n}\n\nsub full_Path {\n    my ($class, $rel_path, $directory, $default) = @_;\n    my $me = \"$class->full_Path\";\n\n    my $basename;\n    my $slash = '/';\n    my $updir = '/\\.\\./';\n    my $fullname = $rel_path || $default || '';\n    if ($fullname !~ /^$slash/ && defined $directory) {\n        my $save_dir = cwd;\n        chdir($directory);\n        my $fulldir = cwd;\n        $fullname = \"$fulldir$slash$fullname\"; \n        chdir($save_dir);\n    } else {\n        my $dirname = dirname($fullname);\n        my $basename = basename($fullname);\n        my $save_dir = cwd;\n        chdir($dirname);\n        my $fulldir = cwd;\n        $fullname = \"$fulldir$slash$basename\"; \n        chdir($save_dir);\n    }    \n    $fullname =~ s/$slash\\.?$slash/$slash/g;\n    while ($fullname =~ /$updir/) {\n        $fullname =~ s/(.+)(?!$updir)$slash.+?$updir/$1$slash/;\n    }\n    $fullname =~ s/$slash$//;\n    return $fullname;\n}\n\nsub relative_path {\n    my ($class, $basepath, $path, $root) = @_;\n    my $me = __PACKAGE__.\"::relative_path\";\n\n    return $path if $path =~ /:/;\n    my $rel;\n    my $li = 1;\n    while (1) {\n        my $i = index($path, '/', $li);\n        last if $i < 0 ||\n                $i != index($basepath, '/', $li) ||\n                substr($path,$li,$i-$li) ne substr($basepath,$li,$i-$li);\n        $li=$i+1;\n    }\n    substr($path, 0,$li) = '';\n    substr($basepath,0,$li) = '';\n\n    $rel = \"\";\n\n    $path = ('../' x $basepath =~ tr|/|/|) . $path;\n    $path = \"./\" if $path eq \"\";\n    $rel = $path;\n\n    return $rel;\n}\n\nsub string_from_file {&string_from_File(@_);}\nsub string_from_File {\n    my ($class, $filename) = @_;\n    my $me = __PACKAGE__.\"->string_from_File\";\n\n    my $save = $/;\n    undef $/;\n    open INFILE, $filename or \n        die sprintf((\n            \"error %s - can't open file '%s' for input\"),\n            $me, $filename);    \n    undef $/;\n    my $string = <INFILE>;\n    close INFILE;\n    $/ = $save;\n\n    return $string;\n}\n\nsub reload_any_altered_modules {\n    my ($class) = @_;\n    my $me = __PACKAGE__.\"->reload_any_altered_modules\";\n\n    my $stat = \\%stat;\n    my $reloaded = 0;\n    my ($prefix, $msg);\n    if (ref $class) {\n        $prefix = ($class->{diag}{indent} || $indent);\n    } else {\n        $prefix = $indent;\n    }\n    $prefix .= \"- $me\";\n    while(my($key,$file) = each %INC) {\n        local $^W = 0;\n        my $mtime = (stat $file)[9];\n        unless (defined $mtime and $mtime) {\n            print \"$prefix - Can't locate $file\\n\",next \n        }\n        unless(defined $stat->{$file}) {\n            $stat->{$file} = $^T;\n        }\n\n        if($mtime > $stat->{$file}) {\n            delete $INC{$key};\n            require $key;\n            $reloaded++;\n            print \"$prefix - Reloading $key in process $$\\n\";\n        }\n        $stat->{$file} = $mtime;\n    }\n    return \"Reloaded $reloaded module(s) in process $$\";\n}\n\n\n1",
      "file" : "/var/tmp/arv_Zuq0eo/Glade-Perl-0.61/Glade/PerlRun.pm",
      "package" : "Glade::PerlRun"
   }
]
