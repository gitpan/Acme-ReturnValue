[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub compile_file {\n  my ($self, $filename) = @_;\n\n\n\n  my $fh;\n\n  if (ref $filename eq 'GLOB') {\n    $fh = $filename;\n  } else {\n    open($fh, '<', $filename)\n      || die \"couldn't read unliner script '$filename': $!\";\n  }\n\n  my $file_contents = do { local $/; <$fh> };\n\n  close($fh);\n\n\n\n  my $parsed;\n\n  if ($file_contents =~ $App::Unliner::Grammar::parsers->{file_parser}) {\n    $parsed = \\%/;\n  } else {\n    my $err = Dumper(\\@!);\n    die \"couldn't parse unliner script '$filename': ($err)\";\n  }\n\n\n  ## Process each directive\n\n  my $defs;\n\n  foreach my $directive (@{$parsed->{file}->{directive}}) {\n    if ($directive->{include}) {\n      #print \"INCLUDING $directive->{include}->{package}\\n\";\n      die \"include not impl\";\n    } elsif ($directive->{def}) {\n      $defs->{$directive->{def}->{name}} = $directive->{def};\n    }\n  }\n\n  $self->{defs} = { %{ $self->{defs} }, %$defs };\n\n  return $self;\n}\n\n\n\n\nsub run {\n  my ($self, %args) = @_;\n\n  my $def_name = $args{def_name};\n\n  die \"no such def '$def_name'\"\n    unless $self->{defs}->{$def_name};\n\n  App::Unliner::Program::Compiled->new( program => $self,\n                                        def_name => $args{def_name},\n                                        argv => $args{argv},\n                                      )\n                                 ->optimise\n                                 ->execute;\n\n  return $self;\n}\n\n\n\n1\n",
      "file" : "/var/tmp/arv_5lCR1_/App-Unliner-0.011/lib/App/Unliner/Program.pm",
      "package" : "App::Unliner::Program"
   },
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub construct_pipeline {\n  my ($self) = @_;\n\n  my $def_parsed; \n\n  my $def_body = $self->{def_body};\n  $def_body =~ s/^\\s*[|]//;\n  $def_body =~ s/[|]\\s*$//;\n\n  if ($def_body =~ $App::Unliner::Grammar::parsers->{pipeline_parser}) {\n    $def_parsed = \\%/;\n  } else {\n    my $err = Dumper(\\@!);\n    die \"couldn't parse $self->{def_name}: ($err)\";\n  }\n\n  my $output = $def_parsed->{pipeline}->{command};\n\n  foreach my $pipeline_component (@$output) {\n    $pipeline_component->{shell_arg} = [ map { $self->process_arg($_) } @{$pipeline_component->{shell_arg}} ];\n  }\n\n  return $output;\n}\n\n\nsub process_arg {\n  my ($self, $arg) = @_;\n\n  unless ($arg =~ /^'/) {\n    $arg =~ s{ \\$\n               (?: (\\w+) |\n                   \\{\n                     (.*?)\n                   \\}\n               )\n             }{\n               $self->{context}->{$2 || $1} // $ENV{$2 || $1}\n             }egx;\n  }\n\n  $arg = App::Unliner::Grammar::PostProc::arg($arg);\n\n  return @{ $self->{argv} } if ($arg eq '$@');\n\n  return $arg;\n}\n\n\n\n1\n",
      "file" : "/var/tmp/arv_5lCR1_/App-Unliner-0.011/lib/App/Unliner/Language/Shell.pm",
      "package" : "App::Unliner::Language::Shell"
   }
]
