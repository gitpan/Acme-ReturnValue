[
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nrequire 5.006;\n$GDS2::VERSION = '3.00'; \n$GDS2::revision = '@(#) $Id: GDS2.pm,v $ $Revision: 2.12 $ $Date: 2006-02-20 00:12:55-06 $';\n\n\n\n\nuse strict;\nuse warnings;\n\nmy $G_timer;\nBEGIN\n{\n    use constant TRUE    => 1;\n    use constant FALSE   => 0;\n    use constant UNKNOWN => -1;\n    \n    use constant HAVE_FLOCK => TRUE;  \n    use constant TIMER_ON   => FALSE; \n    use Config;\n    use IO::File;\n}\n\nif (HAVE_FLOCK)\n{\n    use Fcntl q(:flock);  \n}\n\nif (TIMER_ON)\n{\n    $G_timer = new Benchmark::Timer;\n}\nno strict qw( refs );\n\nmy $isLittleEndian = FALSE; \n$isLittleEndian = TRUE if ($Config{'byteorder'} =~ m/^1/); \n\nuse constant NO_REC_DATA  => 0;\nuse constant BIT_ARRAY    => 1;\nuse constant INTEGER_2    => 2;\nuse constant INTEGER_4    => 3;\nuse constant REAL_4       => 4; \nuse constant REAL_8       => 5;\nuse constant ACSII_STRING => 6;\n\nuse constant HEADER       =>  0;   \nuse constant BGNLIB       =>  1;   \nuse constant LIBNAME      =>  2;   \nuse constant UNITS        =>  3;   \nuse constant ENDLIB       =>  4;   \nuse constant BGNSTR       =>  5;   \nuse constant STRNAME      =>  6;   \nuse constant ENDSTR       =>  7;   \nuse constant BOUNDARY     =>  8;   \nuse constant PATH         =>  9;   \nuse constant SREF         => 10;   \nuse constant AREF         => 11;   \nuse constant TEXT         => 12;   \nuse constant LAYER        => 13;   \nuse constant DATATYPE     => 14;   \nuse constant WIDTH        => 15;   \nuse constant XY           => 16;   \nuse constant ENDEL        => 17;   \nuse constant SNAME        => 18;   \nuse constant COLROW       => 19;   \nuse constant TEXTNODE     => 20;   \nuse constant NODE         => 21;   \nuse constant TEXTTYPE     => 22;   \nuse constant PRESENTATION => 23;   \nuse constant SPACING      => 24;   \nuse constant STRING       => 25;   \nuse constant STRANS       => 26;   \nuse constant MAG          => 27;   \nuse constant ANGLE        => 28;   \nuse constant UINTEGER     => 29;   \nuse constant USTRING      => 30;   \nuse constant REFLIBS      => 31;   \nuse constant FONTS        => 32;   \nuse constant PATHTYPE     => 33;   \nuse constant GENERATIONS  => 34;   \nuse constant ATTRTABLE    => 35;   \nuse constant STYPTABLE    => 36;   \nuse constant STRTYPE      => 37;   \nuse constant EFLAGS       => 38;   \nuse constant ELKEY        => 39;   \nuse constant LINKTYPE     => 40;   \nuse constant LINKKEYS     => 41;   \nuse constant NODETYPE     => 42;   \nuse constant PROPATTR     => 43;   \nuse constant PROPVALUE    => 44;   \nuse constant BOX          => 45;   \nuse constant BOXTYPE      => 46;   \nuse constant PLEX         => 47;   \nuse constant BGNEXTN      => 48;   \nuse constant ENDEXTN      => 49;   \nuse constant TAPENUM      => 50;   \nuse constant TAPECODE     => 51;   \nuse constant STRCLASS     => 52;   \nuse constant RESERVED     => 53;   \nuse constant FORMAT       => 54;   \nuse constant MASK         => 55;   \nuse constant ENDMASKS     => 56;   \nuse constant LIBDIRSIZE   => 57;   \nuse constant SRFNAME      => 58;   \nuse constant LIBSECUR     => 59;   \nuse vars '$StrSpace';\nuse vars '$ElmSpace';\n$StrSpace='';\n$ElmSpace='';\n\nmy %RecordTypeNumbers=(\n'HEADER'      => HEADER,\n'BGNLIB'      => BGNLIB,\n'LIBNAME'     => LIBNAME,\n'UNITS'       => UNITS,\n'ENDLIB'      => ENDLIB,\n'BGNSTR'      => BGNSTR,\n'STRNAME'     => STRNAME,\n'ENDSTR'      => ENDSTR,\n'BOUNDARY'    => BOUNDARY,\n'PATH'        => PATH,\n'SREF'        => SREF,\n'AREF'        => AREF,\n'TEXT'        => TEXT,\n'LAYER'       => LAYER,\n'DATATYPE'    => DATATYPE,\n'WIDTH'       => WIDTH,\n'XY'          => XY,\n'ENDEL'       => ENDEL,\n'SNAME'       => SNAME,\n'COLROW'      => COLROW,\n'TEXTNODE'    => TEXTNODE,\n'NODE'        => NODE,\n'TEXTTYPE'    => TEXTTYPE,\n'PRESENTATION'=> PRESENTATION,\n'SPACING'     => SPACING,\n'STRING'      => STRING,\n'STRANS'      => STRANS,\n'MAG'         => MAG,\n'ANGLE'       => ANGLE,\n'UINTEGER'    => UINTEGER,\n'USTRING'     => USTRING,\n'REFLIBS'     => REFLIBS,\n'FONTS'       => FONTS,\n'PATHTYPE'    => PATHTYPE,\n'GENERATIONS' => GENERATIONS,\n'ATTRTABLE'   => ATTRTABLE,\n'STYPTABLE'   => STYPTABLE,\n'STRTYPE'     => STRTYPE,\n'EFLAGS'      => EFLAGS,\n'ELKEY'       => ELKEY,\n'LINKTYPE'    => LINKTYPE,\n'LINKKEYS'    => LINKKEYS,\n'NODETYPE'    => NODETYPE,\n'PROPATTR'    => PROPATTR,\n'PROPVALUE'   => PROPVALUE,\n'BOX'         => BOX,\n'BOXTYPE'     => BOXTYPE,\n'PLEX'        => PLEX,\n'BGNEXTN'     => BGNEXTN,\n'ENDEXTN'     => ENDEXTN,\n'TAPENUM'     => TAPENUM,\n'TAPECODE'    => TAPECODE,\n'STRCLASS'    => STRCLASS,\n'RESERVED'    => RESERVED,\n'FORMAT'      => FORMAT,\n'MASK'        => MASK,\n'ENDMASKS'    => ENDMASKS,\n'LIBDIRSIZE'  => LIBDIRSIZE,\n'SRFNAME'     => SRFNAME,\n'LIBSECUR'    => LIBSECUR,\n);\n\nmy @RecordTypeStrings=( \n'HEADER',\n'BGNLIB',\n'LIBNAME',\n'UNITS',\n'ENDLIB',\n'BGNSTR',\n'STRNAME',\n'ENDSTR',\n'BOUNDARY',\n'PATH',\n'SREF',\n'AREF',\n'TEXT',\n'LAYER',\n'DATATYPE',\n'WIDTH',\n'XY',\n'ENDEL',\n'SNAME',\n'COLROW',\n'TEXTNODE',\n'NODE',\n'TEXTTYPE',\n'PRESENTATION',\n'SPACING',\n'STRING',\n'STRANS',\n'MAG',\n'ANGLE',\n'UINTEGER',\n'USTRING',\n'REFLIBS',\n'FONTS',\n'PATHTYPE',\n'GENERATIONS',\n'ATTRTABLE',\n'STYPTABLE',\n'STRTYPE',\n'EFLAGS',\n'ELKEY',\n'LINKTYPE',\n'LINKKEYS',\n'NODETYPE',\n'PROPATTR',\n'PROPVALUE',\n'BOX',\n'BOXTYPE',\n'PLEX',\n'BGNEXTN',\n'ENDEXTN',\n'TAPENUM',\n'TAPECODE',\n'STRCLASS',\n'RESERVED',\n'FORMAT',\n'MASK',\n'ENDMASKS',\n'LIBDIRSIZE',\n'SRFNAME',\n'LIBSECUR',\n);\nmy @CompactRecordTypeStrings=( \n'gds2{',          \n'',               \n'lib',            \n'',               \n'}',              \n'cell{',          \n'',               \n'}',              \n'b{',             \n'p{',             \n's{',             \n'a{',             \n't{',             \n'',               \n' dt',            \n' w',             \n' xy(',           \n'}',              \n'',               \n' cr',            \n' tn',            \n' no',            \n' tt',            \n'',               \n' sp',            \n'',               \n'',               \n' m',             \n' a',             \n' ui',            \n' us',            \n' rl',            \n' f',             \n' pt',            \n' gen',           \n' at',            \n' st',            \n' strt',          \n' ef',            \n' ek',            \n' lt',            \n' lk',            \n' nt',            \n' ptr',           \n' pv',            \n' bx',            \n' bt',            \n' px',            \n' bx',            \n' ex',            \n' tnum',          \n' tcode',         \n' strc',          \n' resv',          \n' fmt',           \n' msk',           \n' emsk',          \n' lds',           \n' srfn',          \n' libs',          \n);\n\nmy %RecordTypeData=(\n'HEADER'       => INTEGER_2,\n'BGNLIB'       => INTEGER_2,\n'LIBNAME'      => ACSII_STRING,\n'UNITS'        => REAL_8,\n'ENDLIB'       => NO_REC_DATA,\n'BGNSTR'       => INTEGER_2,\n'STRNAME'      => ACSII_STRING,\n'ENDSTR'       => NO_REC_DATA,\n'BOUNDARY'     => NO_REC_DATA,\n'PATH'         => NO_REC_DATA,\n'SREF'         => NO_REC_DATA,\n'AREF'         => NO_REC_DATA,\n'TEXT'         => NO_REC_DATA,\n'LAYER'        => INTEGER_2,\n'DATATYPE'     => INTEGER_2,\n'WIDTH'        => INTEGER_4,\n'XY'           => INTEGER_4,\n'ENDEL'        => NO_REC_DATA,\n'SNAME'        => ACSII_STRING,\n'COLROW'       => INTEGER_2,\n'TEXTNODE'     => NO_REC_DATA,\n'NODE'         => NO_REC_DATA,\n'TEXTTYPE'     => INTEGER_2,\n'PRESENTATION' => BIT_ARRAY,\n'SPACING'      => UNKNOWN, \n'STRING'       => ACSII_STRING,\n'STRANS'       => BIT_ARRAY,\n'MAG'          => REAL_8,\n'ANGLE'        => REAL_8,\n'UINTEGER'     => UNKNOWN, \n'USTRING'      => UNKNOWN, \n'REFLIBS'      => ACSII_STRING,\n'FONTS'        => ACSII_STRING,\n'PATHTYPE'     => INTEGER_2,\n'GENERATIONS'  => INTEGER_2,\n'ATTRTABLE'    => ACSII_STRING,\n'STYPTABLE'    => ACSII_STRING, \n'STRTYPE'      => INTEGER_2, \n'EFLAGS'       => BIT_ARRAY,\n'ELKEY'        => INTEGER_4, \n'LINKTYPE'     => INTEGER_2, \n'LINKKEYS'     => INTEGER_4, \n'NODETYPE'     => INTEGER_2, \n'PROPATTR'     => INTEGER_2,\n'PROPVALUE'    => ACSII_STRING,\n'BOX'          => NO_REC_DATA,\n'BOXTYPE'      => INTEGER_2,\n'PLEX'         => INTEGER_4,\n'BGNEXTN'      => INTEGER_4,\n'ENDEXTN'      => INTEGER_4,\n'TAPENUM'      => INTEGER_2,\n'TAPECODE'     => INTEGER_2,\n'STRCLASS'     => UNKNOWN,\n'RESERVED'     => INTEGER_4,\n'FORMAT'       => INTEGER_2,\n'MASK'         => ACSII_STRING,\n'ENDMASKS'     => NO_REC_DATA,\n'LIBDIRSIZE'   => UNKNOWN, \n'SRFNAME'      => ACSII_STRING,\n'LIBSECUR'     => UNKNOWN, \n);\n\n$GDS2::DefaultClass = 'GDS2' unless defined $GDS2::DefaultClass;\nmy $G_epsilon=0.000001; \n\n\n\n\n\nsub new \n{\n    my($class,%arg) = @_;\n    my $self = {};\n    bless $self,$class || ref $class || $GDS2::DefaultClass;\n    my $fileName = $arg{'-fileName'};\n    if (! defined $fileName)\n    {\n        die \"new expects a gds2 file name. Missing -fileName => 'name' $!\";\n    }\n    my $resolution = $arg{'-resolution'};\n    if (! defined $resolution)\n    {\n        $resolution=1000;\n    }\n    die \"new expects a positive integer resolution. ($resolution) $!\" if (($resolution <= 0) || ($resolution !~ m|^\\d+$|));\n    my $lockMode = LOCK_SH;   \n    my $openModStr = substr($fileName,0,2);  \n    $openModStr =~ s|^\\s+||;\n    $openModStr =~ s|[^\\+>]+||g;\n    my $openModeNum = O_RDONLY;\n    if ($openModStr =~ m|^\\+|)\n    {\n        warn(\"Ignoring '+' in open mode\"); \n        $openModStr =~ s|\\++||;\n    }\n    if ($openModStr eq '>')\n    {\n        $openModeNum = O_WRONLY|O_CREAT;\n        $lockMode = LOCK_EX;\n        $fileName =~ s|^$openModStr||;\n    }\n    elsif ($openModStr eq '>>')\n    {\n        $openModeNum = O_WRONLY|O_APPEND;\n        $lockMode = LOCK_EX;\n        $fileName =~ s|^$openModStr||;\n    }\n    my $fileHandle = new IO::File;\n    $fileHandle -> open(\"$fileName\",$openModeNum) or die \"Unable to open $fileName because $!\";\n    if (HAVE_FLOCK)\n    {\n        flock($fileHandle,$lockMode) or die \"File lock on $fileName failed because $!\";\n    }\n    binmode $fileHandle,':raw'; \n    $self -> {'Fd'}         = $fileHandle -> fileno;\n    $self -> {'FileHandle'} = $fileHandle;\n    $self -> {'FileName'}   = $fileName; \n    $self -> {'BytesDone'}  = 0;         \n    $self -> {'EOLIB'}      = FALSE;     \n    $self -> {'INHEADER'}   = UNKNOWN;   \n    $self -> {'INDATA'}     = FALSE;     \n    $self -> {'Length'}     = 0;         \n    $self -> {'DataType'}   = UNKNOWN;   \n    $self -> {'UUnits'}     = -1.0;      \n    $self -> {'DBUnits'}    = -1.0;      \n    $self -> {'Record'}     = '';        \n    $self -> {'RecordType'} = UNKNOWN;\n    $self -> {'DataIndex'}  = 0;\n    $self -> {'RecordData'} = ();\n    $self -> {'CurrentDataList'} = '';\n    $self -> {'InBoundary'} = FALSE;     \n    $self -> {'InTxt'}      = FALSE;     \n    $self -> {'DateFld'}    = 0;     \n    $self -> {'Resolution'} = $resolution;\n    $self -> {'UsingPrettyPrint'} = FALSE; \n    $self;\n}\n\n\nsub fileNum \n{\n    my($self,%arg) = @_;\n    int($self -> {'Fd'});\n}\n\n\nsub close \n{\n    my($self,%arg) = @_;\n    my $markEnd = $arg{'-markEnd'};\n    my $pad = $arg{'-pad'};\n    if ((defined $markEnd)&&($markEnd))\n    {\n        my $fh = $self -> {'FileHandle'};\n        print $fh \"\\x1a\\x04\"; \n        $self -> {'BytesDone'} += 2;\n    }\n    if ((defined $pad)&&($pad > 0))\n    {\n        my $fh = $self -> {'FileHandle'};\n        $fh -> flush;\n        seek($fh,0,SEEK_END);\n        my $fileSize = tell($fh);\n        my $padSize = $pad - ($fileSize % $pad);\n        $padSize=0 if ($padSize == $pad);\n        for (my $i=0; $i < $padSize; $i++)\n        {\n            print $fh \"\\0\"; \n        }\n    }\n    $self -> {'FileHandle'} -> close;\n}\n\n\n\n\n\nsub printInitLib \n{\n    my($self,%arg) = @_;\n    my $libName = $arg{'-name'};\n    if (! defined $libName)\n    {\n        die \"printInitLib expects a library name. Missing -name => 'name' $!\";\n    }\n    my $isoDate = $arg{'-isoDate'};\n    if (! defined $isoDate)\n    {\n        $isoDate = FALSE;\n    }\n    elsif ($isoDate != 0)\n    {\n        $isoDate = TRUE;\n    }\n\n    my $uUnit = $arg{'-uUnit'};\n    if (! defined $uUnit)\n    {\n        $uUnit = 0.001;\n    }\n    else\n    {\n        $self -> {'Resolution'} = (1 / $uUnit); \n    }\n    $self -> {'UUnits'} = $uUnit;\n    my $dbUnit = $arg{'-dbUnit'};\n    if (! defined $dbUnit)\n    {\n        $dbUnit = 1e-9;\n    }\n    $self -> {'DBUnits'} = $dbUnit;\n    \n    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);\n    $mon++;\n    $year += 1900 if ($isoDate); \n    $self -> printGds2Record(-type => 'HEADER',-data => 3); \n    $self -> printGds2Record(-type => 'BGNLIB',-data => [$year,$mon,$mday,$hour,$min,$sec,$year,$mon,$mday,$hour,$min,$sec]);\n    $self -> printGds2Record(-type => 'LIBNAME',-data => $libName);\n    $self -> printGds2Record(-type => 'UNITS',-data => [$uUnit,$dbUnit]);\n}\n\n\nsub printBgnstr \n{\n    my($self,%arg) = @_;\n\n    my $strName = $arg{'-name'};\n    if (! defined $strName)\n    {\n        die \"bgnStr expects a structure name. Missing -name => 'name' $!\";\n    }\n    my $createTime = $arg{'-createTime'};\n    my $isoDate = $arg{'-isoDate'};\n    if (! defined $isoDate)\n    {\n        $isoDate = FALSE;\n    }\n    elsif ($isoDate != 0)\n    {\n        $isoDate = TRUE;\n    }\n    my ($csec,$cmin,$chour,$cmday,$cmon,$cyear,$cwday,$cyday,$cisdst);\n    if (defined $createTime)\n    {\n        ($csec,$cmin,$chour,$cmday,$cmon,$cyear,$cwday,$cyday,$cisdst) = localtime($createTime);\n    }\n    else\n    {\n        ($csec,$cmin,$chour,$cmday,$cmon,$cyear,$cwday,$cyday,$cisdst) = localtime(time);\n    }\n    $cmon++;\n\n    my $modTime = $arg{'-modTime'};\n    my ($msec,$mmin,$mhour,$mmday,$mmon,$myear,$mwday,$myday,$misdst);\n    if (defined $modTime)\n    {\n        ($msec,$mmin,$mhour,$mmday,$mmon,$myear,$mwday,$myday,$misdst) = localtime($modTime);\n    }\n    else\n    {\n        ($msec,$mmin,$mhour,$mmday,$mmon,$myear,$mwday,$myday,$misdst) = localtime(time);\n    }\n    $mmon++;\n\n    if ($isoDate)\n    {\n        $cyear += 1900;  \n        $myear += 1900;\n    }\n    $self -> printGds2Record(-type => 'BGNSTR',-data => [$cyear,$cmon,$cmday,$chour,$cmin,$csec,$myear,$mmon,$mmday,$mhour,$mmin,$msec]);\n    $self -> printGds2Record(-type => 'STRNAME',-data => $strName);\n}\n\n\nsub printPath \n{\n    my($self,%arg) = @_;\n    my $resolution = $self -> {'Resolution'};\n    my $layer = $arg{'-layer'};\n    $layer=0 if (! defined $layer);\n\n    my $dataType = $arg{'-dataType'};\n    $dataType=0 if (! defined $dataType);\n\n    my $pathType = $arg{'-pathType'};\n    $pathType=0 if (! defined $pathType);\n\n    my $bgnExtn = $arg{'-bgnExtn'};\n    $bgnExtn=0 if (! defined $bgnExtn);\n\n    my $endExtn = $arg{'-endExtn'};\n    $endExtn=0 if (! defined $endExtn);\n    \n    my $unitWidth = $arg{'-unitWidth'};\n    my $widthReal = $arg{'-width'};\n    my $width = 0;\n    if ((defined $unitWidth)&&($unitWidth >= 0))\n    {\n        $width=int($unitWidth);\n    }\n    if ((defined $widthReal)&&($widthReal >= 0.0))\n    {\n        $width = int(($widthReal*$resolution)+$G_epsilon);\n    }\n    my $xyInt = $arg{'-xyInt'}; \n    my $xy = $arg{'-xy'};       \n    my @xyTmp=();               \n    if (! ((defined $xy) || (defined $xyInt)))\n    {\n        die \"printPath expects an xy array reference. Missing -xy => \\\\\\@array $!\";\n    }\n    if (defined $xyInt)\n    {\n        $xy = $xyInt;\n        $resolution=1;\n    }\n    $self -> printGds2Record(-type => 'PATH');\n    $self -> printGds2Record(-type => 'LAYER',-data => $layer);\n    $self -> printGds2Record(-type => 'DATATYPE',-data => $dataType);\n    $self -> printGds2Record(-type => 'PATHTYPE',-data => $pathType) if ($pathType);\n    $self -> printGds2Record(-type => 'WIDTH',-data => $width) if ($width);\n    if ($pathType == 4)\n    {\n        $self -> printGds2Record(-type => 'BGNEXTN',-data => $bgnExtn); \n        $self -> printGds2Record(-type => 'ENDEXTN',-data => $endExtn); \n    }\n    for(my $i=0;$i<=$#$xy;$i++) \n    {\n        if ($xy -> [$i] >= 0) { push @xyTmp,int((($xy -> [$i])*$resolution)+$G_epsilon);}\n        else                  { push @xyTmp,int((($xy -> [$i])*$resolution)-$G_epsilon);}\n    }\n    if ($bgnExtn || $endExtn) \n    {\n        my $bgnX1 = $xyTmp[0];\n        my $bgnY1 = $xyTmp[1];\n        my $bgnX2 = $xyTmp[2];\n        my $bgnY2 = $xyTmp[3];\n        my $endX1 = $xyTmp[$#xyTmp - 1];\n        my $endY1 = $xyTmp[$#xyTmp];\n        my $endX2 = $xyTmp[$#xyTmp - 3];\n        my $endY2 = $xyTmp[$#xyTmp - 2];\n        if ($bgnExtn)\n        {\n            if ($bgnX1 == $bgnX2) \n            {\n                if ($bgnY1 < $bgnY2) \n                {\n                    $xyTmp[1] -= $bgnExtn;\n                    $xyTmp[1] += int($width/2) if ($pathType != 0);\n                }\n                else \n                {\n                    $xyTmp[1] += $bgnExtn;\n                    $xyTmp[1] -= int($width/2) if ($pathType != 0);\n                }\n            }\n            elsif ($bgnY1 == $bgnY2) \n            {\n                if ($bgnX1 < $bgnX2) \n                {\n                    $xyTmp[0] -= $bgnExtn;\n                    $xyTmp[0] += int($width/2) if ($pathType != 0);\n                }\n                else \n                {\n                    $xyTmp[0] += $bgnExtn;\n                    $xyTmp[0] -= int($width/2) if ($pathType != 0);\n                }\n            }\n        }\n\n        if ($endExtn)\n        {\n            if ($endX1 == $endX2) \n            {\n                if ($endY1 < $endY2) \n                {\n                    $xyTmp[$#xyTmp] -= $endExtn;\n                    $xyTmp[$#xyTmp] += int($width/2) if ($pathType != 0);\n                }\n                else \n                {\n                    $xyTmp[$#xyTmp] += $endExtn;\n                    $xyTmp[$#xyTmp] -= int($width/2) if ($pathType != 0);\n                }\n            }\n            elsif ($endY1 == $endY2) \n            {\n                if ($endX1 < $endX2) \n                {\n                    $xyTmp[$#xyTmp - 1] -= $endExtn;\n                    $xyTmp[$#xyTmp - 1] += int($width/2) if ($pathType != 0);\n                }\n                else \n                {\n                    $xyTmp[$#xyTmp - 1] += $endExtn;\n                    $xyTmp[$#xyTmp - 1] -= int($width/2) if ($pathType != 0);\n                }\n            }\n        }\n    }\n    $self -> printGds2Record(-type => 'XY',-data => \\@xyTmp);\n    $self -> printGds2Record(-type => 'ENDEL');\n}\n\n\nsub printBoundary \n{\n    my($self,%arg) = @_;\n    my $resolution = $self -> {'Resolution'};\n    my $layer = $arg{'-layer'};\n    if (! defined $layer)\n    {\n        $layer=0;\n    }\n    my $dataType = $arg{'-dataType'};\n    if (! defined $dataType)\n    {\n        $dataType=0;\n    }\n    my $xyInt = $arg{'-xyInt'}; \n    my $xy = $arg{'-xy'}; \n    my @xyTmp=(); \n    if (! ((defined $xy) || (defined $xyInt)))\n    {\n        die \"printBoundary expects an xy array reference. Missing -xy => \\\\\\@array $!\";\n    }\n    if (defined $xyInt)\n    {\n        $xy = $xyInt;\n        $resolution=1;\n    }\n    $self -> printGds2Record(-type => 'BOUNDARY');\n    $self -> printGds2Record(-type => 'LAYER',-data => $layer);\n    $self -> printGds2Record(-type => 'DATATYPE',-data => $dataType);\n    if (my $numPoints=$#$xy+1 < 6)\n    {\n        die \"printBoundary expects an xy array of at leasts 3 coordinates $!\";\n    }\n    for(my $i=0;$i<=$#$xy;$i++) \n    {\n        if ($xy -> [$i] >= 0) {push @xyTmp,int((($xy -> [$i])*$resolution)+$G_epsilon);}\n        else                  {push @xyTmp,int((($xy -> [$i])*$resolution)-$G_epsilon);}\n    }\n    if (($xy -> [0] != ($xy -> [($#$xy - 1)])) || ($xy -> [1] != ($xy -> [$#$xy])))\n    {\n        if ($xy -> [0] >= 0) {push @xyTmp,int((($xy -> [0])*$resolution)+$G_epsilon);}\n        else                 {push @xyTmp,int((($xy -> [0])*$resolution)-$G_epsilon);}\n        if ($xy -> [1] >= 0) {push @xyTmp,int((($xy -> [1])*$resolution)+$G_epsilon);}\n        else                 {push @xyTmp,int((($xy -> [1])*$resolution)-$G_epsilon);}\n    }\n    $self -> printGds2Record(-type => 'XY',-data => \\@xyTmp);\n    $self -> printGds2Record(-type => 'ENDEL');\n}\n\n\nsub printSref \n{\n    my($self,%arg) = @_;\n    my $useSTRANS=FALSE;\n    my $resolution = $self -> {'Resolution'};\n    my $sname = $arg{'-name'};\n    if (! defined $sname)\n    {\n        die \"printSref expects a name string. Missing -name => 'text' $!\";\n    }\n    my $xyInt = $arg{'-xyInt'}; \n    my $xy = $arg{'-xy'}; \n    if (! ((defined $xy) || (defined $xyInt)))\n    {\n        die \"printSref expects an xy array reference. Missing -xy => \\\\\\@array $!\";\n    }\n    if (defined $xyInt)\n    {\n        $xy = $xyInt;\n        $resolution=1;\n    }\n    $self -> printGds2Record(-type => 'SREF');\n    $self -> printGds2Record(-type => 'SNAME',-data => $sname);\n    my $reflect = $arg{'-reflect'};\n    if ((! defined $reflect)||($reflect <= 0))\n    {\n        $reflect=0;\n    }\n    else\n    {\n        $reflect=1;\n        $useSTRANS=TRUE;\n    }\n    my $mag = $arg{'-mag'};\n    if ((! defined $mag)||($mag <= 0))\n    {\n        $mag=0;\n    }\n    else\n    {\n        $useSTRANS=TRUE;\n    }\n    my $angle = $arg{'-angle'};\n    if (! defined $angle)\n    {\n        $angle=0;\n    }\n    else\n    { \n        $angle=posAngle($angle);\n        $useSTRANS=TRUE;\n    }\n    if ($useSTRANS)\n    {\n        my $data=$reflect.'0'x15; \n        $self -> printGds2Record(-type => 'STRANS',-data => $data);\n        $self -> printGds2Record(-type => 'MAG',-data => $mag) if ($mag);\n        $self -> printGds2Record(-type => 'ANGLE',-data => $angle) if ($angle);\n    }\n    my @xyTmp=(); \n    for(my $i=0;$i<=$#$xy;$i++) \n    {\n        if ($xy -> [$i] >= 0) {push @xyTmp,int((($xy -> [$i])*$resolution)+$G_epsilon);}\n        else                  {push @xyTmp,int((($xy -> [$i])*$resolution)-$G_epsilon);}\n    }\n    $self -> printGds2Record(-type => 'XY',-data => \\@xyTmp);\n    $self -> printGds2Record(-type => 'ENDEL');\n}\n\n\nsub printAref \n{\n    my($self,%arg) = @_;\n    my $useSTRANS=FALSE;\n    my $resolution = $self -> {'Resolution'};\n    my $sname = $arg{'-name'};\n    if (! defined $sname)\n    {\n        die \"printAref expects a sname string. Missing -name => 'text' $!\";\n    }\n    my $xyInt = $arg{'-xyInt'}; \n    my $xy = $arg{'-xy'}; \n    if (! ((defined $xy) || (defined $xyInt)))\n    {\n        die \"printAref expects an xy array reference. Missing -xy => \\\\\\@array $!\";\n    }\n    if (defined $xyInt)\n    {\n        $xy = $xyInt;\n        $resolution=1;\n    }\n    $self -> printGds2Record(-type => 'AREF');\n    $self -> printGds2Record(-type => 'SNAME',-data => $sname);\n    my $reflect = $arg{'-reflect'};\n    if ((! defined $reflect)||($reflect <= 0))\n    {\n        $reflect=0;\n    }\n    else\n    {\n        $reflect=1;\n        $useSTRANS=TRUE;\n    }\n    my $mag = $arg{'-mag'};\n    if ((! defined $mag)||($mag <= 0))\n    {\n        $mag=0;\n    }\n    else\n    {\n        $useSTRANS=TRUE;\n    }\n    my $angle = $arg{'-angle'};\n    if (! defined $angle)\n    {\n        $angle=0;\n    }\n    else\n    {\n        $angle=posAngle($angle);\n        $useSTRANS=TRUE;\n    }\n    if ($useSTRANS)\n    {\n        my $data=$reflect.'0'x15; \n        $self -> printGds2Record(-type => 'STRANS',-data => $data);\n        $self -> printGds2Record(-type => 'MAG',-data => $mag) if ($mag);\n        $self -> printGds2Record(-type => 'ANGLE',-data => $angle) if ($angle);\n    }\n    my $columns = $arg{'-columns'};\n    if ((! defined $columns)||($columns <= 0))\n    {\n        $columns=1;\n    }\n    else\n    {\n        $columns=int($columns);\n    }\n    my $rows = $arg{'-rows'};\n    if ((! defined $rows)||($rows <= 0))\n    {\n        $rows=1;\n    }\n    else\n    {\n        $rows=int($rows);\n    }\n    $self -> printGds2Record(-type => 'COLROW',-data => [$columns,$rows]);\n    my @xyTmp=(); \n    for(my $i=0;$i<=$#$xy;$i++) \n    {\n        if ($xy -> [$i] >= 0) {push @xyTmp,int((($xy -> [$i])*$resolution)+$G_epsilon);}\n        else                  {push @xyTmp,int((($xy -> [$i])*$resolution)-$G_epsilon);}\n    }\n    $self -> printGds2Record(-type => 'XY',-data => \\@xyTmp);\n    $self -> printGds2Record(-type => 'ENDEL');\n}\n\n\nsub printText \n{\n    my($self,%arg) = @_;\n    my $useSTRANS=FALSE;\n    my $string = $arg{'-string'};\n    if (! defined $string)\n    {\n        die \"printText expects a string. Missing -string => 'text' $!\";\n    }\n    my $resolution = $self -> {'Resolution'};\n    my $x = $arg{'-x'};\n    my $y = $arg{'-y'};\n    my $xyInt = $arg{'-xyInt'}; \n    my $xy = $arg{'-xy'}; \n    if (defined $xyInt)\n    {\n        $xy = $xyInt;\n        $resolution=1;\n    }\n    if (defined $xy)\n    {\n        $x = $xy -> [0];\n        $y = $xy -> [1];\n    }\n\n    my $x2 = $arg{'-x'};\n    if (defined $x2)\n    {\n        $x = $x2;\n    }\n    if (! defined $x)\n    {\n        die \"printText expects a x coord. Missing -xy=>\\@array or -x => 'num' $!\";\n    }\n    if ($x>=0) {$x = int(($x*$resolution)+$G_epsilon);}\n    else       {$x = int(($x*$resolution)-$G_epsilon);}\n\n    my $y2 = $arg{'-y'};\n    if (defined $y2)\n    {\n        $y = $y2;\n    }\n    if (! defined $y)\n    {\n        die \"printText expects a y coord. Missing -xy=>\\@array or -y => 'num' $!\";\n    }\n    if ($y>=0) {$y = int(($y*$resolution)+$G_epsilon);}\n    else       {$y = int(($y*$resolution)-$G_epsilon);}\n\n    my $layer = $arg{'-layer'};\n    if (! defined $layer)\n    {\n        $layer=0;\n    }\n    my $textType = $arg{'-textType'};\n    if (! defined $textType)\n    {\n        $textType=0;\n    }\n    my $reflect = $arg{'-reflect'};\n    if ((! defined $reflect)||($reflect <= 0))\n    {\n        $reflect=0;\n    }\n    else\n    {\n        $reflect=1;\n        $useSTRANS=TRUE;\n    }\n\n    my $font = $arg{'-font'};\n    if ((! defined $font) || ($font < 0) || ($font > 3))\n    {\n        $font=0;\n    }\n    $font = sprintf(\"%02d\",$font);\n\n    my $vertical;\n    my $top = $arg{'-top'};\n    my $middle = $arg{'-middle'};\n    my $bottom = $arg{'-bottom'};\n    if    (defined $top)    {$vertical = '00';}\n    elsif (defined $bottom) {$vertical = '10';}\n    else                    {$vertical = '01';} \n    my $horizontal; \n    my $left   = $arg{'-left'};\n    my $center = $arg{'-center'};\n    my $right  = $arg{'-right'};\n    if    (defined $left)  {$horizontal = '00';}\n    elsif (defined $right) {$horizontal = '10';}\n    else                   {$horizontal = '01';} \n    my $presString = '0'x10;\n    $presString .= \"$font$vertical$horizontal\";\n\n    my $mag = $arg{'-mag'};\n    if ((! defined $mag)||($mag <= 0))\n    {\n        $mag=0;\n    }\n    my $angle = $arg{'-angle'};\n    if (! defined $angle)\n    {\n        $angle=0;\n    }\n    else\n    {\n        $angle=posAngle($angle);\n    }\n    $self -> printGds2Record(-type=>'TEXT');\n    $self -> printGds2Record(-type=>'LAYER',-data=>$layer);\n    $self -> printGds2Record(-type=>'TEXTTYPE',-data=>$textType);\n    $self -> printGds2Record(-type => 'PRESENTATION',-data => $presString) if (defined $font || defined $top || defined $middle || defined $bottom || defined $bottom || defined $left || defined $center || defined $right);\n    if ($useSTRANS)\n    {\n        my $data=$reflect.'0'x15; \n        $self -> printGds2Record(-type=>'STRANS',-data=>$data);\n    }\n    $self -> printGds2Record(-type=>'MAG',-data=>$mag) if ($mag);\n    $self -> printGds2Record(-type=>'ANGLE',-data=>$angle) if ($angle);\n    $self -> printGds2Record(-type=>'XY',-data=>[$x,$y]);\n    $self -> printGds2Record(-type=>'STRING',-data=>$string);\n    $self -> printGds2Record(-type=>'ENDEL');\n}\n\n\n\n\nsub saveGds2Record \n{\n    my ($self,%arg) = @_;\n    my $record='';\n\n    my $type = $arg{'-type'};\n    if (! defined $type)\n    {\n        die \"saveGds2Record expects a type name. Missing -type => 'name' $!\";\n    }\n    else\n    {\n        $type = uc $type;\n    }\n\n    my $saveEnd=$\\;\n    $\\='';\n\n    my @data = $arg{'-data'};\n    my $dataString = $arg{'-asciiData'};\n    die \"saveGds2Record can not handle both -data and -asciiData options $!\" if ((defined $dataString)&&((defined $data[0])&&($data[0] ne '')));\n\n    my $data = '';\n    if ($type eq 'RECORD') \n    {\n        return $data[0];\n    }\n    else\n    {\n        my $numDataElements = 0;\n        my $resolution = $self -> {'Resolution'};\n\n        my $scale = $arg{'-scale'};\n        if (! defined $scale)\n        {\n            $scale=1;\n        }\n        if ($scale <= 0)\n        {\n            die \"saveGds2Record expects a positive scale -scale => $scale $!\";\n        }\n\n        my $snap = $arg{'-snap'};\n        if (! defined $snap) \n        {\n            $snap = 1;\n        }\n        else\n        {\n            $snap = $snap*$resolution; \n        }\n        if ($snap < 1)\n        {\n            die \"saveGds2Record expects a snap >= 1/resolution -snap => $snap $!\";\n        }\n\n        if ((defined $data[0])&&($data[0] ne ''))\n        {\n            $data = $data[0];\n            $numDataElements = @$data;\n            if ($numDataElements) \n            {\n                @data = @$data; \n            }\n            else\n            {\n                $numDataElements = @data;\n            }\n        }\n\n        my $recordDataType = $RecordTypeData{$type};\n        if (defined $dataString)\n        {\n            $dataString=~s|^\\s+||; \n            $dataString=~s|\\s+$||;\n            $dataString=~s|\\s+| |g if ($dataString !~ m|'|); \n            $dataString=~s|'$||; \n            $dataString=~s|^'||; \n            if (($recordDataType == BIT_ARRAY)||($recordDataType == ACSII_STRING))\n            {\n                $data = $dataString;\n            }\n            else\n            {\n                $dataString=~s|\\s*[\\s,;:/\\\\]+\\s*| |g; \n                @data = split(' ',$dataString);\n                $numDataElements = @data;\n                if ($recordDataType == INTEGER_4)\n                {\n                    my @xyTmp=();\n                    for(my $i=0;$i<$numDataElements;$i++) \n                    {\n                        if ($data[$i]>=0) {push @xyTmp,int((($data[$i])*$resolution)+$G_epsilon);}\n                        else              {push @xyTmp,int((($data[$i])*$resolution)-$G_epsilon);}\n                    }\n                    @data=@xyTmp;\n                }\n            }\n        }\n        my $byte;\n        my $length = 0;\n        if ($recordDataType == BIT_ARRAY)\n        {\n            $length = 2;\n        }\n        elsif ($recordDataType == INTEGER_2)\n        {\n            $length = 2 * $numDataElements;\n        }\n        elsif ($recordDataType == INTEGER_4)\n        {\n            $length = 4 * $numDataElements;\n        }\n        elsif ($recordDataType == REAL_8)\n        {\n            $length = 8 * $numDataElements;\n        }\n        elsif ($recordDataType == ACSII_STRING)\n        {\n            my $slen = length $data;\n            $length = $slen + ($slen % 2); \n        }\n\n        my $recordLength = pack 'S',($length + 4); \n        $record .= $recordLength;\n        my $recordType = pack 'C',$RecordTypeNumbers{$type};\n        $record .= $recordType;\n\n        my $dataType   = pack 'C',$RecordTypeData{$type};\n        $record .= $dataType;\n\n        if ($recordDataType == BIT_ARRAY)     \n        {\n            my $bitLength = $length * 8;\n            $record .= pack(\"B$bitLength\",$data);\n        }\n        elsif ($recordDataType == INTEGER_2)  \n        {\n            foreach my $num (@data)\n            {\n                $record .= pack('s',$num);\n            }\n        }\n        elsif ($recordDataType == INTEGER_4)  \n        {\n            foreach my $num (@data)\n            {\n                $num = scaleNum($num,$scale) if ($scale != 1);\n                $num = snapNum($num,$snap) if ($snap != 1);\n                $record .= pack('i',$num);\n            }\n        }\n        elsif ($recordDataType == REAL_8)  \n        {\n            foreach my $num (@data)\n            {\n                my $real = $num;\n                my $negative = FALSE;\n                if($num < 0.0) \n                {\n                    $negative = TRUE;\n                    $real = 0 - $num;\n                }\n\n                my $exponent = 0;\n                while($real >= 1.0) \n                {\n                    $exponent++;\n                    $real = ($real / 16.0);\n                }\n\n                if ($real != 0) \n                {\n                    while($real < 0.0625) \n                    {\n                        --$exponent;\n                        $real = ($real * 16.0);\n                    }\n                }\n\n                if($negative) { $exponent += 192; }\n                else          { $exponent += 64; }\n                $record .= pack('C',$exponent);\n\n                for (my $i=1; $i<=7; $i++) \n                {\n                    if ($real>=0) {$byte = int(($real*256.0)+$G_epsilon);}\n                    else          {$byte = int(($real*256.0)-$G_epsilon);}\n                    $record .= pack('C',$byte);\n                    $real = $real * 256.0 - ($byte + 0.0);\n                }\n            }\n        }\n        elsif ($recordDataType == ACSII_STRING)  \n        {\n            $record .= pack(\"a$length\",$data);\n        }\n    }\n    $\\=$saveEnd;\n    $record;\n}\n\n\nsub printGds2Record \n{\n    my ($self,%arg) = @_;\n\n    my $type = $arg{'-type'};\n    if (! defined $type)\n    {\n        die \"printGds2Record expects a type name. Missing -type => 'name' $!\";\n    }\n    else\n    {\n        $type = uc $type;\n    }\n    my @data = $arg{'-data'};\n    my $dataString = $arg{'-asciiData'};\n    die \"printGds2Record can not handle both -data and -asciiData options $!\" if ((defined $dataString)&&((defined $data[0])&&($data[0] ne '')));\n\n    my $fh = $self -> {'FileHandle'};\n    my $saveEnd=$\\;\n    $\\='';\n\n    my $data = '';\n    my $recordLength; \n    if ($type eq 'RECORD') \n    {\n        if ($isLittleEndian)\n        {\n            my $length = substr($data[0],0,2);\n            $recordLength = unpack 'v',$length;\n            $self -> {'BytesDone'} += $recordLength;\n            $length = reverse $length;\n            print($fh $length);\n\n            my $recordType = substr($data[0],2,1);\n            print($fh $recordType);\n            $recordType = unpack 'C',$recordType;\n            $type = $RecordTypeStrings[$recordType]; \n\n            my $dataType = substr($data[0],3,1);\n            print($fh $dataType);\n            $dataType = unpack 'C',$dataType;\n            if ($recordLength > 4)\n            {\n                my $lengthLeft = $recordLength - 4; \n                my $recordDataType = $RecordTypeData{$type};\n\n                if (($recordDataType == INTEGER_2) || ($recordDataType == BIT_ARRAY))\n                {\n                    my $binData = unpack 'b*',$data[0];\n                    my $intData = substr($binData,32); \n                    \n                    my ($byteInt2String,$byte2);\n                    for(my $i=0; $i<($lengthLeft/2); $i++)\n                    {\n                        $byteInt2String = reverse(substr($intData,0,16,''));\n                        $byte2=pack 'B16',reverse($byteInt2String);\n                        print($fh $byte2);\n                    }\n                }\n                elsif ($recordDataType == INTEGER_4)\n                {\n                    my $binData = unpack 'b*',$data[0];\n                    my $intData = substr($binData,32); \n                    my ($byteInt4String,$byte4);\n                    for(my $i=0; $i<($lengthLeft/4); $i++)\n                    {\n                        $byteInt4String = reverse(substr($intData,0,32,''));\n                        $byte4=pack 'B32',reverse($byteInt4String);\n                        print($fh $byte4);\n                    }\n                }\n                elsif ($recordDataType == REAL_8)\n                {\n                    my $binData = unpack 'b*',$data[0];\n                    my $realData = substr($binData,32); \n                    my ($bit64String,$mantissa,$byteString,$byte);\n                    for(my $i=0; $i<($lengthLeft/8); $i++)\n                    {\n                        $bit64String = substr($realData,($i*64),64);\n                        print($fh pack 'b8',$bit64String);\n                        $mantissa = substr($bit64String,8,56);\n                        for(my $j=0; $j<7; $j++)\n                        {\n                            $byteString = substr($mantissa,($j*8),8);\n                            $byte=pack 'b8',$byteString;\n                            print($fh $byte);\n                        }\n                    }\n                }\n                elsif ($recordDataType == ACSII_STRING)  \n                {\n                    print($fh pack(\"a$lengthLeft\",substr($data[0],4)));\n                }\n                elsif ($recordDataType == REAL_4)  \n                {\n                    die \"4-byte reals are not supported $!\";\n                }\n            }\n        }\n        else\n        {\n            print($fh $data[0]);\n            $recordLength = length $data[0];\n            $self -> {'BytesDone'} += $recordLength;\n        }\n    }\n    else \n    {\n        my $numDataElements = 0;\n        my $resolution = $self -> {'Resolution'};\n        my $uUnits = $self -> {'UUnits'};\n\n        my $scale = $arg{'-scale'};\n        if (! defined $scale)\n        {\n            $scale=1;\n        }\n        if ($scale <= 0)\n        {\n            die \"printGds2Record expects a positive scale -scale => $scale $!\";\n        }\n\n        my $snap = $arg{'-snap'};\n        if (! defined $snap) \n        {\n            $snap = 1;\n        }\n        else\n        {\n            $snap = int(($snap*$resolution)+$G_epsilon); \n        }\n        if ($snap < 1)\n        {\n            die \"printGds2Record expects a snap >= 1/resolution -snap => $snap $!\";\n        }\n\n        if ((defined $data[0])&&($data[0] ne ''))\n        {\n            $data = $data[0];\n            $numDataElements = @$data;\n            if ($numDataElements) \n            {\n                @data = @$data; \n            }\n            else\n            {\n                $numDataElements = @data;\n            }\n        }\n\n        my $recordDataType = $RecordTypeData{$type};\n        \n        if (defined $dataString)\n        {\n            $dataString=~s|^\\s+||; \n            $dataString=~s|\\s+$||;\n            $dataString=~s|\\s+| |g if ($dataString !~ m|'|); \n            $dataString=~s|'$||; \n            $dataString=~s|^'||; \n            if (($recordDataType == BIT_ARRAY)||($recordDataType == ACSII_STRING))\n            {\n                $data = $dataString;\n            }\n            else\n            {\n                $dataString=~s|\\s*[\\s,;:/\\\\]+\\s*| |g; \n                @data = split(' ',$dataString);\n                $numDataElements = @data;\n                if ($recordDataType == INTEGER_4)\n                {\n                    my @xyTmp=();\n                    for(my $i=0;$i<$numDataElements;$i++) \n                    {\n                        if ($data[$i]>=0) {push @xyTmp,int((($data[$i])*$resolution)+$G_epsilon);}\n                        else              {push @xyTmp,int((($data[$i])*$resolution)-$G_epsilon);}\n                    }\n                    @data=@xyTmp;\n                }\n            }\n        }\n        my $byte;\n        my $length = 0;\n        if ($recordDataType == BIT_ARRAY)\n        {\n            $length = 2;\n        }\n        elsif ($recordDataType == INTEGER_2)\n        {\n            $length = 2 * $numDataElements;\n        }\n        elsif ($recordDataType == INTEGER_4)\n        {\n            $length = 4 * $numDataElements;\n        }\n        elsif ($recordDataType == REAL_8)\n        {\n            $length = 8 * $numDataElements;\n        }\n        elsif ($recordDataType == ACSII_STRING)\n        {\n            my $slen = length $data;\n            $length = $slen + ($slen % 2); \n        }\n        $self -> {'BytesDone'} += $length;\n        if ($isLittleEndian)\n        {\n            $recordLength = pack 'v',($length + 4);\n            $recordLength = reverse $recordLength;\n        }\n        else\n        {\n            $recordLength = pack 'S',($length + 4);\n        }\n        print($fh $recordLength);\n\n        my $recordType = pack 'C',$RecordTypeNumbers{$type};\n        $recordType = reverse $recordType if ($isLittleEndian);\n        print($fh $recordType);\n\n        my $dataType   = pack 'C',$RecordTypeData{$type};\n        $dataType = reverse $dataType if ($isLittleEndian);\n        print($fh $dataType);\n\n        if ($recordDataType == BIT_ARRAY)     \n        {\n            my $bitLength = $length * 8;\n            my $value = pack(\"B$bitLength\",$data);\n            print($fh $value);\n        }\n        elsif ($recordDataType == INTEGER_2)  \n        {\n            my $value;\n            foreach my $num (@data)\n            {\n                $value = pack('s',$num);\n                $value = reverse $value if ($isLittleEndian);\n                print($fh $value);\n            }\n        }\n        elsif ($recordDataType == INTEGER_4)  \n        {\n            my $value;\n            foreach my $num (@data)\n            {\n                $num = scaleNum($num,$scale) if ($scale != 1);\n                $num = snapNum($num,$snap) if ($snap != 1);\n                $value = pack('i',$num);\n                $value = reverse $value if ($isLittleEndian);\n                print($fh $value);\n            }\n        }\n        elsif ($recordDataType == REAL_8)  \n        {\n            my ($real,$negative,$exponent,$value);\n            foreach my $num (@data)\n            {\n                $real = $num;\n                $negative = FALSE;\n                if($num < 0.0) \n                {\n                    $negative = TRUE;\n                    $real = 0 - $num;\n                }\n\n                $exponent = 0;\n                while($real >= 1.0) \n                {\n                    $exponent++;\n                    $real = ($real / 16.0);\n                }\n\n                if ($real != 0) \n                {\n                    while($real < 0.0625) \n                    {\n                        --$exponent;\n                        $real = ($real * 16.0);\n                    }\n                }\n                if($negative) { $exponent += 192; }\n                else          { $exponent += 64; }\n                $value = pack('C',$exponent);\n                $value = reverse $value if ($isLittleEndian);\n                print($fh $value);\n\n                for (my $i=1; $i<=7; $i++) \n                {\n                    if ($real>=0) {$byte = int(($real*256.0)+$G_epsilon);}\n                    else          {$byte = int(($real*256.0)-$G_epsilon);}\n                    my $value = pack('C',$byte);\n                    $value = reverse $value if ($isLittleEndian);\n                    print($fh $value);\n                    $real = $real * 256.0 - ($byte + 0.0);\n                }\n            }\n        }\n        elsif ($recordDataType == ACSII_STRING)  \n        {\n            print($fh pack(\"a$length\",$data));\n        }\n    }\n    $\\=$saveEnd;\n}\n\n\nsub printRecord \n{\n    my ($self,%arg) = @_;\n    my $record = $arg{'-data'};\n    if (! defined $record)\n    {\n        die \"printGds2Record expects a data record. Missing -data => \\$record $!\";\n    }\n    my $type = $arg{'-type'};\n    if (defined $type)\n    {\n        die \"printRecord does not take -type. Perhaps you meant to use printGds2Record? $!\";\n    }\n    $self -> printGds2Record(-type=>'record',-data=>$record);\n}\n\n\n\n\n\nsub readGds2Record \n{\n    my $self = shift;\n    return \"\" if ($self -> {'EOLIB'});\n    $self -> readGds2RecordHeader();\n    $self -> readGds2RecordData();\n    $self -> {'INHEADER'} = FALSE;\n    $self -> {'INDATA'}   = TRUE; \n    $self -> {'Record'};\n}\n\n\nsub readGds2RecordHeader \n{\n    my $self = shift;\n\n    $self -> skipGds2RecordData() if ((! $self -> {'INDATA'}) && ($self -> {'INHEADER'} != UNKNOWN)) ; \n    $self -> {'Record'} = '';\n    $self -> {'RecordType'} = UNKNOWN;\n    $self -> {'INHEADER'} = TRUE; \n    $self -> {'INDATA'}   = FALSE;\n    return '' if ($self -> {'EOLIB'}); \n\n    my $buffer = '';\n    return 0 if (! read($self -> {'FileHandle'},$buffer,4));\n    my $data;\n    $data = substr($buffer,0,2);\n    {\n        $data = reverse $data if ($isLittleEndian);\n        $self -> {'Record'} = $data;\n        $self -> {'Length'} = unpack 'S',$data; \n        $self -> {'BytesDone'} += $self -> {'Length'};\n    }\n\n    $data = substr($buffer,2,1);\n    {\n        $data = reverse $data if ($isLittleEndian);\n        $self -> {'Record'} .= $data;\n        $self -> {'RecordType'} = unpack 'C',$data; \n        $self -> {'EOLIB'} = TRUE if (($self -> {'RecordType'}) == ENDLIB);\n\n        if ($self -> {'UsingPrettyPrint'})\n        {\n            putStrSpace('')   if (($self -> {'RecordType'}) == ENDSTR);\n            putStrSpace('  ') if (($self -> {'RecordType'}) == BGNSTR);\n\n            putElmSpace('  ') if ((($self -> {'RecordType'}) == TEXT) || (($self -> {'RecordType'}) == PATH) || \n                                 (($self -> {'RecordType'}) == BOUNDARY) || (($self -> {'RecordType'}) == SREF) || \n                                 (($self -> {'RecordType'}) == AREF));\n            if (($self -> {'RecordType'}) == ENDEL)\n            {\n                putElmSpace('');\n                $self -> {'InTxt'} = FALSE;\n                $self -> {'InBoundary'} = FALSE;\n            }\n            $self -> {'InTxt'} = TRUE if (($self -> {'RecordType'}) == TEXT);\n            $self -> {'InBoundary'} = TRUE if (($self -> {'RecordType'}) == BOUNDARY);\n            if ((($self -> {'RecordType'}) == LIBNAME) || (($self -> {'RecordType'}) == STRNAME))\n\n            {\n                $self -> {'DateFld'} = 0;\n            }\n            $self -> {'DateFld'} = 1 if ((($self -> {'RecordType'}) == BGNLIB) || (($self -> {'RecordType'}) == BGNSTR));\n        }\n    }\n\n    $data = substr($buffer,3,1);\n    {\n        $data = reverse $data if ($isLittleEndian);\n        $self -> {'Record'} .= $data;\n        $self -> {'DataType'} = unpack 'C',$data; \n    }\n    return 1;\n}\n\n\nsub readGds2RecordData \n{\n    my $self = shift;\n\n    $self -> readGds2RecordHeader() if ($self -> {'INHEADER'} != TRUE); \n    return $self -> {'Record'} if ($self -> {'DataType'} == NO_REC_DATA); \n    $self -> {'INHEADER'} = FALSE; \n    $self -> {'INDATA'}   = TRUE;  \n    $self -> {'RecordData'} = '';\n    $self -> {'RecordData'} = ();\n    $self -> {'CurrentDataList'} = '';\n    my $bytesLeft = $self -> {'Length'} - 4; \n    my $data;\n    if ($self -> {'DataType'} == BIT_ARRAY)     \n    {\n        $self -> {'DataIndex'}=0;\n        read($self -> {'FileHandle'},$data,$bytesLeft);\n        $data = reverse $data if ($isLittleEndian);\n        my $bitsLeft = $bytesLeft * 8;\n        $self -> {'Record'} .= $data;\n        $self -> {'RecordData'}[0] = unpack \"B$bitsLeft\",$data;\n        $self -> {'CurrentDataList'} = ($self -> {'RecordData'}[0]);\n    }\n    elsif ($self -> {'DataType'} == INTEGER_2)  \n    {\n        my $tmpListString = ''; \n        my $i = 0;\n        while ($bytesLeft)\n        {\n            read($self -> {'FileHandle'},$data,2);\n            $data = reverse $data if ($isLittleEndian);\n            $self -> {'Record'} .= $data;\n            $self -> {'RecordData'}[$i] = unpack 's',$data;\n            $tmpListString .= ',';\n            $tmpListString .= $self -> {'RecordData'}[$i];\n            $i++;\n            $bytesLeft -= 2;\n        }\n        $self -> {'DataIndex'} = $i - 1;\n        $self -> {'CurrentDataList'} = $tmpListString;\n    }\n    elsif ($self -> {'DataType'} == INTEGER_4)  \n    {\n        my $tmpListString = ''; \n        my $i = 0;\n        my $buffer = '';\n        read($self -> {'FileHandle'},$buffer,$bytesLeft); \n        for(my $start=0; $start < $bytesLeft; $start += 4)\n        {\n            $data = substr($buffer,$start,4);\n            $data = reverse $data if ($isLittleEndian);\n            $self -> {'Record'} .= $data;\n            $self -> {'RecordData'}[$i] = unpack 'i',$data;\n            $tmpListString .= ',';\n            $tmpListString .= $self -> {'RecordData'}[$i];\n            $i++;\n        }\n        $self -> {'DataIndex'} = $i - 1;\n        $self -> {'CurrentDataList'} = $tmpListString;\n    }\n    elsif ($self -> {'DataType'} == REAL_4)  \n    {\n        die \"4-byte reals are not supported $!\";\n    }\n    elsif ($self -> {'DataType'} == REAL_8)  \n    {\n        my $resolution = $self -> {'Resolution'};\n        my $tmpListString = ''; \n        my $i = 0;\n        my ($negative,$exponent,$mantdata,$byteString,$byte,$mantissa,$real);\n        while ($bytesLeft)\n        {\n            read($self -> {'FileHandle'},$data,1); \n            $self -> {'Record'} .= $data;\n            $negative = unpack 'B',$data; \n            $exponent = unpack 'C',$data;\n            if ($negative)\n            {\n                $exponent -= 192; \n            }\n            else\n            {\n                $exponent -= 64;\n            }\n            read($self -> {'FileHandle'},$data,7); \n            $mantdata = unpack 'b*',$data;\n            $self -> {'Record'} .= $data;\n            $mantissa = 0.0;\n            for(my $j=0; $j<7; $j++)\n            {\n                $byteString = substr($mantdata,0,8,'');\n                $byte = pack 'b*',$byteString;\n                $byte = unpack 'C',$byte;\n                $mantissa += $byte / (256.0**($j+1));\n            }\n            $real = $mantissa * (16**$exponent);\n            $real = (0 - $real) if ($negative);\n            if ($RecordTypeStrings[$self -> {'RecordType'}] eq 'UNITS')\n            {\n                if ($self -> {'UUnits'} == -1.0)\n                {\n                    $self -> {'UUnits'} = $real;\n                }\n                elsif ($self -> {'DBUnits'} == -1.0)\n                {\n                    $self -> {'DBUnits'} = $real;\n                }\n            }\n            else\n            {\n                $real = int(($real+($self -> {'UUnits'}/$resolution))/$self -> {'UUnits'})*$self -> {'UUnits'} if ($self -> {'UUnits'} != 0); \n            }\n            $self -> {'RecordData'}[$i] = $real;\n            $tmpListString .= ',';\n            $tmpListString .= $self -> {'RecordData'}[$i];\n            $i++;\n            $bytesLeft -= 8;\n        }\n        $self -> {'DataIndex'} = $i - 1;\n        $self -> {'CurrentDataList'} = $tmpListString;\n    }\n    elsif ($self -> {'DataType'} == ACSII_STRING)  \n    {\n        $self -> {'DataIndex'} = 0;\n        read($self -> {'FileHandle'},$data,$bytesLeft);\n        $self -> {'Record'} .= $data;\n        $self -> {'RecordData'}[0] = unpack \"a$bytesLeft\",$data;\n        $self -> {'RecordData'}[0] =~ s|\\0||g; \n        $self -> {'CurrentDataList'} = ($self -> {'RecordData'}[0]);\n    }\n    return 1;\n}\n\n\n\n\nsub returnRecordType \n{\n    my $self = shift;\n    $self -> {'RecordType'};\n}\n\n\nsub returnRecordTypeString \n{\n    my $self = shift;\n    $RecordTypeStrings[($self -> {'RecordType'})];\n}\n\n\nsub returnRecordAsString() \n{\n    my($self,%arg) = @_;\n    my $compact = $arg{'-compact'};\n    $compact = FALSE if (! defined $compact);\n    my $string = '';\n    $self -> {'UsingPrettyPrint'} = TRUE;\n    my $inText = $self -> {'InTxt'};\n    my $inBoundary = $self -> {'InBoundary'};\n    my $dateFld = $self -> {'DateFld'};\n    if (! $compact)\n    {\n        $string .= getStrSpace() if ($self -> {'RecordType'} != BGNSTR);\n        $string .= getElmSpace() if (!(\n                        ($self -> {'RecordType'} == BOUNDARY) ||\n                        ($self -> {'RecordType'} == PATH) || \n                        ($self -> {'RecordType'} == TEXT) ||\n                        ($self -> {'RecordType'} == SREF) || \n                        ($self -> {'RecordType'} == AREF)\n                    ));\n    }\n    my $recordType = $RecordTypeStrings[$self -> {'RecordType'}];\n    if ($compact)\n    {\n        $string .= $CompactRecordTypeStrings[$self -> {'RecordType'}];\n    }\n    else\n    {\n        $string .= $recordType;\n    }\n    my $i = 0;\n    while ($i <= $self -> {'DataIndex'})\n    {\n        if ($self -> {'DataType'} == BIT_ARRAY)\n        {\n            my $bitString = $self -> {'RecordData'}[$i];\n            if ($isLittleEndian)\n            {\n                $bitString =~ m|(........)(........)|;\n                $bitString = \"$2$1\";\n            }\n            if ($compact)\n            {\n                $string .= ' fx' if($bitString =~ m/^1/);\n                if ($inText && ($self -> {'RecordType'} != STRANS))\n                {\n                    $string .= ' f';\n                    $string .= '0' if ($bitString =~ m/00....$/);\n                    $string .= '1' if ($bitString =~ m/01....$/);\n                    $string .= '2' if ($bitString =~ m/10....$/);\n                    $string .= '3' if ($bitString =~ m/11....$/);\n                    $string .= ' t' if ($bitString =~ m/00..$/);\n                    $string .= ' m' if ($bitString =~ m/01..$/);\n                    $string .= ' b' if ($bitString =~ m/10..$/);\n                    $string .= 'l' if ($bitString =~ m/00$/);\n                    $string .= 'c' if ($bitString =~ m/01$/);\n                    $string .= 'r' if ($bitString =~ m/10$/);\n                }\n            }\n            else\n            {\n                $string .= '  '.$bitString;\n            }\n        }\n        elsif (\n            ($self -> {'DataType'} == INTEGER_2) ||\n            ($self -> {'DataType'} == REAL_8)\n        )\n        {\n            if ($compact)\n            {\n                if ($dateFld)\n                {\n                    my $num = $self -> {'RecordData'}[$i];\n                    if ($dateFld =~ m/^[17]$/)\n                    {\n                        if ($dateFld eq '1')\n                        {\n                            if ($recordType eq 'BGNLIB')\n                            {\n                               $string .= 'm=';\n                            }\n                            else\n                            {\n                               $string .= 'c=';\n                            }\n                        }\n                        elsif ($dateFld eq '7')\n                        {\n                            if ($recordType eq 'BGNLIB')\n                            {\n                               $string .= ' a=';\n                            }\n                            else\n                            {\n                               $string .= ' m=';\n                            }\n                        }\n                        $num += 1900 if ($num < 1900);\n                    }\n                    $num = sprintf(\"%02d\",$num);\n                    $string .= '-' if ($dateFld =~ m/^[2389]/);\n                    $string .= ':' if ($dateFld =~ m/^[56]/);\n                    $string .= ':' if ($dateFld =~ m/^1[12]/);\n                    $string .= ' ' if (($dateFld eq '4') || ($dateFld eq '10'));\n                    $string .= $num;\n                }\n                else\n                {\n                    $string .= ' ' unless ($string =~ m/ (a|m|pt|dt|tt)$/i);\n                    $string .= $self -> {'RecordData'}[$i];\n                }\n            }\n            else\n            {\n                $string .= '  ';\n                $string .= $self -> {'RecordData'}[$i];\n            }\n            if ($recordType eq 'UNITS')\n            {\n                $string =~ s|(\\d)\\.e|$1e|; \n                $string =~ s|(\\d)e\\-0+|$1e-|; \n            }\n        }\n        elsif ($self -> {'DataType'} == INTEGER_4)\n        {\n            if ($compact)\n            {\n                $string .= ' ' if ($i);\n            }\n            else\n            {\n                $string .= '  ';\n            }\n            $string .= $self -> {'RecordData'}[$i]*($self -> {'UUnits'});\n            if ($compact && $i && ($i == $#{$self -> {'RecordData'}}))\n            {\n                $string =~ s/ +[\\d\\.\\-]+ +[\\d\\.\\-]+$// if ($inBoundary); \n                $string .= ')';\n            }\n        }\n        elsif ($self -> {'DataType'} == ACSII_STRING)\n        {\n            $string .= ' ' if (! $compact);\n            $string .= \" '\".$self -> {'RecordData'}[$i].\"'\";\n        }\n        $i++;\n        $dateFld++ if ($dateFld);\n    } \n\n    $string;\n}\n\n\nsub returnXyAsArray() \n{\n    my($self,%arg) = @_;\n    my $asInteger = $arg{'-asInteger'};\n    if (! defined $asInteger)\n    {\n        $asInteger = TRUE;\n    }\n    my $withClosure = $arg{'-withClosure'};\n    if (! defined $withClosure)\n    {\n        $withClosure = TRUE;\n    }\n    my @xys=();\n    if ($self -> isXy)\n    {\n        my $i = 0;\n        my $stopPoint = $self -> {'DataIndex'};\n        if ($withClosure)\n        {\n            return @{$self -> {'RecordData'}} if ($asInteger);\n        }\n        else\n        {\n            $stopPoint -= 2;\n        }\n        my $num=0;\n        while ($i <= $stopPoint)\n        {\n            if ($asInteger)\n            {\n                $num = $self -> {'RecordData'}[$i];\n            }\n            else\n            {\n                $num = ($self -> {'RecordData'}[$i]) * ($self -> {'UUnits'});\n            }\n            push @xys,$num;\n            $i++;\n        }\n    }\n    @xys;\n}\n\n\n\nsub returnRecordAsPerl() \n{\n    my($self,%arg) = @_;\n    my $gds2File = $arg{'-gds2File'};\n    if (! defined $gds2File)\n    {\n        $gds2File = '$gds2File';\n    }\n    my $PGR = $arg{'-printGds2Record'};\n    if (! defined $PGR)\n    {\n        $PGR = 'printGds2Record';\n    }\n    my $string = '';\n    $self -> {'UsingPrettyPrint'} = TRUE;\n    $string .= getStrSpace() if ($self -> {'RecordType'} != BGNSTR);\n    $string .= getElmSpace() if (!(\n                        ($self -> {'RecordType'} == TEXT) ||\n                        ($self -> {'RecordType'} == PATH) || \n                        ($self -> {'RecordType'} == BOUNDARY) ||\n                        ($self -> {'RecordType'} == SREF) || \n                        ($self -> {'RecordType'} == AREF)\n                    ));\n    if (\n        ($self -> {'RecordType'} == TEXT) || \n        ($self -> {'RecordType'} == PATH) || \n        ($self -> {'RecordType'} == BOUNDARY) ||\n        ($self -> {'RecordType'} == SREF) || \n        ($self -> {'RecordType'} == AREF) || \n        ($self -> {'RecordType'} == ENDEL) ||\n        ($self -> {'RecordType'} == ENDSTR) ||\n        ($self -> {'RecordType'} == ENDLIB)\n       )\n    {\n        $string .= $gds2File.'->'.$PGR.'(-type=>'.\"'\".$RecordTypeStrings[$self -> {'RecordType'}].\"'\".');';\n    }\n    else\n    {\n        $string .= $gds2File.'->'.$PGR.'(-type=>'.\"'\".$RecordTypeStrings[$self -> {'RecordType'}].\"',-data=>\";\n        my $i = 0;\n        my $maxi = $self -> {'DataIndex'};\n        if ($maxi >= 1) {$string .= '['}\n        while ($i <= $maxi)\n            {\n            if ($self -> {'DataType'} == BIT_ARRAY)\n            {\n                $string .= \"'\".$self -> {'RecordData'}[$i].\"'\";\n            }\n            elsif ($self -> {'DataType'} == INTEGER_2)\n            {\n                $string .= $self -> {'RecordData'}[$i];\n            }\n            elsif ($self -> {'DataType'} == INTEGER_4)\n            {\n                $string .= $self -> {'RecordData'}[$i];\n            }\n            elsif ($self -> {'DataType'} == REAL_8)\n            {\n                $string .= $self -> {'RecordData'}[$i];\n            }\n            elsif ($self -> {'DataType'} == ACSII_STRING)\n            {\n                $string .= \"'\".$self -> {'RecordData'}[$i].\"'\";\n            }\n            if ($i < $maxi) {$string .= ', '}\n            $i++;\n        }\n        if ($maxi >= 1) {$string .= ']'}\n        $string .= ');';\n    }\n    $string;\n}\n\n\n\n\n\nsub printAngle \n{\n    my($self,%arg) = @_;\n    my $angle = $arg{'-num'};\n    $angle=0 if (! defined $angle);\n    $angle=posAngle($angle);\n    $self -> printGds2Record(-type => 'ANGLE',-data => $angle) if ($angle);\n}\n\n\nsub printAttrtable \n{\n    my($self,%arg) = @_;\n    my $string = $arg{'-string'};\n    if (! defined $string)\n    {\n        die \"printAttrtable expects a string. Missing -string => 'text' $!\";\n    }\n    $self -> printGds2Record(-type => 'ATTRTABLE',-data => $string);\n}\n\n\nsub printBgnextn \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printBgnextn expects a extension number. Missing -num => #.# $!\";\n    }\n    my $resolution = $self -> {'Resolution'};\n    if ($num >= 0) {$num = int(($num*$resolution)+$G_epsilon);}\n    else           {$num = int(($num*$resolution)-$G_epsilon);}\n    $self -> printGds2Record(-type => 'BGNEXTN',-data => $num);\n}\n\n\nsub printBgnlib \n{\n    my($self,%arg) = @_;\n    my $isoDate = $arg{'-isoDate'};\n    if (! defined $isoDate)\n    {\n        $isoDate = 0;\n    }\n    elsif ($isoDate != 0)\n    {\n        $isoDate = 1;\n    }\n    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);\n    $mon++;\n    $year += 1900 if ($isoDate); \n    $self -> printGds2Record(-type=>'BGNLIB',-data=>[$year,$mon,$mday,$hour,$min,$sec,$year,$mon,$mday,$hour,$min,$sec]);\n}\n\n\nsub printBox \n{\n    my $self = shift;\n    $self -> printGds2Record(-type => 'BOX');\n}\n\n\nsub printBoxtype \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printBoxtype expects a number. Missing -num => # $!\";\n    }\n    $self -> printGds2Record(-type => 'BOXTYPE',-data => $num);\n}\n\n\nsub printColrow \n{\n    my($self,%arg) = @_;\n    my $columns = $arg{'-columns'};\n    if ((! defined $columns)||($columns <= 0))\n    {\n        $columns=1;\n    }\n    else\n    {\n        $columns=int($columns);\n    }\n    my $rows = $arg{'-rows'};\n    if ((! defined $rows)||($rows <= 0))\n    {\n        $rows=1;\n    }\n    else\n    {\n        $rows=int($rows);\n    }\n    $self -> printGds2Record(-type => 'COLROW',-data => [$columns,$rows]);\n}\n\n\nsub printDatatype \n{\n    my($self,%arg) = @_;\n    my $dataType = $arg{'-num'};\n    if (! defined $dataType)\n    {\n        $dataType=0;\n    }\n    $self -> printGds2Record(-type => 'DATATYPE',-data => $dataType);\n}\n\nsub printEflags \n{\n    my $self = shift;\n    die \"EFLAGS type not supported $!\";\n}\n\n\nsub printElkey \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printElkey expects a number. Missing -num => #.# $!\";\n    }\n    $self -> printGds2Record(-type => 'ELKEY',-data => $num);\n}\n\n\nsub printEndel \n{\n    my $self = shift;\n    $self -> printGds2Record(-type => 'ENDEL');\n}\n\n\nsub printEndextn \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printEndextn expects a extension number. Missing -num => #.# $!\";\n    }\n    my $resolution = $self -> {'Resolution'};\n    if ($num >= 0) {$num = int(($num*$resolution)+$G_epsilon);}\n    else           {$num = int(($num*$resolution)-$G_epsilon);}\n    $self -> printGds2Record(-type => 'ENDEXTN',-data => $num);\n}\n\n\nsub printEndlib \n{\n    my $self = shift;\n    $self -> printGds2Record(-type => 'ENDLIB');\n}\n\n\nsub printEndstr \n{\n    my $self = shift;\n    $self -> printGds2Record(-type => 'ENDSTR');\n}\n\n\nsub printEndmasks \n{\n    my $self = shift;\n    $self -> printGds2Record(-type => 'ENDMASKS');\n}\n\n\nsub printFonts \n{\n    my($self,%arg) = @_;\n    my $string = $arg{'-string'};\n    if (! defined $string)\n    {\n        die \"printFonts expects a string. Missing -string => 'text' $!\";\n    }\n    $self -> printGds2Record(-type => 'FONTS',-data => $string);\n}\n\nsub printFormat \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printFormat expects a number. Missing -num => #.# $!\";\n    }\n    $self -> printGds2Record(-type => 'FORMAT',-data => $num);\n}\n\nsub printGenerations \n{\n    my $self = shift;\n    $self -> printGds2Record(-type => 'GENERATIONS');\n}\n\n\nsub printHeader \n{\n    my($self,%arg) = @_;\n    my $rev = $arg{'-num'};\n    if (! defined $rev)\n    {\n        $rev=3;\n    }\n    $self -> printGds2Record(-type=>'HEADER',-data=>$rev);\n}\n\n\nsub printLayer \n{\n    my($self,%arg) = @_;\n    my $layer = $arg{'-num'};\n    if (! defined $layer)\n    {\n        $layer=0;\n    }\n    $self -> printGds2Record(-type => 'LAYER',-data => $layer);\n}\n\nsub printLibdirsize \n{\n    my $self = shift;\n    $self -> printGds2Record(-type => 'LIBDIRSIZE');\n}\n\n\nsub printLibname \n{\n    my($self,%arg) = @_;\n    my $libName = $arg{'-name'};\n    if (! defined $libName)\n    {\n        die \"printLibname expects a library name. Missing -name => 'name' $!\";\n    }\n    $self -> printGds2Record(-type => 'LIBNAME',-data => $libName);\n}\n\nsub printLibsecur \n{\n    my $self = shift;\n    $self -> printGds2Record(-type => 'LIBSECUR');\n}\n\nsub printLinkkeys \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printLinkkeys expects a number. Missing -num => #.# $!\";\n    }\n    $self -> printGds2Record(-type => 'LINKKEYS',-data => $num);\n}\n\nsub printLinktype \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printLinktype expects a number. Missing -num => #.# $!\";\n    }\n    $self -> printGds2Record(-type => 'LINKTYPE',-data => $num);\n}\n\n\nsub printPathtype \n{\n    my($self,%arg) = @_;\n    my $pathType = $arg{'-num'};\n    $pathType=0 if (! defined $pathType);\n    $self -> printGds2Record(-type => 'PATHTYPE',-data => $pathType) if ($pathType);\n}\n\n\nsub printMag \n{\n    my($self,%arg) = @_;\n    my $mag = $arg{'-num'};\n    $mag=0 if ((! defined $mag)||($mag <= 0));\n    $self -> printGds2Record(-type => 'MAG',-data => $mag)if ($mag);\n}\n\nsub printMask \n{\n    my($self,%arg) = @_;\n    my $string = $arg{'-string'};\n    if (! defined $string)\n    {\n        die \"printMask expects a string. Missing -string => 'text' $!\";\n    }\n    $self -> printGds2Record(-type => 'MASK',-data => $string);\n}\n\nsub printNode \n{\n    my $self = shift;\n    $self -> printGds2Record(-type => 'NODE');\n}\n\n\nsub printNodetype \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printNodetype expects a number. Missing -num => # $!\";\n    }\n    $self -> printGds2Record(-type => 'NODETYPE',-data => $num);\n}\n\nsub printPlex \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printPlex expects a number. Missing -num => #.# $!\";\n    }\n    $self -> printGds2Record(-type => 'PLEX',-data => $num);\n}\n\n\nsub printPresentation \n{\n    my($self,%arg) = @_;\n    my $font = $arg{'-font'};\n    if ((! defined $font) || ($font < 0) || ($font > 3))\n    {\n        $font=0;\n    }\n    $font = sprintf(\"%02d\",$font);\n\n    my $vertical;\n    my $top = $arg{'-top'};\n    my $middle = $arg{'-middle'};\n    my $bottom = $arg{'-bottom'};\n    if    (defined $top)    {$vertical = '00';}\n    elsif (defined $bottom) {$vertical = '10';}\n    else                    {$vertical = '01';} \n    my $horizontal; \n    my $left   = $arg{'-left'};\n    my $center = $arg{'-center'};\n    my $right  = $arg{'-right'};\n    if    (defined $left)  {$horizontal = '00';}\n    elsif (defined $right) {$horizontal = '10';}\n    else                   {$horizontal = '01';} \n\n    my $bitstring = '0'x10;\n    $bitstring .= \"$font$vertical$horizontal\";\n    $self -> printGds2Record(-type => 'PRESENTATION',-data => $bitstring);\n}\n\n\nsub printPropattr \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printPropattr expects a number. Missing -num => # $!\";\n    }\n    $self -> printGds2Record(-type => 'PROPATTR',-data => $num);\n}\n\n\nsub printPropvalue \n{\n    my($self,%arg) = @_;\n    my $string = $arg{'-string'};\n    if (! defined $string)\n    {\n        die \"printPropvalue expects a string. Missing -string => 'text' $!\";\n    }\n    $self -> printGds2Record(-type => 'PROPVALUE',-data => $string);\n}\n\nsub printReflibs \n{\n    my($self,%arg) = @_;\n    my $string = $arg{'-string'};\n    if (! defined $string)\n    {\n        die \"printReflibs expects a string. Missing -string => 'text' $!\";\n    }\n    $self -> printGds2Record(-type => 'REFLIBS',-data => $string);\n}\n\nsub printReserved \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printReserved expects a number. Missing -num => #.# $!\";\n    }\n    $self -> printGds2Record(-type => 'RESERVED',-data => $num);\n}\n\n\nsub printSname \n{\n    my($self,%arg) = @_;\n    my $string = $arg{'-name'};\n    if (! defined $string)\n    {\n        die \"printSname expects a cell name. Missing -name => 'text' $!\";\n    }\n    $self -> printGds2Record(-type => 'SNAME',-data => $string);\n}\n\nsub printSpacing \n{\n    my $self = shift;\n    die \"SPACING type not supported $!\";\n}\n\nsub printSrfname \n{\n    my $self = shift;\n    $self -> printGds2Record(-type => 'SRFNAME');\n}\n\n\nsub printStrans \n{\n    my($self,%arg) = @_;\n    my $reflect = $arg{'-reflect'};\n    if ((! defined $reflect)||($reflect <= 0))\n    {\n        $reflect=0;\n    }\n    else\n    {\n        $reflect=1;\n    }\n    my $data=$reflect.'0'x15; \n    $self -> printGds2Record(-type => 'STRANS',-data => $data);\n}\n\nsub printStrclass \n{\n    my $self = shift;\n    $self -> printGds2Record(-type => 'STRCLASS');\n}\n\n\nsub printString \n{\n    my($self,%arg) = @_;\n    my $string = $arg{'-string'};\n    if (! defined $string)\n    {\n        die \"printString expects a string. Missing -string => 'text' $!\";\n    }\n    $self -> printGds2Record(-type => 'STRING',-data => $string);\n}\n\n\nsub printStrname \n{\n    my($self,%arg) = @_;\n    my $strName = $arg{'-name'};\n    if (! defined $strName)\n    {\n        die \"printStrname expects a structure name. Missing -name => 'name' $!\";\n    }\n    $self -> printGds2Record(-type => 'STRNAME',-data => $strName);\n}\n\nsub printStrtype \n{\n    my $self = shift;\n    die \"STRTYPE type not supported $!\";\n}\n\nsub printStyptable \n{\n    my($self,%arg) = @_;\n    my $string = $arg{'-string'};\n    if (! defined $string)\n    {\n        die \"printStyptable expects a string. Missing -string => 'text' $!\";\n    }\n    $self -> printGds2Record(-type => 'STYPTABLE',-data => $string);\n}\n\nsub printTapecode \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printTapecode expects a number. Missing -num => #.# $!\";\n    }\n    $self -> printGds2Record(-type => 'TAPECODE',-data => $num);\n}\n\nsub printTapenum \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printTapenum expects a number. Missing -num => #.# $!\";\n    }\n    $self -> printGds2Record(-type => 'TAPENUM',-data => $num);\n}\n\nsub printTextnode \n{\n    my $self = shift;\n    $self -> printGds2Record(-type => 'TEXTNODE');\n}\n\n\nsub printTexttype \n{\n    my($self,%arg) = @_;\n    my $num = $arg{'-num'};\n    if (! defined $num)\n    {\n        die \"printTexttype expects a number. Missing -num => # $!\";\n    }\n    $num = 0 if ($num < 0);\n    $self -> printGds2Record(-type => 'TEXTTYPE',-data => $num);\n}\n\nsub printUinteger \n{\n    my $self = shift;\n    die \"UINTEGER type not supported $!\";\n}\n\n\nsub printUnits \n{\n    my($self,%arg) = @_;\n    \n    my $uUnit = $arg{'-uUnit'};\n    if (! defined $uUnit)\n    {\n        $uUnit = 0.001;\n    }\n    else\n    {\n        $self -> {'Resolution'} = (1 / $uUnit); \n    }\n    $self -> {'UUnits'} = $uUnit;\n    my $dbUnit = $arg{'-dbUnit'};\n    if (! defined $dbUnit)\n    {\n        $dbUnit = 1e-9;\n    }\n    $self -> {'DBUnits'} = $dbUnit;\n\n    $self -> printGds2Record(-type => 'UNITS',-data => [$uUnit,$dbUnit]);\n}\n\nsub printUstring \n{\n    my $self = shift;\n    die \"USTRING type not supported $!\";\n}\n\n\nsub printWidth \n{\n    my($self,%arg) = @_;\n    my $width = $arg{'-num'};\n    if ((! defined $width)||($width <= 0))\n    {\n        $width=0;\n    }\n    $self -> printGds2Record(-type => 'WIDTH',-data => $width) if ($width);\n}\n\n\nsub printXy \n{\n    my($self,%arg) = @_;\n    my $xyInt = $arg{'-xyInt'}; \n    my $xy = $arg{'-xy'}; \n    my $resolution = $self -> {'Resolution'};\n    if (! ((defined $xy) || (defined $xyInt)))\n    {\n        die \"printXy expects an xy array reference. Missing -xy => \\\\\\@array $!\";\n    }\n    if (defined $xyInt)\n    {\n        $xy = $xyInt;\n        $resolution=1;\n    }\n    my @xyTmp=(); \n    for(my $i=0;$i<=$#$xy;$i++) \n    {\n        if ($xy -> [$i] >= 0) {push @xyTmp,int((($xy -> [$i])*$resolution)+$G_epsilon);}\n        else                  {push @xyTmp,int((($xy -> [$i])*$resolution)-$G_epsilon);}\n    }\n    $self -> printGds2Record(-type => 'XY',-data => \\@xyTmp);\n}\n\n\n\n\n\n\nsub returnBgnextn \n{\n    my $self = shift;\n    if ($self -> isBgnextn) { $self -> {'RecordData'}[0]; }\n    else { 0; }\n}\n\n\nsub returnDatatype \n{\n    my $self = shift;\n    if ($self -> isDatatype) { $self -> {'RecordData'}[0]; }\n    else { UNKNOWN; }\n}\n\n\nsub returnEndextn \n{\n    my $self = shift;\n    if ($self -> isEndextn) { $self -> {'RecordData'}[0]; }\n    else { 0; }\n}\n\n\nsub returnLayer \n{\n    my $self = shift;\n    if ($self -> isLayer) { $self -> {'RecordData'}[0]; }\n    else { UNKNOWN; }\n}\n\n\nsub returnPathtype \n{\n    my $self = shift;\n    if ($self -> isPathtype) { $self -> {'RecordData'}[0]; }\n    else { UNKNOWN; }\n}\n\n\nsub returnPropattr \n{\n    my $self = shift;\n    if ($self -> isPropattr) { $self -> {'RecordData'}[0]; }\n    else { UNKNOWN; }\n}\n\n\nsub returnPropvalue \n{\n    my $self = shift;\n    if ($self -> isPropvalue) { $self -> {'RecordData'}[0]; }\n    else { ''; }\n}\n\n\nsub returnSname \n{\n    my $self = shift;\n    if ($self -> isSname) { $self -> {'RecordData'}[0]; }\n    else { ''; }\n}\n\n\nsub returnString \n{\n    my $self = shift;\n    if ($self -> isString) { $self -> {'RecordData'}[0]; }\n    else { ''; }\n}\n\n\nsub returnStrname \n{\n    my $self = shift;\n    if ($self -> isStrname) { $self -> {'RecordData'}[0]; }\n    else { ''; }\n}\n\n\nsub returnTexttype \n{\n    my $self = shift;\n    if ($self -> isTexttype) { $self -> {'RecordData'}[0]; }\n    else { UNKNOWN; }\n}\n\n\nsub returnWidth \n{\n    my $self = shift;\n    if ($self -> isWidth) { $self -> {'RecordData'}[0]; }\n    else { UNKNOWN; }\n}\n\n\n\n\n\nsub isAref \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == AREF) { 1; }\n    else { 0; }\n}\n\n\nsub isBgnlib \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == BGNLIB) { 1; }\n    else { 0; }\n}\n\n\nsub isBgnstr \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == BGNSTR) { 1; }\n    else { 0; }\n}\n\n\nsub isBoundary \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == BOUNDARY) { 1; }\n    else { 0; }\n}\n\n\nsub isDatatype \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == DATATYPE) { 1; }\n    else { 0; }\n}\n\n\nsub isEndlib \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == ENDLIB) { 1; }\n    else { 0; }\n}\n\n\nsub isEndel \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == ENDEL) { 1; }\n    else { 0; }\n}\n\n\nsub isEndstr \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == ENDSTR) { 1; }\n    else { 0; }\n}\n\n\n\nsub isHeader \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == HEADER) { 1; }\n    else { 0; }\n}\n\n\nsub isLibname \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == LIBNAME) { 1; }\n    else { 0; }\n}\n\n\nsub isPath \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == PATH) { 1; }\n    else { 0; }\n}\n\n\nsub isSref \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == SREF) { 1; }\n    else { 0; }\n}\n\n\nsub isSrfname \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == SRFNAME) { 1; }\n    else { 0; }\n}\n\n\nsub isText \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == TEXT) { 1; }\n    else { 0; }\n}\n\n\nsub isUnits \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == UNITS) { 1; }\n    else { 0; }\n}\n\n\nsub isLayer \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == LAYER) { 1; }\n    else { 0; }\n}\n\n\nsub isStrname \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == STRNAME) { 1; }\n    else { 0; }\n}\n\n\nsub isWidth \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == WIDTH) { 1; }\n    else { 0; }\n}\n\n\nsub isXy \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == XY) { 1; }\n    else { 0; }\n}\n\n\nsub isSname \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == SNAME) { 1; }\n    else { 0; }\n}\n\n\nsub isColrow \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == COLROW) { 1; }\n    else { 0; }\n}\n\n\nsub isTextnode \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == TEXTNODE) { 1; }\n    else { 0; }\n}\n\n\nsub isNode \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == NODE) { 1; }\n    else { 0; }\n}\n\n\nsub isTexttype \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == TEXTTYPE) { 1; }\n    else { 0; }\n}\n\n\nsub isPresentation \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == PRESENTATION) { 1; }\n    else { 0; }\n}\n\n\nsub isSpacing \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == SPACING) { 1; }\n    else { 0; }\n}\n\n\nsub isString \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == STRING) { 1; }\n    else { 0; }\n}\n\n\nsub isStrans \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == STRANS) { 1; }\n    else { 0; }\n}\n\n\nsub isMag \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == MAG) { 1; }\n    else { 0; }\n}\n\n\nsub isAngle \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == ANGLE) { 1; }\n    else { 0; }\n}\n\n\nsub isUinteger \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == UINTEGER) { 1; }\n    else { 0; }\n}\n\n\nsub isUstring \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == USTRING) { 1; }\n    else { 0; }\n}\n\n\nsub isReflibs \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == REFLIBS) { 1; }\n    else { 0; }\n}\n\n\nsub isFonts \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == FONTS) { 1; }\n    else { 0; }\n}\n\n\nsub isPathtype \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == PATHTYPE) { 1; }\n    else { 0; }\n}\n\n\nsub isGenerations \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == GENERATIONS) { 1; }\n    else { 0; }\n}\n\n\nsub isAttrtable \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == ATTRTABLE) { 1; }\n    else { 0; }\n}\n\n\nsub isStyptable \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == STYPTABLE) { 1; }\n    else { 0; }\n}\n\n\nsub isStrtype \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == STRTYPE) { 1; }\n    else { 0; }\n}\n\n\nsub isEflags \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == EFLAGS) { 1; }\n    else { 0; }\n}\n\n\nsub isElkey \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == ELKEY) { 1; }\n    else { 0; }\n}\n\n\nsub isLinktype \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == LINKTYPE) { 1; }\n    else { 0; }\n}\n\n\nsub isLinkkeys \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == LINKKEYS) { 1; }\n    else { 0; }\n}\n\n\nsub isNodetype \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == NODETYPE) { 1; }\n    else { 0; }\n}\n\n\nsub isPropattr \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == PROPATTR) { 1; }\n    else { 0; }\n}\n\n\nsub isPropvalue \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == PROPVALUE) { 1; }\n    else { 0; }\n}\n\n\nsub isBox \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == BOX) { 1; }\n    else { 0; }\n}\n\n\nsub isBoxtype \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == BOXTYPE) { 1; }\n    else { 0; }\n}\n\n\nsub isPlex \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == PLEX) { 1; }\n    else { 0; }\n}\n\n\nsub isBgnextn \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == BGNEXTN) { 1; }\n    else { 0; }\n}\n\n\nsub isEndextn \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == ENDEXTN) { 1; }\n    else { 0; }\n}\n\n\nsub isTapenum \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == TAPENUM) { 1; }\n    else { 0; }\n}\n\n\nsub isTapecode \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == TAPECODE) { 1; }\n    else { 0; }\n}\n\n\nsub isStrclass \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == STRCLASS) { 1; }\n    else { 0; }\n}\n\n\nsub isReserved \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == RESERVED) { 1; }\n    else { 0; }\n}\n\n\nsub isFormat \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == FORMAT) { 1; }\n    else { 0; }\n}\n\n\nsub isMask \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == MASK) { 1; }\n    else { 0; }\n}\n\n\nsub isEndmasks \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == ENDMASKS) { 1; }\n    else { 0; }\n}\n\n\nsub isLibdirsize \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == LIBDIRSIZE) { 1; }\n    else { 0; }\n}\n\n\nsub isLibsecur \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == LIBSECUR) { 1; }\n    else { 0; }\n}\n\n\nsub getRecordData \n{\n    my $self = shift;\n    my $dt = $self -> {'DataType'};\n    if ($dt==NO_REC_DATA)\n    {\n        return '';\n    }\n    elsif ($dt==INTEGER_2 || $dt==INTEGER_4 || $dt==REAL_8)\n    {\n        my $stuff = $self -> {'CurrentDataList'};\n        $stuff =~ s|^,||;\n        return(split(/,/,$stuff));\n    }\n    elsif ($dt==ACSII_STRING)\n    {\n        my $stuff = $self -> {'CurrentDataList'};\n        $stuff =~ s|\\0||g;\n        return($stuff);\n    }\n    else \n    {\n        return ($self -> {'CurrentDataList'});\n    }\n}\n\nsub readRecordTypeAndData \n{\n    my $self = shift;\n    return ($RecordTypeStrings[$self -> {'RecordType'}],$self -> {'RecordData'});\n}\n\nsub skipGds2RecordData \n{\n    my $self = shift;\n    $self -> readGds2RecordHeader() if ($self -> {'INHEADER'} != TRUE); \n    if (TIMER_ON)\n    {\n        $G_timer -> reset();\n        $G_timer -> start('skipGds2RecordData');\n    }\n    $self -> {'INHEADER'} = FALSE;\n    $self -> {'INDATA'}   = TRUE;  \n    seek($self -> {'FileHandle'},$self -> {'Length'} - 4,SEEK_CUR); \n    $self -> {'DataIndex'} = UNKNOWN;\n    if (TIMER_ON)\n    {\n        $G_timer -> stop;\n        $G_timer -> report;\n    }\n    return 1;\n}\n\nsub returnNumCoords \n{\n    my $self = shift;\n    if ($self -> {'RecordType'} == XY)  \n    {\n        int(($self -> {'Length'} - 4) / 8);\n    }\n    else\n    {\n        0;\n    }\n}\n\nsub roundNum \n{\n    my $self = shift;\n    my $num = shift;\n    my $places = shift;\n    sprintf(\"%.${places}f\",$num);\n}\n\nsub scaleNum($$) \n{\n    my $num=shift;\n    my $scale=shift;\n    die \"1st number passed into scaleNum() must be an integer $!\" if ($num !~ m|^-?\\d+|);\n    $num = $num * $scale;\n    $num = int($num+0.5) if ($num =~ m|\\.|);\n    $num;\n}\n\nsub snapNum($$) \n{\n    my $num=shift;\n    die \"1st number passed into snapNum() must be an integer $!\" if ($num !~ m|^-?\\d+$|);\n    my $snap=shift;\n    my $snapLength = length(\"$snap\");\n    my $lean=1; \n    $lean = -1 if($num < 0);\n    my $littlePart=substr($num,-$snapLength,$snapLength);\n    if($num<0)\n    {\n        $littlePart = -$littlePart;\n    }\n    $littlePart = int(($littlePart/$snap)+(0.5*$lean))*$snap;\n    my $bigPart=substr($num,0,-$snapLength);\n    if ($bigPart =~ m|^[-]?$|)\n    {\n        $bigPart=0;\n    }\n    else\n    {\n        $bigPart *= 10**$snapLength;\n    }\n    $num = $bigPart + $littlePart;\n    $num;\n}\n\nsub DESTROY \n{\n    my $self = shift;\n}\n\nsub posAngle($) \n{\n    my $angle = shift;\n    $angle += 360.0 while ($angle < 0.0);\n    $angle -= 360.0 while ($angle >= 360.0);\n    $angle;\n}\n\n\nsub recordSize() \n{\n    my $self = shift;\n    $self -> {'Length'};\n}\n\n\nsub dataSize() \n{\n    my $self = shift;\n    $self -> {'Length'} - 4;\n}\n\n\nsub returnUnitsAsArray\n{\n    my $self = shift;\n    if ($self -> isUnits) { ($self -> {'UUnits'}, $self -> {'DBUnits'}); }\n    else { () }\n}\n\nsub subbyte() \n{\n    my($what,$where,$howmuch) = @_;\n    unpack(\"x$where C$howmuch\", $what);\n}\n\n\nsub version() \n{\n    return $GDS2::VERSION;\n}\n\n\nsub revision() \n{\n    return $GDS2::revision;\n}\n\nsub getElmSpace\n{\n    return $ElmSpace;\n}\n\nsub putElmSpace\n{\n    $ElmSpace = shift;\n}\n\nsub getStrSpace\n{\n    return $StrSpace;\n}\n\nsub putStrSpace\n{\n    $StrSpace = shift;\n}\n\n1;\n}",
      "file" : "/var/tmp/arv_txlXGH/GDS2-3.00/lib/GDS2.pm",
      "package" : "GDS2"
   }
]
