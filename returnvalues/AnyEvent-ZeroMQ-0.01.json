[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "subtype SocketDirection, as Str, where {\n    /^(r|rw|wr|w|)$/;\n}, message { \"Socket direction must be r, w, rw, or the empty string; not '$_'\" }",
      "file" : "/var/tmp/arv_ymbnzg/AnyEvent-ZeroMQ-0.01/lib/AnyEvent/ZeroMQ/Types.pm",
      "package" : "AnyEvent::ZeroMQ::Types"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "around 'mangle_message' => sub {\n    my ($orig, $self, $msg, %args) = @_;\n    my $topic = delete $args{topic};\n    $msg = \"$topic$msg\" if defined $topic;\n    return $self->$orig($msg, %args);\n}",
      "file" : "/var/tmp/arv_ymbnzg/AnyEvent-ZeroMQ-0.01/lib/AnyEvent/ZeroMQ/Publish/Trait/Topics.pm",
      "package" : "AnyEvent::ZeroMQ::Publish::Trait::Topics"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "role {\n    my $p = shift;\n\n    my $type   = $p->socket_type;\n    my $dir    = $p->socket_direction;\n\n    has 'context' => (\n        is       => 'ro',\n        isa      => 'ZeroMQ::Raw::Context',\n        required => 1,\n    );\n\n    has 'connect' => (\n        init_arg => 'connect',\n        isa      => Endpoints,\n        default  => sub { [] },\n        coerce   => 1,\n        traits   => ['Array'],\n        handles  => {\n            connected_to => 'elements',\n            _connect     => 'push',\n        },\n    );\n\n    has 'bind' => (\n        init_arg => 'bind',\n        isa      => Endpoints,\n        default  => sub { [] },\n        coerce   => 1,\n        traits   => ['Array'],\n        handles  => {\n            bound_to => 'elements',\n            _bind    => 'push',\n        },\n    );\n\n    my @roles = 'AnyEvent::ZeroMQ::Handle::Role::Generic';\n    push @roles, 'AnyEvent::ZeroMQ::Handle::Role::Readable' if $dir =~ /r/;\n    push @roles, 'AnyEvent::ZeroMQ::Handle::Role::Writable' if $dir =~ /w/;\n\n    my @methods = map { \"$_\" } map { $_->meta->get_required_method_list } @roles;\n\n    has 'handle' => (\n        reader     => 'handle',\n        isa        => 'AnyEvent::ZeroMQ::Handle',\n        lazy_build => 1,\n        handles    => [@methods],\n    );\n\n    after 'bind' => sub {\n        my ($self, $bind_to) = @_;\n        $self->_bind($bind_to);\n    };\n\n    after 'connect' => sub {\n        my ($self, $connect_to) = @_;\n        $self->_connect($connect_to);\n    };\n\n    has '_extra_initargs' => (\n        is       => 'ro',\n        isa      => 'HashRef',\n        required => 1,\n    );\n\n    method '_build_handle' => sub {\n        my $self = shift;\n\n        my $socket = ZeroMQ::Raw::Socket->new($self->context, $type);\n\n        my $h = AnyEvent::ZeroMQ::Handle->new(\n            socket => $socket,\n            %{$self->_extra_initargs || {}},\n        );\n\n        for my $bind ($self->bound_to){\n            $h->bind($bind);\n        }\n\n        for my $connect ($self->connected_to){\n            $h->connect($connect);\n        }\n\n        return $h;\n    };\n\n    method 'BUILDARGS' => sub {\n        my ($class, @in) = @_;\n        my %in;\n        while(@in) {\n            my $key = shift @in;\n            my $value = shift @in;\n            if($key eq 'bind' || $key eq 'connect'){\n                $in{$key} ||= [];\n                push @{$in{$key}}, ref $value ? @$value : $value;\n            }\n            else {\n                $in{$key} = $value;\n            }\n        }\n        my %extra;\n        for my $m (grep { !/bind|connect/ } @methods) {\n            $extra{$m} = delete $in{$m} if exists $in{$m};\n        }\n        return { %in, _extra_initargs => \\%extra };\n    };\n\n    method 'BUILD' => sub {\n        my $self = shift;\n        $self->handle; \n    };\n}",
      "file" : "/var/tmp/arv_ymbnzg/AnyEvent-ZeroMQ-0.01/lib/AnyEvent/ZeroMQ/Role/WithHandle.pm",
      "package" : "AnyEvent::ZeroMQ::Role::WithHandle"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "around '_call_callback' => sub {\n    my ($orig, $self, $cb, @rest) = @_;\n    $self->$orig( sub {\n        my ($self, $item, @rest) = @_;\n        my $tr = $self->topic_regex;\n        if(my ($topic, $item) = ($item =~ /$tr/)){\n            $cb->($self, $item, $topic, @rest);\n        }\n        else {\n            $cb->($self, $item, undef,  @rest);\n        }\n    }, @rest);\n\n}",
      "file" : "/var/tmp/arv_ymbnzg/AnyEvent-ZeroMQ-0.01/lib/AnyEvent/ZeroMQ/Subscribe/Trait/Topics.pm",
      "package" : "AnyEvent::ZeroMQ::Subscribe::Trait::Topics"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "requires 'push_write'",
      "file" : "/var/tmp/arv_ymbnzg/AnyEvent-ZeroMQ-0.01/lib/AnyEvent/ZeroMQ/Handle/Role/Writable.pm",
      "package" : "AnyEvent::ZeroMQ::Handle::Role::Writable"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "requires 'push_read'",
      "file" : "/var/tmp/arv_ymbnzg/AnyEvent-ZeroMQ-0.01/lib/AnyEvent/ZeroMQ/Handle/Role/Readable.pm",
      "package" : "AnyEvent::ZeroMQ::Handle::Role::Readable"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "requires 'connect'",
      "file" : "/var/tmp/arv_ymbnzg/AnyEvent-ZeroMQ-0.01/lib/AnyEvent/ZeroMQ/Handle/Role/Generic.pm",
      "package" : "AnyEvent::ZeroMQ::Handle::Role::Generic"
   }
]
