[
   {
      "PPI" : "PPI::Statement::Scheduled",
      "bad" : "BEGIN{\n\tuse Fcntl;\n        eval{\n          no warnings; O_NONBLOCK; F_SETFL;\n        };\n        if ($@){\n           warn \"O_NONBLOCK is broken, but a workaround is in place.\\n\";\n\t   eval'sub BROKEN_NONBLOCKING(){1}';\n        }else{\n\t   eval'sub BROKEN_NONBLOCKING(){0}';\n        };\n}\n\nsub makeref($){\n\tref($_[0]) ? $_[0] : \\$_[0]\n};\n\nsub import(){\n\n  DEBUG and print __PACKAGE__,\" import called\\n\";\n\n  shift; # we don't need to know __PACKAGE__\n\n  my %args = @_;\n  DEBUG and do{\n\tprint \"$_ is $args{$_}\\n\" foreach sort keys %args\n\n  };\n  exists $args{port} and *Port = $args{port};\n  exists $args{timeout} and *Timeout = $args{timeout};\n  exists $args{maxclients} and *MaxClients = $args{maxclients};\n  exists $args{static} and *Static = $args{static};\n  exists $args{function} and *Function = $args{function};\n  exists $args{cgibin} and *CgiBin = $args{cgibin};\n  exists $args{servertype} and *ServerType = $args{servertype};\n  exists $args{webemail} and *WebEmail = makeref($args{webemail});\n  exists $args{path} and *Path = $args{path};\n\n  @Port or die __PACKAGE__.\" invoked with empty \\@Port array\";\n\n  @Listeners = ();\n  for (@Port) {\n     my $l;\n     socket($l, PF_INET, SOCK_STREAM,getprotobyname('tcp'))\n        || die \"socket: $!\";\n     unless (BROKEN_NONBLOCKING){\n       fcntl($l, F_SETFL, O_NONBLOCK) \n        || die \"can't set non blocking: $!\";\n     };\n     setsockopt($l, SOL_SOCKET,\n                SO_REUSEADDR,\n                pack(\"l\", 1))\n        || die \"setsockopt: $!\";\n     bind($l, sockaddr_in($_, INADDR_ANY))\n        || do {warn \"bind: $!\";next};\n     listen($l,SOMAXCONN)\n        || die \"listen: $!\";\n     if (defined $l){\n        print \"bound listener to $_\\n\";\n        $PortNo[fileno($l)] = $_;\n        push @Listeners,$l;\n     }else{\n         print \"Could not bind listener to $_\\n\";\n     };\n  } ;\n\n  @Listeners or die __PACKAGE__.\" could not bind any listening sockets among @Port\";\n\n\n\n\n   for (keys %Function){\n      die \"$Function{$_} is not a coderef\"\n        unless (ref $Function{$_} eq 'CODE');\n      $Path{$_} = $Function{$_};\n   }\n   for (keys %Static){\n      die \"path $_ already defined\" if exists $Path{$_};\n      $Path{$_} = \"STATIC $Static{$_}\";\n   }\n   for (keys %CgiBin){\n      die \"path $_ already defined\" if exists $Path{$_};\n      $Path{$_} = \"CGI $CgiBin{$_}\";\n   }\n\n   {\n      no strict;\n      *{caller().'::Serve'} = \\&Serve;\n   }\n\n\n};\n\nmy %RCtext =(\n    100=> 'Continue',\n    101=> 'Switching Protocols',\n    200=> 'OK',\n    201=> 'Created',\n    202=> 'Accepted',\n    203=> 'Non-Authoritative Information',\n    204=> 'No Content',\n    205=> 'Reset Content',\n    206=> 'Partial Content',\n    300=> 'Multiple Choices',\n    301=> 'Moved Permanently',\n    302=> 'Found',\n    303=> 'See Other',\n    304=> 'Not Modified',\n    305=> 'Use Proxy',\n    306=> '(Unused)',\n    307=> 'Temporary Redirect',\n    400=> 'Bad Request',\n    401=> 'Unauthorized',\n    402=> 'Payment Required',\n    403=> 'Forbidden',\n    404=> 'Not Found',\n    405=> 'Method Not Allowed',\n    406=> 'Not Acceptable',\n    407=> 'Proxy Authentication Required',\n    408=> 'Request Timeout',\n    409=> 'Conflict',\n    410=> 'Gone',\n    411=> 'Length Required',\n    412=> 'Precondition Failed',\n    413=> 'Request Entity Too Large',\n    414=> 'Request-URI Too Long',\n    415=> 'Unsupported Media Type',\n    416=> 'Requested Range Not Satisfiable',\n    417=> 'Expectation Failed',\n    500=> 'Internal Server Error',\n    501=> 'Not Implemented',\n    502=> 'Bad Gateway',\n    503=> 'Service Unavailable',\n    504=> 'Gateway Timeout',\n    505=> 'HTTP Version Not Supported'\n); \n\n\nour @Moustache;  \n\nsub dispatch(){\n\n   if(DEBUG){\n     print \"Request on fn $fn:\\n${_}END_REQUEST\\n\";\n   };\n\n   *_ = $Moustache[$fn] = {\n       Data => undef,\n       ResultCode => 200\n   };\n\n   $continue[$fn] = undef;\n\n   /^(\\w+) (\\S+) HTTP\\/(\\S+)\\s*(.*)$CRLF$CRLF/s\n      or do { $_{ResultCode} = 400;\n              return <<EOF;\n   };\n   @_{qw/\n      REQUEST_METHOD REQUEST_URI HTTPver RequestHeader\n      REMOTE_ADDR REMOTE_PORT SERVER_ADDR SERVER_PORT/\n   } = (\n      $1,$2,$3,$4,\n      $Caddr[$fn], $Cport[$fn],\n      $Saddr[$fn], $Sport[$fn]\n   );\n   if(DEBUG){for( sort keys %_ ){\n      print \"$_ is $_{$_}\\n\";\n   }};\n\n\n   my $shortURI;\n   ($shortURI ,$_{QUERY_STRING}) = $_{REQUEST_URI}=~m#(/[^\\?]*)\\??(.*)$#;\n   $shortURI =~ s/%(..)/chr hex $1/ge; \n   if (uc($_{REQUEST_METHOD}) eq 'POST'){\n      $_{POST_DATA} = $PostData[$fn];\n   };\n\n   my @URIpath = split '/',$shortURI,-1; \n   my @Castoffs;\n   my $mypath;\n   while (@URIpath){\n      $mypath = join '/',@URIpath;\n      DEBUG and warn \"considering $mypath\\n\";\n      if (exists $Path{$mypath}){\n         $_{SCRIPT_NAME} = $mypath;\n         print \"PATH $mypath is $Path{$mypath}\";\n         $_{PATH_INFO} = join '/', @Castoffs;\n         print \" and PATH_INFO is $_{PATH_INFO}\\n\";\n         if (ref $Path{$mypath}){\n            my $DynPage;\n            eval {\n               $DynPage = &{$Path{$mypath}};\n            };\n            $@ or return $DynPage;\n            $_{ResultCode} = 500;\n            return <<EOF;\n         };\n         if ($Path{$mypath} =~/^STATIC (.+)/){\n            my $FILE;\n            my $filename = \"$1/$_{PATH_INFO}\";\n            print \"filename: $filename\\n\";\n            $filename =~ s/\\/\\.\\.\\//\\//g; \n            my ($ext) = $filename =~ /\\.(\\w+)$/;\n            my $ContentType = $MimeType{$ext}||$DefaultMimeType;\n            unless(open $FILE, \"<\", $filename){\n               $_{ResultCode} = 404;\n               return <<EOF;\n            };\n            my $size = -s $filename;\n            my $slurp;\n            my $read = sysread $FILE, $slurp, $StaticBufferSize ;\n\n            if ($read < $size){\n               $LargeFile[$fn] = $FILE;\n            };\n\n            return \"Content-type: $ContentType\\n\\n$slurp\";\n\n         };\n         $_{ResultCode} = 404;\n         return <<EOF;\n      };\n      if((length $URIpath[$#URIpath]) > 0){\n         unshift @Castoffs, pop @URIpath;\n      }else{\n         $URIpath[$#URIpath] = '/'\n      };\n   };\n\n\n   $_{ResultCode} = 404;\n   <<EOF;\n\n};\n\n\nsub HandleRequest(){\n   $RequestTally++;\n   print \"Handling request $RequestTally on fn $fn\\n\";\n   DEBUG and warn \"Inbuf:\\n$inbuf[$fn]\\n\";\n   *_ = \\delete $inbuf[$fn]; \n   \n   my $dispatchretval = dispatch;\n   $dispatchretval or return undef;\n   $outbuf[$fn]=<<EOF;  \n   HandleDRV($dispatchretval);\n   DEBUG and warn \"Outbuf:\\n$outbuf[$fn]\\n\";\n};\nsub HandleDRV{\n   my $dispatchretval = shift;\n   @_ and $dispatchretval = [$dispatchretval,shift]; \n   $continue[$fn] = undef;\n   { no warnings; length $_{Data} and $outbuf[$fn] .= $_{Data}; }\n   if(ref($dispatchretval)){\n      $continue[$fn] = $dispatchretval;\n\n   }else{\n\t$outbuf[$fn].=$dispatchretval\n   }\n\n};\n\nmy $client_tally = 0;\nsub Serve(){\n   DEBUG and print \"L: (@Listeners) C: (@Clients)\\n\";\n   my ($rin,$win,$ein,$rout,$wout,$eout);\n   my $nfound;\n\nBEGIN_SERVICE:\n\n  @PollMe = grep {\n\t $fn = $_;\n         DEBUG and warn \"polling $_\";\n         if ( $continue[$_] ) {\n           *_ = $Moustache[$_]; \n\t   DEBUG and warn \"still working with $_\";\n           $_{Data} = '';\n   \t   HandleDRV( &{$continue[$_]} );\n\t   $continue[$_];\n         }\n  } @PollMe;\n\n\n\n   my $Accepting = ($client_tally < $MaxClients);\n   $rin = $win = $ein = '';\n   if($Accepting){\n      for(@Listeners){\n         $fn = fileno($_);\n         vec($rin,$fn,1) = 1;\n         vec($win,$fn,1) = 1;\n         vec($ein,$fn,1) = 1;\n      };\n   };\n\n\n   my @Outs;\n   my @CompleteRequests;\n   for(@Clients){\n      $fn = fileno($_);\n      vec($rin,$fn,1) = 1;\n      vec($ein,$fn,1) = 1;\n      if( length $outbuf[$fn]){\n         vec($win,$fn,1) = 1;\n         push @Outs, $_;\n      }\n   };\n\n   $nfound = select($rout=$rin, $wout=$win, $eout=$ein, $Timeout);\n   $nfound > 0 or return;\n   my $Services = 0; \n   if($Accepting){\n      for(@Listeners){\n         my $paddr;\n         vec($rout,fileno($_),1) or next;\n          while ($paddr=accept(my $NewServer, $_)){\n            $fn =fileno($NewServer); \n\t    $continue[$fn] = undef;\n\t    $Moustache[$fn] = {};\n            $inbuf[$fn] = $outbuf[$fn] = '';\n\t    ($Cport[$fn], my $iaddr) = sockaddr_in($paddr);\n\t    $Caddr[$fn] = inet_ntoa($iaddr);\n\n\t    my $mysockaddr = getsockname($NewServer);\n\t    ($Sport[$fn], $iaddr) = sockaddr_in($mysockaddr);\n\t    $Saddr[$fn] = inet_ntoa($iaddr);\n\n            print \"Accepted $NewServer (\",\n                  $fn,\") \",\n                  ++$client_tally,\n                  \"/$MaxClients on $_ ($fn) port $PortNo[fileno($_)]\\n\";\n            push @Clients, $NewServer;\n\n\t    BROKEN_NONBLOCKING and last; \n          }\n      }\n   } \n\n   my $wlen;\n   for my $OutFileHandle (@Outs){\n      $fn = fileno($OutFileHandle);\n      ((defined $fn) and vec($wout,$fn,1)) or next;\n         $Services++;\n      $wlen = syswrite $OutFileHandle, $outbuf[$fn], (BROKENSYSWRITE ? 1 : length($outbuf[$fn]));\n      if(defined $wlen){\n        DEBUG and print \"wrote $wlen of \",length($outbuf[$fn]),\" to ($fn)\\n\";\n        substr $outbuf[$fn], 0, $wlen, '';\n      \n        if(\n           length($outbuf[$fn]) < $StaticBufferSize\n        ){\n         if(\n           defined($LargeFile[$fn])\n         ){\n             my $slurp;\n             my $read = sysread $LargeFile[$fn], $slurp, $StaticBufferSize ;\n             if ($read){\n               $outbuf[$fn].= $slurp; \n             }else{\n                print \"sysread error: $!\" unless defined $read;\n                delete $LargeFile[$fn];\n             };\n         }elsif(\n           $continue[$fn]\n         ){\n           *_ = $Moustache[$fn]; \n           $_{Data} = '';\n   \t   HandleDRV( &{$continue[$fn]} );\n           length ($outbuf[$fn]) or push @PollMe, $fn;\n           next;\n         };\n        }\n      }else{\n         warn \"Error writing to socket $OutFileHandle ($fn): $!\";\n         $outbuf[$fn] = '';\n      }\n\n      length($outbuf[$fn]) or close $OutFileHandle;\n   }\n\n   for(@Clients){\n      defined($fn = fileno($_)) or next;\n      if(vec($rout,$fn,1)){\n\n         my $char;\n         sysread $_,$char,64000;\n\t if(length $char){\n                DEBUG and print \"$fn: read [$char]\\n\";\n\t\t$inbuf[$fn] .= $char;\n                if($inbuf[$fn] =~\n/^POST .*?Content-Length: ?(\\d+)[\\015\\012]+(.*)$/is){\n                   DEBUG and print \"posting $1 bytes\\n\";\n                   if(length $2 >= $1){\n                      push @CompleteRequests, $fn;\n                      $PostData[$fn] = $2;\n                   }else{\n                      if(DEBUG){\n                       print \"$fn: Waiting for $1 octets of POST data\\n\";\n                       print \"$fn: only have \",length($2),\"\\n\";\n                      }\n                   }\n\t\t}elsif(substr($inbuf[$fn],-4,4) eq \"\\015\\012\\015\\012\"){\n                   push @CompleteRequests, $fn;\n                }elsif(DEBUG){\n                   print \"Waiting for request completion. So far have\\n[\",\n                   $inbuf[$fn],\"]\\n\";\n\n                };   \n\t }else{\n            print \"Received empty packet on $_ ($fn)\\n\";\n\t\t print \"CLOSING fd $fn\\n\";\n                 close $_ or print \"error on close: $!\\n\";\n                 $client_tally--;\n                 print \"down to $client_tally / $MaxClients\\n\";\n\t };\n      }\n      if(vec($eout,$fn,1)){\n         print \"error on $_ ($fn)\\n\";\n\t print \"CLOSING fd $fn\\n\";\n         close $_ or print \"error on close: $!\\n\";\n      };\n   }\n\n\n   @Clients = grep { defined fileno($_) } @Clients;\n   $client_tally = @Clients;\n   DEBUG and print \"$client_tally / $MaxClients\\n\";\n\n   for $fn (@CompleteRequests){\n\n      HandleRequest\n\n   };\n\n   $Services and goto BEGIN_SERVICE; \n\n\n};\n\n\n\n\n1;\n__END__\n\n\n",
      "file" : "/var/tmp/arv_hPJA0H/HTTP-Server-Singlethreaded-0.12/Singlethreaded.pm",
      "package" : "HTTP::Server::Singlethreaded"
   }
]
