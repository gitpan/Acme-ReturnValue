[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub recur {\n    my $class = shift;\n    my %args = @_;\n    my %args_backup = @_;\n\n    if ( exists $args{count} )\n    {\n        my $n = $args{count};\n        delete $args{count};\n        my $count_inf = $class->recur( %args )->{set}\n                  ->select( count => $n );\n        return bless { set => $count_inf }, 'DateTime::Set';\n    }\n\n\n    my %tmp_args = @_;\n    delete $tmp_args{dtstart};\n    delete $tmp_args{dtend};\n    my $recur_str = _param_str(%tmp_args);\n\n    my $span = \n        exists $args{dtstart} ?\n            DateTime::Span->from_datetimes( start => $args{dtstart} ) :\n            DateTime::Set->empty_set->complement;\n\n    $span = $span->complement( \n                DateTime::Span->from_datetimes( after => delete $args{dtend} )\n            ) if exists $args{dtend};\n\n    $span = $span->complement(\n                DateTime::Span->from_datetimes( after => delete $args{until} )\n            ) if exists $args{until};\n\n    $args{interval} = 1 unless $args{interval};\n\n    my $dtstart = exists $args{dtstart} ?\n            delete $args{dtstart} : \n            DateTime->new( year => 2000, month => 1, day => 1 );\n\n    if ( $args{freq} eq 'daily' ) {\n        if ( exists $args{bymonth} &&\n             $args{interval} == 1 ) \n        {\n            $args{freq} = 'yearly';\n            $args{bymonthday} = [ 1 .. 31 ] unless exists $args{bymonthday};\n        }\n    }\n\n    my $base_set;\n    my %by;\n\n    $base_set = _recur_by_freq($args{freq},$dtstart,\\%args);\n    unless (defined $base_set) {\n        die \"invalid freq ($args{freq})\";\n    }\n\n    delete $args{wkst};    \n\n\n    %by = ();\n    my $has_day = 0;\n\n    my $by_year_day;\n    if ( exists $args{byyearday} ) \n    {\n        $by_year_day = _yearly_recurrence($dtstart, \\%args);\n    }\n\n    my $by_month_day;\n    if ( exists $args{bymonthday} ||\n         exists $args{bymonth} ) \n    {\n        $by_month_day = _yearly_recurrence($dtstart, \\%args);\n    }\n\n    my $by_week_day;\n    if ( exists $args{byday} ||\n         exists $args{byweekno} ) \n    {\n        $by_week_day = _weekly_recurrence($dtstart, \\%args);\n    }\n\n    my $by_hour;\n    if ( exists $args{byhour} ) \n    {\n        my %by = %args;\n        $by{byminute} = $args_backup{byminute} if $args_backup{byminute};\n        $by{byminute} = [ 0 .. 59 ] if $args{freq} eq 'minutely';\n        $by{bysecond} = $args_backup{bysecond} if $args_backup{bysecond};\n        $by{bysecond} = [ 0 .. 59 ] if $args{freq} eq 'secondly';\n        $by_hour = _daily_recurrence($dtstart, \\%by);\n        delete $args{byhour};\n    }\n\n\n    $base_set = $base_set && $by_year_day ?\n                $base_set->intersection( $by_year_day ) :\n                ( $base_set ? $base_set : $by_year_day );\n    $base_set = $base_set && $by_month_day ?\n                $base_set->intersection( $by_month_day ) :\n                ( $base_set ? $base_set : $by_month_day );\n    $base_set = $base_set && $by_week_day ?\n                $base_set->intersection( $by_week_day ) :\n                ( $base_set ? $base_set : $by_week_day );\n    $base_set = $base_set && $by_hour ?\n                $base_set->intersection( $by_hour ) :\n                ( $base_set ? $base_set : $by_hour );\n\n\n    if ( exists $args{bysetpos} ) {\n        $base_set = _recur_bysetpos (\n            freq => $args{freq},\n            interval => $args{interval},\n            bysetpos => $args{bysetpos},\n            recurrence => $base_set );\n        delete $args{bysetpos};\n    }\n\n    $base_set = $base_set->intersection( $span )\n                if $span;\n\n    delete $args{freq};\n    my @args = %args;\n    die \"these arguments are not implemented: \"._param_str(%args) if @args;\n\n    bless $base_set, 'DateTime::Set::ICal';\n    $base_set->set_ical( include => [ uc('rrule:'.$recur_str) ] ); \n\n    return $base_set;\n}",
      "file" : "/var/tmp/arv__yExRP/DateTime-Event-ICal-0.11/lib/DateTime/Event/ICal.pm",
      "package" : "DateTime::Event::ICal"
   }
]
