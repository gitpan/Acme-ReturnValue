[
   {
      "PPI" : "PPI::Statement::Sub",
      "bad" : "sub new\n  {\n  my ($class, %parameters) = @_;\n  if ($^O ne 'MSWin32')\n    {\n    DEBUG && print STDERR \" DDD this is not windows\\n\";\n    return undef;\n    } \n  my (@asTry, $sCscript);\n  push @asTry, catfile($ENV{windir}, 'system32', 'cscript.exe');\n  foreach my $sTry (@asTry)\n    {\n    if (-f $sTry)\n      {\n      $sCscript = $sTry;\n      last;\n      } \n    } \n  DEBUG && print STDERR \" DDD cscript is ==$sCscript==\\n\";\n  if ($sCscript eq '')\n    {\n    warn \"can not find executable cscript\\n\";\n    return undef;\n    } \n  eval q{use Win32API::File qw( :DRIVE_ )};\n  if ($@)\n    {\n    DEBUG && warn \" EEE can not use Win32API::File because $@\\n\";\n    return undef;\n    } \n  my @asDrive = Win32API::File::getLogicalDrives();\n  DEBUG && print STDERR \" DDD logical drives are: @asDrive\\n\";\n  my @asHD;\n  foreach my $sDrive (@asDrive)\n    {\n    my $sType = Win32API::File::GetDriveType($sDrive);\n    push @asHD, $sDrive if ($sType eq eval'DRIVE_FIXED');\n    } # foreach\n  DEBUG && print STDERR \" DDD hard drives are: @asHD\\n\";\n  # Find the adsutil.vbs script:\n  my $sAdsutil = '';\n  @asTry = ();\n  # This is the default location, according to microsoft.com:\n  push @asTry, catdir($ENV{windir}, qw( System32 Inetsrv AdminSamples ));\n  # This is where I find it on my old IIS installation:\n  push @asTry, map { catdir($_, qw( inetpub AdminScripts )) } @asHD;\n  @asTry = map { catfile($_, 'adsutil.vbs') } @asTry;\n  foreach my $sTry (@asTry)\n    {\n    if (-f $sTry)\n      {\n      $sAdsutil = $sTry;\n      last;\n      } # if\n    } # foreach\n  DEBUG && print STDERR \" DDD adsutil is ==$sAdsutil==\\n\";\n  if ($sAdsutil eq '')\n    {\n    warn \"can not find adsutil.vbs\\n\";\n    return undef;\n    } # if\n  # Now we have all the info we need to get started:\n  my %hash = (\n              adsutil => $sAdsutil,\n              cscript => $sCscript,\n             );\n  my $self = bless (\\%hash, ref ($class) || $class);\n  return $self;\n  } # new\n\n\n# Not published.\n\nsub _config_set_value\n  {\n  my $self = shift;\n  local $\" = ',';\n  DEBUG_SET && print STDERR \" DDD _config_set_value(@_)\\n\";\n  # Required arg1 = section:\n  my $sSection = shift || '';\n  return unless ($sSection ne '');\n  # Required arg2 = parameter name:\n  my $sParameter = shift || '';\n  return unless ($sParameter ne '');\n  # Remaining arg(s) will be taken as the value(s) for this parameter.\n  return unless @_;\n  my $sRes = $self->_execute_script('adsutil', 'SET', \"$sSection/$sParameter\", map { qq/\"$_\"/ } @_);\n  if ($sRes =~ m!ERROR TRYING TO GET THE SCHEMA!i)\n    {\n    # Unknown parameter name:\n    $self->_add_error($sRes);\n    return;\n    } # if\n  if ($sRes =~ m!ERROR TRYING TO GET THE OBJECT!i)\n    {\n    # Section does not exist:\n    $self->_add_error($sRes);\n    return;\n    } # if\n  if ($sRes =~ m!ERROR TRYING TO SET THE PROPERTY!i)\n    {\n    # Type mismatch\n    $self->_add_error($sRes);\n    return;\n    } # if\n  # Assume success at this point:\n  return '';\n  } # _config_set_value\n\n\n# Not published.\n\nsub _config_get_value\n  {\n  my $self = shift;\n  local $\" = ',';\n  DEBUG_FETCH && print STDERR \" DDD _config_get_value(@_)\\n\";\n  # Required arg1 = section:\n  my $sSection = shift || '';\n  return unless ($sSection ne '');\n  # Required arg2 = parameter name:\n  my $sParameter = shift || '';\n  return unless ($sParameter ne '');\n  my $sRes = $self->_execute_script('adsutil', 'GET', \"$sSection/$sParameter\");\n  if ($sRes =~ m!ERROR TRYING TO GET!i)\n    {\n    $self->_add_error($sRes);\n    return;\n    } # if\n  my $oIS = IO::String->new($sRes);\n  my $sLine = <$oIS>;\n  if ($sLine =~ m!\\A(\\S+)\\s+:\\s+\\((\\S+)\\)\\s*(.+)\\Z!)\n    {\n    my ($sProperty, $sType, $sValue) = ($1, $2, $3);\n    my @asValue;\n    if ($sType eq 'STRING')\n      {\n      # Protect backslashes, in case this value is a dir/file path:\n      $sValue =~ s!\\\\!/!g;\n      $sValue = eval $sValue;\n      return $sValue;\n      } # if STRING\n    elsif ($sType eq 'INTEGER')\n      {\n      $sValue = eval $sValue;\n      return $sValue;\n      } # if INTEGER\n    elsif ($sType eq 'EXPANDSZ')\n      {\n      # Protect backslashes, this value is a dir/file path:\n      $sValue =~ s!\\\\!/!g;\n      $sValue = eval $sValue;\n      $sValue =~ s!%([^%]+)%!$ENV{$1}!g;\n      return $sValue;\n      } # if INTEGER\n    elsif ($sType eq 'BOOLEAN')\n      {\n      $sValue = ($sValue eq 'True');\n      return $sValue;\n      }\n    elsif ($sType eq 'LIST')\n      {\n      my @asValue = ();\n      if ($sValue =~ m!(\\d+)\\sItems!)\n        {\n        my $iCount = 0 + $1;\n      ITEM_OF_LIST:\n        for (1..$iCount)\n          {\n          my $sSubline = <$oIS>;\n          if ($sSubline =~ m!\\A\\s+\\042([^\"]+)\\042!) #\n            {\n            push @asValue, $1;\n            } # if\n          else\n            {\n            print STDERR \" WWW list item does not look like string, in line ==$sLine==\\n\";\n            }\n          } # for ITEM_OF_LIST\n        } # if\n      else\n        {\n        print STDERR \" WWW found LIST type but not item count at line ==$sLine==\\n\";\n        next LINE_OF_CONFIG;\n        }\n      return \\@asValue;\n      } # if LIST\n    elsif ($sType eq 'MimeMapList')\n      {\n      my %hash;\n      while ($sValue =~ m!\"(\\S+)\"!g)\n        {\n        my ($sExt, $sType) = split(',', $1);\n        $hash{$sExt} = $sType;\n        } # while\n      return \\%hash;\n      }\n    else\n      {\n      print STDERR \" EEE unknown type =$sType=\\n\";\n      }\n    } # if PropertyName : (TYPE) value\n  else\n    {\n    DEBUG_PARSE && print STDERR \" WWW unparsable line ==$sLine==\\n\";\n    }\n  return;\n  } # _config_get_value\n\n\n=item iis_version\n\nReturns the version of IIS found on this machine,\nin a decimal number format like \"6.0\".\n\n=cut\n\nsub iis_version\n  {\n  my $self = shift;\n  if (! defined  $self->{_iss_version_})\n    {\n    my $iMajor = $self->_config_get_value('/W3SVC/Info',\n                                          'MajorIIsVersionNumber');\n    my $iMinor = $self->_config_get_value('/W3SVC/Info',\n                                          'MinorIIsVersionNumber');\n    $self->{_iss_version_} = \"$iMajor.$iMinor\";\n    } # if\n  return $self->{_iss_version_};\n  } # iis_version\n\n\n=item get_timeout\n\nReturns the IIS timeout value.\n\n=cut\n\nsub get_timeout\n  {\n  my $self = shift;\n  $self->_config_get_value('/W3SVC', 'CGITimeout');\n  } # set_timeout\n\n\n=item set_timeout\n\nGiven an integer,\nsets the IIS timeout to that value.\nDoes no checking on the value passed in, so use carefully!\n\n=cut\n\nsub set_timeout\n  {\n  my $self = shift;\n  # Required arg1 = an integer:\n  my $iArg = shift() + 0;\n  $self->_config_set_value('/W3SVC', 'CGITimeout', $iArg);\n  } # set_timeout\n\n\n=item path_of_virtual_dir\n\nGiven the name of a virtual directory (or 'ROOT'),\nreturns the absolute full path of where the physical files are located.\nReturns undef if there is no virtual directory matching the name given.\n\n=cut\n\nsub path_of_virtual_dir\n  {\n  my $self = shift;\n  my $sDir = shift || '';\n  if ($sDir eq '')\n    {\n    $self->_add_error(qq(Argument <virtual dir name> is required on path_of_virtual_dir.));\n    return;\n    } # if\n  # We cravenly refuse to modify anything but the default #1 webserver:\n  my $sWebsite = 1;\n  if ($sDir eq 'ROOT')\n    {\n    goto ROOT;\n    } # if\n  my $sVersion = $self->iis_version;\n  if (\"6.0\" le $sVersion)\n    {\n    my $sSection = join('/', 'W3SVC', $sWebsite);\n    my $sRes .= $self->_execute_script('iisvdir', '/query', $sSection) || '';\n    if ($sRes =~ m!Error!)\n      {\n      $self->_add_error($sRes);\n      return;\n      } # if\n    DEBUG_FETCH && print STDERR \" DDD iisvdir returned:\", $sRes;\n    my $oIS = IO::String->new($sRes);\n  FIND_DIVIDER_LINE:\n    while (my $sLine = <$oIS>)\n      {\n      last if ($sLine =~ m!={22}!);\n      } # while FIND_DIVIDER_LINE\n  VIR_DIR_LINE:\n    while (my $sLine = <$oIS>)\n      {\n      chomp $sLine;\n      my ($sVirDir, $sPath) = split(/ +/, $sLine);\n      DEBUG_FETCH && print STDERR \" DDD found virdir=$sVirDir==>$sPath\\n\";\n      # Question: do we want to match the vir-dir name\n      # case-INsensitively?\n      if ($sVirDir =~ m!\\A/?$sDir\\Z!)\n        {\n        return $sPath;\n        } # if\n      } # while VIR_DIR_LINE\n    return '';\n    } # if\n ROOT:\n  # If we get here, we must be using IIS 5.0:\n  my $sSection = join('/', '', 'W3SVC', $sWebsite, 'ROOT');\n  if ($sDir !~ m!\\AROOT\\Z!i)\n    {\n    $sSection .= \"/$sDir\";\n    } # if\n  my $sPath = $self->_config_get_value($sSection, 'Path') || '';\n  return $sPath;\n  } # path_of_virtual_dir\n\n\n=item create_virtual_dir\n\nGiven the following named arguments, create a virtual directory on the\ndefault #1 server on the local machine's IIS instance.\n\n=over\n\n=item -dir_name => 'virtual'\n\nThis is the virtual directory name as it will appear to your browsers.\n\n=item -path => 'C:/local/path'\n\nThis is the full path the the actual location of the data files.\n\n=item -executable => 1\n\nGive this argument if your virtual directory holds executable programs.\nDefault is 0 (NOT executable).\n\n=back\n\n=cut\n\nsub create_virtual_dir\n  {\n  my $self = shift;\n  my %hArgs = @_;\n  $hArgs{-dir_name} ||= '';\n  if ($hArgs{-dir_name} eq '')\n    {\n    $self->_add_error(qq(Argument -dir_name is required on create_virtual_dir.));\n    return;\n    } # if\n  $hArgs{-path} ||= '';\n  if ($hArgs{-path} eq '')\n    {\n    $self->_add_error(qq(Argument -path is required on create_virtual_dir.));\n    return;\n    } # if\n  $hArgs{-executable} ||= 0;\n  # print STDERR Dumper(\\%hArgs);\n  # We cravenly refuse to modify anything but the default #1 webserver:\n  my $sWebsite = 1;\n  # First, see if a virtual directory with the same name is already\n  # exists:\n  my $sPath = $self->path_of_virtual_dir($hArgs{-dir_name});\n  my $sRes = '';\n  if ($sPath ne '')\n    {\n    # There is already a virtual directory with that name.  Create a\n    # sensible error message:\n    if ($sPath ne $hArgs{-path})\n      {\n      $self->_add_error(qq(There is already a virtual directory named '$hArgs{-dir_name}', but it points to $sPath));\n      return;\n      } # if\n    $self->_add_error(qq(There is already a virtual directory named '$hArgs{-dir_name}' pointing to $sPath));\n    # Fall through and (try to) set the access rules.\n    } # if\n  else\n    {\n    # Virtual dir not there, create it:\n    my @asArgs = ('mkwebdir',\n                  qq(-v \"$hArgs{-dir_name}\",\"$hArgs{-path}\"),\n                  qq(-w $sWebsite),\n                  # qq(-c $sComputer),\n                 );\n    if ('6.0' le $self->iis_version)\n      {\n      @asArgs = ('iisvdir', '/create', \"W3SVC/$sWebsite\",\n                 $hArgs{-dir_name}, $hArgs{-path});\n      } # if\n    $sRes .= $self->_execute_script(@asArgs) || '';\n    if ($sRes =~ m!Error!)\n      {\n      $self->_add_error($sRes);\n      return;\n      } # if\n    } # else\n  # Whether the dir was already defined or not, try to set permissions\n  # as requested:\n  if ($hArgs{-executable})\n    {\n    my $sSection = join('/', '', 'W3SVC', $sWebsite, 'Root', $hArgs{-dir_name});\n    if ('6.0' le $self->iis_version)\n      {\n      $sRes .= $self->_config_set_value($sSection, \"AccessExecute\", 'True');\n      # These seem to get turned on by default, but we'll make them\n      # explicit anyway:\n      $sRes .= $self->_config_set_value($sSection, \"AccessScript\", 'True');\n      $sRes .= $self->_config_set_value($sSection, \"AccessRead\", 'True');\n      }\n    else\n      {\n      # For some reason, the argument to chaccess has no leading slash\n      # (some other scripts require leading slash):\n      $sSection =~ s!\\A/!!;\n      # Set accesses for execution:\n      $sRes .= $self->_execute_script('chaccess',\n                                      -a => $sSection,\n                                      qw( +execute +read +script ),\n                                     );\n      } # else\n    } # if\n  return $sRes;\n  } # create_virtual_dir\n\n\n=item add_extension_restriction\n\nGiven the following named arguments,\nadds an \"extension restriction\" to\nthe default #1 server on the local machine's IIS instance.\nOnly works on IIS version 6.0.\nNote: no checking is done on the arguments,\nso it is possible to add bogus/duplicate/conflicting/illegal values to your IIS configuration.\nFor more information, see\nhttp://www.microsoft.com/technet/prodtechnol/WindowsServer2003/Library/IIS/79652e88-e713-4aa5-a88c-8e2bd6a2955e.mspx?mfr=true\n\n\nsub add_extension_restriction\n  {\n  my $self = shift;\n  if ($self->iis_version < 6.0)\n    {\n    return;\n    } \n  my %hArgs = (\n               -allow => 0,\n               -groupid => '',\n               -description => '',\n               @_,\n               -deletable => 1,\n              );\n  $hArgs{-allow} = 0 if ($hArgs{-allow} ne '1');\n  if (! exists $hArgs{-path})\n    {\n    $self->add_error(\"add_extension_restriction() called without required argument -path\");\n    return;\n    } \n  my $s = join(',', @hArgs{qw( -allow -path -deletable -groupid -description )});\n  my $ra = $self->_config_get_value('/W3SVC', 'WebSvcExtRestrictionList');\n  push @{$ra}, $s;\n  $self->_config_set_value('/W3SVC', 'WebSvcExtRestrictionList', @{$ra});\n  } \n\n\n\nsub remove_extension_restriction\n  {\n  my $self = shift;\n  my $sPath = shift || '';\n  DEBUG_EXT && print STDERR \" DDD remove_extension_restriction($sPath)\\n\";\n  $self->_remove_extension_restriction_by_elem($sPath, 1);\n  } \n\n\n\nsub remove_extension_restriction_group\n  {\n  my $self = shift;\n  my $sValue = shift || '';\n  DEBUG_EXT && print STDERR \" DDD remove_extension_restriction_group($sValue)\\n\";\n  $self->_remove_extension_restriction_by_elem($sValue, 3);\n  } \n\n\nsub _remove_extension_restriction_by_elem\n  {\n  my $self = shift;\n  my $sValue = shift || '';\n  my $iElem = shift;\n  return if ! defined($iElem);\n  return if ($iElem < 0);\n  return if (4 < $iElem);\n  if ($sValue eq '')\n    {\n    return;\n    } \n  if ($self->iis_version < 6.0)\n    {\n    return;\n    } \n  my $rasOrig = $self->_config_get_value('/W3SVC', 'WebSvcExtRestrictionList');\n  DEBUG_EXT && print STDERR \" DDD   before, list is \", Dumper($rasOrig);\n  my @asNew;\n  foreach my $s (@$rasOrig)\n    {\n    my @asElem = split(',', $s);\n    if (($asElem[$iElem] || '') eq $sValue)\n      {\n      DEBUG_EXT && print STDERR \" DDD   found one to remove\\n\";\n      }\n    else\n      {\n      push @asNew, $s;\n      }\n    } \n  DEBUG_EXT && print STDERR \" DDD   after, list is \", Dumper(\\@asNew);\n  $self->_config_set_value('/W3SVC', 'WebSvcExtRestrictionList', @asNew);\n  } \n\n\n\nsub restart_iis\n  {\n  my $self = shift;\n  my $sProg = 'IISReset';\n  my $iRes = system(qq'$sProg /RESTART');\n  if ($iRes)\n    {\n    $self->add_error(\"$sProg failed: $!\");\n    } \n  } \n\n\n\nsub errors\n  {\n  } \n\nsub _add_error\n  {\n  my $self = shift;\n  print STDERR \"@_\\n\";\n  } \n\nsub _execute_script\n  {\n  my $self = shift;\n  my $sVBS = shift;\n  my $sScriptFname;\n  if (defined $self->{$sVBS})\n    {\n    $sScriptFname = $self->{$sVBS};\n    }\n  else\n    {\n    $sScriptFname = $self->{cscript};\n    $sScriptFname =~ s!cscript\\.exe!$sVBS.vbs!i;\n    }\n  my $sCmd = join(' ', $self->{cscript}, '-nologo', $sScriptFname, @_);\n  DEBUG_EXEC && print STDERR \" DDD exec ==$sCmd==\\n\";\n  my $sRes = qx/$sCmd/;\n  print STDERR \" DDD   result ===$sRes===\\n\" if (1 < DEBUG_EXEC);\n  return $sRes;\n  } \n\n\n1;\n\n__END__\n\n",
      "file" : "/var/tmp/arv_DbREtT/Win32-IIS-Admin-1.024/lib/Win32/IIS/Admin.pm",
      "package" : "Win32::IIS::Admin"
   }
]
