[
   {
      "PPI" : "PPI::Statement::Include",
      "bad" : "use Class::Autouse (<<'#\\'END_USE' =~ m!(\\w+::[\\w:]+)!g);\n\nuse Mail::Summary::Tools::CLI::Context;\nuse Mail::Summary::Tools::CLI::Config;\n\n#'END_USE\n\nuse strict;\nuse warnings;\n\nuse constant global_opt_spec => (\n\t[ \"verbose|v!\" => \"Verbose output\" ],\n);\n\nuse constant plugin_search_path => __PACKAGE__;\n\nsub _module_pluggable_options {\n\treturn (\n\t\tonly   => qr/CLI::\\w+$/x, \n\t\texcept => qr/CLI::(?:Context|Config|Command)$/,\n\t);\n}\n\nsub config {\n\tmy $self = shift;\n\t$self->{config} ||= Mail::Summary::Tools::CLI::Config->new();\n}\n\nsub context {\n\tmy $self = shift;\n\t$self->{context} ||= Mail::Summary::Tools::CLI::Context->new();\n}\n\n__PACKAGE__;\n\n__END__\n\n\n\n",
      "file" : "/var/tmp/arv_nA99Ua/Mail-Summary-Tools-0.06/lib/Mail/Summary/Tools/CLI.pm",
      "package" : "Mail::Summary::Tools::CLI"
   },
   {
      "PPI" : "PPI::Statement::Include",
      "bad" : "use Class::Autouse (<<'#\\'END_USE' =~ m!(\\w+::[\\w:]+)!g);\n\nuse Mail::Summary::Tools::Summary;\nuse Mail::Summary::Tools::Output::TT;\n\n#'END_USE\n\nuse Text::Wrap ();\n\nuse constant options => (\n\t[ 'verbose|v!'    => \"Output progress information\" ],\n    [ 'input|i=s'     => 'Summary file to read' ],\n    [ 'output|o=s'    => 'The file to output (defaults to STDOUT)' ],\n\t[ 'shortening|s!' => \"Enable URI shortening (defaults to true)\", { default => 1 } ],\n    [ 'shorten=s'     => 'shortening service (defaults to \"Metamark\" -- http://xrl.us/)' ], \n    [ 'archive|a=s'   => 'The on-line archive to use (defaults to \"google\")', { default => \"google\" }],\n\t[ 'columns|c=i'   => 'The column width to wrap to (defaults to 75)', { default => 75 } ],\n    [ 'force_wrap|w!' => 'Force wrapping of overflowed text (like long URIs)' ], \n\t[ 'template=s'    => \"Override the template toolkit file used to format the text\" ],\n);\n\nsub usage_desc {\n\t\"%c totext %o [summary.yaml]\"\n}\n\nsub wrap {\n    my ( $self, $text, $columns, $first_indent, $rest_indent ) = @_;\n\n    $columns ||= $self->{opt}{columns} || 80;\n    $first_indent ||= '    ';\n    $rest_indent  ||= '    ';\n\n    no warnings 'once';\n    local $Text::Wrap::huge = $self->_wrap_huge;\n    local $Text::Wrap::columns = $columns;\n\n\t$text =~ s/\\\\(\\S)/$1/g; \n\n    Text::Wrap::fill( $first_indent, $rest_indent, $self->process_body($text) );\n}\n\nsub process_body {\n\tmy ( $self, $text ) = @_;\n\n\t$text =~ s/<(\\w+:\\S+?)>/$self->expand_uri($1)/ge;\n\t$text =~ s/\\[(.*?)\\]\\((\\w+:\\S+?)\\)/$self->expand_uri($2, $1)/sge;\n\n\treturn $text;\n}\n\nsub bullet {\n    my ( $self, $text, $columns ) = @_;\n    $self->wrap( $text, $columns, '    * ', '      ' );\n}\n\nsub subject {\n    my ( $self, $text, $columns ) = @_;\n    $self->wrap( $text, $columns, '  ', '  ' );\n}\n\nsub heading {\n    my ( $self, $text, $columns ) = @_;\n    $self->wrap( $text, $columns, ' ', ' ' );\n}\n\nsub _wrap_huge {\n    my $self = shift;\n    return $self->{opt}{force_wrap} ? 'wrap' : 'overflow'; \n}\n\nsub shorten {\n    my ( $self, $uri ) = @_;\n\n\tif ( $self->should_shorten($uri) ) {\n\t\t$self->really_shorten( $uri );\n\t} else {\n\t\treturn $uri;\n\t}\n}\n\nsub rt_uri {\n\tmy ( $self, $rt, $id ) = @_;\n\n\tif ( $rt eq \"perl\" ) {\n\t\treturn $self->shorten(\"http://rt.perl.org/rt3/Ticket/Display.html?id=$id\");\n\t} else {\n\t\tdie \"unknown rt installation: $rt\";\n\t}\n}\n\nsub link_to_message {\n\tmy ( $self, $message_id, $text ) = @_;\n\n\tmy $thread = $self->{__summary}->get_thread_by_id( $message_id )\n\t\t|| die \"The link to <$message_id> could not be resolved, because no thread with that message ID is in the summary data\";\n\n\tmy $uri = $self->shorten($thread->archive_link->thread_uri);\n\t\n\t$text ||= $thread->subject;\n\n\t\"$text <$uri>\";\n}\n\nsub expand_uri {\n\tmy ( $self, $uri_string, $text ) = @_;\n\n\tmy $uri = URI->new($uri_string);\n\n\tif ( $uri->scheme eq 'rt' ) {\n\t\tmy ( $rt, $id ) = ( $uri->authority, substr($uri->path, 1) );\n\t   \tmy $rt_uri = $self->rt_uri($rt, $id);\n\t\t$text ||= \"[$rt #$id]\";\n\t\treturn \"$text <$rt_uri>\";\n\t} elsif ( $uri->scheme eq 'msgid' ) {\n\t\treturn $self->link_to_message( join(\"\", grep { defined } $uri->authority, $uri->path), $text );\n\t} else {\n\t\tmy $short_uri = $self->shorten($uri) || $uri;\n\t\treturn $text ? \"$text <$short_uri>\" : \"<$short_uri>\";\n\t}\n}\n\nsub really_shorten {\n    my ( $self, $uri ) = @_;\n    my $service = $self->{opt}{shorten};\n\n\tmy $cache = $self->app->context->cache;\n\n\tmy $cache_key = join(\":\", \"shorten\", $service, $uri);\n\n\tif ( my $short = $cache->get($cache_key) ) {\n\t\treturn $short;\n\t} else {\n\t\t$self->diag( \"Shortening URI (cache miss): $uri\" );\n\t\tmy $mod = \"WWW::Shorten::$service\";\n\t\tunless ( $mod->can(\"makeashorterlink\") ) {\n\t\t\tmy $file = join(\"/\", split(\"::\", $mod ) ) . \".pm\";\n\t\t\trequire $file;\n\t\t}\n\n\t\tno strict 'refs';\n\t\tmy $short = &{\"${mod}::makeashorterlink\"}( $uri );\n\t\t$cache->set( $cache_key, $short ) if $short;\n\t\treturn $short || \"$uri\";\n\t}\n}\n\nsub shortening_enabled {\n    my ( $self, $uri ) = @_;\n    if ( $self->{opt}{shorten} ) {\n        return 1;\n    } else {\n        return;\n    }\n}\n\nsub should_shorten {\n    my ( $self, $uri ) = @_;\n    return unless $self->shortening_enabled;\n\n    length($uri) > 40 || $uri =~ /gmane|groups\\.google/\n}\n\nsub template_input {\n    my $self = shift;\n\n    if ( my $file = $self->{opt}{template} ) {\n        open my $fh, \"<\", $file or die \"Couldn't open template (open($file): $!)\\n\";\n\t\tbinmode $fh, \":utf8\";\n        return $fh;\n    } else {\n\t\tbinmode DATA, \":utf8\";\n        return \\*DATA;\n    }\n}\n\nsub template_output {\n    my $self = shift;\n\tmy $opt = $self->{opt};\n    \n    if ( !$opt->{output} or $opt->{output} eq '-' ) {\n\t\tbinmode STDOUT, \":utf8\";\n        return \\*STDOUT;\n    } elsif ( my $file = $opt->{output} ) {\n        open my $fh, \">\", $file or die \"Couldn't open output (open($file): $!)\\n\";\n\t\tbinmode $fh, \":utf8\";\n        return $fh;\n    }\n}\n\nsub validate {\n\tmy ( $self, $opt, $args ) = @_;\n\t@$args and $opt->{$_} ||= shift @$args for qw/input output/;\n\n\tunless ( $opt->{input} ) {\n\t\t$self->usage_error(\"Please specify an input summary YAML file.\");\n\t}\n\t\n\tif ( @$args ) {\n\t\t$self->usage_error(\"Unknown arguments: @$args.\");\n\t}\n\n\t$opt->{shortening} = 1 if exists $opt->{shorten};\n\t$opt->{shorten} ||= 'Metamark' if $opt->{shortening};\n\n\t$self->{opt} = $opt;\n}\n\nsub run {\n    my ( $self, $opt, $args ) = @_;\n\n    my $summary = Mail::Summary::Tools::Summary->load(\n        $opt->{input},\n        thread => {\n            default_archive => $opt->{archive} || \"google\",\n\t\t\tarchive_link_params => { cache => $self->app->context->cache },\n        },\n    );\n\n\tmy $o = Mail::Summary::Tools::Output::TT->new(\n\t\ttemplate_input  => $self->template_input,\n\t\ttemplate_output => $self->template_output,\n\t);\n\n\t$o->process(\n\t\t$self->{__summary} = $summary, \n\t\t{\n\t\t\tshorten => sub { $self->shorten(shift) },\n\t\t\twrap    => sub { $self->wrap(shift) },\n\t\t\tbullet  => sub { $self->bullet(shift) },\n\t\t\theading => sub { $self->heading(shift) },\n\t\t\tsubject => sub { $self->subject(shift) },\n\t\t},\n\t);\n}\n\n__PACKAGE__;\n\n\n__DATA__\n[% summary.title %]\n\n[% IF summary.extra.header %][% FOREACH section IN summary.extra.header %][% heading(section.title) %]\n\n[% wrap(section.body) %]\n[% END %]\n[% END %][% FOREACH list IN summary.lists %][% num_threads = 0 %][% list_block = BLOCK %]\n [% list.title %]\n[% IF list.extra.description %]\n[% wrap(list.extra.description) %]\n[% END %][% FOREACH thread IN list.threads %][% IF thread.hidden %][% NEXT %][% END %][% num_threads = num_threads + 1 %]\n[% head = BLOCK %][% thread.subject %] <[% shorten(thread.archive_link.thread_uri) %]>[% END %][% subject(head) %]\n\n[% IF thread.summary %][% wrap(thread.summary) %]\n[% ELSE %]    Posters:[% FOREACH participant IN thread.extra.posters %]\n    - [% participant.name %][% END %]\n[% END %][% END %][% END %][% IF num_threads > 0 %][% list_block %][% END %][% END %][% IF summary.extra.footer %][% FOREACH section IN summary.extra.footer %]\n[% heading(section.title) %]\n\n[% wrap(section.body) %]\n[% END %]\n[% END %][% IF summary.extra.see_also %][% heading(\"See Also\") %]\n\n[% FOREACH item IN summary.extra.see_also %][% link = BLOCK %][% item.name %] <[% shorten(item.uri ) %]>[% END %][% bullet(link) %]\n[% END %]\n[% END %]\n",
      "file" : "/var/tmp/arv_nA99Ua/Mail-Summary-Tools-0.06/lib/Mail/Summary/Tools/CLI/ToText.pm",
      "package" : "Mail::Summary::Tools::CLI::ToText"
   },
   {
      "PPI" : "PPI::Statement::Include",
      "bad" : "use Class::Autouse (<<'#\\'END_USE' =~ m!(\\w+::[\\w:]+)!g);\n\nuse Mail::Summary::Tools::Summary;\nuse Mail::Summary::Tools::Output::HTML;\n\n#'END_USE\n\nuse constant options => (\n\t[ 'verbose|v!'      => \"Output verbose information\" ],\n\t[ 'input|i=s'       => 'The summary YAML file to emit' ],\n\t[ 'output|o=s'      => 'A file to output to (defaults to STDOUT)' ],\n\t[ 'archive|a=s'     => 'On-line archive to use', { default => \"google\" } ],\n\t[ 'compact|c!'      => 'Emit compact HTML (no <div> tags, etc)' ],\n\t[ 'body_only|b!'    => 'Emit body fragment only (as opposed to a full, valid document)' ],\n\t[ 'xml|x!'          => \"use HTML::Element's as_XML method instead of the indented as_HTML\" ],\n\t[ 'xhtml!'          => \"hackishly use startag_XML in as_HTML mode to emit valid xhtml (defaults to true)\", { default => 1 }],\n\t[ 'h1=s@'           => 'Tags to use instead of h1 (e.g. --h1 p,b emits <p><b>heading</b></p>)', { default => [\"h1\"] } ],\n\t[ 'h2=s@'           => 'see h1', { default => [\"h2\"] } ],\n\t[ 'h3=s@'           => 'see h1', { default => [\"h3\"] } ],\n\t[ 'lang=s'          => 'sets the lang or xml:lang attribute of the <html> element', { default => \"en\" } ],\n);\n\nsub output {\n\tmy $self = shift;\n\tmy $opt = $self->{opt};\n\n\tif ( !$opt->{output} or $opt->{output} eq '-' ) {\n\t\tbinmode STDOUT, \":utf8\";\n\t\treturn \\*STDOUT;\n\t} elsif ( my $file = $opt->{output} ) {\n\t\topen my $fh, \">:utf8\", $file or die \"Couldn't open output (open($file): $!)\\n\";\n\t\treturn $fh;\n\t}\n}\n\nsub validate {\n\tmy ( $self, $opt, $args ) = @_;\n\t@$args and $opt->{$_} ||= shift @$args for qw/input output/;\n\n\tunless ( $opt->{input} ) {\n\t\t$self->usage_error(\"Please specify an input summary YAML file.\");\n\t}\n\t\n\tif ( @$args ) {\n\t\t$self->usage_error(\"Unknown arguments: @$args.\");\n\t}\n\n\tforeach my $tag ( qw/h1 h2 h3/ ) {\n\t\t@{ $opt->{$tag} } = map { split ',' } @{ $opt->{$tag} };\n\t}\n\n\t$self->{opt} = $opt;\n}\n\nsub run {\n\tmy ( $self, $opt, $args ) = @_;\n\n\tmy $summary = Mail::Summary::Tools::Summary->load(\n\t\t$opt->{input},\n\t\tthread => {\n\t\t\tdefault_archive => $opt->{archive} || \"google\",\n\t\t\tarchive_link_params => { cache => $self->app->context->cache },\n\t\t},\n\t);\n\n\tmy $o = Mail::Summary::Tools::Output::HTML->new(\n\t\tsummary    => $summary,\n\t\tbody_only  => $opt->{body_only},\n\t\tstrip_divs => $opt->{compact},\n\t\tlang       => $opt->{lang},\n\t\tmap { $_ . \"_tag\" => $opt->{$_} } qw/h1 h2 h3/,\n\t);\n\n\tmy @tree = $o->process;\n\n\t$self->print_tree($self->doctype, @tree);\n}\n\nsub pi_xhtml {\n\tHTML::Element->new('~literal' => text => '<?xml version=\"1.0\" encoding=\"UTF-8\"?>');\n}\n\nsub pi_xml {\n\tHTML::Element->new('~pi' => text => 'xml version=\"1.0\" encoding=\"UTF-8\"');\n}\n\nsub doctype_xhtml_11 {\n\tHTML::Element->new('~declaration' => text =>\n\t\t'DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"' . \"\\n\" .\n\t\t' \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"'\n\t);\n}\n\nsub doctype_html_401 {\n\tHTML::Element->new('~declaration' => text =>\n\t\t'DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"' . \"\\n\" .\n\t\t' \"http://www.w3.org/TR/html4/loose.dtd\"'\n\t);\n}\n\nsub doctype {\n\tmy $self = shift;\n\treturn if $self->{opt}{body_only};\n\n\tif ( $self->{opt}{xml} ) {\n\t\treturn ( $self->pi_xml, $self->doctype_xhtml_11 );\n\t} elsif ( $self->{opt}{xhtml} ) {\n\t\treturn ( $self->pi_xhtml, $self->doctype_xhtml_11 );\n\t} else {\n\t\treturn ( $self->doctype_html_401 );\n\t}\n}\n\nsub print_tree {\n\tmy ( $self, @tree ) = @_;\n\tmy $out = $self->output;\n\tprint $out $self->tree_to_text(@tree);\n}\n\nsub tree_to_text {\n\tmy ( $self, @tree ) = @_;\n\n\tif ( $self->{opt}{xml} ) {\n\t\treturn join(\"\", map { $_->as_XML } @tree);\n\t} else {\n\t\tno warnings 'redefine';\n\t\tlocal *HTML::Element::starttag = sub {\n\t\t\tmy ( $elem, $p ) = @_;\n\t\t\tmy $empty = $elem->_empty_element_map->{$elem->tag};\n\t\t\t$elem->starttag_XML($p, $empty ? 1 : () );\n\t\t} if $self->{opt}{xhtml};\n\n\t\tunless ( $self->{opt}{xhtml} ) {\n\t\t\tforeach my $subtree ( @tree ) {\n\t\t\t\tif ( $subtree->tag eq \"html\" ) {\n\t\t\t\t\t$subtree->attr( xmlns => undef );\n\t\t\t\t\t$subtree->attr( lang => $subtree->attr( 'xml:lang' => undef ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn join(\"\", map { $_->as_HTML(undef, '  ', {}) } @tree);\n\t}\n}\n\n__PACKAGE__;\n\n__END__\n",
      "file" : "/var/tmp/arv_nA99Ua/Mail-Summary-Tools-0.06/lib/Mail/Summary/Tools/CLI/ToHTML.pm",
      "package" : "Mail::Summary::Tools::CLI::ToHTML"
   },
   {
      "PPI" : "PPI::Statement::Include",
      "bad" : "use Class::Autouse (<<'#\\'END_USE' =~ m!(\\w+::[\\w:]+)!g);\n\nuse Mail::Summary::Tools::Summary;\nuse Mail::Summary::Tools::FlatFile;\nuse Proc::InvokeEditor;\n\n#'END_USE\n\nuse constant options => (\n\t[ 'verbose|v!'        => 'Output progress information' ],\n\t[ 'input|i=s'         => 'The summary file to edit' ],\n\t[ 'mode'              => hidden => { default => \"interactive\", one_of => [\n\t\t[ 'interactive'      => \"Edit the file interactively (the default)\" ],\n\t\t[ 'save'             => \"Output a flatfile to a file or STDOUT\" ],\n\t\t[ 'load'             => \"Load the specified file or STDIN into the summary\" ],\n\t] } ],\n\t[ 'skip|s!'           => 'Skip threads that have already been summarized' ],\n\t[ 'hidden|H!'         => 'Include hidden threads' ],\n\t[ 'links|l!'          => 'Include links to on-line archives', { default => 1 } ], \n\t[ 'archive|a=s'       => 'The rchive to use (defaults to \"google\")', { default => \"google\" } ],\n\t[ 'posters|p!'        => 'Include posters names in the comment section', { default => 1 } ],\n\t[ 'dates|d!'          => 'Include start and end dates in the comment section', { default => 1 } ],\n\t[ 'misc|m!'           => 'Include misc info in the comment section', { default => 1 } ],\n\t[ 'extra_fields|e=s@' => \"Additional fields to include in the YAML header (can be used several times)\" ],\n\t[ 'pattern|P=s@'      => \"Only include summaries matching this regex (matches against formatted text)\" ],\n);\n\nsub validate {\n\tmy ( $self, $opt, $args ) = @_;\n\t@$args and $opt->{$_} ||= shift @$args for qw/input/;\n\n\tunless ( $opt->{input} ) {\n\t\t$self->usage_error(\"Please specify an input summary YAML file.\");\n\t}\n\t\n\tif ( @$args ) {\n\t\t$self->usage_error(\"Unknown arguments: @$args.\");\n\t}\n\n\tif ( defined($opt->{load}) and $opt->{load} eq \"\" || $opt->{load} ) {\n\t\t$self->usage_error(\"You can choose one and only one of --interactive, --load or --save.\") if $opt->{interactive};\n\t\t$opt->{load} = \\*STDIN;\n\t\tunless ( ref( my $file = $opt->{load} ) ) {\n\t\t\topen my $in, \"<\", $file || die \"open($file): $!\";\n\t\t\t$opt->{load} = $in;\n\t\t}\n\n\t\tbinmode $opt->{load}, \":utf8\";\n\t}\n\t\n\tif ( defined($opt->{save}) and $opt->{save} eq \"\" || $opt->{save} ) {\n\t\t$self->usage_error(\"You can choose one and only one of --interactive, --load or --save.\") if $opt->{load};\n\t\t$opt->{save} = \\*STDOUT;\n\t\tunless ( ref( my $file = $opt->{save} ) ) {\n\t\t\topen my $out, \">\", $file || die \"open($file): $!\";\n\t\t\t$opt->{save} = $out;\n\t\t}\n\n\t\tbinmode $opt->{save}, \":utf8\";\n\t}\n\n\t$self->{opt} = $opt;\n}\n\nsub load_summary {\n\tmy $self = shift;\n\tmy $opt = $self->{opt};\n\n\tMail::Summary::Tools::Summary->load(\n\t\t$opt->{input},\n\t\tthread => {\n\t\t\tdefault_archive     => $opt->{archive},\n\t\t\tarchive_link_params => { cache => $self->app->context->cache },\n\t\t},\n\t);\n}\n\nsub create_flatfile {\n\tmy ( $self, $summary ) = @_;\n\tmy $opt = $self->{opt};\n\n\tMail::Summary::Tools::FlatFile->new(\n\t\tsummary         => $summary,\n\t\tskip_summarized => $opt->{skip},\n\t\tinclude_hidden  => $opt->{hidden},\n\t\tlist_posters    => $opt->{posters},\n\t\tlist_dates      => $opt->{dates},\n\t\tlist_misc       => $opt->{misc},\n\t\tadd_links       => $opt->{links},\n\t\textra_fields    => [ map { split ',', $_ } @{ $opt->{extra_fields} } ],\n\t\tpatterns        => [ map { qr/$_/ } @{ $opt->{pattern} || [] } ],\n\t);\n}\n\nsub run {\n\tmy ( $self, $opt, $args ) = @_;\n\tmy $method = \"run_$opt->{mode}\";\n\t$self->$method;\n}\n\nsub run_save {\n\tmy $self = shift;\n\n\tmy $out = $self->{opt}{save};\n\tprint $out $self->create_flatfile( $self->load_summary )->save;\n}\n\nsub run_load {\n\tmy $self = shift;\n\tmy $opt = $self->{opt};\n\n\tmy $summary = $self->load_summary;\n\tmy $flat = $self->create_flatfile( $summary );\n\n\tmy $in = $opt->{load}; \n\tmy $buffer = do { local $/; <$in> };\n\n\t$flat->load($buffer);\n\t$summary->save( $opt->{input} );\n}\n\nsub run_interactive {\n\tmy $self = shift;\n\tmy $opt = $self->{opt};\n\n\tmy $summary = $self->load_summary;\n\tmy $flat = $self->create_flatfile( $summary );\n\t\n\tmy $buffer = $flat->save;\n\tdo {\n\t\tif ( $@ ) {\n\t\t\tmy $err = $@;\n\t\t\t$err =~ s/^/# /mg;\n\t\t\t$buffer = \"# There was an error in your output:\\n\\n$err\\n\\n# to abort clear the entire file\\n\\n$buffer\";\n\t\t}\n\n\t\t$buffer = Proc::InvokeEditor->edit( $buffer );\n\n\t\texit unless $buffer =~ /\\S/;\n\n\t} until eval { $flat->load($buffer) };\n\n\t$summary->save( $opt->{input} );\n}\n\n__PACKAGE__;\n\n__END__\n\n\n\n",
      "file" : "/var/tmp/arv_nA99Ua/Mail-Summary-Tools-0.06/lib/Mail/Summary/Tools/CLI/Edit.pm",
      "package" : "Mail::Summary::Tools::CLI::Edit"
   },
   {
      "PPI" : "PPI::Statement::Include",
      "bad" : "use Class::Autouse (<<'#\\'END_USE' =~ m!(\\w+::[\\w:]+)!g);\n\nuse Mail::Box::Manager;\n\nuse Mail::Summary::Tools::Summary;\nuse Mail::Summary::Tools::Summary::List;\nuse Mail::Summary::Tools::Summary::Thread;\nuse Mail::Summary::Tools::ThreadFilter;\n\n#'END_USE\n\nuse Mail::Summary::Tools::ThreadFilter::Util qw/\n\tget_root_message guess_mailing_list\n\tthread_root last_in_thread any_in_thread all_in_thread\n\tnegate\n\tmailing_list_is in_date_range\n/; \n\nsub usage_desc {\n\t\"%c create %o summary.yaml mailbox [mailbox2]\\n\".\n\t\"%c create \\%o -o summary.yaml -i mailbox -i mailbox2\"\n}\n\nuse constant options => (\n\t[ 'input|i=s@'   => \"Mailboxes to read from (can be used several times)\" ],\n\t[ 'output|o=s'   => \"Summary file to write\" ],\n\t[ 'update|u!'    => \"Update an existing summary\" ],\n\t[ 'from|f=s'     => \"From date (any string Date::Manip can parse)\" ],\n\t[ 'to|t=s'       => \"To date (any string Date::Manip can parse)\" ],\n\t[ 'list|l=s@'    => \"Only posts in this list (can be used several times)\" ],\n\t[ 'posters|p!'   => \"Collect information about posters (defaults to true)\", { default => 1 } ],\n\t[ 'dates|d!'     => \"Collect information about dates (defaults to true)\", { default => 1 } ],\n\t[ 'clean|c!'     => \"Scrub the thread subjects\" ],\n\t[ 'rt|r!'        => \"Collect information about RT tickets (defaults to true)\", { default => 1 } ],\n);\n\nsub construct_filters {\n\tmy $self = shift;\n\n\treturn (\n\t\t$self->construct_date_filter,\n\t\t$self->construct_list_filter,\n\t\t$self->construct_subject_filter,\n\t);\n}\n\nsub construct_date_filter {\n\tmy $self = shift;\n\tmy $opt = $self->{opt};\n\n\tmy $from = DateTime::Format::DateManip->parse_datetime( $opt->{from} || return );\n\tmy $to   = DateTime::Format::DateManip->parse_datetime( $opt->{to} || return );\n\n\tif ( defined($from) || defined($to) ) {\n\t\t$from = DateTime::Infinite::Past->new   unless defined($from);\n\t\t$to   = DateTime::Infinite::Future->new unless defined($to);\n\n\t\treturn $self->comb_filter( in_date_range( $from, $to ) );\n\t} else {\n\t\tdie \"From or to date specification is invalid\\n\";\n\t}\n}\n\nsub construct_list_filter {\n\tmy $self = shift;\n\n\tif ( my $list = $self->{opt}{list} ) {\n\t\treturn $self->comb_filter( mailing_list_is($list) );\n\t} else {\n\t\treturn;\n\t}\n}\n\nsub construct_subject_filter {\n\treturn;\n}\n\nsub comb_filter {\n\tmy ( $self, $filter ) = @_;\n\tany_in_thread( $filter );\n}\n\nsub filter {\n\tmy ( $self, @params ) = @_;\n\n\tmy $f = Mail::Summary::Tools::ThreadFilter->new(\n\t\tfilters => [ $self->construct_filters ],\n\t);\n\n\treturn $f->filter(@params);\n}\n\nsub clean_subject {\n\tmy ( $self, $subject ) = @_;\n\n\treturn $subject unless $self->{opt}{clean};\n\n\t$subject =~ s/^\\s*(?:Re|Fwd):\\s*//i;\n\t$subject =~ s/^\\s*\\[[\\w-]+\\]\\s*//; \n\t$subject =~ s/^\\s*|\\s*$//g; \n\n\treturn $subject;\n}\n\nsub validate {\n\tmy ( $self, $opt, $args ) = @_;\n\t$self->{opt} = $opt;\n\n\t@$args and $opt->{$_} ||= shift @$args for qw/output/;\n\tpush @{ $opt->{input} ||= [] }, @$args; @$args = ();\n\n\tunless ( $opt->{output} and @{ $opt->{input} } ) {\n\t\t$self->usage_error(\"Please specify a summary output file and at least one mail box for input.\");\n\t}\n}\n\nsub run {\n\tmy ( $self, $opt, $args ) = @_;\n\n\tmy @folders     = @{ $opt->{input} };\n\tmy $summary_out = $opt->{output};\n\n\tif ( -f $summary_out and !$opt->{update} ) {\n\t\tdie \"The output file '$summary_out' exists. Either remove it or specify the --update option\\n\";\n\t}\n\t\n\tmy $summary = -f $summary_out\n\t\t? Mail::Summary::Tools::Summary->load( $summary_out )\n\t\t: Mail::Summary::Tools::Summary->new;\n\n\t$self->diag(\"loading and threading mailboxes: @folders\");\n\n\tmy $mgr = Mail::Box::Manager->new;\n\tmy $threads = $mgr->threads(\n\t\tfolders  => [ map { $mgr->open( folder => $_ ) } @folders ],\n\t\ttimespan => 'EVER',\n\t\twindow   => 'ALL',\n\t\t( $self->app->global_options->{verbose} ? (trace => \"PROGRESS\") : ()),\n\t);\n\n\tmy %lists = map { $_->name => $_ } $summary->lists;\n\tmy %seen;\n\n\t$self->filter( threads => $threads, callback => sub {\n\t\tmy $thread = shift;\n\t\t\n\t\tmy $root = get_root_message($thread);\n\t\treturn if $seen{$root->messageId}++;\n\n\t\tmy $list_name = eval { guess_mailing_list($root)->listname };\n\t\tmy $list_key = $list_name || \"unknown\";\n\n\t\tmy $list = $lists{$list_key} ||= do {\t\n\t\t\tmy $list = Mail::Summary::Tools::Summary::List->new( $list_name ? (name => $list_name) : () );\n\t\t\t$summary->add_lists( $list );\n\t\t\t$list;\n\t\t};\n\n\t\tmy $summarized_thread = Mail::Summary::Tools::Summary::Thread->from_mailbox_thread( $thread,\n\t\t\tcollect_posters => $opt->{posters},\n\t\t\tcollect_dates   => $opt->{dates},\n\t\t\tcollect_rt      => $opt->{dates},\n\t\t\tprocess_subject => sub { $self->clean_subject(shift) },\n\t\t);\n\n\n\t\tif ( my $existing = $summary->get_thread_by_id( $summarized_thread->message_id ) ) {\n\t\t\tmy $was_out_of_date = $existing->extra->{out_of_date};\n\t\t\t$existing->merge( $summarized_thread );\n\t\t\t$self->diag($summarized_thread->message_id . \" is now out of date\") if !$was_out_of_date and $existing->extra->{out_of_date};\n\t\t} else {\n\t\t\t$self->diag($summarized_thread->message_id . \" has been added to the summary\");\n\t\t\t$list->add_threads( $summarized_thread );\n\t\t}\n\t});\n\n\t$self->diag( \"found threads in the mailing lists: @{[ map { $_->name || '<unknown>' } values %lists ]}\" );\n\n\t$summary->save( $summary_out );\n}\n\n__PACKAGE__;\n\n__END__\n\n\n\n",
      "file" : "/var/tmp/arv_nA99Ua/Mail-Summary-Tools-0.06/lib/Mail/Summary/Tools/CLI/Create.pm",
      "package" : "Mail::Summary::Tools::CLI::Create"
   }
]
