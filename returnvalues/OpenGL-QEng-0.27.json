[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "{;\n my %deflt_cache;\n\n sub not_default {\n   my ($self) = @_;\n\n   unless (exists $deflt_cache{ref $self}) {\n     $deflt_cache{ref $self} = ref($self)->new(no_events=>1);\n   }\n   my $dflt = $deflt_cache{ref $self};\n\n   my $href = {};\n   for my $key (keys %{$self}) {\n     if (!defined($dflt->{$key})) {\n       $href->{$key} = $self->{$key};\n     }\n     elsif (defined $self->{$key}) {\n       $href->{$key} = $self->{$key}\n\t if (ref2str($self->{$key}) ne ref2str($dflt->{$key}));\n     }\n   }\n   $href;\n }\n} \n\nsub boring_stuff {\n  {x         => 1,\n   z         => 1,\n   yaw       => 1,\n   GLid      => 1,\n   event     => 1,\n   is_at     => 1,\n   holds     => 1,\n   parts     => 1,\n   map_view  => 1,\n   range_2   => 1,\n   near_code => 1,\n   event_code=> 1,\n   wrap_class=> 1,\n   objects   => 1,\n   tlines    => 1,\n  }\t\t\n}\n\nsub printMe {\n  my ($self,$depth) = @_;\n\n  $depth ||= 0;\n  my $started = 0;\n  for my $sp ($self->special_parts) {\n    next unless defined $self->{$sp};\n    unless ($started) {\n      print STDOUT '  'x$depth,\"partof_next;\\n\" unless $started;\n      $started = 1;\n    }\n    $self->{$sp}->{name} =\n      'XX'.$self->{$sp} unless defined($self->{$sp}->{name});\n    $self->{$sp}->printMe($depth+1);\n  }\n  print STDOUT '  'x$depth,\"done;\\n\" if $started;\n\n  (my $map_ref = ref $self) =~ s/OpenGL::QEng:://;\n  print STDOUT '  'x$depth,\"$map_ref $self->{x} $self->{z} $self->{yaw}\";\n  my $spec = $self->not_default;\n  my $boring = $self->boring_stuff;\n  for my $key (keys %{$spec}) {\n    next unless defined $spec->{$key};\n    next if defined $boring->{$key};\n\n    if    (ref($spec->{$key}) eq '') {\n      print STDOUT \" $key=>\";\n      printScalar($spec->{$key});\n    }\n    elsif (ref($spec->{$key}) eq 'ARRAY') {\n      next unless @{$spec->{$key}};\n      print STDOUT \" $key=>\";\n      printArray($spec->{$key});\n    }\n    elsif (ref($spec->{$key}) eq 'HASH') {\n      next unless keys %{$spec->{$key}};\n      print STDOUT \" $key=>\";\n      printHash($spec->{$key});\n    }\n    else {\n      warn \"$self ->printMe won't do '$key' because it is a \",\n\tref $spec->{$key};\n    }\n  }\n  for my $sp ($self->special_parts) {\n    print STDOUT \" $sp=>{named=>'$self->{$sp}->{name}'},\"\n      if defined($self->{$sp});\n  }\n  print STDOUT \";\\n\";\n\n  my @parts = @{$self->parts} if $self->parts;\n  $started = 0;\n PART:\n  for my $thing (@parts) {\n    next if exists $thing->{i_am_a_wall_chunk};\n    for my $sp ($self->special_parts) {\n      next PART if ((!$self->{$sp}) || $thing eq $self->{$sp});\n    }\n    unless ($started) {\n      print STDOUT '  'x$depth,\"partof_last;\\n\" unless $started;\n      $started = 1;\n    }\n    $thing->printMe($depth+1);\n  }\n  print STDOUT '  'x$depth,\"done;\\n\" if $started;\n\n  my @holds = @{$self->holds} if $self->holds;\n  $started = 0;\n  for my $thing (@holds) {\n    unless ($started) {\n      print STDOUT '  'x$depth,\"in_last;\\n\" unless $started;\n      $started = 1;\n    }\n    $thing->printMe($depth+1);\n  }\n  print STDOUT '  'x$depth,\"done;\\n\" if $started;\n}\n\nsub handle_touch {\n  return unless defined($ENV{WIZARD});\n  my $where = $_[0]->is_at || 'undef';\n  print STDERR \"Thing::handle_touch(\",join(',',@_),\")\\n\";\n  print STDERR \"--\\t$_[0] is_at: $where\\n\";\n}\n\nsub handle_near {\n  my ($self,$stash,$obj,$ev,$tx,$tz,$currmap,@args) = @_;\n  warn 'handle_near: undefined currmap' unless defined $currmap;\n\n  return unless defined $self->range;\n  my $range = $self->range;\n  $self->range(undef);\t\t\n\n  if (defined($self->near_code) && $self->is_at eq $currmap) {\n    my $distSq = ($self->x-$tx)*($self->x-$tx)+($self->z-$tz)*($self->z-$tz);\n    $self->{range_2} ||= $range*$range;\n    $self->near_code->($distSq) if ($distSq <= $self->{range_2});\n  }\n\n  $self->range($range);\t\t\n}\n\nsub tractable { \n  return 'passable';\n}\n\nsub color_me_gone {\n  my $self = shift;\n\n  my $where_am_i = $self->is_at();\n  $where_am_i->take_thing($self);\n}\n\nsub unlock {\n  my ($self,$team_holds) = @_;\n\n  my ($unlocker) = ($self->key or $self->opener or '(undef)');\n  my $try_key =\n    (ref($team_holds) eq 'OpenGL::QEng::Key') ? $team_holds->type : ref($team_holds);\n  $try_key =~ s/OpenGL::QEng:://;\n\n  if ($try_key eq $unlocker) {\n    $self->state('closed');\n    if (defined $self->opener) {\n      $self->send_event('msg',\"'Using the $try_key, frees the door'\\n\");\n    } else {\n      $self->send_event('msg',\"The $try_key key turns in the lock\\n\",\n\t\t\t      \"'Click'\\n\");\n    }\n    return $team_holds;\n  } else {                    \n    print \"Locked/Stuck tryed: $try_key, need: $unlocker\\n\"\n      if ($ENV{WIZARD});\n    if (defined $self->opener) {       \n      $self->send_event('msg',\"Stuck\\n\");\n    }\n    else {\n      if (ref($team_holds) eq 'OpenGL::QEng::Key') { \n\t$self->send_event('msg',\"The $try_key key doesn't fit.\\n\");\n      }\n      elsif ($try_key) {               \n\t$self->send_event('msg',\"A $try_key won't unlock it.\\n\");\n      }\n      else {                           \n\t$self->send_event('msg',\"Locked\\n\");\n      }\n    }\n    return 0;\n  }\n}\n\nsub model {\n  die \"bad arg @_ from \",join(':',caller) if defined $_[1] && !ref $_[1];\n  die \"$_[0] has no model in hash \",join(':',caller)\n    unless exists $_[0]->{model};\n  return unless exists $_[0]->{model};\n  $_[0]->{model} = $_[1] if defined $_[1];\n  $_[0]->{model};\n}\n\nsub get_corners {\n  my ($self) = @_;\n\n  my $corners = [];\n  return $corners unless $self->visible;\n\n  my $color = ($self->seen) ? $self->color || 'black' : undef;\n  $color = $color->[0] if ref $color eq 'ARRAY';\n  my $tract = $self->tractable;\n  die \"oops: $self\" unless $tract;\n\n  die 'bad model' unless (ref $self->{model} eq 'HASH');\n  my ($minx, $maxx) = ($self->{model}{minx}, $self->{model}{maxx});\n  my ($miny, $maxy) = ($self->{model}{miny}, $self->{model}{maxy});\n  my ($minz, $maxz) = ($self->{model}{minz}, $self->{model}{maxz});\n\n  if (defined($minx) && defined($maxx) && defined($minz) && defined($maxz)) {\n    if (($self->y+$miny) < 1 && ($self->y+$maxy) > 0) {\n      push @$corners,\n\t[$minx, $minz, $minx, $maxz, $color, $tract, $self],\n        [$minx, $maxz, $maxx, $maxz, $color, $tract, $self],\n\t[$maxx, $maxz, $maxx, $minz, $color, $tract, $self],\n\t[$maxx, $minz, $minx, $minz, $color, $tract, $self];\n    }\n  }\n  $corners;\n}\n\nsub find_objects {\n  my ($self) = @_;\n\n  unless (defined $self->{objects}) {\n    my $yaw = $self->yaw;\n    my ($selfX,$selfY,$selfZ) = ($self->x,$self->y,$self->z);\n    die \"$self missing prereqs: $yaw,$selfX,$selfZ\"\n      unless defined($yaw) && defined($selfX) && defined($selfZ);\n\n    my $objects;\n    for my $obj (@{$self->contains}) {\n      for my $list ($obj->find_objects) {\n\tdie \"poor map view from $obj: list=$list\\n\"\n\t  unless defined $list && ref($list) eq 'ARRAY';\n\tpush @$objects, @$list;\n      }\n    }\n    push @{$self->{objects}}, [$self->x,$self->y,$self->z,$self];\n    for my $line (@$objects) {\n      push @{$self->{objects}},\n\t[$selfX+cos($yaw*RADIANS)*$line->[0]+sin($yaw*RADIANS)*$line->[2],\n\t $selfY+$line->[1],\n\t $selfZ-sin($yaw*RADIANS)*$line->[0]+cos($yaw*RADIANS)*$line->[2],\n\t $line->[3]];\n    }\n  }\n  return $self->{objects};\n}\n\nsub get_map_view {\n  my $self = shift;\n\n  unless (defined $self->{map_view}) {\n    my $yaw = $self->yaw;\n    my ($selfX,$selfY,$selfZ) = ($self->x,$self->y,$self->z);\n    die \"$self missing prereqs: $yaw,$selfX,$selfZ\"\n      unless defined($yaw) && defined($selfX) && defined($selfZ);\n\n    my @corners = @{$self->get_corners};\n\n    for my $obj (@{$self->contains}) {\n      my %parts;\n      for my $line ($obj->get_map_view) {\n\tdie \"poor map view from $obj:\"\n\t  unless defined $line && ref($line) eq 'ARRAY' && @$line >= 4;\n\tpush @corners,[$line->[0],$line->[1],$line->[2],$line->[3],\n\t\t       $line->[4],$line->[5],$line->[6]];\n\t$parts{$line->[6]} = $line->[6];\n      }\n      for my $p (keys %parts) { delete($parts{$p}->{tlines}) }\n    }\n\n    my @view;\n    for my $line (@corners) {\n      my $tline =\n\t[$selfX+cos($yaw*RADIANS)*$line->[0]+sin($yaw*RADIANS)*$line->[1],\n\t $selfZ-sin($yaw*RADIANS)*$line->[0]+cos($yaw*RADIANS)*$line->[1],\n\t $selfX+cos($yaw*RADIANS)*$line->[2]+sin($yaw*RADIANS)*$line->[3],\n\t $selfZ-sin($yaw*RADIANS)*$line->[2]+cos($yaw*RADIANS)*$line->[3],\n\t $line->[4],$line->[5],$line->[6]];\n      push @view, $tline;\n      push @{$line->[6]->{tlines}}, $tline;\n    }\n    $self->{map_view} = \\@view;\n  }\n  return @{$self->{map_view}};\n}\n\nsub invalidate_map_view {\n  my ($self,$thing) = @_;\n\n  undef $self->{map_view};\n  undef $self->{objects} if ref $thing;\n\n  $self->is_at->invalidate_map_view($thing)\n    if defined $self->is_at && $self->is_at->can('invalidate_map_view');\n  (print STDERR \"$self has no home\\n\",return) unless defined $self->is_at;\n  print STDERR \"${self}'s home can't invalidate\\n\" unless $self->is_at->can('invalidate_map_view');\n}\n\nsub move {\n  my ($self) = @_;\n\n  my $need_redraw = 0;\n  if (values %{$self->target}) {\n    my %quantum = (x=>.2,   y=>.2,   z=>.2,\n\t\t   roll=>2, pitch=>2, yaw=>2,\n\t\t   opening=>2, levang=>2);\n    for my $attr (keys %quantum) {\n      if (defined $self->{target}{$attr}) {\n\tdie \"oops: $attr\" unless defined $self->{$attr};\n\tif ($self->{$attr} == $self->{target}{$attr}) {\n\t  undef $self->{target}{$attr};\n\t}\n\telse {\n\t  my $delta = abs($self->{$attr} - $self->{target}{$attr});\n\t  if ($delta <= $quantum{$attr}) {\n\t    $self->{$attr} = $self->{target}{$attr};\n\t    undef $self->{target}{$attr};\n\t  } elsif ($self->{target}{$attr} > $self->{$attr}) {\n\t    $self->{$attr} += $quantum{$attr};\n\t  } else {\n\t    $self->{$attr} -= $quantum{$attr};\n\t  }\n\t  $need_redraw++;\n\t  $self->invalidate_map_view($self);\n\t}\n      }\n    }\n  }\n  if ($self->isa('OpenGL::QEng::Team')) {\n    $self->send_event('team_at',$self->x,$self->z,$self->is_at)\n      if $need_redraw;\n  }\n  elsif ($self->contains) {\n    foreach my $o (@{$self->contains}) {\n      $o->move;\n    }\n  }\n  $self->send_event('need_redraw') if $need_redraw;\n}\n\n{;\n my $textList;\n\n sub pickTexture {\n   my ($self,$key) = @_;\n\n   unless (defined $textList) {\n     my $idir = File::ShareDir::dist_dir('Games-Quest3D');\n     $idir .= '/images';\n     $textList = OpenGL::QEng::TextureList->new($idir);\n   }\n   $textList->pickTexture($key);\n }\n}\n\n\n{;\n my %colors;\n\n sub make_color_map {\n   %colors = ('blue'     =>[0.0,0.0,1.0],\n\t      'purple'   =>[160.0/255.0, 23.0/255.0, 240.0/255.0],\n\t      'pink'     =>[1.0,192.0/255.0,203.0/255.0],\n\t      'red'      =>[1.0,0.0,0.0],\n\t      'magenta'  =>[1.0,0.0,1.0],\n\t      'yellow'   =>[1.0,1.0,0.0],\n\t      'white'    =>[1.0,1.0,1.0],\n\t      'cyan'     =>[0.0,1.0,1.0],\n\t      'green'    =>[0.0,1.0,0.0],\n\t      'beige'    =>[245.0/255.0,245.0/255.0,135.0/255.0],\n\t      'brown'    =>[141.0/255.0, 76.0/255.0, 47.0/255.0],\n\t      'orange'   =>[255.0/255.0,165.0/255.0,0.0/255.0],\n\t      'gold'     =>[255.0/255.0,215.0/255.0,0.0/255.0],\n\t      'gray'     =>[64.0/255.0,64.0/255.0,64.0/255.0],\n\t      'gray75'   =>[191.0/255.0,191.0/255.0,191.0/255.0],\n\t      'slate gray'=>[112.0/255.0,128.0/255.0,144.0/255.0],\n\t      'darkgray' =>[47.0/255.0,79.0/255.0,79.0/255.0],\n\t      'medgray'  =>[192.0/255.0,192.0/255.0,192.0/255.0],\n\t      'lightgray'=>[211.0/255.0,211.0/255.0,211.0/255.0],\n\t      'black'    =>[0.0,0.0,0.0],\n\t      'cream'    =>[250.0/255.0,240.0/255.0,230.0/255.0],\n\t      'light green' =>[144.0/255.0,238.0/255.0,144.0/255.0],\n\t      'light blue' =>[173.0/255.0,216.0/255.0,230.0/255.0],\n\t     );\n   my $path = 'rgb.txt';\n   for my $p ('/etc/X11/rgb.txt',\n\t      '/usr/share/X11/rgb.txt',\n\t      '/usr/X11R6/lib/X11/rgb.txt',\n\t      '/usr/openwin/lib/X11/rgb.txt',\n\t     ) {\n     ($path=$p, last) if -f $p;\n   }\n   if (open my $rgb,'<',$path) {\n     while (my $line = <$rgb>) {\n       my ($r,$g,$b,$name);\n       next unless ($r,$g,$b,$name) =\n\t $line =~ /^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\w.*\\w)\\s*$/;\n       $colors{lc $name} = [$r/255.0,$g/255.0,$b/255.0,];\n     }\n     close $rgb;\n   }\n }\n\n sub setColor {\n   my ($self,$color) = @_;\n\n   die \"setColor($self,) c.f. \",join(':',caller),\"\\n\" unless $color;\n   make_color_map() unless $colors{red};\n   $color = lc $color;\n   if ($color eq 'clear'){\n     glColor4f(0.0,0.0,0.0,1.0);\n   } elsif (defined($colors{$color})) {\n     glColor4f($colors{$color}[0],$colors{$color}[1],$colors{$color}[2],1.0);\n   } else {\n     print \"unknown color $color\\n\";\n   }\n }\n\n sub getColor {\n   my ($self,$color) = @_;\n\n   die \"getColor($self,) c.f. \",join(':',caller),\"\\n\" unless $color;\n   make_color_map() unless $colors{red};\n   $color = lc $color;\n   if (defined $colors{$color}) {\n     return @{$colors{$color}};\n   }\n   print \"unknown color $color\\n\";\n }\n} \n\nsub tErr { return; \n  my ($self,$w) = @_;\n\n  while (my $e = glGetError()) {\n    print \"$e, \",gluErrorString($e),\" \\@:$w\\n\";\n  }\n}\n\n{my $dlRoot = 1;\n sub getDLname {\n   $dlRoot++;\n }\n}\n\nsub ref2str {\n  my ($ref) = @_;\n\n  if    (ref($ref) eq 'ARRAY') {\n    return aref2str($ref);\n  }\n  elsif (ref($ref) eq 'HASH') {\n    return href2str($ref);\n  }\n  elsif (! defined $ref) {\n    return 'undef';\n  }\n  else {\n    return $ref;\n  }\n}\n\nsub aref2str {\n  my ($aref) = @_;\n\n  my $str = '[';\n  for my $i (@$aref) {\n    if    (ref($i) eq 'ARRAY') {\n      $str .= aref2str($i);\n    }\n    elsif (ref($i) eq 'HASH') {\n      $str .= href2str($i);\n    }\n    elsif (! defined $i) {\n      $str .= 'undef,';\n    }\n    else {\n      $str .= $i.',';\n    }\n  }\n  $str .= '],';\n}\n\nsub href2str {\n  my ($href) = @_;\n\n  my $str = '{';\n  for my $k (keys %$href) {\n    $str .= \"$k=>\";\n    if    (ref($href->{$k}) eq 'ARRAY') {\n      $str .= aref2str($href->{$k});\n    }\n    elsif (ref($href->{$k}) eq 'HASH') {\n      $str .= href2str($href->{$k});\n    }\n    elsif (! defined $href->{$k}) {\n      $str .= 'undef,';\n    }\n    else {\n      $str .= $href->{$k}.',';\n    }\n  }\n  $str .= '},';\n}\n\nif (not defined caller()) {\n  package main;\n\n  my $v = OpenGL::QEng::Thing->new;\n  warn $v;\n  $v->printMe;\n}\n\n1",
      "file" : "/var/tmp/arv_A26dgv/OpenGL-QEng-0.27/lib/OpenGL/QEng/Thing.pm",
      "package" : "OpenGL::QEng::Thing"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "{;\n my $dl = 0;\n\n sub draw {\n   my ($self,$mode) = @_;\n\n   if ($mode == OpenGL::GL_SELECT) {\n     OpenGL::glLoadName($self->{GLid});\n   }\n   if ($self->texture ne 'coins') {\n     $self->SUPER::draw(@_);\n     return;\n   }\n   OpenGL::glTranslatef($self->{x},$self->y,$self->{z});\n   OpenGL::glRotatef($self->{yaw},0,1,0) if $self->{yaw};\n   if ($dl) {\n     OpenGL::glCallList($dl);\n   } else {\n     $dl = $self->getDLname();\n     OpenGL::glNewList($dl,OpenGL::GL_COMPILE);\n     OpenGL::glColor3f(165.0/255.0,42.0/255.0,42.0/255.0); \n     $self->tErr('err @ treasure9');\n     for (my $zidx=0;$zidx<16;$zidx++) {\n       OpenGL::glBegin(OpenGL::GL_TRIANGLE_STRIP);\n       my $zStep = 1;\n       my $z  = ($zidx*2/15-1.0);\n       my $z1 = (($zidx+$zStep)*2/15-1.0);\n       my $scale  = $self->{model}{scale}[$zidx];\n       my $scale1 = $self->{model}{scale}[($zidx+$zStep)];\n       for (my $idx=1; $idx<(@{$self->{model}{x}})-1; $idx++) {\n\t if ($idx%5 == 0) {\n\t   OpenGL::glColor3f(139.0/255.0,35.0/255.0,35.0/255.0);\t\n\t } else {\n\t   OpenGL::glColor3f(165.0/255.0,42.0/255.0,42.0/255.0);\t\n\t }\n\t my $currx  = $self->{model}{x}[$idx]*$scale*0.6;\n\t my $currx1 = $self->{model}{x}[$idx]*$scale1*0.6;\n\t my $curry  = $self->{model}{y}[$idx]*$scale;\n\t my $curry1 = $self->{model}{y}[$idx]*$scale1;\n\t OpenGL::glVertex3f($currx,$curry,$z);\n\t OpenGL::glVertex3f($currx1,$curry1,$z1);\n       }\n       OpenGL::glEnd();\n       $self->tErr('err @ treasure0');\n     }\n     OpenGL::glColor3f(0.0,0.0,0.0);\t\n     OpenGL::glBegin(OpenGL::GL_LINE_STRIP);\n     OpenGL::glVertex3f(-1.0,0.0,4.2/5);\n     OpenGL::glVertex3f(-0.5,0.5/5,4.0/5);\n     OpenGL::glVertex3f(-0.45,0.125/5,4/5);\n     OpenGL::glVertex3f(-0.525,0.25/5,4/5);\n     OpenGL::glVertex3f(-0.5475,0.375/5,4/5);\n     OpenGL::glVertex3f(-0.5325,0.5/5,4/5);\n     OpenGL::glVertex3f(-0.5025,0.625/5,4/5);\n     OpenGL::glVertex3f(-0.4125,0.75/5,4/5);\n     OpenGL::glVertex3f(-0.225,0.8125/5,4/5);\n     OpenGL::glVertex3f(-0.135,0.675/5,4/5);\n     OpenGL::glVertex3f(-0.075,0.6625/5,4/5);\n     OpenGL::glVertex3f(0.15,0.75/5,4/5);\n     OpenGL::glVertex3f(0.36,0.625/5,4/5);\n     OpenGL::glVertex3f(0.45,0.4375/5,4/5);\n     OpenGL::glVertex3f(0.5925,0.25/5,4/5);\n     OpenGL::glVertex3f(1.0,0.0,4/5);\n     OpenGL::glEnd();\n     $self->tErr('err @ treasure2');\n\n     OpenGL::glEndList();\n     OpenGL::glCallList($dl); \n   }\n   OpenGL::glRotatef(-$self->{yaw},0,1,0) if $self->{yaw};\n   OpenGL::glTranslatef(-$self->{x},-$self->y,-$self->{z});\n }\n} \n\n1",
      "file" : "/var/tmp/arv_A26dgv/OpenGL-QEng-0.27/lib/OpenGL/QEng/Treasure.pm",
      "package" : "OpenGL::QEng::Treasure"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "{;\n my $lastx    = -999;\n my $lastz    = -999;\n my $lastdir  = -999;\n my $lastdist = 0;;\n\n sub performStep {\n   my ($self,$stash,$team,$ev,$steps,$speed,$direction) = @_;\n\n   return unless defined $self->{cmap};\n\n   if ($speed < 0) {\n     $direction = ($direction+180) % 360;\n     $speed = -$speed;\n   }\n   my @min_dist = (10.0,10.0,10.0,10.0);\t\t\n\n   my $tx = $team->x;\n   my $tz = $team->z;\n   my $tyaw = -$team->yaw+90;\t\n   my $pyaw = 65;\n   my $step = $speed*$steps;\n   my $moveYaw = $team->yaw + $direction;\n\n   if ($ENV{DESLUG} && $tx==$lastx && $tz==$lastz && $moveYaw==$lastdir\n       && $lastdist>$step+.5) {\n     $team->x($team->x+$step*cos($moveYaw*RADIANS));\n     $team->z($team->z+$step*sin($moveYaw*RADIANS));\n     $min_dist[3] = $lastdist - $step;\n   }\n   else {\n     my @p_ = (['x','y'],['x','y'],['x','y'],['x','y']);\n\n     $p_[0][0] = $tx+$min_dist[0]*sin(($tyaw-$pyaw)*RADIANS);\n     $p_[0][1] = $tz+$min_dist[0]*cos(($tyaw-$pyaw)*RADIANS);\n\n     $p_[1][0] = $tx+$min_dist[1]*sin($tyaw*RADIANS);\n     $p_[1][1] = $tz+$min_dist[1]*cos($tyaw*RADIANS);\n\n     $p_[2][0] = $tx+$min_dist[2]*sin(($tyaw+$pyaw)*RADIANS);\n     $p_[2][1] = $tz+$min_dist[2]*cos(($tyaw+$pyaw)*RADIANS);\n\n     $p_[3][0] = $tx+$min_dist[3]*sin(($tyaw - $direction)*RADIANS);\n     $p_[3][1] = $tz+$min_dist[3]*cos(($tyaw - $direction)*RADIANS);\n\n     my @seen_maybe = ([],[],[]);\n     my ($obstacle,$tractable,$thing);\n     my $map = $self->currmap;\n     $map->get_map_view;\n     $map->find_objects;\n     my ($oc,$ic) = (0,0);\n     foreach my $o (@{$map->{objects}}) {\n       $oc++;\n       my ($ox,$oy,$oz,$or) = @$o;\n       next unless (($ox-$tx)*($ox-$tx)+($oz-$tz)*($oz-$oz)) < 100;\n       next if $or == $map;\n       my @sides = (defined $or->{tlines}) ? @{$or->{tlines}} : ();\n       for my $i (0..3) {\n\t my ($px,$pz) = ($p_[$i][0],$p_[$i][1]);\n\t my $touch = 0;\n\t for my $side (@sides) {\n\t   next unless defined $side;\n\t   $ic++;\n\t   my ($prx,$prz) = intersect($side->[0],$side->[1],\n\t\t\t\t      $side->[2],$side->[3],\n\t\t\t\t      $tx,$tz,$px,$pz);\n\t   unless ($prx == -1 && $prz == -1) {\n\t     $px = $prx;\t\t\n\t     $pz = $prz;\n\t     $touch = 1;\n\t     $tractable = $side->[5];\n\t     $thing = $side->[6];\n\t   }\n\t }\n\t if ($touch) {\n\t   my $dist = sqrt(($px-$tx)*($px-$tx)+($pz-$tz)*($pz-$tz));\n\t   if ($dist < $min_dist[$i]) {\n\t     if ($i < 3) {\t\t\n\t       push @{$seen_maybe[$i]}, [$dist,$thing];\n\t       if ($tractable eq 'solid') {           \n\t\t ($p_[$i][0],$p_[$i][1]) = ($px,$pz); \n\t\t $min_dist[$i] = $dist;\n\t       }\n\t     }\n\t     else {\t\t\n\t       if ($tractable ne 'passable') {        \n\t\t ($p_[$i][0],$p_[$i][1]) = ($px,$pz); \n\t\t $min_dist[$i] = $dist;\n\t\t $obstacle = $or;\n\t       }\n\t     }\n\t   }\n\t }\n       }\n     }\n     my $thingsSeen = 0;\t\t\n     my $nodDist    = 6.0;\t\t\n     for my $i (0..3) {\n       for my $candidate (@{$seen_maybe[$i]}) {\n\t if ($candidate->[0] <= $min_dist[$i]) {\n\t   $candidate->[1]->{seen} = 'true';\n\t   if ($candidate->[1]->can('make_me_nod')\n\t       && $candidate->[1]->make_me_nod ) {\n\t     if ($candidate->[0] <= $nodDist) {\n\t       $thingsSeen++;\n\t       my $elev = $team->y-1;\n\t       my $atan2val = -atan2($elev,$candidate->[0])*DEGREES;\n\t       $team->{target}{pitch} = $atan2val;\n\t     }\n\t   }\n\t }\n       }\n     }\n     $team->{target}{pitch} = 0 unless $thingsSeen;\n\n     return if ($step==0 and $direction==0);\n\n     my $dist = $min_dist[3];\n     if ($dist >= abs($step)+0.5 || $ENV{'WIZARD'}) {\n       my $moveYaw = $team->yaw + $direction;\n       $team->x($team->x+$step*cos($moveYaw*RADIANS));\n       $team->z($team->z+$step*sin($moveYaw*RADIANS));\n       print STDERR \"$obstacle is in our way\\n\"\n\t if ($ENV{'WIZARD'} && $dist < abs($step)+0.5);\n     } else {\n       print \"Bang!!\\n\";\n       $self->send_event('msg',\"Bang!!\\n\");\n       $self->send_event('bell');\n     }\n   }\n   $lastx = $team->x; $lastz = $team->z; $lastdir = $moveYaw;\n   $lastdist = $min_dist[3];\n\n   $team->is_at($self->currmap);\n   $self->send_event('team_at',$team->x,$team->z,$self->currmap);\n   $self->send_event('need_redraw');\n }\n}\n\nsub intersect {\n  my ($x1,$y1,$x2,$y2,$x3,$y3,$x4,$y4) = @_;\n\n  my $denom = (($y4-$y3)*($x2-$x1)-($x4-$x3)*($y2-$y1));\n  if ($denom == 0) {\n    return (-1,-1);\n  }\n  my $ua = (($x4-$x3)*($y1-$y3)-($y4-$y3)*($x1-$x3))/$denom;\n  my $ub = (($x2-$x1)*($y1-$y3)-($y2-$y1)*($x1-$x3))/$denom;\n\n  if (($ua<0) || ($ua>1) || ($ub<0) || ($ub>1)) {\n    return (-1,-1);\n  }\n\n  return ($x1+$ua*($x2-$x1),$y1+$ua*($y2-$y1));\n}\n\nif (!defined(caller())) {\n  package main;\n\n  print \"gameState\\n\";\n\n  open(my $m,'>','/tmp/gs_testmap.txt');\n  print $m \"map 0 0 0 xsize=>24, zsize=>24;\\n\";\n  print $m \"in_last;\\n\";\n  print $m \"   wall 16 0 270;\\n\";\n  print $m \"done;\\n\";\n  close $m;\n\n  my $g = GameState->load('/tmp/gs_testmap.txt');\n  print \"$g\\n\";\n  print \"bye\\n\";\n}\n\n1",
      "file" : "/var/tmp/arv_A26dgv/OpenGL-QEng-0.27/lib/OpenGL/QEng/GameState.pm",
      "package" : "OpenGL::QEng::GameState"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "{;\n my $textList;\n\n sub pickTexture {\n   my ($self,$key) = @_;\n\n   unless (defined $textList) {\n     my $idir = File::ShareDir::dist_dir('Games-Quest3D');\n     $idir .= '/images';\n     $textList = OpenGL::QEng::TextureList->new($idir);\n   }\n   $textList->pickTexture($key);\n }\n}\n\n\n\n{;\n my %colors;\n\n sub make_color_map {\n   %colors = ('blue'     =>[0.0,0.0,1.0],\n\t      'purple'   =>[160.0/255.0, 23.0/255.0, 240.0/255.0],\n\t      'pink'     =>[1.0,0.733,0.870],\n\t      'pink'     =>[1.0,192.0/255.0,203.0/255.0],\n\t      'red'      =>[1.0,0.0,0.0],\n\t      'magenta'  =>[1.0,0.0,1.0],\n\t      'yellow'   =>[1.0,1.0,0.0],\n\t      'white'    =>[1.0,1.0,1.0],\n\t      'cyan'     =>[0.0,1.0,1.0],\n\t      'green'    =>[0.0,1.0,0.0],\n\t      'beige'    =>[245.0/255.0,245.0/255.0,135.0/255.0],\n\t      'brown'    =>[141.0/255.0, 76.0/255.0, 47.0/255.0],\n\t      'orange'   =>[255.0/255.0,165.0/255.0,0.0/255.0],\n\t      'gold'     =>[255.0/255.0,215.0/255.0,0.0/255.0],\n\t      'gray'     =>[64.0/255.0,64.0/255.0,64.0/255.0],\n\t      'gray75'   =>[191.0/255.0,191.0/255.0,191.0/255.0],\n\t      'slate gray'=>[112.0/255.0,128.0/255.0,144.0/255.0],\n\t      'darkgray' =>[47.0/255.0,79.0/255.0,79.0/255.0],\n\t      'medgray'  =>[192.0/255.0,192.0/255.0,192.0/255.0],\n\t      'lightgray'=>[211.0/255.0,211.0/255.0,211.0/255.0],\n\t      'black'    =>[0.0,0.0,0.0],\n\t      'cream'    =>[250.0/255.0,240.0/255.0,230.0/255.0],\n\t      'light green' =>[144.0/255.0,238.0/255.0,144.0/255.0],\n\t      'light blue' =>[173.0/255.0,216.0/255.0,230.0/255.0],\n\t     );\n   my $path = 'rgb.txt';\n   for my $p ('/etc/X11/rgb.txt',\n\t      '/usr/share/X11/rgb.txt',\n\t      '/usr/X11R6/lib/X11/rgb.txt',\n\t      '/usr/openwin/lib/X11/rgb.txt',\n\t     ) {\n     ($path=$p, last) if -f $p;\n   }\n   if (open my $rgb,'<',$path) {\n     while (my $line = <$rgb>) {\n       my ($r,$g,$b,$name);\n       next unless ($r,$g,$b,$name) =\n\t $line =~ /^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\w.*\\w)\\s*$/;\n       $colors{lc $name} = [$r/255.0,$g/255.0,$b/255.0,];\n     }\n     close $rgb;\n   }\n }\n\n sub setColor {\n   my ($self,$color) = @_;\n\n   make_color_map() unless $colors{red};\n   $color = lc $color;\n   if ($color eq 'clear'){\n     glColor4f(0.0,0.0,0.0,1.0);\n   } elsif (defined($colors{$color})) {\n     glColor4f($colors{$color}[0],$colors{$color}[1],$colors{$color}[2],1.0);\n   } else {\n     print \"unknown color $color\\n\";\n   }\n }\n\nsub getColor {\n   my ($self,$color) = @_;\n\n   make_color_map() unless $colors{red};\n   $color = lc $color;\n   if (defined $colors{$color}) {\n     return @{$colors{$color}};\n   }\n   print \"unknown color $color\\n\";\n }\n} \n\nif (not defined caller()) {\n  package main;\n\n  use OpenGL qw\\:all\\;\n\n\n}\n\n1",
      "file" : "/var/tmp/arv_A26dgv/OpenGL-QEng-0.27/lib/OpenGL/QEng/GUIThing.pm",
      "package" : "OpenGL::QEng::GUIThing"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "{; \n my $dl = 0;\n my $chkErr = 0; \n\n sub draw {\n   my ($self,$mode) = @_;\n\n   my $mdl = $self->model();\n\n   if ($mode == OpenGL::GL_SELECT) {\n     glLoadName($self->{GLid});\n   }\n\n   glTranslatef($self->{x},$self->y,$self->{z});\n   glRotatef($self->{yaw},0,1,0) if $self->{yaw};\n\n   if ($dl) {\n     OpenGL::glCallList($dl);\n     $chkErr && $self->tErr('draw Door3');\n   } else {\n     $dl = $self->getDLname();\n     OpenGL::glNewList($dl,OpenGL::GL_COMPILE);\n\n     $self->setColor('black');\n     glBegin(OpenGL::GL_QUADS);\n     glVertex3f($mdl->{minx},                 $mdl->{miny},$mdl->{minz});\n     glVertex3f($mdl->{minx}+$mdl->{barWidth},$mdl->{miny},$mdl->{minz});\n     glVertex3f($mdl->{minx}+$mdl->{barWidth},$mdl->{maxy},$mdl->{minz});\n     glVertex3f($mdl->{minx},                 $mdl->{maxy},$mdl->{minz});\n     &OpenGL::glEnd();\n     $chkErr && $self->tErr('Door_9');\n     my $vx = $mdl->{minx}+$mdl->{gapWidth};\n     for (my $i = 1; $i<$mdl->{barCnt}; $i++) {\n       glBegin(OpenGL::GL_QUADS);\n       glVertex3f($vx,                 $mdl->{miny},$mdl->{minz});\n       glVertex3f($vx+$mdl->{barWidth},$mdl->{miny},$mdl->{minz});\n       glVertex3f($vx+$mdl->{barWidth},$mdl->{maxy},$mdl->{minz});\n       glVertex3f($vx,                 $mdl->{maxy},$mdl->{minz});\n       &OpenGL::glEnd();\n       $vx += $mdl->{barWidth}+$mdl->{gapWidth};\n     }\n     glBegin(OpenGL::GL_QUADS);\n     glVertex3f($mdl->{minx},                 $mdl->{miny},$mdl->{maxz});\n     glVertex3f($mdl->{minx}-$mdl->{barWidth},$mdl->{miny},$mdl->{maxz});\n     glVertex3f($mdl->{minx}-$mdl->{barWidth},$mdl->{maxy},$mdl->{maxz});\n     glVertex3f($mdl->{minx},                 $mdl->{maxy},$mdl->{maxz});\n     &OpenGL::glEnd();\n\n     $chkErr && $self->tErr('Door_91');\n     glBegin(OpenGL::GL_QUADS);\n     glVertex3f($mdl->{maxx},$mdl->{h1}-$mdl->{hbarWidth}/2,$mdl->{minz});\n     glVertex3f($mdl->{maxx},$mdl->{h1}+$mdl->{hbarWidth}/2,$mdl->{minz});\n     glVertex3f($mdl->{minx},$mdl->{h1}+$mdl->{hbarWidth}/2,$mdl->{minz});\n     glVertex3f($mdl->{minx},$mdl->{h1}-$mdl->{hbarWidth}/2,$mdl->{minz});\n     &OpenGL::glEnd();\n     glBegin(OpenGL::GL_QUADS);\n     glVertex3f($mdl->{maxx},$mdl->{h2}-$mdl->{hbarWidth}/2,$mdl->{minz});\n     glVertex3f($mdl->{maxx},$mdl->{h2}+$mdl->{hbarWidth}/2,$mdl->{minz});\n     glVertex3f($mdl->{minx},$mdl->{h2}+$mdl->{hbarWidth}/2,$mdl->{minz});\n     glVertex3f($mdl->{minx},$mdl->{h2}-$mdl->{hbarWidth}/2,$mdl->{minz});\n     &OpenGL::glEnd();\n     glBegin(OpenGL::GL_QUADS);\n     glVertex3f($mdl->{maxx},$mdl->{h3}-$mdl->{hbarWidth}/2,$mdl->{minz});\n     glVertex3f($mdl->{maxx},$mdl->{h3}+$mdl->{hbarWidth}/2,$mdl->{minz});\n     glVertex3f($mdl->{minx},$mdl->{h3}+$mdl->{hbarWidth}/2,$mdl->{minz});\n     glVertex3f($mdl->{minx},$mdl->{h3}-$mdl->{hbarWidth}/2,$mdl->{minz});\n     &OpenGL::glEnd();\n     OpenGL::glEndList();\n     OpenGL::glCallList($dl);   \n     $chkErr && $self->tErr('draw Door1');\n   }\n   if ($self->contains) {\n     foreach my $o (@{$self->contains}) {\n       $o->draw($mode);\n     }\n   }\n\n   glRotatef(-$self->{yaw},0,1,0) if $self->{yaw};\n   glTranslatef(-$self->{x},-$self->y,-$self->{z});\n\n   $chkErr && $self->tErr('Door_texture');\n }\n} \n\nsub tractable { \n  return 'seethru';\n}\n\n1",
      "file" : "/var/tmp/arv_A26dgv/OpenGL-QEng-0.27/lib/OpenGL/QEng/BarDoor.pm",
      "package" : "OpenGL::QEng::BarDoor"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "{;\n my $classname = 'XAAAAA';\n\n sub wrap_class {\n   my ($self) = @_;\n\n   my $class = $classname++;\n   {\n     no strict 'refs';\n     push @{\"$class\\::ISA\"}, ref($self);\n\n     unless (ref $self->{wrap_class} eq 'HASH') {\n       my $cmdTxt = '$self->{wrap_class} = ' .$self->{wrap_class};\n       eval $cmdTxt;\n       if ($@) {\n\t print STDERR \"EVAL ($cmdTxt) FAILED: $@\\n\";\n\t print STDERR \"wrap_class failed for $self\\n\";\n\t return;\n       }\n     }\n     for my $method (keys %{$self->{wrap_class}}) {\n       *{$class.'::'.$method} = $self->{wrap_class}{$method};\n     }\n   }\n   return bless($self, $class);\n }\n}\n\n1",
      "file" : "/var/tmp/arv_A26dgv/OpenGL-QEng-0.27/lib/OpenGL/QEng/OUtil.pm",
      "package" : "OpenGL::QEng::OUtil"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "{;\n my %BUTS =\n   ('move' =>\n    [['go_forward',      0,1,['step',0.3,0.0], '<Up>',       'repeat'],\n     ['go_back',         2,1,['step',0.3,180.0],'<Down>',    'repeat'],\n     ['turn_right',      0,2,['turn',+90],     '<Right>',    undef   ],\n     ['turn_left',       0,0,['turn',-90],     '<Left>',     undef   ],\n     ['turn_around',     1,1,['turn',180],     '<Control_A>',undef   ],\n     ['go_right',        2,2,['step',+0.3,+90],'<Control_R>','repeat'],\n     ['go_left',         2,0,['step',+0.3,-90],'<Control_L>','repeat'],\n     ['turn_left_some',  1,0,['turn',-3.0],    '<Left>',     'repeat'],\n     ['turn_right_some', 1,2,['turn',+3.0],    '<Right>',    'repeat'],\n     ['Save',            4,0,['saveGame'],     ' ',          'text'  ],\n     ['Load',            4,2,['loadGame'],     ' ',          'text'  ],\n     ['Quit',            4,1,['quit'],         '<Control_Q>','text'  ],\n     ['event',           3,0,['special'],      ' ',          'text'  ],\n    ],\n\n    'yesno' => [\n\t\t['Yes',    1,0,['answer','Yes'],  '<Y>',    'text'],\n\t\t['No',     1,2,['answer','No'],   '<N>',    'text'],\n\t\t['Quit',   3,1,['quit'],   '  <Control_Q>', 'text'],\n\t       ],\n\n    'blank' => [\n\t\t['Quit',   3,1,['quit'],  '<Control_Q>', 'text'],\n\t       ],\n   );\n\n sub _present {\n   my ($self) = @_;\n\n   undef $self->{repeat};\n   my ($w,$h) = (40,40);\n\n   $self->{buttons} = $BUTS{$self->style};\n   my $i = 0;\n   foreach my $bi ( @{$self->{buttons}} ) {\n     ($i++,next) if $bi->[5] && $bi->[5] eq 'blank';\n     ($i++,next) if $bi->[3][0] eq 'special' and not $ENV{WIZARD};\n\n     my ($tex,$label);\n     my $pcb;\t\t\t                    \n     my $ccb = sub {\n\t\t    $self->send_event(@{$bi->[3]})}; \n\n     if ($bi->[5] and $bi->[5] eq 'text') {\n       $label = $bi->[0];\n       $tex = 'brass_btn';\n     }\n     else {\n       $tex = $bi->[0];\n     }\n     if ($bi->[5] && $bi->[5] eq 'repeat') {\n       my $ri = $i;\n       $pcb     = sub {\n\t\t       $self->{repeat} = $ri};\n       $ccb     = sub {undef $self->{repeat}};\n     }\n     $self->adopt(OpenGL::QEng::GUIiButton->new(text         => $label,\n\t\t\t\t  textColor    => 'black',\n\t\t\t\t  texture      => [$tex.'_up',$tex.'_dn',],\n\t\t\t\t  x            => $bi->[2]*($w+4)+$self->x,\n\t\t\t\t  y            => $bi->[1]*($h+4)+$self->y,\n\t\t\t\t  width        => $w,\n\t\t\t\t  height       => $h,\n\t\t\t\t  pressCallback=> $pcb,\n\t\t\t\t  clickCallback=> $ccb,\n\t\t\t\t ));\n     $i++;\n   }\n }\n}\n\nsub stateTest {\n  my ($self) = @_;\n\n  return unless defined $self->{repeat};\n  $self->send_event(@{ $self->{buttons}[$self->{repeat}][3] })\n    if defined($self->{repeat});\n}\n\nsub cpush {\n  my ($self,$style) = @_;\n\n  push @{$self->{stack}}, $self->{style};\n  undef $self->{repeat};\n  undef $self->{children};\n  $self->{style} = $style;\n  $self->_present;\n}\n\nsub cpop {\n  my ($self) = @_;\n\n  if (@{$self->{stack}}) {\n    undef $self->{repeat};\n    undef $self->{children};\n    $self->{style} = pop @{$self->{stack}};\n    $self->_present;\n  }\n  else {warn 'cpop with empty stack'}\n  $self;\n}\n\nsub keyboard {\n  my ($self, $key, $x, $y) = @_;\n  die \"keyboard($self) from \",join(':',caller), unless ref $self;\n\n  return unless ref $self;\n  if    ($key == 100) { \n    $self->send_event('pivot',-3.0);\n  }\n  elsif ($key == 101) { \n    $self->send_event('step', 0.3,0);\n  }\n  elsif ($key == 102) { \n    $self->send_event('pivot',+3.0);\n  }\n  elsif ($key == 103) { \n    $self->send_event('step', 0.3,180);\n  }\n  elsif ($key == 104) { \n    $self->send_event('turn',+90.0);\n  }\n  elsif ($key == 105) { \n    $self->send_event('step',+0.3,+90);\n  }\n  elsif ($key == 106) { \n    $self->send_event('turn',-90.0);\n  }\n  elsif ($key == 107) { \n    $self->send_event('step',+0.3,-90);\n  }\n}\n\nif (not defined caller()) {\n  package main;\n\n  require OpenGL;\n  require GUIMaster;\n\n  my $winsize = 400;\n  OpenGL::glutInit;\n  OpenGL::glutInitDisplayMode(OpenGL::GLUT_RGB   |\n\t\t\t      OpenGL::GLUT_DEPTH |\n\t\t\t      OpenGL::GLUT_DOUBLE);\n  OpenGL::glutInitWindowSize($winsize,$winsize);\n  OpenGL::glutInitWindowPosition(200,100);\n\n  my $win1 = OpenGL::glutCreateWindow(\"OpenGL Control Test\");\n  glViewport(0,0,$winsize,$winsize);\n\n  my $GUIRoot = OpenGL::QEng::GUIMaster->new(wid=>$win1,\n\t\t\t       x=>$winsize, y=>0,\n\t\t\t       width=>$winsize, height=>$winsize);\n  glutDisplayFunc(\\&GUIMaster::GUIDraw);\n  $GUIRoot->adopt(OpenGL::QEng::Control->new($GUIRoot,'move',100,100));\n\n  $GUIRoot->adopt(OpenGL::QEng::GUIButton->new(x=>150,y=>300,width=>100,height=>30,\n\t\t\t\t text=>'Quit',\n\t\t\t\t clickCallback=>sub{exit(0)},\n\t\t\t\t pressCallback=>\n\t\t\t\t sub{print STDERR \"Waiting for Release\\n\";}));\n\n  glutDisplayFunc(sub{ $GUIRoot->GUIDraw(@_) });\n  glutMouseFunc(  sub{ $GUIRoot->mouseButton(@_) });\n\n  glutMainLoop;\n}\n\n1",
      "file" : "/var/tmp/arv_A26dgv/OpenGL-QEng-0.27/lib/OpenGL/QEng/Control.pm",
      "package" : "OpenGL::QEng::Control"
   }
]
