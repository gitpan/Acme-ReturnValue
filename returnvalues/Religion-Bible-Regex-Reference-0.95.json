[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "sub v2   { shift->{'reference'}{'data'}{'v2'};   }\n\nsub ob   { shift->{'reference'}{'original'}{'b'};  }\nsub ob2  { shift->{'reference'}{'original'}{'b2'}; }\nsub oc   { shift->{'reference'}{'original'}{'c'};  }\nsub oc2  { shift->{'reference'}{'original'}{'c2'}; }\nsub ov   { shift->{'reference'}{'original'}{'v'};  }\nsub ov2  { shift->{'reference'}{'original'}{'v2'}; }\n\nsub s2   { my $s = shift; return unless defined($s->{'reference'}{'spaces'}); return $s->{'reference'}{'spaces'}{'s2'}; }\nsub s3   { my $s = shift; return unless defined($s->{'reference'}{'spaces'}); return $s->{'reference'}{'spaces'}{'s3'}; }\nsub s4   { my $s = shift; return unless defined($s->{'reference'}{'spaces'}); return $s->{'reference'}{'spaces'}{'s4'}; }\nsub s5   { my $s = shift; return unless defined($s->{'reference'}{'spaces'}); return $s->{'reference'}{'spaces'}{'s5'}; }\nsub s6   { my $s = shift; return unless defined($s->{'reference'}{'spaces'}); return $s->{'reference'}{'spaces'}{'s6'}; }\nsub s7   { my $s = shift; return unless defined($s->{'reference'}{'spaces'}); return $s->{'reference'}{'spaces'}{'s7'}; }\nsub s8   { my $s = shift; return unless defined($s->{'reference'}{'spaces'}); return $s->{'reference'}{'spaces'}{'s8'}; }\nsub s9   { my $s = shift; return unless defined($s->{'reference'}{'spaces'}); return $s->{'reference'}{'spaces'}{'s9'}; }\n\nsub book { \n    my $self = shift;\n    return $self->get_regexes->book($self->key);\n}\nsub book2 { \n    my $self = shift;\n    return $self->get_regexes->book($self->key2);\n}\nsub abbreviation  {\n    my $self = shift;\n    return $self->get_regexes->abbreviation($self->key);\n}\nsub abbreviation2  {\n    my $self = shift;\n    return $self->get_regexes->abbreviation($self->key2);\n}\nsub context_words  { shift->{'reference'}{'data'}{'context_words'}; }\nsub cvs            { shift->{'reference'}{'info'}{'cvs'}; }\nsub dash           { shift->{'reference'}{'info'}{'dash'}; }\n\nsub abbreviation2book {}\nsub book2abbreviation {}\nsub key2book {}\nsub key2abbreviation {}\nsub book2key {}\nsub abbreviation2key {}\n\nsub set_key   {\n    my $self = shift; \n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'data'}{'key'} = $e; \n}\nsub set_c     {\n    my $self = shift;\n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'data'}{'c'}   = $e; \n    $self->{'reference'}{'original'}{'c'}   = $e; \n}\nsub set_v     {\n    my $self = shift;\n    my $e = shift;\n\n    my $r = $self->get_regexes;\n    return unless (_non_empty($e));\n    if ($e =~ m/($r->{'verse_number'})($r->{'verse_letter'})/) {\n\t$self->{'reference'}{'data'}{'v'}   = $1 if defined($1);\n\t$self->{'reference'}{'data'}{'vletter'} = $2 if defined($2);\n    } else {\n\t$self->{'reference'}{'data'}{'v'}   = $e;\n    }\n    $self->{'reference'}{'original'}{'v'}   = $e; \n}\n\n sub set_key2  {\n    my $self = shift;\n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'data'}{'key2'} = $e; \n}\n\n sub set_ob  {\n    my $self = shift;\n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'original'}{'b'} = $e; \n}\n\n sub set_ob2  {\n    my $self = shift;\n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'original'}{'b2'} = $e; \n}\n\nsub set_b     {\n    my $self = shift;\n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'original'}{'b'}  = $e; \n\n    my $key = $self->get_regexes->key($e);\n    unless (defined($key)) {\n      print Dumper $self->{'regex'}{'book2key'};\n  \t  print Dumper $self->{'regex'}{'abbreviation2key'};\n\t    croak \"Book or Abbreviation must be defined in the configuration file: $e\\n\";\n    }\n    $self->{'reference'}{'data'}{'key'} = $self->get_regexes->key($e);\n}\nsub set_b2    {\n    my $self = shift;\n    my $e = shift;\n    return unless (_non_empty($e));\n\n    $self->{'reference'}{'original'}{'b2'}  = $e; \n    $self->{'reference'}{'data'}{'key2'} = $self->get_regexes->key($e);\n}\nsub set_c2    {\n    my $self = shift; \n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'data'}{'c2'}   = $e; \n    $self->{'reference'}{'original'}{'c2'}   = $e; \n}\nsub set_v2    {\n    my $self = shift;\n    my $e = shift;\n\n    my $r = $self->get_regexes;\n    return unless (_non_empty($e));\n    if ($e =~ m/($r->{'verse_number'})($r->{'verse_letter'})/) {\n\t$self->{'reference'}{'data'}{'v2'} = $1 if (defined($1));\n\t$self->{'reference'}{'data'}{'v2letter'} = $2 if (defined($1));\n    } else {\n\t$self->{'reference'}{'data'}{'v2'}   = $e;\n    }\n    $self->{'reference'}{'original'}{'v2'}   = $e;  \n}\nsub set_context_words  {\n    my $self = shift;\n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'data'}{'context_words'} = $e; \n}\n\nsub set_s2    {\n    my $self = shift; \n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'spaces'}{'s2'} = $e; \n}\nsub set_s3    {\n    my $self = shift; \n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'spaces'}{'s3'} = $e; \n}\nsub set_s4    {\n    my $self = shift; \n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'spaces'}{'s4'} = $e; \n}\nsub set_s5    {\n    my $self = shift; \n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'spaces'}{'s5'} = $e; \n}\nsub set_s6    {\n    my $self = shift; \n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'spaces'}{'s6'} = $e; \n}\nsub set_s7    {\n    my $self = shift;\n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'spaces'}{'s7'} = $e; \n}\nsub set_s8    {\n    my $self = shift;\n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'spaces'}{'s8'} = $e; \n}\nsub set_s9    {\n    my $self = shift;\n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'spaces'}{'s9'} = $e; \n}\n\n\nsub set_cvs   {\n    my $self = shift;\n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'info'}{'cvs'} = $e; \n}\nsub set_dash  {\n    my $self = shift;\n    my $e = shift;\n    return unless (_non_empty($e));\n    $self->{'reference'}{'info'}{'dash'} = $e; \n}\n\nsub book_type {\n    my $self = shift;\n    return 'NONE' unless (_non_empty($self->ob));\n    return 'CANONICAL_NAME' if ($self->ob =~ m/@{[$self->get_regexes->{'livres'}]}/);\n    return 'ABBREVIATION' if ($self->ob =~ m/@{[$self->get_regexes->{'abbreviations'}]}/);\n    return 'UNKNOWN';\n}\n\nsub formatted_book {\n    my $self = shift;\n    my $book_format = shift || 'ORIGINAL';\n    my $ret = '';\n\n    if (!($book_format eq 'ORIGINAL' || $book_format eq 'CANONICAL_NAME' || $book_format eq 'ABBREVIATION')) {\n        confess \"book_format should be either 'ORIGINAL', 'CANONICAL_NAME', 'ABBREVIATION'\";\n        $book_format = 'ORIGINAL';\n    }\n\n    if ($book_format eq 'ABBREVIATION' || ($book_format eq 'ORIGINAL' && $self->book_type eq 'ABBREVIATION')) {\n    \t$ret .= $self->abbreviation || '';\n    } else {\n    \t$ret .= $self->book || '';\n    }\n\n    return $ret;\n} \n\nsub formatted_book2 {\n    my $self = shift;\n    my $book_format = shift || 'ORIGINAL';\n    my $ret = '';\n\n    if (!($book_format eq 'ORIGINAL' || $book_format eq 'CANONICAL_NAME' || $book_format eq 'ABBREVIATION')) {\n\tconfess \"book_format should be either 'ORIGINAL', 'CANONICAL_NAME', 'ABBREVIATION'\";\n\t$book_format = 'ORIGINAL';\n    }\n\n    if ($book_format eq 'ABBREVIATION' || ($book_format eq 'ORIGINAL' && $self->book_type eq 'ABBREVIATION')) {\n    \t$ret .= $self->abbreviation2 || '';\n    } else {\n    \t$ret .= $self->book2 || '';\n    }\n\n    return $ret;\n} \n\nsub set {\n    my $self = shift;\n    my $r = shift;\n    my $context = shift;\n\n    $self->{reference} = {};\n    $self->{reference} = dclone($context->{reference}) if defined($context->{reference});\n\n    return unless(defined($r) && ref($r) eq 'HASH');\n\n    $self->set_context_words($r->{context_words});\n\n    if (defined($r->{key})) {\n      $self->set_key($r->{key});   \n    } else {\n      $self->set_b($r->{b});   \n    }\n\n    $self->set_ob($r->{ob});   \n    $self->set_c($r->{c});   \n    $self->set_v($r->{v});   \n\n    if (defined($r->{key2})) {\n      $self->set_key2($r->{key2});   \n    } else {\n      $self->set_b2($r->{b2});   \n    }\n\n    $self->set_ob2($r->{ob2});   \n    $self->set_c2($r->{c2});  \n    $self->set_v2($r->{v2});  \n\n    $self->set_cvs($r->{cvs}) if ((defined($r->{c}) && defined($r->{v})) || (defined($r->{c2}) && defined($r->{v2})));   \n    $self->set_dash($r->{dash}); \n\n    if(((defined($self->book) && $self->book =~ m/@{[$self->get_regexes->{'livres_avec_un_chapitre'}]}/) ||\n\t(defined($self->abbreviation) && $self->abbreviation =~ m/@{[$self->get_regexes->{'livres_avec_un_chapitre'}]}/)) &&\n       !(defined($self->c) && defined($self->c) && $self->c eq '1')) {\n\t$self->set_v($self->c);\n\t$self->set_c('1');\n\t$self->set_cvs(':');\n    }\n\n\n    $self->set_s2($r->{s2});\n    $self->set_s3($r->{s3});\n    $self->set_s4($r->{s4});\n    $self->set_s5($r->{s5});\n    $self->set_s6($r->{s6});\n    $self->set_s7($r->{s7});\n    $self->set_s8($r->{s8});\n    $self->set_s9($r->{s9});\n\n}\n\nsub parse {\n    my $self = shift; \n    my $token = shift;\n    my $state = shift;\n    my $context_words = '';\n    ($context_words, $state) = $self->parse_context_words($token, $state);\n\n    my $r = $self->get_regexes;\n    my $spaces = '[\\s ]*';\n    \n    if ($token =~ m/($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)($r->{'intervale'})($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)/x) {\n\n        $self->set({b=>$2, s2=>$3, c=>$4, s3=>$5, cvs=>$6, s4=>$7, v=>$8, s5=>$9, dash=>$10, s6=>$11, b2=>$12, s7=>$13, c2=>$14, s8=>$15, s9=>$17, v2=>$18,  context_words=>$context_words});\n    }   \n    \n    elsif ($token =~ m/($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)($r->{'intervale'})($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)/x) {\n\t\n\t$self->set({ b=>$2, s2=>$3, c=>$4, s3=>$5, cvs=>$6, s4=>$7, v=>$8, s5=>$9, dash=>$10, s6=>$11, b2=>$12, s7=>$13, c2=>$14, s8=>$15, context_words=>$context_words });\n    }\n\n    elsif ($token =~ m/($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)($r->{'intervale'})($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)/x) {\n\t\n        $self->set({ b=>$2, s2=>$3, c=>$4, s3=>$5, dash=>$6, s6=>$7, b2=>$8, s7=>$9, c2=>$10, s8=>$11, cvs=>$12, s9=>$13, v2=>$14, context_words=>$context_words });\n    }\n\n    elsif ($token =~ m/($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)($r->{'intervale'})($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)/x) {\n\t\n        $self->set({ b=>$2, s2=>$3, c=>$4, s3=>$5, cvs=>$6, s4=>$7, v=>$8, s5=>$9, dash=>$10, s6=>$11, c2=>$12, s8=>$13, s9=>$15, v2=>$16, context_words=>$context_words});\n    }\n\n    elsif ($token =~ m/($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)($r->{'intervale'})($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)/x) {\n\t\n\t$self->set({ b=>$2, s2=>$3, c=>$4, s3=>$5, dash=>$6, s6=>$7, b2=>$8, s7=>$9, c2=>$10, s8=>$11, context_words=>$context_words });\n    }\n\n    elsif ($token =~ m/($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)($r->{'intervale'})($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)/x) {\n        \n        $self->set({b=>$2, s2=>$3, c=>$4, s3=>$5, dash=>$6, s6=>$7, c2=>$8, s8=>$9, cvs=>$10, s9=>$11, v2=>$12, context_words=>$context_words});\n    }  \n\n    elsif ($token =~ m/($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)($r->{'intervale'})($spaces)($r->{'verset'})($spaces)/x) {\n        \n        $self->set({b=>$2, s2=>$3, c=>$4, s3=>$5, cvs=>$6, s4=>$7, v=>$8, s5=>$9, dash=>$10, s6=>$11, v2=>$12, s7=>$13, context_words=>$context_words});\n    }\n\n    elsif ($token =~ m/($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)/x) {\n        \n        $self->set({b=>$2, s2=>$3, c=>$4, s3=>$5, cvs=>$6, s4=>$7, v=>$8, s5=>$9, context_words=>$context_words});\n    } \n\n    elsif ($token =~ m/($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)($r->{'intervale'})($spaces)($r->{'chapitre'})($spaces)/x) {\n\t\n        $self->set({b=>$2, s2=>$3, c=>$4, s3=>$5, dash=>$6, s6=>$7, c2=>$8, s7=>$9, context_words=>$context_words});\n    }\n\n    elsif ($token =~ m/($spaces)($r->{'livres_et_abbreviations'})($spaces)($r->{'chapitre'})($spaces)/x) {        \n        $self->set({b=>$2, s2=>$3, c=>$4, s3=>$5, context_words=>$context_words});\n    } else {\n\t$self->parse_chapitre($token, $state, $context_words);\n    } \n    return $self;\n}\n\nsub parse_chapitre {\n    my $self = shift; \n    my $token = shift;\n    my $state = shift;\n    my $context_words = shift;\n    my $r = $self->get_regexes;\n    my $spaces = '[\\s ]*';\n\n\n    if ($token =~ m/($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)($r->{'intervale'})($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)/x) {\n        $state = 'match';\n        $self->set({ s2=>$1, c=>$2, s3=>$3, cvs=>$4, s4=>$5, v=>$6, s5=>$7, dash=>$8, s6=>$9, c2=>$10, s8=>$11, s9=>$13, v2=>$14, context_words=>$context_words });\n    } \n\n    elsif ($token =~ m/($spaces)($r->{'chapitre'})($spaces)($r->{'intervale'})($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)/x) {\n        $state = 'match';\n        $self->set({ s2=>$1, c=>$2, s3=>$3, dash=>$4, s6=>$5, c2=>$6, s8=>$7, cvs=>$8, s9=>$9, v2=>$10, context_words=>$context_words });\n    } \n\n    elsif ($token =~ m/($spaces)($r->{'chapitre'})($spaces)($r->{'cv_separateur'})($spaces)($r->{'verset'})($spaces)($r->{'intervale'})($spaces)($r->{'verset'})($spaces)/x) {\n        $state = 'match';\n        $self->set({ s2=>$1, c=>$2, s3=>$3, cvs=>$4, s4=>$5, v=>$6, s5=>$7, dash=>$8, s6=>$9, v2=>$10, s7=>$11, context_words=>$context_words });\n    } \n\n    elsif ($token =~ m/([\\s ]*)($r->{'chapitre'})([\\s ]*)($r->{'cv_separateur'})([\\s ]*)($r->{'verset'})([\\s ]*)/x) {\n        $state = 'match';\n        $self->set({ s2=>$1, c=>$2, s3=>$3, cvs=>$4, s4=>$5, v=>$6, s5=>$7, context_words=>$context_words });\n    }\n\n    elsif ($token =~ m/($spaces)($r->{'chapitre'})($spaces)($r->{'intervale'})($spaces)($r->{'chapitre'})($spaces)/ && $state eq CHAPTER) {\n        $state = 'match';\n        $self->set({ s2=>$1, c=>$2, s3=>$3, dash=>$4, s4=>$5, c2=>$6, s7=>$7, context_words=>$context_words });\n    } \n\n    elsif ($token =~ m/([\\s ]*)($r->{'chapitre'})([\\s ]*)/ && $state eq CHAPTER) {\n        $state = 'match';\n        $self->set({ s2=>$1, c=>$2, s3=>$3, context_words=>$context_words });\n    } \n\n    else {\n        $self->parse_verset($token, $state, $context_words);\n    }\n}\n\nsub parse_verset {\n    my $self = shift; \n    my $token = shift;\n    my $state = shift; \n    my $context_words = shift;\n    my $r = $self->get_regexes;\n\n    my $spaces = '[\\s ]*';\n\n    unless (defined($state)) {\n        carp \"\\n\\n$token: \" .__LINE__ .\"\\n\\n\";\n    }\n    if ($token =~ m/($spaces)($r->{'verset'})($spaces)($r->{'intervale'})($spaces)($r->{'verset'})($spaces)/ && $state eq VERSE) {\n        $state = 'match';\n        $self->set({s2=>$1, v=>$2, s5=>$3, dash=>$4, s6=>$5, v2=>$6, context_words=>$context_words});\n    }\n    \n    elsif ($token =~ m/([\\s ]*)($r->{'verset'})([\\s ]*)/ && $state eq VERSE) {\n        $state = 'match';\n        $self->set({s2=>$1, v=>$2, s5=>$3, context_words=>$context_words});\n    } \n\n    else {\n        $self->set({type => 'Error'});\n    }\n}\n\nsub parse_context_words {\n    my $self = shift;\n    my $refstr = shift;\n    my $r = $self->get_regexes;\n    my $spaces = '[\\s ]*';\n    my $state = shift;\n    my $header = '';\n\n    if ($refstr =~ m/^($r->{'livres_et_abbreviations'})(?:$spaces)(?:$r->{'cv_list'})/) {\n\t$state = BOOK;\n    } elsif ($refstr =~ m/^($r->{'chapitre_mots'})(?:$spaces)(?:$r->{'cv_list'})/) {\n\t$header = $1; $state = CHAPTER;\n    } elsif ($refstr =~ m/($r->{'verset_mots'})(?:$spaces)(?:$r->{'cv_list'})/) {\n\t$header = $1; $state = VERSE;\n    }\n    return ($header, $state);\n}\n\nsub formatted_context_words {\n    my $self = shift;\n    my $ret = '';\n    \n\t$ret .= $self->context_words || '';\n\n    return $ret;\n}\n\nsub formatted_c  { shift->c || ''; }\nsub formatted_v  { shift->v || ''; }\nsub formatted_c2 { shift->c2 || ''; }\nsub formatted_v2 { shift->v2 || ''; }\n\nsub formatted_cvs {\n    my $self = shift;\n    my $state = shift || 'BOOK';\n    my $book_format = shift || 'ORIGINAL';\n    \n    return (\n\t(_non_empty($self->c) && _non_empty($self->v)) \n\t? \n\t(defined($self->get_configuration->get('reference','cvs')) \n\t ? \n\t $self->get_configuration->get('reference','cvs')\n\t :\n\t (defined( $self->cvs ) ? $self->cvs : ':')) \n\t:\n\t'');\n}\n\nsub formatted_cvs2 {\n    my $self = shift;\n    my $state = shift || 'BOOK';\n    my $book_format = shift || 'ORIGINAL';\n    \n    return (\n\t(_non_empty($self->c2) && _non_empty($self->v2)) \n\t? \n\t(defined($self->get_configuration->get('reference','cvs')) \n\t ? \n\t $self->get_configuration->get('reference','cvs') \n\t :\n\t (defined( $self->cvs ) ? $self->cvs : ':')) \n\t:\n\t'');\n}\n\nsub formatted_interval {\n    my $self = shift;\n    my $state = shift || 'BOOK';\n    my $book_format = shift || 'ORIGINAL';\n    \n    return ((_non_empty($self->formatted_book2) || _non_empty($self->c2) || _non_empty($self->v2) ) \n\t    ? \n\t    (defined($self->get_configuration->get('reference','intervale'))\n\t     ? \n\t     $self->get_configuration->get('reference','intervale') \n\t     :\n\t     (defined( $self->dash ) ? $self->dash : ':')) \n\t    :\n\t    '');\n}\n\nsub formatted_normalize {\n    my $self = shift;\n    my $state = shift || 'BOOK';\n    my $book_format = shift || 'ORIGINAL';\n    my $ret = '';\n    \n    my ($book, $book2, $c, $c2) = ('','','','');\n\n    if (defined($self->book) && defined($self->book2) || (!(defined($self->v) || defined($self->v2)) && $state eq 'VERSE') ) {\n\t$state = 'BOOK';\n    } elsif (defined($self->c) && defined($self->c2) && $state eq 'VERSE') {\n\t$state = 'CHAPTER';\n    }\n\n    if (_non_empty($self->formatted_context_words)) {\n\t$ret .= $self->formatted_context_words;\n\t$ret .= ' ' if defined($self->s2);\n    }\n\n    if ($state eq 'BOOK') {\t\n\t$ret .= $book = $self->formatted_book($book_format);\n\t$ret .= ' ' if defined($self->s2) && _non_empty($self->formatted_book($book_format));\n    }\n\n    if ($state eq 'BOOK' || $state eq 'CHAPTER') {\n\t$ret .= $c = $self->formatted_c;\n\t$ret .= $self->formatted_cvs;\n    }\n\n    $ret .= $self->formatted_v;\n\n    if ($self->has_interval) {\n\t$ret .= '-';\t\n\n\t$book2 = $self->formatted_book2($book_format);\n\t$ret .= $book2 if ($book ne $book2);\n\n\t$ret .= ' ' if (defined($self->s7) && $book ne $book2);\n\n\t$c2 = $self->formatted_c2;\n\t$ret .= $c2 if ($c ne $c2);\n\n\t$ret .= $self->formatted_cvs2 if defined($self->c2) && defined($self->v2) && ($c ne $c2);\n\n\t$ret .= $self->formatted_v2;\n    }\n    return $ret;\n}\n\nsub n { return shift->normalize; }\n\nsub bol {\n    my $self = shift;\n    my $state = shift || 'BOOK';\n    my $book_format = shift || 'ORIGINAL';\n    my $ret = '';\n    \n    my ($book, $book2, $c, $c2) = ('','','','');\n\n    if ((!(defined($self->v) || defined($self->v2)) && $state eq 'VERSE')) {\n    \t$state = 'BOOK';\n    } elsif (defined($self->c) && defined($self->c2) && $state eq 'VERSE') {\n    \t$state = 'CHAPTER';\n    }\n\n    if ($state eq 'BOOK') {\t\n    \t$ret .= $book = $self->formatted_book($book_format);\n    \t$ret .= ' ' if defined($self->s2);\n    }\n\n    if ($state eq 'BOOK' || $state eq 'CHAPTER') {\n    \t$ret .= $c = $self->formatted_c;\n    \t$ret .= (_non_empty($self->c) && ! _non_empty($self->v)) ? '$' : '';\n    \t$ret .= $self->formatted_cvs;\n    }\n\n    $ret .= $self->formatted_v;\n\n    $ret .= $self->formatted_interval;\n\n    $book2 = $self->formatted_book2($book_format);\n\n    if ($state eq 'BOOK' && _non_empty($book2) && $book ne $book2) {\n    \t$ret .= $book2;\n\n    \t$ret .= ' ' if (defined($self->s7));\n    }\n\n    $c2 = $self->formatted_c2;\n    if (_non_empty($c) && $c ne $c2 && ($state eq 'BOOK' || $state eq 'CHAPTER')) {\n     \t$ret .= $c2;\n    \t$ret .= (_non_empty($self->c2) && ! _non_empty($self->v2)) ? '$' : '';\n    \t$ret .= $self->formatted_cvs2;\n    }\n\n    $ret .= $self->formatted_v2;\n\n    return $ret;\n}\n\nsub normalize {\n    my $self = shift;\n    my $ret = '';\n    \n    my ($book, $book2, $c, $c2) = ('','','','');\n\n    $ret .= $self->formatted_context_words;\n    $ret .= $book = $self->formatted_book('CANONICAL_NAME');\n    $ret .= ' ' if defined($self->s2);\n\n    $ret .= $c = $self->formatted_c;\n    $ret .= ':' if defined($self->c) && defined($self->v);\n\n    $ret .= $self->formatted_v;\n\n    if ($self->has_interval) {\n    \t$ret .= '-';\t\n\n    \t$book2 = $self->formatted_book2('CANONICAL_NAME');\n    \t$ret .= $book2 if ($book ne $book2);\n\n    \t$ret .= ' ' if (defined($self->s7) && $book ne $book2);\n\n    \t$c2 = $self->formatted_c2;\n    \t$ret .= $c2 if ($c ne $c2);\n\n    \t$ret .= ':' if defined($self->c2) && defined($self->v2) && ($c ne $c2);\n  \n    \t$ret .= $self->formatted_v2;\n    }\n    return $ret;\n}\n\n\nsub state_is_chapitre {\n    my $self = shift;\n    return _non_empty($self->c) && !$self->is_explicit;\n}\n\nsub state_is_verset {\n    my $self = shift;\n    return _non_empty($self->v) && !_non_empty($self->c) && !$self->is_explicit;\n}\n\nsub state_is_book {\n    my $self = shift;\n    return $self->is_explicit;\n}\n\nsub state {\n    my $self = shift;\n    return 'BOOK'    if $self->state_is_book;\n    return 'CHAPTER' if $self->state_is_chapitre;\n    return 'VERSE'   if $self->state_is_verset;\n    return 'UNKNOWN';\n}\n\nsub context_is_verset {\n    my $self = shift;\n    return _non_empty($self->v) || _non_empty($self->v2);\n}\n\nsub context_is_chapitre {\n    my $self = shift;\n    return (_non_empty($self->c) || _non_empty($self->c2)) && !$self->context_is_verset;\n}\n\nsub context_is_book {\n    my $self = shift;\n    return (_non_empty($self->formatted_book) || _non_empty($self->formatted_book2)) && !$self->context_is_chapitre;\n}\n\nsub context {\n    my $self = shift;\n    return 'BOOK'    if $self->context_is_book;\n    return 'CHAPTER' if $self->context_is_chapitre;\n    return 'VERSE'   if $self->context_is_verset;\n    return 'UNKNOWN';\n}\n\nsub is_explicit {\n    my $self = shift;\n    return (_non_empty($self->key));\n}\n\nsub shared_state {\n    my $r1 = shift;\n    my $r2 = shift;\n\n\n    return unless ($r1->state eq $r2->state);\n\n    return VERSE   if ( ((defined($r1->v) && defined($r2->v)) && ($r1->v ne $r2->v))\n\t\t\t&& \n\t\t\t((defined($r1->c) && defined($r2->c) && ($r1->c eq $r2->c)) || (!(defined($r1->c) && defined($r2->c))))\n\t\t\t&& \n\t\t\t((defined($r1->key) && defined($r2->key) && ($r1->key eq $r2->key)) || (!(defined($r1->key) && defined($r2->key))))\n\t);\n\n    return CHAPTER if ((defined($r1->c) && defined($r2->c))     && (($r1->c ne $r2->c) && (!(defined($r1->key) && defined($r2->key)) || (defined($r1->c) && defined($r2->c) && $r1->key eq $r2->key))) );\n    return BOOK    if ((defined($r1->key) && defined($r2->key)) && (($r1->key ne $r2->key)));\n    return;\n}\n\n\nsub has_interval {\n    my $self = shift;\n    return ((defined($self->key) && defined($self->key2) && $self->key ne $self->key2) \n\t    || \n\t    (defined($self->c) && defined($self->c2) && $self->c ne $self->c2)\n\t    || \n\t    (defined($self->v) && defined($self->v2) && $self->v ne $self->v2)\n\t);\n}\n\nsub begin_interval_reference {\n    my $self = shift;\n    my $ret = new Religion::Bible::Regex::Reference($self->get_configuration, $self->get_regexes); \n\n    $ret->set({ key => $self->key, \n                ob => $self->ob, \n            \t\tc => $self->oc, \n                v => $self->ov, \n                s2 => $self->s2, \n                s3 => $self->s3, s4 => $self->s4, \n                s5 => $self->s5, cvs => $self->cvs, \n      \t        context_words => $self->context_words});\n\n    return $ret;\n}\nsub end_interval_reference {\n    my $self = shift;\n    my $ret = new Religion::Bible::Regex::Reference($self->get_configuration, $self->get_regexes); \n\n    my ($b, $c, $s7, $key);\n\n    if (!defined($self->key2) && (defined($self->oc2) || defined($self->ov2) )) {\n    \t$b = $self->ob;\n      $key = $self->key;\n    \t$s7 = $self->s2;\n    } else {\n    \t$b = $self->ob2;\n      $key = $self->key2;\n    \t$s7 = $self->s7;\n    }\n\n    if (!defined($self->oc2) && ( defined($self->ov2) )) {\n    \t$c = $self->oc;\n    } else {\n    \t$c = $self->oc2;\n    }\n    \n    return unless (_non_empty($b) || _non_empty($c) || _non_empty($self->ov2));\n\n    $ret->set({ key => $key, \n                ob => $b,\n                c => $c, \n                v => $self->ov2, \n                s2 => $s7,\n                s3 => $self->s8, \n                s4 => $self->s9, \n                cvs => $self->cvs,\n                context_words => $self->context_words});\n\n    return $ret;\n}\n\nsub interval {\n    my $r1 = shift;\n    my $r2 = shift;\n    \n    return unless (_non_empty($r1));\n    return unless (_non_empty($r2));\n\n    return $r1 if ($r1->compare($r2) == 0);\n\n    unless ($r1->state eq $r2->state) {\n\tcarp \"Attempted to compare two reference that do no have the same state: \" . $r1->normalize . \" and \" . $r2->normalize . \"\\n\";\n\treturn;\n    }\n    \n    my $min = $r1->begin_interval_reference->min($r1->end_interval_reference, $r2->begin_interval_reference, $r2->end_interval_reference);\n    my $max = $r1->begin_interval_reference->max($r1->end_interval_reference, $r2->begin_interval_reference, $r2->end_interval_reference);\n\n    my $ret = new Religion::Bible::Regex::Reference($r1->get_configuration, $r1->get_regexes);\n\n    $ret->set({ key => $min->key, \n                ob => $min->ob, \n                c => $min->c, \n                v => $min->v, \n                key2 => $max->key, \n                ob2 => $max->ob,\n                c2 => $max->c, \n                v2 => $max->v2 || $max->v,\n                cvs => $min->cvs || $max->cvs, \n                dash => '-',\n                s2 => $min->s2, \n                s3 => $min->s3, \n                s4 => $min->s4, \n                s5 => $min->s5,  \n                s7 => $max->s2, \n                s8 => $max->s3,\n                s9 => $max->s4, \n                context_words => $min->context_words\n\t      });\n\n    return $ret;\n}\nsub min {\n    my $self = shift;\n    my @refs = @_; \n    my $ret = $self;\n\n    foreach my $r (@refs) {\n        if ($ret->gt($r)) {\n            $ret = $r;\n        }\n    }\n    return $ret;\n} \n\nsub max {\n    my $self = shift;\n    my @refs = @_; \n    my $ret = $self;\n\n    foreach my $r (@refs) {\n        if ($ret->lt($r)) {\n            $ret = $r;\n        }\n    }\n    return $ret;\n} \n\nsub compare {\n    my $r1 = shift;\n    my $r2 = shift;\n    \n    return unless (_non_empty($r1));\n    return unless (_non_empty($r2));\n\n    unless ($r1->state eq $r2->state) {\n\tcarp \"Attempted to compare two reference that do no have the same state: \" . $r1->normalize . \" and \" . $r2->normalize . \"\\n\";\n\treturn;\n    }\n\n    if (defined($r1->key) && defined($r2->key)) {\n\tif (($r1->key + 0 <=> $r2->key + 0) == 0) {\n\t    if (defined($r1->c) && defined($r2->c)) {\n\t\tif (($r1->c + 0 <=> $r2->c + 0) == 0) {\n\t\t    if (defined($r1->v) && defined($r2->v)) {\n\t\t\treturn ($r1->v + 0 <=> $r2->v + 0);\n\t\t    } else {\n\t\t\treturn ($r1->c + 0 <=> $r2->c + 0);\n\t\t    }\n\t\t} else {\n\t\t    return ($r1->c + 0 <=> $r2->c + 0);\n\t\t}\n\t    } else {\n\t\treturn ($r1->key + 0 <=> $r2->key + 0);\n\t    }\n\t} else {\n\t    return ($r1->key + 0 <=> $r2->key + 0);\n\t}\t\n    } \n    else {\n\tif (defined($r1->c) && defined($r2->c)) {\n\t    if (($r1->c + 0 <=> $r2->c + 0) == 0) {\n\t\tif (defined($r1->v) && defined($r2->v)) {\n\t\t    return ($r1->v + 0 <=> $r2->v + 0);\n\t\t} else {\n\t\t    return ($r1->c + 0 <=> $r2->c + 0);\n\t\t}\n\t    } else {\n\t\treturn ($r1->c + 0 <=> $r2->c + 0);\n\t    }\n\t} else {\n\t    if (defined($r1->v) && defined($r2->v)) {\n\t\treturn ($r1->v + 0 <=> $r2->v + 0);\n\t    } else {\n\t\treturn ($r1->c + 0 <=> $r2->c + 0);\n\t    }\n\t}\n    }\n\n    return;\n}\nsub gt {\n    my $r1 = shift;\n    my $r2 = shift;\n    \n    return unless (_non_empty($r1));\n    return unless (_non_empty($r2));\n\n    unless ($r1->state eq $r2->state) {\n\tcarp \"Attempted to compare two reference that do no have the same state: \" . $r1->normalize . \" and \" . $r2->normalize . \"\\n\";\n\treturn;\n    }\n\n    ($r1->compare($r2) == -1) ? return : return 1;\n\n}\nsub lt {\n    my $r1 = shift;\n    my $r2 = shift;\n    \n    return unless (_non_empty($r1));\n    return unless (_non_empty($r2));\n\n    unless ($r1->state eq $r2->state) {\n\tcarp \"Attempted to compare two reference that do no have the same state: \" . $r1->normalize . \" and \" . $r2->normalize . \"\\n\";\n\treturn;\n    }\n\n    my $ret = $r1->compare($r2);\n    ($ret == 1) ? return : return 1;\n\n}\n\n\nsub combine {\n    my $r1 = shift;\n    my $r2 = shift;\n    my %p; \n\n    return unless (_non_empty($r1));\n    return unless (_non_empty($r2));\n    \n    my $ret = new Religion::Bible::Regex::Reference($r1->get_configuration, $r1->get_regexes);\n\n    if ($r2->state eq 'BOOK') {\n      $p{'context_words'} = ($r2->context_words) if (defined($r2->context_words));\n\t    $ret->set( \\%p, $r2 );\n    } elsif ($r2->state eq 'CHAPTER') {    \n      $p{'key'} = ($r1->key2 || $r1->key) if (defined($r1->key2 || $r1->key));\n      $p{'ob'} = ($r1->ob2 || $r1->ob) if (defined($r1->ob2 || $r1->ob));\n      $p{'c'} = ($r2->c) if (defined($r2->c));\n      $p{'v'} = ($r2->v) if (defined($r2->v));\n      $p{'c2'} = ($r2->c2) if (defined($r2->c2));\n      $p{'v2'} = ($r2->v2) if (defined($r2->v2));\n      $p{'cvs'} = ($r2->cvs ||  $r1->cvs) if (defined($r2->cvs ||  $r1->cvs));\n      $p{'dash'} = ($r2->dash || $r1->dash) if (defined($r2->dash || $r1->dash));\n      $p{'context_words'} = ($r2->context_words) if (defined($r2->context_words));\n      $p{'s2'} = ($r2->s2 || $r1->s2) if (defined( $r2->s2 || $r1->s2 ));\n      $p{'s3'} = ($r2->s3 || $r1->s3) if (defined( $r2->s3 || $r1->s3 ));\n      $p{'s4'} = ($r2->s4 || $r1->s4) if (defined( $r2->s4 || $r1->s4 ));\n      $p{'s5'} = ($r2->s5 || $r1->s5) if (defined( $r2->s5 || $r1->s5 ));\n      $p{'s6'} = ($r2->s6 || $r1->s6) if (defined( $r2->s6 || $r1->s6 ));\n      $p{'s8'} = ($r2->s8 || $r1->s8) if (defined( $r2->s8 || $r1->s8 ));\n      $p{'s9'} = ($r2->s9 || $r1->s9) if (defined( $r2->s9 || $r1->s9 ));\n      $ret->set( \\%p, $r2);\n    } else {\n      $p{'key'} = ($r1->key2 || $r1->key) if (defined($r1->key2 || $r1->key));\n      $p{'ob'} = ($r1->ob2 || $r1->ob) if (defined($r1->ob2 || $r1->ob));\n      $p{'c'} = ($r2->c2 || $r2->c || $r1->c2 || $r1->c,) if (defined($r2->c2 || $r2->c || $r1->c2 || $r1->c,));\n      $p{'v'} = ($r2->v) if (defined($r2->v));\n      $p{'v2'} = ($r2->v2) if (defined($r2->v2));\n      $p{'cvs'} = ($r2->cvs ||  $r1->cvs) if (defined($r2->cvs ||  $r1->cvs));\n      $p{'dash'} = ($r2->dash || $r1->dash) if (defined($r2->dash || $r1->dash));\n      $p{'context_words'} = ($r2->context_words) if (defined($r2->context_words));\n      $p{'s2'} = ($r2->s2 || $r1->s2) if (defined( $r2->s2 || $r1->s2 ));\n      $p{'s3'} = ($r2->s3 || $r1->s3) if (defined( $r2->s3 || $r1->s3 ));\n      $p{'s4'} = ($r2->s4 || $r1->s4) if (defined( $r2->s4 || $r1->s4 ));\n      $p{'s5'} = ($r2->s5 || $r1->s5) if (defined( $r2->s5 || $r1->s5 ));\n      $p{'s6'} = ($r2->s6 || $r1->s6) if (defined( $r2->s6 || $r1->s6 ));\n      $p{'s8'} = ($r2->s8 || $r1->s8) if (defined( $r2->s8 || $r1->s8 ));\n      $p{'s9'} = ($r2->s9 || $r1->s9) if (defined( $r2->s9 || $r1->s9 ));\n      $ret->set( \\%p, $r2);\n    }\n    \n    return $ret;\n\n}\nsub _non_empty {\n    my $value = shift;\n    return (defined($value) && $value ne '');\n}  \n\nsub _setor {\n    foreach my $v (@_) {\n        return $v if _non_empty($v);\n    }\n    \n    return '';\n}\n\n1",
      "file" : "/var/tmp/arv_Rn1k47/Religion-Bible-Regex-Reference-0.95/lib/Religion/Bible/Regex/Reference.pm",
      "package" : "Religion::Bible::Regex::Reference"
   }
]
