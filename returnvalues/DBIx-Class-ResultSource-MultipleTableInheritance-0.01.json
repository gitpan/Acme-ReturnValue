[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method new ($class: @args) {\n  my $new = $class->next::method(@args);\n  my $rc = $new->result_class;\n  if (my $meth = $rc->can('result_source_instance')) {\n    my $source = $rc->$meth;\n    if ($source->result_class ne $new->result_class\n        && $new->result_class->isa($source->result_class)) {\n      $new->parent_source($source);\n    }\n  }\n  return $new;\n}\n\nmethod add_additional_parents (@classes) {\n  foreach my $class (@classes) {\n    Class::C3::Componentised->ensure_class_loaded($class);\n    $self->add_additional_parent(\n      $class->result_source_instance\n    );\n  }\n}\n\nmethod add_additional_parent ($source) {\n  my ($our_pk, $their_pk) = map {\n    join('|',sort $_->primary_columns)\n  } ($self, $source);\n\n  confess \"Can't attach additional parent ${\\$source->name} - it has different PKs ($their_pk versus our $our_pk)\"\n    unless $their_pk eq $our_pk;\n  $self->additional_parents([\n    @{$self->additional_parents||[]}, $source\n  ]);\n  $self->add_columns(\n    map {\n      $_ => \n      { originally_defined_in => $source->name, %{$source->column_info($_)}, },\n    } grep !$self->has_column($_), $source->columns\n  );\n  foreach my $rel ($source->relationships) {\n    my $rel_info = $source->relationship_info($rel);\n    $self->add_relationship(\n      $rel, $rel_info->{source}, $rel_info->{cond},\n      {originally_defined_in => $source->name, %{$rel_info->{attrs}}},\n    );\n  }\n  { no strict 'refs';\n    push(@{$self->result_class.'::ISA'}, $source->result_class);\n  }\n}\n\nmethod _source_by_name ($name) {\n  my $schema = $self->schema;\n  my ($source) =\n    grep { $_->name eq $name }\n      map $schema->source($_), $schema->sources;\n  confess \"Couldn't find attached source for parent $name - did you use load_classes? This module is only compatible with load_namespaces\"\n    unless $source;\n  return $source;\n}\n\nmethod schema (@args) {\n  my $ret = $self->next::method(@args);\n  if (@args) {\n    if ($self->parent_source) {\n      my $parent_name = $self->parent_source->name;\n      $self->parent_source($self->_source_by_name($parent_name));\n    }\n    $self->additional_parents([\n      map { $self->_source_by_name($_->name) }\n      @{$self->additional_parents||[]}\n    ]);\n  }\n  return $ret;\n}\n\nmethod attach_additional_sources () {\n  my $raw_name = $self->raw_source_name;\n  my $schema = $self->schema;\n\n  return if grep { $_ eq $raw_name } $schema->sources;\n\n\n  my $parent;\n  if ($self->parent_source) {\n      my $parent_name = $self->parent_source->name;\n    ($parent) =\n      grep { $_->name eq $parent_name }\n        map $schema->source($_), $schema->sources;\n    confess \"Couldn't find attached source for parent $parent_name - did you use load_classes? This module is only compatible with load_namespaces\"\n      unless $parent;\n    $self->parent_source($parent); \n  }\n\n\n  my $table = Table->new({ name => $self->raw_table_name });\n\n\n  my %pk_join;\n\n  if ($parent) {\n    foreach my $pri ($self->primary_columns) {\n      my %info = %{$self->column_info($pri)};\n      delete @info{qw(is_auto_increment sequence auto_nextval)};\n      $table->add_column($pri => \\%info);\n      $pk_join{\"foreign.${pri}\"} = \"self.${pri}\";\n    }\n    $table->add_relationship('parent', $parent->raw_source_name, \\%pk_join);\n    $self->deploy_depends_on->{$parent->result_class} = 1;\n  }\n\n  foreach my $add (@{$self->additional_parents||[]}) {\n    $table->add_relationship(\n      'parent_'.$add->name, $add->source_name, \\%pk_join\n    );\n    $self->deploy_depends_on->{$add->result_class} = 1 if $add->isa('DBIx::Class::ResultSource::View');\n  }\n  $table->add_columns(\n    map { ($_ => { %{$self->column_info($_)} }) }\n      grep { $self->column_info($_)->{originally_defined_in} eq $self->name }\n        $self->columns\n  );\n  $table->set_primary_key($self->primary_columns);\n\n\n\n  foreach my $rel ($self->relationships) {\n    my $rel_info = $self->relationship_info($rel);\n\n    next unless $rel_info->{attrs}{originally_defined_in} eq $self->name;\n\n    my $f_source = $schema->source($rel_info->{source});\n\n\n    my $one_of_us = $f_source->isa(__PACKAGE__);\n\n    my $f_source_name = $f_source->${\\\n                        ($one_of_us ? 'raw_source_name' : 'source_name')\n                      };\n\n    $table->add_relationship(\n      '_'.$rel, $f_source_name, @{$rel_info}{qw(cond attrs)}\n    );\n\n    unless ($one_of_us) {\n      my $reverse = do {\n        local @{$schema->source_registrations}\n               {map $self->$_, qw(source_name result_class)}\n          = ($self, $self);\n        $self->reverse_relationship_info($rel);\n      };\n      foreach my $rev_rel (keys %$reverse) {\n        $f_source->add_relationship(\n          '_raw_'.$rev_rel, $raw_name, @{$reverse->{$rev_rel}}{qw(cond attrs)}\n        );\n      }\n    }\n  }\n\n  $schema->register_source($raw_name => $table);\n}\n\nmethod set_primary_key (@args) {\n  if ($self->parent_source) {\n    confess \"Can't set primary key on a subclass\";\n  }\n  return $self->next::method(@args);\n}\n\nmethod set_sequence ($table_name, @pks) {\n  return $table_name . '_' . join('_',@pks) . '_' . 'seq';\n}\n\nmethod raw_source_name () {\n  my $base = $self->source_name;\n  confess \"Can't generate raw source name for ${\\$self->name} when we don't have a source_name\"\n    unless $base;\n  return 'Raw::'.$base;\n}\n\nmethod raw_table_name () {\n  return '_'.$self->name;\n}\n\nmethod add_columns (@args) {\n  my $ret = $self->next::method(@args);\n  $_->{originally_defined_in} ||= $self->name for values %{$self->_columns};\n  return $ret;\n}\n\nmethod add_relationship ($name, $f_source, $cond, $attrs) {\n  $self->next::method(\n    $name, $f_source, $cond,\n    { originally_defined_in => $self->name, %{$attrs||{}}, }\n  );\n}\n\nBEGIN {\n\n\n  sub argify {\n    my @names = @_;\n    map '_' . $_, @names;\n  }\n\n  sub qualify_with {\n    my $source = shift;\n    my @names  = @_;\n    my $name   = blessed($source) ? $source->name : $source;\n    map join( '.', $name, $_ ), @names;\n  }\n\n  sub body_cols {\n    my $source = shift;\n    my %pk;\n    @pk{ $source->primary_columns } = ();\n    map +{ %{ $source->column_info($_) }, name => $_ },\n      grep !exists $pk{$_}, $source->columns;\n  }\n\n  sub pk_cols {\n    my $source = shift;\n    map +{ %{ $source->column_info($_) }, name => $_ },\n      $source->primary_columns;\n  }\n\n  sub names_of { my @cols = @_; map $_->{name}, @cols }\n\n  sub function_body {\n    my ( $name, $args, $body_parts ) = @_;\n    my $arglist =\n      join( ', ', map \"_${\\$_->{name}} ${\\uc($_->{data_type})}\", @$args );\n    my $body = join( \"\\n\", '', map \"          $_;\", @$body_parts );\n    return strip tt q{\n      CREATE OR REPLACE FUNCTION [% name %]\n        ([% arglist %])\n        RETURNS VOID AS $function$\n        BEGIN\n          [%- body %]\n        END;\n      $function$ LANGUAGE plpgsql;\n    };\n  }\n}\n\nBEGIN {\n\n  sub arg_hash {\n    my $source = shift;\n    map +( $_ => \\( argify $_) ), names_of body_cols $source;\n  }\n\n  sub rule_body {\n    my ( $on, $to, $oldlist, $newlist ) = @_;\n    my $arglist = join( ', ',\n      ( qualify_with 'OLD', names_of @$oldlist ),\n      ( qualify_with 'NEW', names_of @$newlist ),\n    );\n    $to = $to->name if blessed($to);\n    return strip tt q{\n      CREATE RULE _[% to %]_[% on %]_rule AS\n        ON [% on | upper %] TO [% to %]\n        DO INSTEAD (\n          SELECT [% to %]_[% on %]([% arglist %])\n        );\n    };\n  }\n}\n\nmethod root_table () {\n  $self->parent_source\n    ? $self->parent_source->root_table\n    : $self->schema->source($self->raw_source_name)\n}\n\nmethod view_definition () {\n  my $schema = $self->schema;\n  confess \"Can't generate view without connected schema, sorry\"\n    unless $schema && $schema->storage;\n  my $sqla = $schema->storage->sql_maker;\n  my $table = $self->schema->source($self->raw_source_name);\n  my $super_view = $self->parent_source;\n  my @all_parents = my @other_parents = @{$self->additional_parents||[]};\n  push(@all_parents, $super_view) if defined($super_view);\n  my @sources = ($table, @all_parents);\n  my @body_cols = map body_cols($_), @sources;\n\n  my %body_cols = map { $_->{name} => $_ } @body_cols;\n  @body_cols =\n    map { $body_cols{$_} }\n    grep { defined $body_cols{$_} }\n    $self->columns;\n  my @pk_cols = pk_cols $self;\n\n  for my $pk_col (@pk_cols) {\n    $self->columns_info->{ $pk_col->{name} }->{sequence} =\n      $self->root_table->name . '_id_seq';\n  }\n\n\n  my $am_root = !($super_view || @other_parents);\n\n  my $select = $sqla->select(\n    ($am_root\n      ? ($table->name)\n      : ([   \n           { $table->name => $table->name },\n           map {\n             my $parent = $_;\n             [ \n               { $parent->name => $parent->name },\n               { map +(qualify_with($parent, $_), qualify_with($table, $_)),\n                   names_of @pk_cols }\n             ]\n           } @all_parents\n         ])\n      ),\n    [ (qualify_with $table, names_of @pk_cols), names_of @body_cols ],\n  ).';';\n\n  my ($now, @next) = grep defined, $super_view, $table, @other_parents;\n\n\n  my $insert_func =\n    function_body\n      $self->name.'_insert',\n      \\@body_cols,\n      [\n        $sqla->insert( \n          $now->name,\n          { arg_hash $now },\n        ),\n        (map {\n          $sqla->insert( \n            $_->name,\n            {\n              (arg_hash $_),\n              id => \\\"currval('${\\$self->root_table->name}_id_seq')\",\n            }\n          )\n        } @next)\n      ];\n\n  my $pk_where = { \n    map +($_ => \\\"= ${\\argify $_}\"), names_of @pk_cols\n  };\n\n\n  my $update_func =\n    function_body\n      $self->name.'_update',\n      [ @pk_cols, @body_cols ],\n      [ map $sqla->update(\n          $_->name, \n          { arg_hash $_ }, \n          $pk_where,\n        ), @sources\n      ];\n\n\n  my $delete_func =\n    function_body\n      $self->name.'_delete',\n      [ @pk_cols ],\n      [ map $sqla->delete($_->name, $pk_where), @sources ];\n\n  my @rules = (\n    (rule_body insert => $self, [], \\@body_cols),\n    (rule_body update => $self, \\@pk_cols, \\@body_cols),\n    (rule_body delete => $self, \\@pk_cols, []),\n  );\n  return join(\"\\n\\n\", $select, $insert_func, $update_func, $delete_func, @rules);\n}\n\n1",
      "file" : "/var/tmp/arv_F_verg/DBIx-Class-ResultSource-MultipleTableInheritance-0.01/lib/DBIx/Class/ResultSource/MultipleTableInheritance.pm",
      "package" : "DBIx::Class::ResultSource::MultipleTableInheritance"
   }
]
