[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method read_stdin ($line) {\n    chomp $line;\n    my @args = split /\\s+/, $line;\n    return $->run( @args );\n}\n\nmethod run ($before, $after, $ref) {\n    my $is_new_head = $before =~ /^0{40}/;\n    my $is_delete = $after =~ /^0{40}/;\n\n    $before  = $before ne '0000000000000000000000000000000000000000' \n                ? qx(git rev-parse $before) \n                : undef;\n\n    $after   = $after ne '0000000000000000000000000000000000000000' \n                ? qx(git rev-parse $after) \n                : undef;\n\n    chomp($before) if $before;\n    chomp($after) if $after;\n\n    my ($ref_type,$ref_name) = ( $ref =~ m{refs/([^/]+)/([^/]+)} );\n    my $repo = getcwd;\n    my @commits = $->get_commits($before,$after);\n    return {\n        before     => $before,\n        after      => $after,\n        repository => $repo,\n        ref        => $ref_name,\n        ref_type   => $ref_type,\n        ( $is_new_head \n            ? (new_head => $is_new_head)\n            : () ),\n        ( $is_delete \n            ? (delete => $is_delete)\n            : () ),\n        commits    => \\@commits,\n    };\n}\n\nmethod get_commits ($before,$after) {\n    my $log_string;\n\n    if( $before && $after ) {\n        $log_string = qx(git rev-list --pretty $before...$after);\n    }\n    elsif( $after ) {\n        $log_string = qx(git rev-list --pretty $after);\n    }\n\n    return ( ) unless $log_string;\n\n    my @lines = split /\\n/,$log_string;\n    my @commits = ();\n    my $buffer = '';\n    for( @lines ) {\n        if(/^commit\\s/ && $buffer ) {\n            push @commits,$buffer;\n            $buffer = '';\n        }\n        $buffer .= $_ . \"\\n\";\n    }\n    push @commits, $buffer;\n    return reverse map { \n                my @lines = split /\\n/,$_;\n                my $info = {  };\n                for my $line ( @lines ) {\n                    given($line) {\n                        when( m{^commit (.*)$}i ) { $info->{id} = $1; }\n                        when( m{^author:\\s+(.*?)\\s<(.*?)>}i ) { \n                                $info->{author} = { \n                                    name => $1,\n                                    email => $2\n                                };\n                            }\n                        when( m{^date:\\s+(.*)$}i ) {  $info->{date} = DateTime::Format::DateParse->parse_datetime( $1 ); }\n                        when( m{^merge: (\\w+)\\s+(\\w+)} ) { $info->{merge} = { parent1 => $1 , parent2 => $2 } }\n                        default {\n                            $info->{message} .= $line . \"\\n\";\n                        }\n                    }\n                }\n                $info;\n            } @commits;\n}\n\n1",
      "file" : "/var/tmp/arv_6nPGpm/Git-Hook-PostReceive-0.01/lib/Git/Hook/PostReceive.pm",
      "package" : "Git::Hook::PostReceive"
   }
]
