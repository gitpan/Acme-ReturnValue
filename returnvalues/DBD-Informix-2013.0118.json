[
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\tpackage DBD::Informix::Summary;\n\n\t$VERSION = \"2013.0118\";\n\t$VERSION = \"0.97002\" if ($VERSION =~ m%[:]VERSION[:]%);\n\n\t1;\n}",
      "file" : "/var/tmp/arv_Btnlcp/DBD-Informix-2013.0118/lib/DBD/Informix/Summary.pm",
      "package" : "DBD::Informix::Summary"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n    require Exporter;\n    require DynaLoader;\n    @ISA = qw(Exporter DynaLoader);\n    @EXPORT = qw(type_info_all);\n    use DBI qw(:sql_types);\n\n\tmy\n\t$VERSION = \"2013.0118\";\n\t$VERSION = \"2003.00\" if $VERSION =~ m/[:]VERSION[:]/;\n\n    $type_info_all = [\n        {\n            TYPE_NAME          =>  0,\n            DATA_TYPE          =>  1,\n            COLUMN_SIZE        =>  2,\n            LITERAL_PREFIX     =>  3,\n            LITERAL_SUFFIX     =>  4,\n            CREATE_PARAMS      =>  5,\n            NULLABLE           =>  6,\n            CASE_SENSITIVE     =>  7,\n            SEARCHABLE         =>  8,\n            UNSIGNED_ATTRIBUTE =>  9,\n            FIXED_PREC_SCALE   => 10,\n            AUTO_UNIQUE_VALUE  => 11,\n            LOCAL_TYPE_NAME    => 12,\n            MINIMUM_SCALE      => 13,\n            MAXIMUM_SCALE      => 14,\n            SQL_DATA_TYPE      => 15,\n            SQL_DATETIME_SUB   => 16,\n            NUM_PREC_RADIX     => 17,\n            INTERVAL_PRECISION => 18,\n        },\n        [ \"MULTISET\",                            -109,                          4,          \"'\",    \"'\",   \"'\",               1, 0, 2, 1, 0, 0, \"MULTISET\",                            undef, undef, -109,              undef, undef, undef ],\n        [ \"SET\",                                 -108,                          4,          \"'\",    \"'\",   \"'\",               1, 0, 2, 1, 0, 0, \"SET\",                                 undef, undef, -108,              undef, undef, undef ],\n        [ \"LIST\",                                -107,                          4,          \"'\",    \"'\",   \"'\",               1, 0, 2, 1, 0, 0, \"LIST\",                                undef, undef, -107,              undef, undef, undef ],\n        [ \"ROW\",                                 -105,                          4,          \"'\",    \"'\",   \"'\",               1, 0, 2, 1, 0, 0, \"ROW\",                                 undef, undef, -105,              undef, undef, undef ],\n        [ \"CLOB\",                                -103,                          2147483647, undef,  undef, undef,             1, 0, 0, 1, 0, 0, \"CLOB\",                                undef, undef, -103,              undef, undef, undef ],\n        [ \"BLOB\",                                -102,                          2147483647, undef,  undef, undef,             1, 0, 0, 1, 0, 0, \"BLOB\",                                undef, undef, -102,              undef, undef, undef ],\n        [ \"BOOLEAN\",                             SQL_BIT,                       1,          undef,  undef, undef,             1, 0, 2, 0, 0, 0, \"BOOLEAN\",                             0,     0,     SQL_BIT,           undef, 2,     undef ],\n        [ \"INT8\",                                -5,                            20,         undef,  undef, undef,             1, 0, 2, 0, 0, 0, \"INT8\",                                0,     0,     -5,                undef, 10,    undef ],\n        [ \"SERIAL8\",                             -5,                            20,         undef,  undef, undef,             0, 0, 2, 0, 0, 1, \"SERIAL8\",                             0,     0,     -5,                undef, 10,    undef ],\n        [ \"BYTE\",                                SQL_LONGVARBINARY,             2147483647, undef,  undef, undef,             1, 0, 0, 1, 0, 0, \"BYTE\",                                undef, undef, SQL_LONGVARBINARY, undef, undef, undef ],\n        [ \"TEXT\",                                SQL_LONGVARCHAR,               2147483647, \"'\",    \"'\",   undef,             1, 0, 0, 1, 0, 0, \"TEXT\",                                undef, undef, SQL_LONGVARCHAR,   undef, undef, undef ],\n        [ \"CHAR\",                                SQL_CHAR,                      32767,      \"'\",    \"'\",   \"length\",          1, 1, 3, 1, 0, 0, \"CHAR\",                                undef, undef, SQL_CHAR,          undef, undef, undef ],\n        [ \"DECIMAL\",                             SQL_DECIMAL,                   32,         undef,  undef, \"precision,scale\", 1, 0, 2, 0, 0, 0, \"DECIMAL\",                             0,     32,    SQL_DECIMAL,       undef, 10,    undef ],\n        [ \"MONEY\",                               SQL_DECIMAL,                   32,         undef,  undef, \"precision,scale\", 1, 0, 2, 0, 1, 0, \"MONEY\",                               0,     32,    SQL_DECIMAL,       undef, 10,    undef ],\n        [ \"INTEGER\",                             SQL_INTEGER,                   10,         undef,  undef, undef,             1, 0, 2, 0, 0, 0, \"INTEGER\",                             0,     0,     SQL_INTEGER,       undef, 10,    undef ],\n        [ \"SERIAL\",                              SQL_INTEGER,                   10,         undef,  undef, undef,             0, 0, 2, 0, 0, 1, \"SERIAL\",                              0,     0,     SQL_INTEGER,       undef, 10,    undef ],\n        [ \"SMALLINT\",                            SQL_SMALLINT,                  5,          undef,  undef, undef,             1, 0, 2, 0, 0, 0, \"SMALLINT\",                            0,     0,     SQL_SMALLINT,      undef, 10,    undef ],\n        [ \"SMALLFLOAT\",                          SQL_REAL,                      7,          undef,  undef, undef,             1, 0, 2, 0, 0, 0, \"SMALLFLOAT\",                          undef, undef, SQL_REAL,          undef, 10,    undef ],\n        [ \"FLOAT\",                               SQL_DOUBLE,                    15,         undef,  undef, undef,             1, 0, 2, 0, 0, 0, \"FLOAT\",                               undef, undef, SQL_DOUBLE,        undef, 10,    undef ],\n        [ \"VARCHAR\",                             SQL_VARCHAR,                   255,        \"'\",    \"'\",   \"max,length\",      1, 1, 3, 1, 0, 0, \"VARCHAR\",                             undef, undef, SQL_VARCHAR,       undef, undef, undef ],\n        [ \"LVARCHAR\",                            SQL_VARCHAR,                   2048,       \"'\",    \"'\",   undef,             1, 1, 3, 1, 0, 0, \"LVARCHAR\",                            undef, undef, SQL_VARCHAR,       undef, undef, undef ],\n        [ \"DATE\",                                SQL_TYPE_DATE,                 10,         \"DATETIME(\",  \") YEAR TO DAY\",  undef,             1, 0, 2, 1, 0, 0, \"DATE\",                                undef, undef, SQL_DATE,          1,     undef, undef ],\n        [ \"DATETIME HOUR TO SECOND\",             SQL_TYPE_TIME,                 8,          \"'\",    \"'\",   undef,             1, 0, 2, 1, 0, 0, \"DATETIME HOUR TO SECOND\",             0,     0,     SQL_DATE,          2,     undef, undef ],\n        [ \"DATETIME YEAR TO FRACTION(5)\",        SQL_TYPE_TIMESTAMP,            25,         \"'\",    \"'\",   undef,             1, 0, 2, 1, 0, 0, \"DATETIME YEAR TO FRACTION(5)\",        5,     5,     SQL_DATE,          3,     undef, undef ],\n        [ \"INTERVAL YEAR(%d) TO YEAR\",           SQL_INTERVAL_YEAR,             9,          \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL YEAR(%d) TO YEAR\",           0,     0,     SQL_TIME,          1,     undef, 9     ],\n        [ \"INTERVAL MONTH(%d) TO MONTH\",         SQL_INTERVAL_MONTH,            9,          \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL MONTH(%d) TO MONTH\",         0,     0,     SQL_TIME,          2,     undef, 9     ],\n        [ \"INTERVAL DAY(%d) TO DAY\",             SQL_INTERVAL_DAY,              9,          \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL DAY(%d) TO DAY\",             0,     0,     SQL_TIME,          3,     undef, 9     ],\n        [ \"INTERVAL HOUR(%d) TO HOUR\",           SQL_INTERVAL_HOUR,             9,          \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL HOUR(%d) TO HOUR\",           0,     0,     SQL_TIME,          4,     undef, 9     ],\n        [ \"INTERVAL MINUTE(%d) TO MINUTE\",       SQL_INTERVAL_MINUTE,           9,          \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL MINUTE(%d) TO MINUTE\",       0,     0,     SQL_TIME,          5,     undef, 9     ],\n        [ \"INTERVAL SECOND(%d) TO SECOND\",       SQL_INTERVAL_SECOND,           9,          \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL SECOND(%d) TO SECOND\",       0,     0,     SQL_TIME,          6,     undef, 9     ],\n        [ \"INTERVAL SECOND(%d) TO FRACTION(%d)\", SQL_INTERVAL_SECOND,           15,         \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL SECOND(%d) TO FRACTION(%d)\", 5,     5,     SQL_TIME,          6,     undef, 9     ],\n        [ \"INTERVAL FRACTION TO FRACTION(%d)\",   SQL_INTERVAL_SECOND,           6,          \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL FRACTION TO FRACTION(%d)\",   5,     5,     SQL_TIME,          6,     undef, 0     ],\n        [ \"INTERVAL YEAR(%d) TO MONTH\",          SQL_INTERVAL_YEAR_TO_MONTH,    12,         \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL YEAR(%d) TO MONTH\",          0,     0,     SQL_TIME,          7,     undef, 9     ],\n        [ \"INTERVAL DAY(%d) TO HOUR\",            SQL_INTERVAL_DAY_TO_HOUR,      12,         \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL DAY(%d) TO HOUR\",            0,     0,     SQL_TIME,          8,     undef, 9     ],\n        [ \"INTERVAL DAY(%d) TO MINUTE\",          SQL_INTERVAL_DAY_TO_MINUTE,    15,         \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL DAY(%d) TO MINUTE\",          0,     0,     SQL_TIME,          9,     undef, 9     ],\n        [ \"INTERVAL DAY(%d) TO SECOND\",          SQL_INTERVAL_DAY_TO_SECOND,    18,         \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL DAY(%d) TO SECOND\",          0,     0,     SQL_TIME,          10,    undef, 9     ],\n        [ \"INTERVAL DAY(%d) TO FRACTION(%d)\",    SQL_INTERVAL_DAY_TO_SECOND,    24,         \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL DAY(%d) TO FRACTION(%d)\",    5,     5,     SQL_TIME,          10,    undef, 9     ],\n        [ \"INTERVAL HOUR(%d) TO MINUTE\",         SQL_INTERVAL_HOUR_TO_MINUTE,   12,         \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL HOUR(%d) TO MINUTE\",         0,     0,     SQL_TIME,          11,    undef, 9     ],\n        [ \"INTERVAL HOUR(%d) TO SECOND\",         SQL_INTERVAL_HOUR_TO_SECOND,   15,         \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL HOUR(%d) TO SECOND\",         0,     0,     SQL_TIME,          12,    undef, 9     ],\n        [ \"INTERVAL HOUR(%d) TO FRACTION(%d)\",   SQL_INTERVAL_HOUR_TO_SECOND,   21,         \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL HOUR(%d) TO FRACTION(%d)\",   5,     5,     SQL_TIME,          12,    undef, 9     ],\n        [ \"INTERVAL MINUTE(%d) TO SECOND\",       SQL_INTERVAL_MINUTE_TO_SECOND, 12,         \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL MINUTE(%d) TO SECOND\",       0,     0,     SQL_TIME,          13,    undef, 9     ],\n        [ \"INTERVAL MINUTE(%d) TO FRACTION(%d)\", SQL_INTERVAL_MINUTE_TO_SECOND, 18,         \"'\",    \"'\",   \"precision\",       1, 0, 2, 0, 0, 0, \"INTERVAL MINUTE(%d) TO FRACTION(%d)\", 5,     5,     SQL_TIME,          13,    undef, 9     ],\n    ];\n\n    1;\n}",
      "file" : "/var/tmp/arv_Btnlcp/DBD-Informix-2013.0118/lib/DBD/Informix/TypeInfo.pm",
      "package" : "DBD::Informix::TypeInfo"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\tpackage DBD::Informix::Configure;\n\n\trequire Exporter;\n\t@ISA = qw(Exporter);\n\t@EXPORT = qw(find_informixdir_and_esql get_esqlc_version map_informix_lib_names);\n\n\t$VERSION = \"2013.0118\";\n\t$VERSION = \"0.97002\" if ($VERSION =~ m%[:]VERSION[:]%);\n\n\tuse strict;\n\tuse Config;\n\tuse DBI;\n\n\tsub find_informixdir_and_esql\n\t{\n\t\tmy ($NTConfiguration) = @_;\n\t\tmy ($esql, $ID);\n\t\tif ($NTConfiguration)\n\t\t{\n\t\t\tmy ($p);\n\t\t\tforeach $p (split( /;/, $ENV{PATH}))\n\t\t\t{\n\t\t\t\tif (-x \"$p/ESQL.EXE\")\n\t\t\t\t{\n\t\t\t\t\t$esql = \"$p\\\\ESQL.EXE\"; \n\t\t\t\t\t$p  =~ s%[/\\\\]BIN%%i;\n\t\t\t\t\t$ID = $p;\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t\t&did_not_read('No executable ESQL/C compiler found in $PATH')\n\t\t\t\tunless defined $esql;\n\t\t\tif ($esql =~ /\\s/o)\n\t\t\t{\n\t\t\t\twarn \"Path to ESQL/C compiler ($esql) contains white space\";\n\t\t\t\tif (defined($ENV{INFORMIXDIR}))\n\t\t\t\t{\n\t\t\t\t\t$ID = $ENV{INFORMIXDIR};\n\t\t\t\t\tdie 'Value of %INFORMIXDIR% ', \"($ID) also contains spaces\"\n\t\t\t\t\t\tif ($ID =~ /\\s/o);\n\t\t\t\t\tmy $p = \"$ID/BIN/\";\n\t\t\t\t\tif (-x \"$p/ESQL.EXE\")\n\t\t\t\t\t{\n\t\t\t\t\t\twarn 'Also found ESQL/C compiler via %INFORMIXDIR% - without spaces';\n\t\t\t\t\t\t$esql = \"$p\\\\ESQL.EXE\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$ID = $ENV{INFORMIXDIR};\n\t\t\t&did_not_read('$INFORMIXDIR is not set') unless ($ID);\n\t\t\t$esql = $ENV{ESQL};\n\t\t\t$esql = \"esql\" unless $esql;\n\t\t\tif ($esql =~ m%/%)\n\t\t\t{\n\t\t\t\t&did_not_read(\"No executable ESQL/C compiler $esql\")\n\t\t\t\t\tunless (-x $esql);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t&did_not_read(\"No executable ESQL/C compiler $ID/bin/$esql\")\n\t\t\t\t\tunless (-x \"$ID/bin/$esql\");\n\t\t\t}\n\t\t\t&did_not_read('$INFORMIXDIR/bin is not in $PATH')\n\t\t\t\tunless ($ENV{PATH} =~ m%:\\Q$ID\\E/bin:% ||\n\t\t\t\t\t\t$ENV{PATH} =~ m%^\\Q$ID\\E/bin:% ||\n\t\t\t\t\t\t$ENV{PATH} =~ m%:\\Q$ID\\E/bin$%);\n\t\t}\n\t\tprint \"Using INFORMIXDIR=$ID and ESQL/C compiler $esql\\n\";\n\t\treturn $ID, $esql;\n\t}\n\n\tsub get_esqlc_version\n\t{\n\t\tmy ($esql) = @_;\n\t\tmy ($infv, $vers);\n\n\t\topen(ESQL, \"$esql -V|\") || die;\n\t\twhile (<ESQL>)\n\t\t{\n\t\t\t$infv = $_ if (m%Informix.* Version%i);\n\t\t}\n\t\tdie \"Failed to read any Informix version from 'esql -V'\\n\"\n\t\t\tunless defined $infv;\n\t\tclose ESQL;\n\n\t\tchomp($infv);\n\t\t$infv =~ s/\\s+$//;\t\n\t\t$infv =~ s/\\s+/ /g;\t\n\t\t$vers = $infv;\n\t\t$vers =~ s/.*INFORMIX-\\w+ Version\\s+(\\d+[.]\\d+).*/$1/i;\n\t\tdie \"Unexpected message from esql script -- $infv\\n\"\n\t\t\tunless ($vers =~ /^\\d+[.]\\d+$/);\n\t\t$vers =~ s/^([0-9])\\./$1/;\n\n\t\treturn $infv, $vers;\n\t}\n\n\n\tsub map_informix_lib_names\n\t{\n\t\tmy @i_libs = @_;\n\t\tmy @o_libs = ();\n\t\tmy $ixd = $ENV{INFORMIXDIR};\n\t\tmy @ixlibdirs = ();\n\n\t\tforeach my $arg (@i_libs)\n\t\t{\n\t\t\tif ($arg =~ m%^-L$ixd/%o)\n\t\t\t{\n\t\t\t\tpush @o_libs, $arg;\n\t\t\t\t$arg =~ s%-L%%;\n\t\t\t\tpush @ixlibdirs, $arg;\n\t\t\t}\n\t\t\telsif ($arg =~ m%^-l.+%o)\n\t\t\t{\n\t\t\t\tpush @o_libs, &map_library($arg, @ixlibdirs);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpush @o_libs, $arg;\n\t\t\t}\n\t\t}\n\n\t\t@o_libs;\n\t}\n\n\tsub map_library\n\t{\n\t\tmy ($lib, @libdirs) = @_;\n\t\tmy $ar_ext = $Config{lib_ext};\t\n\t\tmy $dl_ext = \".$Config{dlext}\";\t\n\t\tmy $so_ext = \".$Config{so}\";\t\n\t\tmy $stub = $lib;\n\t\t$stub =~ s/-l//;\n\t\t$stub = \"lib$stub\";\n\t\tforeach my $dir (@libdirs)\n\t\t{\n\t\t\tforeach my $ext ($so_ext, $dl_ext, $ar_ext)\n\t\t\t{\n\t\t\t\tmy $path = \"$dir/$stub$ext\";\n\t\t\t\tif (-f $path)\n\t\t\t\t{\n\t\t\t\t\tprint \"\\t$0: map $lib to $path\\n\" if $ENV{DBD_INFORMIX_DEBUG_LIBMAP};\n\t\t\t\t\treturn $path;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $lib;\n\t}\n\n\tsub did_not_read\n\t{\n\t\tdie \"\\n*** You didn't read the README file!\\n@_\\n\\n\";\n\t}\n\n\t1;\n}",
      "file" : "/var/tmp/arv_Btnlcp/DBD-Informix-2013.0118/lib/DBD/Informix/Configure.pm",
      "package" : "DBD::Informix::Configure"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\tpackage DBD::Informix::TechSupport;\n\n\trequire Exporter;\n\t@ISA = qw(Exporter);\n\t@EXPORT = qw(print_versions bug_report it_works);\n\n\t$VERSION = \"2013.0118\";\n\t$VERSION = \"0.97002\" if ($VERSION =~ m%[:]VERSION[:]%);\n\n\tuse strict;\n\tuse Config;\n\tuse DBI;\n\tuse DBD::Informix::Configure;\n\tuse DBD::Informix::TestHarness;\n\n\tsub print_versions\n\t{\n\t\tmy ($items) = @_;\n\t\t$items = \"Perl DBI DBD::Informix ESQL/C\" if ! defined($items) || $items eq \"\";\n\n\t\tmy $drh = DBI->install_driver('Informix');\n\t\tprint \"Perl Version $]\\n\" if ($items =~ m%\\bperl\\b%i);\n\t\tprint \"DBI Version $DBI::VERSION\\n\" if ($items =~ m%\\bDBI\\b%i);\n\t\tprint \"DBD::Informix Version $drh->{Version}\\n\" if ($items =~ m%\\bDBD::Informix\\b%i);\n\t\tprint \"$drh->{ix_ProductName}\\n\" if ($items =~ m%\\bESQL/C\\b%i);\n\t}\n\n\n\tsub bug_report\n\t{\n\t\tmy ($opt, @tests) = @_;\n\n\t\t$| = 1;\n\n\t\tmy ($id, $name, $gid, @rgrps, $egid, @egrps, $pad);\n\t\t$name = getpwuid($<);\n\t\t$id = \"uid=$<($name)\";\n\t\t@rgrps = split / /, $(;\n\t\t$gid = $rgrps[0];\n\t\tshift @rgrps;\n\t\t$name = getgrgid($gid);\n\t\t$id .= \" gid=$gid($name)\";\n\t\tif ($< != $>)\n\t\t{\n\t\t\t$name = getpwuid($>);\n\t\t\t$id .= \" euid=$>($name)\";\n\t\t}\n\t\t@egrps = split / /, $);\n\t\t$egid = $egrps[0];\n\t\tif ($egid != $gid)\n\t\t{\n\t\t\t$name = getgrgid($egid);\n\t\t\t$id .= \" egid=$egid($name)\";\n\t\t}\n\t\t$pad = \" groups=\";\n\t\tforeach $gid (@rgrps)\n\t\t{\n\t\t\t$name = getgrgid($gid);\n\t\t\t$id .= \"$pad$gid($name)\";\n\t\t\t$pad = \",\";\n\t\t}\n\n\t\tsystem qq{\n\t\t\techo \"Command:   $0 $opt @tests\"\n\t\t\techo \"Date:      `date`\"\n\t\t\techo \"Machine:   `uname -n` (`uname -s -r`)\"\n\t\t\techo \"User:      $id\"\n\t\t\techo \"Directory: `pwd`\"\n\t\t\techo \"Umask:     `umask`\"\n\t\t\techo \"Terminal:  `tty 2>/dev/null`\"\n\t\t\t};\n\n\t\tprint \"\\n#\\n# Perl Version\\n\";\n\t\tsystem(\"$^X -V\");\n\n\t\tprint \"\\n#\\n# Informix Version\\n\";\n\t\tmy ($INFORMIXDIR, $ESQLC) = &find_informixdir_and_esql();\n\t\tmy ($esqlversion, $esqlvernum) = &get_esqlc_version($ESQLC);\n\t\tprint \"INFORMIXDIR = $INFORMIXDIR\\n\";\n\t\tprint \"ESQLC = $ESQLC\\n\";\n\t\tprint \"Version = $esqlversion\\n\";\n\n\t\tmy $dbmsversion;\n\t\t$dbmsversion = `$INFORMIXDIR/bin/onstat   -V 2>/dev/null`;\n\t\t$dbmsversion = `$INFORMIXDIR/bin/tbstat   -V 2>/dev/null` unless $dbmsversion;\n\t\t$dbmsversion = `$INFORMIXDIR/bin/dbaccess -V 2>/dev/null` unless $dbmsversion;\n\t\t$dbmsversion = `$INFORMIXDIR/lib/sqlturbo -V 2>/dev/null` unless $dbmsversion;\n\t\t$dbmsversion = `$INFORMIXDIR/lib/sqlexec  -V 2>/dev/null` unless $dbmsversion;\n\t\t$dbmsversion = \"*** indeterminate ***\" unless $dbmsversion;\n\n\t\tchomp $dbmsversion;\n\t\t$dbmsversion =~ s/Software Serial Number.*//m;\n\t\tprint \"DBMS Version = $dbmsversion\\n\";\n\n\t\tuse vars qw($db1 $db2 $server1 $server2 $hosts);\n\t\t$db1 = $ENV{DBD_INFORMIX_DATABASE};\n\t\t$db2 = $ENV{DBD_INFORMIX_DATABASE2};\n\t\tif (defined $db1) { $server1 = ($db1 =~ s/.*@//); } else { $server1 = $ENV{INFORMIXSERVER}; }\n\t\tif (defined $db2) { $server2 = ($db2 =~ s/.*@//); } else { $server2 = $ENV{INFORMIXSERVER}; }\n\t\t$hosts = $ENV{INFORMIXSQLHOSTS};\n\t\t$hosts = \"$ENV{INFORMIXDIR}/etc/sqlhosts\" unless defined $hosts;\n\t\tif (open(HOSTS, \"<$hosts\"))\n\t\t{\n\t\t\tprint \"Informix Server Entries in sqlhosts file ($hosts)\\n\";\n\t\t\twhile (<HOSTS>)\n\t\t\t{\n\t\t\t\tprint if m /^($server1|$server2)\\s/;\n\t\t\t}\n\t\t\tclose HOSTS;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprint \"**** Unable to read sqlhosts file $hosts\\n\";\n\t\t}\n\n\t\tuse vars qw($var $val);\n\t\tprint \"\\n#\\n# Sorted Environment\\n\";\n\t\tfor $var (sort keys %ENV)\n\t\t{\n\t\t\t$val = $ENV{$var};\n\t\t\t$val = \"XXXXXXXX\" if ($var =~ m/^DBD_INFORMIX_PASSWORD[12]?$/o);\n\t\t\tprint \"$var=$val\\n\";\n\t\t}\n\t\tprint \"\\n# End of Configuration Report\\n\";\n\n\t\treturn 1 unless ($opt);\n\n\t\tif ($opt =~ m/^-?[abcdABCD]$/)\n\t\t{\n\t\t\tprint \"\\n#\\n# Redoing configuration\\n\";\n\t\t\texecute_command(\"[ ! -f Makefile ] || make realclean\", \"failed on preliminary cleanup\");\n\t\t\texecute_command(\"rm -f esql esqlvrsn.h esqlinfo.h\",    \"failed on preliminary cleanup\");\n\t\t\texecute_command(\"$^X Makefile.PL\", \"running on configuration\");\n\t\t\tif ($opt =~ m/^[bcdBCD]$/)\n\t\t\t{\n\t\t\t\tprint \"\\n#\\n# Redoing build\\n\";\n\t\t\t\texecute_command(\"make\", \"failed on build\");\n\t\t\t\tif ($opt =~ m/^[cdCD]$/)\n\t\t\t\t{\n\t\t\t\t\tprint \"\\n#\\n# Redoing general testing\\n\";\n\t\t\t\t\texecute_command(\"make test\", \"failed on general testing\");\n\t\t\t\t\tif ($opt =~ m/^[dD]$/ && $#tests >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tprint \"\\n#\\n# Doing selective testing\\n\";\n\t\t\t\t\t\texecute_command(\"sh test.one.sh @tests\", \"failed on selective tests\");\n\t\t\t\t\t\tif ($#tests == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprint \"\\n#\\n# Rerunning single test with debug fully enabled\\n\";\n\t\t\t\t\t\t\texecute_command(\"sh -c 'DBI_TRACE=9 sh test.one.sh @tests'\", \"failed on selective tests\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprint \"\\n# End of Bug Report\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprint STDERR \"Usage: $0 [A|B|C|D] [test cases...]\\n\";\n\t\t\treturn 0;\n\t\t}\n\n\t\t1;\n\t}\n\n\tsub execute_command\n\t{\n\t\tmy ($cmd, $msg) = @_;\n\t\tprint \"+ $cmd\\n\";\n\t\twarn $msg unless system($cmd) == 0;\n\t}\n\n\n\tsub it_works\n\t{\n\t\tmy ($sec,$min,$hour,$mday,$mon,$year) = gmtime(time);\n\t\tmy ($date) = sprintf \"%04d-%02d-%02d\", $year + 1900, $mon + 1, $mday;\n\t\tmy ($uname,$passwd,$uid,$gid,$quota,$comment,$gcos,$dir,$shell) = getpwuid $>;\n\n\n\t\tmy ($who) = \"$uname\\@$Config{myhostname}$Config{mydomain}\";\n\t\tif ($comment) \n\t\t{\n\t\t\t$who = \"$comment <$who>\";\n\t\t}\n\t\telsif ($gcos)\n\t\t{\n\t\t\t$who = \"$gcos <$who>\";\n\t\t}\n\n\t\tmy ($dbh) = &connect_to_primary(0);\n\n\t\tmy (%tags);\n\n\n\t\t$tags{DBD_INFORMIX} = \"$dbh->{Driver}->{Version}\";\n\t\t$tags{DBI} = \"$DBI::VERSION\";\n\t\t$tags{INFORMIX_ESQLC} = \"$dbh->{ix_ProductName}\";\n        my ($server) = ($dbh->{ix_InformixOnLine} == 0) ? \"SE\"\n                     : ($dbh->{ix_ServerVersion} < 600) ? \"OnLine\"\n                     : ($dbh->{ix_ServerVersion} < 730) ? \"ODS\"\n                     : ($dbh->{ix_ServerVersion} < 800) ? \"IDS\"\n                     : ($dbh->{ix_ServerVersion} < 900) ? \"XPS\"\n                     : ($dbh->{ix_ServerVersion} < 920) ? \"IUS\"\n                     :                                    \"IDS\"\n                     ;\n\t\t$tags{INFORMIX_SERVER} = sprintf \"%.2f (%s)\", ($dbh->{ix_ServerVersion}/100),\n\t\t\t\t\t\t\t\t\t\t$server;\n\t\t$tags{PERL} = \"$] @Config{qw(archname dlsrc)}\";\n\t\t$tags{SYSTEM} = \"@Config{qw(myuname)}\";\n\t\t$tags{SYS_COMPILER} = \"@Config{qw(cc gccversion)}\";\n\t\t$tags{SYS_LOADER} = \"$Config{ld}\";\n\t\t$tags{WHEN} = \"$date\";\n\t\t$tags{WHO} = \"$who\";\n\t\t$tags{Z_NOTES} = \"Optional Notes\";\n\n\t\tmy ($keylen) = (0);\n\t\tmy ($key, $tag);\n\n\t\tforeach $key (keys %tags)\n\t\t{\n\t\t\t$keylen = length($key) if (length($key) > $keylen);\n\t\t}\n\n\t\tmy ($fmt) = \"    <%s>%s %s </%s>\\n\";\n\n\t\tprint \"<WORKING_VERSION VERSION=\\\"1.00\\\">\\n\";\n\t\tfor $key (sort keys %tags)\n\t\t{\n\t\t\tprintf $fmt, $key, \" \" x ($keylen - length($key)), $tags{$key}, $key;\n\t\t}\n\t\tprint \"</WORKING_VERSION>\\n\";\n\n\t\t$dbh->disconnect;\n\t}\n\n\t1;\n}",
      "file" : "/var/tmp/arv_Btnlcp/DBD-Informix-2013.0118/lib/DBD/Informix/TechSupport.pm",
      "package" : "DBD::Informix::TechSupport"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\tpackage DBD::Informix::TestHarness;\n\trequire Exporter;\n\t@ISA = qw(Exporter);\n\t@EXPORT = qw(\n\t\tall_ok\n\t\tcleanup_database\n\t\tconnect_controllably\n\t\tconnect_to_test_database\n\t\tconnect_to_primary\n\t\tconnect_to_secondary\n\t\tconnect_to_tertiary\n\t\tget_date_as_string\n\t\tis_shared_memory_connection\n\t\tmemory_leak_test\n\t\tprimary_connection\n\t\tprint_dbinfo\n\t\tprint_sqlca\n        smart_blob_space_name\n\t\tsecondary_connection\n\t\tselect_zero_data\n\t\tset_verbosity\n\t\tstmt_comment\n\t\tstmt_err\n\t\tstmt_fail\n\t\tstmt_note\n\t\tstmt_ok\n\t\tstmt_nok\n\t\tstmt_counter\n\t\tstmt_retest\n\t\tstmt_test\n\t\tstmt_skip\n\t\ttest_for_ius\n\t\ttertiary_connection\n\t\tvalidate_unordered_unique_data\n\t\t);\n\n\tuse DBI;\n\tuse Carp;\n\tuse Config;\n\tuse strict;\n\n\trequire_version DBI 1.38;\n\n\tmy\n\t$VERSION = \"2013.0118\";\n\t$VERSION = \"0.97002\" if ($VERSION =~ m%[:]VERSION[:]%);\n\n\tsub print_connection\n\t{\n\t\tmy ($dbase, $user, $pass, $attr) = @_;\n\t\tmy ($xxpass) = (defined $pass) ? 'X' x length($pass) : \"\";\n\n\t\t&stmt_note(\"# DBI->connect('dbi:Informix:$dbase', '$user', '$xxpass');\\n\");\n\t\tif (defined $attr)\n\t\t{\n\t\t\tmy ($key);\n\t\t\tforeach $key (keys %$attr)\n\t\t\t{\n\t\t\t\t&stmt_note(\"#\\tConnect Attribute: $key => $$attr{$key}\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tsub primary_connection\n\t{\n\t\tmy ($dbname) = $ENV{DBD_INFORMIX_DATABASE};\n\t\tmy ($dbuser) = $ENV{DBD_INFORMIX_USERNAME};\n\t\tmy ($dbpass) = $ENV{DBD_INFORMIX_PASSWORD};\n\n\t\t$dbpass = \"\" unless ($dbpass);\n\t\t$dbuser = \"\" unless ($dbuser);\n\t\t$dbpass = \"\" unless ($dbuser && $dbpass);\n\t\t$dbuser = \"\" unless ($dbuser && $dbpass);\n\n\t\t$dbname = $ENV{DBI_DBNAME} if (!$dbname);\n\t\t$dbname = \"stores\" if (!$dbname);\n\t\treturn ($dbname, $dbuser, $dbpass);\n\t}\n\n\tsub secondary_connection\n\t{\n\t\tmy ($dbname) = $ENV{DBD_INFORMIX_DATABASE2};\n\t\tmy ($dbuser) = $ENV{DBD_INFORMIX_USERNAME2};\n\t\tmy ($dbpass) = $ENV{DBD_INFORMIX_PASSWORD2};\n\n\t\tif (!defined $dbname || !defined $dbuser || !defined $dbpass)\n\t\t{\n\t\t\tmy ($dbname1, $dbuser1, $dbpass1) = &primary_connection();\n\t\t\t$dbname = $dbname1 unless defined $dbname;\n\t\t\t$dbuser = $dbuser1 unless defined $dbuser;\n\t\t\t$dbpass = $dbpass1 unless defined $dbpass;\n\t\t}\n\n\t\t$dbpass = \"\" unless ($dbpass);\n\t\t$dbuser = \"\" unless ($dbuser);\n\t\t$dbpass = \"\" unless ($dbuser && $dbpass);\n\t\t$dbuser = \"\" unless ($dbuser && $dbpass);\n\n\t\treturn ($dbname, $dbuser, $dbpass);\n\t}\n\n\tsub tertiary_connection\n\t{\n\t\tmy ($dbname) = $ENV{DBD_INFORMIX_DATABASE3};\n\t\tmy ($dbuser) = $ENV{DBD_INFORMIX_USERNAME3};\n\t\tmy ($dbpass) = $ENV{DBD_INFORMIX_PASSWORD3};\n\n\t\tif (!defined $dbname || !defined $dbuser || !defined $dbpass)\n\t\t{\n\t\t\tmy ($dbname1, $dbuser1, $dbpass1) = &primary_connection();\n\t\t\t$dbname = $dbname1 unless defined $dbname;\n\t\t\t$dbuser = $dbuser1 unless defined $dbuser;\n\t\t\t$dbpass = $dbpass1 unless defined $dbpass;\n\t\t}\n\n\t\t$dbpass = \"\" unless ($dbpass);\n\t\t$dbuser = \"\" unless ($dbuser);\n\t\t$dbpass = \"\" unless ($dbuser && $dbpass);\n\t\t$dbuser = \"\" unless ($dbuser && $dbpass);\n\n\t\treturn ($dbname, $dbuser, $dbpass);\n\t}\n\n\tsub connect_to_test_database\n\t{\n\t\tmy ($attr) = @_;\n\t\tconnect_to_primary(1, $attr);\n\t}\n\n\tsub connect_to_primary\n\t{\n\t\tmy ($verbose, $attr) = @_;\n\t\tconnect_controllably($verbose, $attr, \\&primary_connection);\n\t}\n\n\tsub connect_to_secondary\n\t{\n\t\tmy ($verbose, $attr) = @_;\n\t\tconnect_controllably($verbose, $attr, \\&secondary_connection);\n\t}\n\n\tsub connect_to_tertiary\n\t{\n\t\tmy ($verbose, $attr) = @_;\n\t\tconnect_controllably($verbose, $attr, \\&tertiary_connection);\n\t}\n\n\tsub connect_controllably\n\t{\n\t\tmy ($verbose, $attr, $func) = @_;\n\t\tmy ($dbname, $dbuser, $dbpass) = &$func();\n\n\t\t${$attr}{ChopBlanks} = 1 unless defined ${$attr}{ChopBlanks};\n\t\t&print_connection($dbname, $dbuser, $dbpass, $attr)\n\t\t\tif ($verbose);\n\n\t\tmy ($dbh) = DBI->connect(\"dbi:Informix:$dbname\", $dbuser, $dbpass, $attr);\n\n\t\t&stmt_fail() unless (defined $dbh);\n\n\t\t$dbh;\n\t}\n\n\tsub get_date_as_string\n\t{\n\t\tmy ($dbh, $mm, $dd, $yyyy) = @_;\n\t\tmy ($sth, $sel1, @row);\n\n\t\t$dd = 10 unless defined $dd;\n\t\t$mm = 20 unless defined $mm;\n\t\t$yyyy = 1930 unless defined $yyyy;\n\t\t$sel1 = qq% SELECT MDY($mm,$dd,$yyyy) || '', MDY($mm,$dd,$yyyy) FROM \"informix\".SysTables WHERE Tabid = 1%;\n\t\t(&stmt_nok(), return \"$yyyy-$mm-$dd\") unless $sth = $dbh->prepare($sel1);\n\t\t(&stmt_nok(), return \"$yyyy-$mm-$dd\") unless $sth->execute;\n\t\t(&stmt_nok(), return \"$yyyy-$mm-$dd\") unless @row = $sth->fetchrow_array;\n\t\t(&stmt_nok(), return \"$yyyy-$mm-$dd\") unless $sth->finish;\n\t\t&stmt_ok(0);\n\t\treturn @row;\n\t}\n\n\tsub print_dbinfo\n\t{\n\t\tmy ($dbh) = @_;\n\t\tprint  \"# Database Information\\n\";\n\t\tprintf \"#     Database Name:           %s\\n\", $dbh->{Name};\n\t\tprintf \"#     DBMS Version:            %d\\n\", $dbh->{ix_ServerVersion};\n\t\tprintf \"#     AutoCommit:              %d\\n\", $dbh->{AutoCommit};\n\t\tprintf \"#     PrintError:              %d\\n\", $dbh->{PrintError};\n\t\tprintf \"#     RaiseError:              %d\\n\", $dbh->{RaiseError};\n\t\tprintf \"#     Informix-OnLine:         %d\\n\", $dbh->{ix_InformixOnLine};\n\t\tprintf \"#     Logged Database:         %d\\n\", $dbh->{ix_LoggedDatabase};\n\t\tprintf \"#     Mode ANSI Database:      %d\\n\", $dbh->{ix_ModeAnsiDatabase};\n\t\tprintf \"#     Transaction Active:      %d\\n\", $dbh->{ix_InTransaction};\n\t\tprint  \"#\\n\";\n\t}\n\n\tsub print_sqlca\n\t{\n\t\tmy ($sth) = @_;\n\t\tprint \"# Testing SQLCA handling\\n\";\n\t\tprint \"#     SQLCA.SQLCODE    = $sth->{ix_sqlcode}\\n\";\n\t\tprint \"#     SQLCA.SQLERRM    = '$sth->{ix_sqlerrm}'\\n\";\n\t\tprint \"#     SQLCA.SQLERRP    = '$sth->{ix_sqlerrp}'\\n\";\n\t\tmy ($i) = 0;\n\t\tmy @errd = @{$sth->{ix_sqlerrd}};\n\t\tfor ($i = 0; $i < @errd; $i++)\n\t\t{\n\t\t\tprint \"#     SQLCA.SQLERRD[$i] = $errd[$i]\\n\";\n\t\t}\n\t\tmy @warn = @{$sth->{ix_sqlwarn}};\n\t\tfor ($i = 0; $i < @warn; $i++)\n\t\t{\n\t\t\tprint \"#     SQLCA.SQLWARN[$i] = '$warn[$i]'\\n\";\n\t\t}\n\t\tprint \"# SQLSTATE             = '$DBI::state'\\n\";\n\t\tmy ($rows) = $sth->rows();\n\t\tprint \"# ROWS                 = $rows\\n\";\n\t}\n\n\tmy $test_counter = 0;\n\tmy $fail_counter = 0;\n\n\tsub stmt_err\n\t{\n\t\tmy ($str) = @_;\n\t\tmy ($err, $state);\n\t\t$str = \"Error Message\" unless ($str);\n\t\t$err = (defined $DBI::errstr) ? $DBI::errstr : \"<<no error string>>\";\n\t\t$state = (defined $DBI::state) ? $DBI::state : \"<<no state string>>\";\n\t\t$str .= \":\\n${err}\\nSQLSTATE = ${state}\\n\";\n\t\t$str =~ s/^/# /gm;\n\t\t&stmt_note($str);\n\t}\n\n\tsub stmt_skip\n\t{\n\t\tmy ($reason) = @_;\n\t\t$test_counter++;\n\t\t&stmt_note(\"ok $test_counter # $reason\\n\");\n\t}\n\n\tsub stmt_ok\n\t{\n\t\tmy ($warn) = @_;\n\t\t$test_counter++;\n\t\t&stmt_note(\"ok $test_counter\\n\");\n\t\t&stmt_err(\"Warning Message\") if ($warn);\n\t}\n\n\tsub stmt_nok\n\t{\n\t\tmy ($warn) = @_;\n\t\t&stmt_note($warn) if ($warn);\n\t\t$test_counter++;\n\t\t$fail_counter++;\n\t\t&stmt_note(\"not ok $test_counter\\n\");\n\t}\n\n\tsub stmt_fail\n\t{\n\t\tmy ($warn) = @_;\n\t\t&stmt_nok($warn);\n\t\t&stmt_err(\"Error Message\");\n\t\tconfess \"!! Terminating Test !!\\n\";\n\t}\n\n\tsub stmt_counter\n\t{\n\t\treturn $test_counter;\n\t}\n\n\tsub all_ok\n\t{\n\t\t&stmt_note(\"# *** Testing of DBD::Informix complete ***\\n\");\n\t\tif ($fail_counter == 0)\n\t\t{\n\t\t\t&stmt_note(\"# ***     You appear to be normal!      ***\\n\");\n\t\t\texit(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t&stmt_note(\"# !!!!!! There appear to be problems !!!!!!\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tsub stmt_comment\n\t{\n\t\tmy($str) = @_;\n\t\t$str =~ s/^[^#]/# $&/gmo;\n\t\t$str =~ s/^$/#/gmo;\n\t\tchomp $str;\n\t\tstmt_note(\"$str\\n\");\n\t}\n\n\tsub stmt_note\n\t{\n\t\tprint STDOUT @_;\n\t}\n\n\tsub stmt_test\n\t{\n\t\tmy ($dbh, $stmt, $ok, $test) = @_;\n\t\t$test = \"Test\" unless $test;\n\t\t&stmt_comment(\"$test: do('$stmt'):\\n\");\n\t\tif ($dbh->do($stmt)) { &stmt_ok(0); }\n\t\telsif ($ok)          { &stmt_ok(1); }\n\t\telse                 { &stmt_nok(); }\n\t}\n\n\tsub stmt_retest\n\t{\n\t\tmy ($dbh, $stmt, $ok) = @_;\n\t\t&stmt_test($dbh, $stmt, $ok, \"Retest\");\n\t}\n\n\tsub select_zero_data\n\t{\n\t\tmy($dbh, $sql) = @_;\n\t\tmy($sth) = $dbh->prepare($sql);\n\t\t(&stmt_nok, return) unless $sth;\n\t\t(&stmt_nok, return) unless $sth->execute;\n\t\tmy $ref;\n\t\twhile ($ref = $sth->fetchrow_arrayref)\n\t\t{\n\t\t\t&stmt_nok(\"Unexpected data returned from $sql: @$ref\\n\");\n\t\t\treturn;\n\t\t}\n\t\t&stmt_ok;\n\t}\n\n\tsub test_for_ius\n\t{\n\t\tmy ($dbase1, $user1, $pass1) = &primary_connection();\n\n\t\tmy $drh = DBI->install_driver('Informix');\n\t\tprint \"# Driver Information\\n\";\n\t\tprint \"#     Name:                  $drh->{Name}\\n\";\n\t\tprint \"#     Version:               $drh->{Version}\\n\";\n\t\tprint \"#     Product:               $drh->{ix_ProductName}\\n\";\n\t\tprint \"#     Product Version:       $drh->{ix_ProductVersion}\\n\";\n\t\tmy ($ev) = $drh->{ix_ProductVersion};\n\t\tif ($ev < 900 && !($ev >= 290 && $ev < 400))\n\t\t{\n\t\t\t&stmt_note(\"1..0 # Skip: IUS data types are not supported by $drh->{ix_ProductName}\\n\");\n\t\t\texit(0);\n\t\t}\n\n\t\tmy ($dbh, $sth, $numtabs);\n\t\t&stmt_note(\"# Connect to: $dbase1\\n\");\n\t\t&stmt_fail() unless ($dbh = DBI->connect(\"DBI:Informix:$dbase1\", $user1, $pass1));\n\t\t&stmt_fail() unless ($sth = $dbh->prepare(q%\n\t\t\tSELECT COUNT(*) FROM \"informix\".SysTables WHERE TabID < 100\n\t\t\t%));\n\t\t&stmt_fail() unless ($sth->execute);\n\t\t&stmt_fail() unless (($numtabs) = $sth->fetchrow_array);\n\t\tif ($numtabs < 40)\n\t\t{\n\t\t\t&stmt_note(\"1..0 # Skip IUS data types are not supported by database server.\\n\");\n\t\t\t$dbh->disconnect;\n\t\t\texit(0);\n\t\t}\n\t\t&stmt_note(\"# IUS data types can be tested!\\n\");\n\t\treturn $dbh;\n\t}\n\n\tsub cleanup_database\n\t{\n\t\tmy ($dbh) = @_;\n\t\tmy ($old_p) = $dbh->{PrintError};\n\t\tmy ($old_r) = $dbh->{RaiseError};\n\t\tmy ($type);\n\t\tmy ($sth);\n\n\t\t$dbh->{PrintError} = 0;\n\t\t$dbh->{RaiseError} = 0;\n\n\t\tmy(%map) = ('P' => 'SYNONYM', 'S' => 'SYNONYM', 'V' => 'VIEW', 'T' => 'TABLE');\n\t\tforeach $type ('P', 'S', 'V', 'T')\t\n\t\t{\n\t\t\tmy $kw = $map{$type};\n\t\t\t$sth = $dbh->prepare(qq%SELECT owner, tabname FROM \"informix\".systables WHERE tabname MATCHES  'dbd_ix_*' AND tabtype = '$type'%);\n\t\t\t$sth->execute;\n\t\t\tmy($owner, $name);\n\t\t\t$sth->bind_col(1, \\$owner);\n\t\t\t$sth->bind_col(2, \\$name);\n\t\t\twhile ($sth->fetchrow_array)\n\t\t\t{\n\t\t\t\tmy($sql) = qq%DROP $kw \"$owner\".$name%;\n\t\t\t\t&stmt_note(\"# $sql\\n\");\n\t\t\t\t$dbh->do($sql);\n\t\t\t}\n\t\t}\n\n\t\t$sth = $dbh->prepare(q%SELECT owner, procname FROM \"informix\".sysprocedures WHERE name MATCHES 'dbd_ix_*'%);\n\t\tif ($sth)\n\t\t{\n\t\t\t$sth->execute;\n\t\t\tmy($owner, $name);\n\t\t\t$sth->bind_col(1, \\$owner);\n\t\t\t$sth->bind_col(2, \\$name);\n\t\t\twhile ($sth->fetchrow_array)\n\t\t\t{\n\t\t\t\tmy($sql) = qq%DROP PROCEDURE \"$owner\".$name%;\n\t\t\t\t&stmt_note(\"# $sql\\n\");\n\t\t\t\t$dbh->do($sql);\n\t\t\t}\n\t\t}\n\n\t\t$sth = $dbh->prepare(q%SELECT mode, owner, name FROM \"informix\".sysxtdtypes WHERE name MATCHES 'dbd_ix_*'%);\n\t\tif ($sth)\n\t\t{\n\t\t\t$sth->execute;\n\t\t\tmy($mode, $owner, $name);\n\t\t\t$sth->bind_col(1, \\$mode);\n\t\t\t$sth->bind_col(2, \\$owner);\n\t\t\t$sth->bind_col(3, \\$name);\n\t\t\twhile ($sth->fetchrow_array)\n\t\t\t{\n\t\t\t\tmy($sql);\n\t\t\t\t$sql = qq%DROP ROW TYPE \"$owner\".$name RESTRICT%\n\t\t\t\t\tif ($mode eq \"R\");\t\n\t\t\t\t$sql = qq%DROP     TYPE \"$owner\".$name RESTRICT%\n\t\t\t\t\tif ($mode eq \"D\");\t\n\t\t\t\t&stmt_note(\"# $sql\\n\");\n\t\t\t\t$dbh->do($sql);\n\t\t\t}\n\t\t}\n\n\t\t$dbh->{PrintError} = $old_p;\n\t\t$dbh->{RaiseError} = $old_r;\n\t\t1;\n\t}\n\n\tsub is_shared_memory_connection\n\t{\n\t\treturn 0 if $Config{archname} =~ /MSWin32/;\n\t\tmy($dbs) = @_;\n\t\tmy ($server) = $dbs;\n\t\tif ($dbs !~ /.*@/)\n\t\t{\n\t\t\tmy ($ixsrvr) = $ENV{INFORMIXSERVER};\n\t\t\t$ixsrvr = 'unknown server name' unless $ixsrvr;\n\t\t\t$server = \"$dbs\\@$ixsrvr\";\n\t\t}\n\t\t$server =~ s/.*@//;\n\t\tmy($sqlhosts) = $ENV{INFORMIXSQLHOSTS};\n\t\t$sqlhosts = \"$ENV{INFORMIXDIR}/etc/sqlhosts\" unless $sqlhosts;\n\t\tmy($ent) = qx(grep \"^$server\\[ \t][ \t]*\" $sqlhosts 2>/dev/null);\n\t\t$ent = 'server protocol host service' unless $ent;\n\t\tmy(@ent) = split ' ', $ent;\n\t\treturn (($ent[1] =~ /o[ln]ipcshm/) ? 1 : 0);\n\t}\n\n\tsub memory_leak_test\n\t{\n\t\tmy($sub, $nap, $pscmd) = @_;\n\t\tuse vars qw($ppid $cpid $nap);\n\n\t\t$|=1;\n\t\tprint \"# Bug is fixed if size of process stabilizes (fairly quickly!)\\n\";\n\t\t$ppid = $$;\n\t\t$nap  = 5 unless defined $nap;\n\t\t$pscmd = \"ps -lp\" unless defined $pscmd;\n\t\t$pscmd .= \" $ppid\";\n\n\t\t$cpid = fork();\n\t\tdie \"failed to fork\\n\" unless (defined $cpid);\n\t\tif ($cpid)\n\t\t{\n\t\t\tprint \"# Parent: $ppid, Child: $cpid\\n\";\n\t\t\t&$sub();\n\t\t\tsleep ($nap * 2);\n\t\t\tkill 15, $cpid;\n\t\t\texit(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsystem \"$pscmd | sed 's/^/# /'\";\n\t\t\tsleep $nap;\n\t\t\twhile (kill 0, $ppid)\n\t\t\t{\n\t\t\t\tsystem \"$pscmd | sed -e 1d -e 's/^/# /'\";\n\t\t\t\tsleep $nap;\n\t\t\t}\n\t\t}\n\t}\n\n\tmy $verbose = 0;\n\tsub set_verbosity\n\t{\n\t\t$verbose = $_[0];\n\t}\n\n    sub smart_blob_space_name\n    {\n        my ($dbh) = @_;\n        my ($sbspace) = \"\";\n\n        if ($dbh->{ix_ServerVersion} < 900)\n        {\n            stmt_note \"# No Smart BLOB testing because server version too old\\n\";\n        }\n        elsif ($ENV{DBD_INFORMIX_NO_SBSPACE})\n        {\n            stmt_note \"# No Smart BLOB testing because \\$DBD_INFORMIX_NO_SBSPACE set.\\n\";\n        }\n        else\n        {\n            $sbspace = $ENV{DBD_INFORMIX_SBSPACE};\n            $sbspace = \"sbspace\" unless $sbspace;\n            my $sql = 'select name from sysmaster:\"informix\".sysdbspaces where name = ? and is_sbspace = 1';\n            my $ore = $dbh->{RaiseError};\n            my $ope = $dbh->{PrintError};\n            $dbh->{RaiseError} = 0;\n            $dbh->{PrintError} = 1;\n            my $sth = $dbh->prepare($sql);\n            $dbh->{RaiseError} = $ore;\n            $dbh->{PrintError} = $ope;\n            return \"\" if (!$sth);\n            $sth->execute($sbspace);\n            my @arr;\n            my $ok = 0;\n            while (@arr = $sth->fetchrow_array)\n            {\n                $ok = 1;\n                last;\n            }\n            if ($ok)\n            {\n                stmt_note \"# Smart BLOB testing using smart blob space '$sbspace'\\n\";\n            }\n            else\n            {\n                stmt_note \"# No Smart BLOB testing - can't find smart blob space '$sbspace'\\n\";\n                stmt_note \"# Check value of \\$DBD_INFORMIX_SBSPACE - or set it\\n\";\n                $sbspace = \"\";\n            }\n        }\n        return $sbspace;\n    }\n\n\n\tsub validate_unordered_unique_data\n\t{\n\t\tmy($sth, $key, $val) = @_;\n\t\tmy(%values) = %$val;\n\t\tmy($numexp) = 0;\n\n\t\tforeach my $col (sort keys %values)\n\t\t{\n\t\t\tmy(%columns) = %{$values{$col}};\n\t\t\tprintf \"# Key: %-20s = %s\\n\", \"$key:\", $col if $verbose >= 2;\n\t\t\tstmt_fail \"### TEST ERROR: key column not in expected data: $key = $col\\n\"\n\t\t\t\tif !defined $columns{$key};\n\t\t\tstmt_fail \"### TEST ERROR: inconsistent expected data: $key = $col and $key = $columns{$key}\\n\"\n\t\t\t\tif $col ne $columns{$key};\n\t\t\tforeach my $col (sort keys %columns)\n\t\t\t{\n\t\t\t\tprintf \"#      %-20s = %s\\n\", \"$col:\", $columns{$col} if $verbose >= 2;\n\t\t\t}\n\t\t\t$numexp++;\n\t\t}\n\n\t\tmy ($ref);\n\t\tmy (%state) = ('fail' => 0, 'pass' => 0, 'xtra' => 0, 'miss' => 0);\n\t\tmy $rownum = 0;\n\t\twhile ($ref = $sth->fetchrow_hashref)\n\t\t{\n\t\t\t$rownum++;\n\t\t\tmy %row = %{$ref};\n\t\t\tif (defined $row{$key} && defined $values{$row{$key}})\n\t\t\t{\n\t\t\t\tmy $pass = 0;\n\t\t\t\tmy $fail = 0;\n\t\t\t\tmy %expect = %{$values{$row{$key}}};\n\n\t\t\t\tforeach my $col (keys %row)\n\t\t\t\t{\n\t\t\t\t\tmy($got, $want) = ($row{$col}, $expect{$col});\n\t\t\t\t\tif (defined $got && defined $want)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ($got ne $want)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprint \"# Row $rownum: Got unexpected value <<$got>> for $col (key value = $row{$key}) when <<$want>> expected!\\n\";\n\t\t\t\t\t\t\t$fail++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprint \"# Row $rownum: Got expected value $got for $col (key value = $row{$key})\\n\" if ($verbose >= 2);\n\t\t\t\t\t\t\t$pass++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telsif (!defined $got && !defined $want)\n\t\t\t\t\t{\n\t\t\t\t\t\tprint \"# Row $rownum: Got NULL which was wanted for $col\\n\" if ($verbose >= 2);\n\t\t\t\t\t\t$pass++;\n\t\t\t\t\t}\n\t\t\t\t\telsif (!defined $got)\n\t\t\t\t\t{\n\t\t\t\t\t\tprint \"# Row $rownum: Got NULL for $col (key value = $row{$key}) when $want expected!\\n\";\n\t\t\t\t\t\t$fail++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprint \"# Row $rownum: Got $got for $col (key value = $row{$key}) when NULL expected!\\n\";\n\t\t\t\t\t\t$fail++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tforeach my $col (keys %expect)\n\t\t\t\t{\n\t\t\t\t\tmy($got, $want) = ($row{$col}, $expect{$col});\n\t\t\t\t\tnext if (defined $got && defined $want);\t\n\t\t\t\t\tnext if (!defined $got && !defined $want);\n\t\t\t\t\tif (!defined $got)\n\t\t\t\t\t{\n\t\t\t\t\t\tprint \"# Row $rownum: Did not get result for $col (key value = $row{$key}) when $want expected!\\n\";\n\t\t\t\t\t\t$fail++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($pass > 0 && $fail == 0)\n\t\t\t\t{\n\t\t\t\t\t$state{pass}++;\n\t\t\t\t\tprint \"# Row $rownum: PASS\\n\" if ($verbose >= 1);\n\t\t\t\t\tdelete $values{$row{$key}};\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$state{fail}++;\n\t\t\t\t\tprint \"# Row $rownum: FAIL (erroneous content)\\n\" if ($verbose >= 1);\n\t\t\t\t\tdelete $values{$row{$key}} if $pass > 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprint \"# Row $rownum: Got unexpected row of data!\\n\";\n\t\t\t\tforeach my $col (sort keys %row)\n\t\t\t\t{\n\t\t\t\t\tprintf \"#     %-20s = %s\\n\", \"$col:\", $row{$col};\n\t\t\t\t}\n\t\t\t\t$state{xtra}++;\n\t\t\t\tprint \"# Row $rownum: FAIL (unexpected key value)\\n\" if ($verbose >= 1);\n\t\t\t}\n\t\t}\n\n\t\tforeach my $val (sort keys %values)\n\t\t{\n\t\t\tprint \"# Did not get a row corresponding to expected key $val\\n\";\n\t\t\t$state{miss}++;\n\t\t}\n\n\t\tif ($state{fail} == 0 && $state{miss} == 0 && $state{xtra} == 0 && $state{pass} == $numexp)\n\t\t{\n\t\t\tstmt_note \"# PASSED: $state{pass} row(s) found with expected values\\n\";\n\t\t\tstmt_ok;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmy($msg) = \"# FAILED\";\n\t\t\t$msg .= \": $state{pass} rows were correct\";\n\t\t\t$msg .= \"; $state{fail} rows had faulty data\" if ($state{fail} != 0);\n\t\t\t$msg .= \"; $state{miss} rows did not get selected\" if ($state{miss} != 0);\n\t\t\t$msg .= \"; $state{xtra} rows were selected unexpectedly\" if ($state{xtra} != 0);\n\t\t\tstmt_nok \"$msg\\n\";\n\t\t}\n\t}\n\n\t1;\n}",
      "file" : "/var/tmp/arv_Btnlcp/DBD-Informix-2013.0118/lib/DBD/Informix/TestHarness.pm",
      "package" : "DBD::Informix::TestHarness"
   }
]
