[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'EUC-TW',\n\n    regexp   => '(?:[\\x00-\\x7F]|[\\xA1-\\xFE][\\xA1-\\xFE]|' .\n\t'\\x8E[\\xA1-\\xB0][\\xA1-\\xFE][\\xA1-\\xFE])',\n\n    cmpchar => sub {\n\tlength($_[0]) <=> length($_[1]) || $_[0] cmp $_[1];\n    },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len == 1) {\n\t    return $ch eq \"\\x7F\"\n\t\t? \"\\xA1\\xA1\"\n\t\t: chr(ord($ch)+1);\n\t}\n\telsif ($len == 2) {\n\t    my($c,$d) = unpack('CC', $ch);\n\t    return $ch eq \"\\xFE\\xFE\"\n\t\t    ? \"\\x8E\\xA1\\xA1\\xA1\"\n\t\t    : $d == 0xFE\n\t\t\t? chr($c+1).\"\\xA1\"\n\t\t\t: pack('CC', $c, $d+1);\n\t}\n\telsif ($len == 4) {\n\t    return unless $ch =~ s/^\\x8E//;\n\t    my($b,$c,$d) = unpack('CCC',$ch);\n\t    return $d == 0xFE\n\t\t    ? $c == 0xFE\n\t\t\t? $b == 0xB0\n\t\t\t    ? undef\n\t\t\t    : pack('CCCC', 0x8E, $b+1, 0xA1, 0xA1)\n\t\t\t: pack('CCCC', 0x8E, $b, $c+1, 0xA1)\n\t\t    : pack('CCCC', 0x8E, $b, $c, $d+1);\n\t}\n\telse {\n\t    return;\n\t}\n    },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/EUC_TW.pm",
      "package" : "String::Multibyte::EUC_TW"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'Johab',\n\n    regexp   => '(?:[\\x00-\\x7F]|[\\xD8-\\xDE\\xE0-\\xF9][\\x31-\\x7E\\x91-\\xFE]|'\n\t. '\\x84[\\x44\\x46\\x47\\x4A-\\x50\\x54\\x61\\x81\\xA1\\xC1\\xE1]|'\n\t. '[\\x85\\x86][\\x41\\x61\\x81\\xA1\\xC1\\xE1]|\\x87[\\x41\\x61\\x81\\xA1]|'\n\t. '[\\x88\\x8C\\x90\\x94\\x98\\x9C\\xA0\\xA4\\xA8\\xAC\\xB0\\xB4\\xB8\\xBC'\n\t. '\\xC0\\xC4\\xC8\\xCC\\xD0][\\x41\\x61-\\x71\\x73-\\x7D\\x81-\\x91\\x93-\\x9D'\n\t. '\\xA1-\\xB1\\xB3-\\xBD\\xC1-\\xD1\\xD3-\\xDD\\xE1-\\xF1\\xF3-\\xFD]|'\n\t. '[\\x89\\x8A\\x8D\\x8E\\x91\\x92\\x95\\x96\\x99\\x9A\\x9D\\x9E\\xA1\\xA2\\xA5\\xA6'\n\t. '\\xA9\\xAA\\xAD\\xAE\\xB1\\xB2\\xB5\\xB6\\xB9\\xBA\\xBD\\xBE\\xC1\\xC2\\xC5\\xC6'\n\t. '\\xC9\\xCA\\xCD\\xCE\\xD1\\xD2][\\x41-\\x51\\x53-\\x5D\\x61-\\x71\\x73-\\x7D'\n\t. '\\x81-\\x91\\x93-\\x9D\\xA1-\\xB1\\xB3-\\xBD\\xC1-\\xD1\\xD3-\\xDD\\xE1-\\xF1'\n\t. '\\xF3-\\xFD]|'\n\t. '[\\x8B\\x8F\\x93\\x97\\x9B\\x9F\\xA3\\xA7\\xAB\\xAF\\xB3\\xB7\\xBB\\xBF\\xC3\\xC7'\n\t. '\\xCB\\xCF\\xD3][\\x41-\\x51\\x53-\\x5D\\x61-\\x71\\x73-\\x7D\\x81-\\x91'\n\t. '\\x93-\\x9D\\xA1-\\xB1\\xB3-\\xBD])',\n\n    cmpchar => sub { $_[0] cmp $_[1] },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len == 1) {\n\t    return $ch eq \"\\x7F\"\n\t\t? \"\\x84\\x44\"\n\t\t: chr(ord($ch)+1);\n\t}\n\telsif ($len == 2) {\n\t    return undef if $ch eq \"\\xF9\\xFE\";\n\t    return \"\\xD8\\x31\" if $ch eq \"\\xD3\\xBD\"; \n\t    return \"\\xE0\\x31\" if $ch eq \"\\xDE\\xFE\"; \n\n\t    my ($n, $c, $d);\n\t    ($c, $d) = unpack('CC', $ch);\n\n\t    if (0x84 <= $c && $c <= 0x87 && ($n = $HLNT[$c % 4]{$d}) ||\n\t\t0x88 <= $c && $c <= 0xD3 && ($n = $HSNT[$c % 4]{$d}) ) {\n\t\treturn $n == 0x41\n\t\t    ? pack('CC', $c+1, $n)\n\t\t    : pack('CC', $c,   $n);\n\t    }\n\t    else {\n\t\treturn $d == 0xFE\n\t\t    ? chr($c+1).\"\\x31\"\n\t\t    : $d == 0x7E\n\t\t\t? chr($c).\"\\x91\"\n\t\t\t: pack('CC', $c, $d+1);\n\t    }\n\t}\n\telse {\n\t    return;\n\t}\n    },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/Johab.pm",
      "package" : "String::Multibyte::Johab"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'bytes',\n    regexp   => $] >= 5.006 ? '\\C' : '[\\x00-\\xFF]',\n    nextchar =>\n\tsub {\n\t    my $c = unpack('C', shift);\n\t    $c == 0xFF ? undef : pack('C', 1+$c);\n\t},\n    cmpchar => sub { $_[0] cmp $_[1] },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/Bytes.pm",
      "package" : "String::Multibyte::Bytes"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'GBK',\n\n    regexp   => '(?:[\\x00-\\x80]|[\\x81-\\xFE][\\x40-\\x7E\\x80-\\xFE])',\n\n    cmpchar => sub { $_[0] cmp $_[1] },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len == 1) {\n\t    return $ch eq \"\\x80\"\n\t\t? \"\\x81\\x40\"\n\t\t: chr(ord($ch)+1);\n\t}\n\telsif ($len == 2) {\n\t    my($c, $d) = unpack('CC', $ch);\n\t    return $ch eq \"\\xFE\\xFE\"\n\t\t? undef\n\t\t: $d == 0xFE\n\t\t    ? chr($c+1).\"\\x40\"\n\t\t    : $d == 0x7E\n\t\t\t? chr($c)  .\"\\x80\"\n\t\t\t: pack('CC', $c, $d+1);\n\t}\n\telse {\n\t    return;\n\t}\n    },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/GBK.pm",
      "package" : "String::Multibyte::GBK"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'Big-5',\n\n    regexp   => '(?:[\\x00-\\x7F]|[\\x81-\\xFE][\\x40-\\x7E\\xA1-\\xFE])',\n\n    cmpchar => sub { $_[0] cmp $_[1] },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len < 1 || 2 < $len) {\n\t    return undef;\n\t}\n\telsif ($len == 1) {\n\t    return $ch eq \"\\x7F\"\n\t\t? \"\\x81\\x40\"\n\t\t: chr(ord($ch)+1);\n\t}\n\telse {\n\t    my($c, $d) = unpack('CC', $ch);\n\t    return $ch eq \"\\xFE\\xFE\"\n\t\t? undef\n\t\t: $d == 0xFE\n\t\t    ? chr($c+1).\"\\x40\"\n\t\t    : $d == 0x7E\n\t\t\t? chr($c).\"\\xA1\"\n\t\t\t: pack('CC', $c, $d+1);\n\t}\n    },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/Big5.pm",
      "package" : "String::Multibyte::Big5"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'EUC',\n\n    regexp   => '(?:[\\x00-\\x7F]|[\\xA1-\\xFE][\\xA1-\\xFE])',\n\n    cmpchar => sub { $_[0] cmp $_[1] },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len < 1 || 2 < $len) {\n\t    return undef;\n\t}\n\telsif ($len == 1) {\n\t    return $ch eq \"\\x7F\"\n\t\t? \"\\xA1\\xA1\"\n\t\t: chr(ord($ch)+1);\n\t}\n\telse {\n\t    my($c, $d) = unpack('CC', $ch);\n\t    return $ch eq \"\\xFE\\xFE\"\n\t\t? undef\n\t\t: $d == 0xFE\n\t\t    ? chr($c+1).\"\\xA1\"\n\t\t    : pack('CC', $c, $d+1);\n\t}\n    },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/EUC.pm",
      "package" : "String::Multibyte::EUC"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'UTF-16LE',\n\n    regexp   => '(?:[\\x00-\\xFF][\\xD8-\\xDB][\\x00-\\xFF][\\xDC-\\xDF]|' .\n\t'[\\x00-\\xFF][\\x00-\\xD7\\xE0-\\xFF])',\n\n    cmpchar => sub {\n\tlength($_[0]) <=> length($_[1]) ||\n\tunpack('v', $_[0]) <=> unpack('v', $_[1]) ||\n\treverse($_[0]) cmp reverse($_[1])\n    },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len == 2) {\n\t    return $ch eq \"\\xFF\\xD7\"\n\t\t? \"\\x00\\xE0\"\n\t\t: $ch eq \"\\xFF\\xFF\"\n\t\t    ? \"\\x00\\xD8\\x00\\xDC\"\n\t\t    : pack('v', 1 + unpack 'v', $ch);\n\t}\n\telsif ($len == 4) {\n\t    my($hi,$lo) = unpack('vv', $ch);\n\t    return $ch eq \"\\xFF\\xDB\\xFF\\xDF\"\n\t\t? undef\n\t\t: $lo == 0xDFFF\n\t\t    ? pack('vv', $hi+1, 0xDC00)\n\t\t    : pack('vv', $hi, $lo+1);\n\t}\n\treturn undef;\n    },\n\n    hyphen => \"-\\x00\",\n    escape => \"\\\\\\x00\",\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/UTF16LE.pm",
      "package" : "String::Multibyte::UTF16LE"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'UTF-8',\n\n    regexp   => '(?:[\\x00-\\x7F]|[\\xC2-\\xDF][\\x80-\\xBF]|' .\n\t'\\xE0[\\xA0-\\xBF][\\x80-\\xBF]|\\xED[\\x80-\\x9F][\\x80-\\xBF]|' .\n\t'[\\xE1-\\xEC\\xEE\\xEF][\\x80-\\xBF][\\x80-\\xBF]|' .\n\t'\\xF0[\\x90-\\xBF][\\x80-\\xBF][\\x80-\\xBF]|' .\n\t'[\\xF1-\\xF3][\\x80-\\xBF][\\x80-\\xBF][\\x80-\\xBF]|' .\n\t'\\xF4[\\x80-\\x8F][\\x80-\\xBF][\\x80-\\xBF])',\n\n    cmpchar => sub { $_[0] cmp $_[1] },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len < 1 || 4 < $len) {\n\t    return undef;\n\t}\n\telsif ($len == 1) {\n\t    return $ch eq \"\\x7F\"\n\t\t? \"\\xC2\\x80\"\n\t\t: chr(ord($ch)+1);\n\t}\n\telsif ($len == 2) {\n\t    my($c,$d) = unpack('CC',$ch);\n\t    return $ch eq \"\\xDF\\xBF\"\n\t\t? \"\\xE0\\xA0\\x80\"\n\t\t: $d == 0xBF\n\t\t    ? chr($c+1).\"\\x80\"\n\t\t    : pack('CC', $c, $d+1);\n\t}\n\telsif ($len == 3) {\n\t    my($c,$d,$e) = unpack('CCC',$ch);\n\t    return $ch eq \"\\xEF\\xBF\\xBF\"\n\t\t? \"\\xF0\\x90\\x80\\x80\"\n\t\t: $ch eq \"\\xED\\x9F\\xBF\"\n\t\t    ? \"\\xEE\\x80\\x80\"\n\t\t    : $e == 0xBF\n\t\t\t? $d == 0xBF\n\t\t\t    ? chr($c+1).\"\\x80\\x80\"\n\t\t\t    : pack('CCC', $c, $d+1, 0x80)\n\t\t\t: pack('CCC', $c, $d, $e+1);\n\t}\n\telse {\n\t    my($c,$d,$e,$f) = unpack('CCCC',$ch);\n\t    return $ch ge \"\\xF4\\x8F\\xBF\\xBF\"\n\t\t? undef\n\t\t    : $f == 0xBF\n\t\t\t? $e == 0xBF\n\t\t\t    ? $d == 0xBF\n\t\t\t\t? chr($c+1).\"\\x80\\x80\\x80\"\n\t\t\t\t: pack('CCCC', $c, $d+1, 0x80, 0x80)\n\t\t\t    : pack('CCCC', $c, $d, $e+1, 0x80)\n\t\t\t: pack('CCCC', $c, $d, $e, $f+1);\n\t}\n    },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/UTF8.pm",
      "package" : "String::Multibyte::UTF8"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'UHC',\n\n    regexp   => '(?:[\\x00-\\x7F]|[\\x81-\\xC5][\\x41-\\x5A\\x61-\\x7A\\x81-\\xFE]|'\n\t  . '\\xC6[\\x41-\\x52\\xA1-\\xFE]|[\\xC7-\\xFE][\\xA1-\\xFE])',\n\n    cmpchar => sub { $_[0] cmp $_[1] },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len == 1) {\n\t    return $ch eq \"\\x7F\"\n\t\t? \"\\x81\\x41\"\n\t\t: chr(ord($ch)+1);\n\t}\n\telsif ($len == 2) {\n\t    my($c, $d) = unpack('CC', $ch);\n\t    return $ch eq \"\\xFE\\xFE\"\n\t\t? undef\n\t\t: $ch eq \"\\xC6\\x52\"\n\t\t    ? \"\\xC6\\xA1\"\n\t\t    : $d == 0xFE\n\t\t\t? pack('CC', $c+1, $c < 0xC6 ? 0x41 : 0xA1)\n\t\t\t: $d == 0x5A\n\t\t\t    ? chr($c) .\"\\x61\"\n\t\t\t    : $d == 0x7A\n\t\t\t\t? chr($c) .\"\\x81\"\n\t\t\t\t: pack('CC', $c, $d+1);\n\t}\n\telse {\n\t    return;\n\t}\n    },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/UHC.pm",
      "package" : "String::Multibyte::UHC"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'Shift-JIS',\n\n    regexp   => '(?:[\\x00-\\x7F\\xA1-\\xDF]|' .\n\t'[\\x81-\\x9F\\xE0-\\xFC][\\x40-\\x7E\\x80-\\xFC])',\n\n    cmpchar => sub {\n\tlength($_[0]) <=> length($_[1]) || $_[0] cmp $_[1];\n    },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len < 1 || 2 < $len) {\n\t    return undef;\n\t}\n\telsif ($len == 1) {\n\t    return $ch eq \"\\x7F\"\n\t\t? \"\\xA1\"\n\t\t: $ch eq \"\\xDF\"\n\t\t    ? \"\\x81\\x40\"\n\t\t    : chr(ord($ch)+1);\n\t}\n\telse {\n\t    my($c,$d) = unpack('CC',$ch);\n\t    return $ch eq \"\\x9F\\xFC\"\n\t\t? \"\\xE0\\x40\"\n\t\t: $ch eq \"\\xFC\\xFC\"\n\t\t    ? undef\n\t\t    : $d == 0xFC\n\t\t\t? chr($c+1).\"\\x40\"\n\t\t\t: $d == 0x7E\n\t\t\t    ? chr($c)  .\"\\x80\"\n\t\t\t    : pack('CC', $c, $d+1);\n\t}\n    },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/ShiftJIS.pm",
      "package" : "String::Multibyte::ShiftJIS"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'Big-5 Plus',\n\n    regexp   => '(?:[\\x00-\\x7F]|[\\x81-\\xFE][\\x40-\\x7E\\x80-\\xFE])',\n\n    cmpchar => sub { $_[0] cmp $_[1] },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len < 1 || 2 < $len) {\n\t    return undef;\n\t}\n\telsif ($len == 1) {\n\t    return $ch eq \"\\x7F\"\n\t\t? \"\\x81\\x40\"\n\t\t: chr(ord($ch)+1);\n\t}\n\telse {\n\t    my($c, $d) = unpack('CC', $ch);\n\t    return $ch eq \"\\xFE\\xFE\"\n\t\t? undef\n\t\t: $d == 0xFE\n\t\t    ? chr($c+1).\"\\x40\"\n\t\t    : $d == 0x7E\n\t\t\t? chr($c).\"\\x80\"\n\t\t\t: pack('CC', $c, $d+1);\n\t}\n    },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/Big5Plus.pm",
      "package" : "String::Multibyte::Big5Plus"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'UTF-32BE',\n\n    regexp   => '(?:\\x00\\x00[\\x00-\\xD7\\xE0-\\xFF][\\x00-\\xFF]|'\n\t  . '\\x00[\\x01-\\x10][\\x00-\\xFF][\\x00-\\xFF])',\n\n    cmpchar => sub { $_[0] cmp $_[1] },\n\n    nextchar => sub {\n\tmy $u = unpack('N', $_[0]);\n\treturn if 0x10FFFF <= $u;\n\tpack('N', $u == 0xD7FF ? 0xE000 : $u + 1);\n    },\n\n    hyphen => \"\\x00\\x00\\x00-\",\n    escape => \"\\x00\\x00\\x00\\\\\",\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/UTF32BE.pm",
      "package" : "String::Multibyte::UTF32BE"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset => 'Default Grapheme Cluster',\n    regexp  => $Grapheme,\n }",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/Grapheme.pm",
      "package" : "String::Multibyte::Grapheme"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'EUC-JP',\n\n    regexp   => '(?:[\\x00-\\x7F]|[\\x8E\\xA1-\\xFE][\\xA1-\\xFE]|' .\n\t'\\x8F[\\xA1-\\xFE][\\xA1-\\xFE])',\n\n    cmpchar => sub {\n\tlength($_[0]) <=> length($_[1]) || $_[0] cmp $_[1];\n    },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len < 1 || 3 < $len) {\n\t    return;\n\t}\n\telsif ($len == 1) {\n\t    return $ch eq \"\\x7F\"\n\t\t? \"\\x8E\\xA1\"\n\t\t: chr(ord($ch)+1);\n\t}\n\telsif ($len == 2) {\n\t    my($c,$d) = unpack('CC', $ch);\n\t    return $ch eq \"\\x8E\\xFE\"\n\t\t? \"\\xA1\\xA1\"\n\t\t: $ch eq \"\\xFE\\xFE\"\n\t\t    ? \"\\x8F\\xA1\\xA1\"\n\t\t    : $d == 0xFE\n\t\t\t? chr($c+1).\"\\xA1\"\n\t\t\t: pack('CC', $c, $d+1);\n\t}\n\telse {\n\t    return if 0x8F != ord $ch;\n\t    my($b,$c,$d) = unpack('CCC',$ch);\n\t    return $ch eq \"\\x8F\\xFE\\xFE\"\n\t\t? undef\n\t\t: $d == 0xFE\n\t\t    ? pack('CCC', 0x8F, $c+1, 0xA1)\n\t\t    : pack('CCC', 0x8F, $c, $d+1);\n\t}\n    },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/EUC_JP.pm",
      "package" : "String::Multibyte::EUC_JP"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'GB18030',\n\n    regexp   => '(?:[\\x00-\\x80]|[\\x81-\\xFE][\\x40-\\x7E\\x80-\\xFE]|'\n\t. '[\\x81-\\xFE][\\x30-\\x39][\\x81-\\xFE][\\x30-\\x39])',\n\n    cmpchar => sub {\n\tlength($_[0]) <=> length($_[1]) || $_[0] cmp $_[1];\n    },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len == 1) {\n\t    return $ch eq \"\\x80\"\n\t\t? \"\\x81\\x40\"\n\t\t: chr(ord($ch)+1);\n\t}\n\telsif ($len == 2) {\n\t    my($c, $d) = unpack('CC', $ch);\n\t    return $ch eq \"\\xFE\\xFE\"\n\t\t? \"\\x81\\x30\\x81\\x30\"\n\t\t: $d == 0xFE\n\t\t    ? chr($c+1).\"\\x40\"\n\t\t    : $d == 0x7E\n\t\t\t? chr($c)  .\"\\x80\"\n\t\t\t: pack('CC', $c, $d+1);\n\t}\n\telsif ($len == 4) {\n\t    my($c, $d, $e, $f) = unpack('CCCC', $ch);\n\t    return $f == 0x39\n\t\t    ? $e == 0xFE\n\t\t\t? $d == 0x39\n\t\t\t    ? $c == 0xFE\n\t\t\t\t? undef\n\t\t\t\t: pack('CCCC', $c+1, 0x30, 0x81, 0x30)\n\t\t\t    : pack('CCCC', $c, $d+1, 0x81, 0x30)\n\t\t\t: pack('CCCC', $c, $d, $e+1, 0x30)\n\t\t    : pack('CCCC', $c, $d, $e, $f+1);\n\t}\n\telse {\n\t    return;\n\t}\n    },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/GB18030.pm",
      "package" : "String::Multibyte::GB18030"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'UTF-16BE',\n\n    regexp   => '(?:[\\xD8-\\xDB][\\x00-\\xFF][\\xDC-\\xDF][\\x00-\\xFF]|' .\n\t'[\\x00-\\xD7\\xE0-\\xFF][\\x00-\\xFF])',\n\n    cmpchar => sub {\n\tlength($_[0]) <=> length($_[1]) || $_[0] cmp $_[1];\n    },\n\n    nextchar => sub {\n\tmy $ch = shift;\n\tmy $len = length $ch;\n\tif ($len == 2) {\n\t    return $ch eq \"\\xD7\\xFF\"\n\t\t? \"\\xE0\\x00\"\n\t\t: $ch eq \"\\xFF\\xFF\"\n\t\t    ? \"\\xD8\\x00\\xDC\\x00\"\n\t\t    : pack('n', 1 + unpack 'n', $ch);\n\t}\n\telsif ($len == 4) {\n\t    my($hi,$lo) = unpack('nn', $ch);\n\t    return $ch eq \"\\xDB\\xFF\\xDF\\xFF\"\n\t\t? undef\n\t\t: $lo == 0xDFFF\n\t\t    ? pack('nn', $hi+1, 0xDC00)\n\t\t    : pack('nn', $hi, $lo+1);\n\t}\n\treturn undef;\n    },\n\n    hyphen => \"\\x00-\",\n    escape => \"\\x00\\\\\",\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/UTF16BE.pm",
      "package" : "String::Multibyte::UTF16BE"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'UTF-32LE',\n\n    regexp   => '(?:[\\x00-\\xFF][\\x00-\\xD7\\xE0-\\xFF]\\x00\\x00|'\n\t  . '[\\x00-\\xFF][\\x00-\\xFF][\\x01-\\x10]\\x00)',\n\n    cmpchar => sub { unpack('V', $_[0]) <=> unpack('V', $_[1]) },\n\n    nextchar => sub {\n\tmy $u = unpack('V', $_[0]);\n\treturn if 0x10FFFF <= $u;\n\tpack('V', $u == 0xD7FF ? 0xE000 :$u + 1);\n    },\n\n    hyphen => \"-\\x00\\x00\\x00\",\n    escape => \"\\\\\\x00\\x00\\x00\",\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/UTF32LE.pm",
      "package" : "String::Multibyte::UTF32LE"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "+{\n    charset  => 'Unicode',\n    regexp   => qr/./s,\n    nextchar => sub { pack 'U', 1 + unpack('U', $_[0]) },\n    cmpchar  => sub { $_[0] cmp $_[1] },\n}",
      "file" : "/var/tmp/arv_cyghyf/String-Multibyte-1.10/Multibyte/Unicode.pm",
      "package" : "String::Multibyte::Unicode"
   }
]
