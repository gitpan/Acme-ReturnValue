[
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\nuse vars qw ( $VERSION );\nuse strict;\nuse Carp;\n\n$VERSION = '0.2';\n\nsub parse ($$);\nsub MatchAndEat ($$);\nsub error ($$);\nsub Select ($);\nsub Construct ($);\nsub Describe ($);\nsub OrderBy ($);\nsub Limit ($);\nsub Offset ($);\nsub Delete ($);\nsub From ($);\nsub FromNamed ($);\nsub GraphPattern ($);\nsub GraphAndPattern ($);\nsub PatternElement ($);\nsub GroupGraphPattern ($);\nsub SourceGraphPattern ($);\nsub OptionalGraphPattern ($);\nsub Var ($);\nsub URIOrQName ($);\nsub Literal ($);\nsub TriplePattern ($);\nsub VarOrURIOrQName ($);\nsub VarOrURIOrQNameOrLiteral ($);\nsub Constraint ($);\nsub Prefixes ($);\nsub PrefixDecl ($);\nsub ConditionalOrExpression ($);\nsub ConditionalAndExpression ($);\nsub StringEqualityExpression ($);\nsub PatternLiteral ($);\nsub EqualityExpression ($);\nsub RelationalExpression ($);\nsub AdditiveExpression ($);\nsub MultiplicativeExpression ($);\nsub UnaryExpression ($);\nsub UnaryExpressionNotPlusMinus ($);\nsub PrimaryExpression ($);\nsub FunctionCall ($);\nsub ArgList ($);\n\n%RDQL::Parser::default_prefixes= (\n\t'http://www.w3.org/1999/02/22-rdf-syntax-ns#' => 'rdf',\n\t'http://www.w3.org/2000/01/rdf-schema#' => 'rdfs',\n\t'http://purl.org/rss/1.0/' => 'rss',\n\t'http://www.daml.org/2001/03/daml+oil#' => 'daml',\n\t'http://purl.org/dc/elements/1.1/' => 'dc',\n\t'http://purl.org/dc/terms/' => 'dcq',\n\t'http://xmlns.com/foaf/0.1/' => 'foaf',\n\t'http://www.w3.org/2001/XMLSchema#' => 'xsd',\n\t'http://www.w3.org/2002/07/owl#' => 'owl',\n\t'http://www.w3.org/2001/sw/DataAccess/operations' => 'op',\n\t'http://www.w3.org/2004/07/xpath-functions' => 'fn'\n\t);\n\nsub new {\n\tmy $self = {\n\t\tprefixes\t\t=>\t{},\n\t\tsources\t\t\t=>\t[],\n\t\tfrom_named\t\t=>\t[],\n\t\tresultVars\t\t=>\t[],\n\t\tconstructPatterns\t=>\t[],\n\t\tdescribes\t\t=>\t[],\n\t\tgraphPatterns\t\t=>\t[],\n\t\torder_by\t\t=>\t[]\n\t\t};\n\n\tmap {\n\t\t$self->{'prefixes'}->{ $RDQL::Parser::default_prefixes{ $_ } } = $_ ;\n\t} keys %RDQL::Parser::default_prefixes;\n\n\tbless $self, shift;\n\t};\n\nsub MatchAndEat ($$) {\n\tmy($class,$lit)=@_;\n\n\twhile( $class->{'query_string'} =~ s/^\\s*(#|\\/\\/).*// ) {};\n\n\tif( $class->{'query_string'} =~ s/^\\s*\\/\\*// ) {\n\t\twhile( $class->{'query_string'} !~ s/^\\s*\\*\\/// ) {\n\t\t\t$class->{'query_string'} =~ s/^\\s*(.)\\s*//;\n\t\t\t};\n\t\t};\n\n\treturn $class->{'query_string'} =~ s/^\\s*\\Q$lit\\E\\s*//i;\n};\n\nsub error($$) {\n\tmy($class,$msg)=@_;\n\tcroak \"error: $msg: \".$class->{'query_string'}.\"\\n\";\n};\n\nsub parse($$) {\n\tmy($class,$query) = @_;\n\n\t$class->{'query_string'} = $query;\n\n\t$class->{'context'}=[];\n\t$class->{'graph_patterns_pointer'} = []; \n\t\n\twhile( MatchAndEat $class,'prefix' ) {\n\t\tPrefixDecl $class;\n\t\t};\n\n\tif( MatchAndEat $class,'select' ) {\n\t\t$class->{'queryType'} = 'SELECT';\n\t\tSelect $class;\n\t} elsif( MatchAndEat $class,'construct' ) {\n\t\t$class->{'queryType'} = 'CONSTRUCT';\n\t\tConstruct $class;\n\t} elsif( MatchAndEat $class,'describe' ) {\n\t\t$class->{'queryType'} = 'DESCRIBE';\n\t\tDescribe $class;\n\t} elsif( MatchAndEat $class,'ask' ) {\n\t\t$class->{'queryType'} = 'ASK';\n\t} elsif( MatchAndEat $class,'delete' ) {\n\t\t$class->{'queryType'} = 'DELETE';\n\t\tDelete $class;\n\t} else {\n\t\terror $class,'Expecting SELECT, CONSTRUCT, DESCRIBE, ASK or DELETE token'\n\t\t\tif($class->{'query_string'} ne '');\n\t\t};\n\n\twhile( MatchAndEat $class,'prefix' ) {\n\t\tPrefixDecl $class;\n\t\t};\n\n\twhile(\tMatchAndEat $class,'source' or\n\t\tMatchAndEat $class,'from' ) {\n\t\tif( MatchAndEat $class,'named' ) {\n\t\t\tFromNamed $class;\n\t\t} else {\n\t\t\tFrom $class;\n\t\t\t};\n\t\t};\n\n\tGraphPattern $class\n\t\tif( MatchAndEat $class,'where');\n\n\twhile(\tMatchAndEat $class,'order' and\n\t\tMatchAndEat $class,'by' ) {\n\t\tOrderBy $class;\n\t\t};\n\n\tLimit $class\n\t\tif(MatchAndEat $class,'limit');\n\n\tOffset $class\n\t\tif(MatchAndEat $class,'offset');\n\n        Prefixes $class\n\t\tif(MatchAndEat $class,'using');\n\n\t$class->{'query_string'} =~ s/^\\s*//;\n\t$class->{'query_string'} =~ s/\\s*$//;\n\n\terror $class,'illegal input'\n\t\tif($class->{'query_string'} ne '');\n\n\tdelete($class->{'query_string'});\n\tdelete($class->{'context'});\n\tdelete($class->{'graph_patterns_pointer'});\n\n\n\treturn $class;\n\t};\n\nsub Select($) {\n\tmy($class) = @_;\n\n\t$class->{'distinct'} = ( MatchAndEat $class,'distinct' ) ? 1 : 0;\n\tpush @{ $class->{'context'} }, 'select';\n\tif( MatchAndEat $class,'*') {\n\t\tpush @{$class->{resultVars}},'*';\n\t} elsif( Var $class ) {\n\t\tdo {\n\t\t\tMatchAndEat $class,',';\n\t\t\t} while ( Var $class );\n\t};\n\tpop @{ $class->{'context'} };\n};\n\nsub OrderBy($) {\n\tmy($class) = @_;\n\n\tpush @{ $class->{'context'} }, 'order by';\n\n\tif( MatchAndEat $class,'asc' ) {\n\t\tConditionalOrExpression $class;\n\n\t\tpush @{ $class->{'order_by'} }, 'ASC';\n\t} elsif( MatchAndEat $class,'desc' ) {\n\t\tConditionalOrExpression $class;\n\n\t\tpush @{ $class->{'order_by'} }, 'DESC';\n\t} else {\n\t\tif ( Var $class ) {\n\t\t} elsif ( FunctionCall $class ) {\n\t\t} else {\n\t\t\tConditionalOrExpression $class;\n\t\t\t};\n\n\t\tpush @{ $class->{'order_by'} }, 'ASC';\n\t\t};\n\n\tpop @{ $class->{'context'} };\n};\n\nsub Limit($) {\n\tmy($class) = @_;\n\n\tpush @{ $class->{'context'} }, 'limit';\n\n\terror $class,\"limit requires an integer value\"\n\t\tunless( Literal $class );\n\n\terror $class,\"limit is invalid\"\n\t\tunless(\t$class->{'limit'} >= 0 );\n\n\tpop @{ $class->{'context'} };\n};\n\nsub Offset($) {\n\tmy($class) = @_;\n\n\tpush @{ $class->{'context'} }, 'offset';\n\n\terror $class,\"offset requires an integer value\"\n\t\tunless( Literal $class );\n\n\terror $class,\"offset is invalid\"\n\t\tunless(\t$class->{'offset'} >= 0 );\n\n\tpop @{ $class->{'context'} };\n};\n\nsub Construct($) {\n\tmy($class) = @_;\n\n\t$class->{'distinct'} = 0; \n\tpush @{ $class->{'context'} }, 'construct';\n\tif( MatchAndEat $class,'*') {\n\t\tpush @{$class->{constructPatterns}},'*';\n\t} elsif( TriplePattern $class ) {\n\t} else {\n\t\tif( MatchAndEat $class,'{' ) {\n\t\t\twhile ( TriplePattern $class ) {\n                \t\tMatchAndEat $class,',';\n                \t\t};\n\n\t\t\terror $class,\"missing right brace\"\n\t\t\t\tunless( MatchAndEat $class,'}' );\n\t\t} else {\n\t\t\terror $class,\"missing left brace\";\n\t\t\t};\n\t\t};\n\tpop @{ $class->{'context'} };\n\t};\n\nsub Describe($) {\n\tmy($class) = @_;\n\n\t$class->{'distinct'} = 0; \n\tpush @{ $class->{'context'} }, 'describe';\n\tif( MatchAndEat $class,'*') {\n\t\tpush @{$class->{describes}},'*';\n\t} elsif( VarOrURIOrQName $class ) {\n\t\tdo {\n\t\t\tMatchAndEat $class,',';\n\t\t\t} while ( VarOrURIOrQName $class );\n\t\t};\n\tpop @{ $class->{'context'} };\n\t};\n\nsub Delete($) {\n\tmy($class) = @_;\n\n\t$class->{'distinct'} = 0;\n\tpush @{$class->{resultVars}},'*'\n\t\tif( MatchAndEat $class,'*');\n\t};\n\nsub Var($) {\n\tmy($class) = @_;\n\n\tif($class->{'query_string'} =~ s/^\\s*[\\?\\$]([a-zA-Z0-9_\\.:]+)\\s*//) {\n\t\tmy $var = '?'.$1; \n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'select' ) {\n\t\t\tpush @{$class->{resultVars}}, $var\n\t\t\t\tunless(grep /^\\Q$var\\E$/,@{$class->{resultVars}});\n\t\t\t};\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'describe' ) {\n\t\t\tpush @{$class->{describes}},$var\n\t\t\t\tunless(grep /^\\Q$var\\E$/,@{$class->{describes}});\n\t\t\t};\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'triples' ) {\n\t\t\tpush @{$class->{triple_pattern}}, $var;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'constraints' ) {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, $var;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n\t\t\tpush @{ $class->{'order_by'} }, $var;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'named_graph' ) {\n\t\t\t$class->{'graph_name'} = $var;\n\t\t};\n\n\t\treturn 1;\n\t};\n\treturn 0;\n};\n\nsub FromNamed($) {\n\tmy($class) = @_;\n\n\tpush @{ $class->{'context'} }, 'from_named';\n\tif( URIOrQName $class ) {\n\t\tdo {\n                        MatchAndEat $class,',';\n                        } while ( URIOrQName $class );\n\t} else {\n\t\terror $class, \"malformed URI or QName\";\n\t};\n\tpop @{ $class->{'context'} };\n\t};\n\nsub From($) {\n\tmy($class) = @_;\n\n\tpush @{ $class->{'context'} }, 'source';\n\tif( URIOrQName $class ) {\n\t\tdo {\n                        MatchAndEat $class,',';\n                        } while ( URIOrQName $class );\n\t} else {\n\t\terror $class, \"malformed URI or QName\";\n\t};\n\tpop @{ $class->{'context'} };\n\t};\n\nsub URIOrQName($) {\n\tmy($class) = @_;\n\n\tif($class->{'query_string'} =~ s/^\\s*(\\<[^>]*\\>)\\s*//) { \n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'triples' ) {\n\t\t\tpush @{$class->{triple_pattern}}, $1;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'from_named' ) {\n\t\t\tpush @{$class->{from_named}}, $1;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'source' ) {\n\t\t\tpush @{$class->{sources}}, $1;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'constraints' ) {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, $1;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n\t\t\tpush @{ $class->{'order_by'} }, $1;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'named_graph' ) {\n\t\t\t$class->{'graph_name'} = $1;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'describe' ) {\n\t\t\tpush @{$class->{describes}},$1\n\t\t\t\tunless(grep /^\\Q$1\\E$/,@{$class->{describes}});\n\t\t\t};\n\t\treturn 1;\n\t} elsif($class->{'query_string'} =~ s/^\\s*([a-zA-Z0-9\\-_$\\.]+)?:([a-zA-Z0-9\\-_$\\.]+)\\s*//) {\n\t\tmy $qn;\n\t\tif($1) {\n\t\t\tif( exists $class->{'prefixes'}->{$1} ) {\n\t\t\t\t$qn = '<'. $class->{'prefixes'}->{$1} .$2.'>';\n\t\t\t} else {\n\t\t\t\terror $class,\"Unbound prefix $1 \";\n\t\t\t\t};\n\t\t} else {\n\t\t\t$qn = '<'.( ( exists $class->{'prefixes'}->{'#default'} ) ? $class->{'prefixes'}->{'#default'} : $1 ).$2.'>';\n\t\t\t};\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'triples' ) {\n\t\t\tpush @{$class->{triple_pattern}}, $qn;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'from_named' ) {\n\t\t\tpush @{$class->{from_named}}, $qn;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'source' ) {\n\t\t\tpush @{$class->{sources}}, $qn;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'constraints' ) {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, $qn;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n\t\t\tpush @{ $class->{'order_by'} }, $qn;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'named_graph' ) {\n\t\t\t$class->{'graph_name'} = $qn;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'describe' ) {\n\t\t\tpush @{$class->{describes}},$qn\n\t\t\t\tunless(grep /^\\Q$qn\\E$/,@{$class->{describes}});\n\t\t\t};\n\t\treturn 1;\n\t\t};\n\treturn 0;\n};\n\nsub Literal($) {\n\tmy($class) = @_;\n\n\tif(\t($class->{'query_string'} =~ s/^\\s*(([0-9]+\\.[0-9]*([eE][+-]?[0-9]+)?[fFdD]?)|(\\.[0-9]+([eE][+-]?[0-9]+)?[fFdD]?)|([0-9]+[eE][+-]?[0-9]+[fFdD]?)|([0-9]+([eE][+-]?[0-9]+)?[fFdD]))\\s*//) or\n\t\t($class->{'query_string'} =~ s/^\\s*(%?[\\\"\\']((([^\\\"\\'\\\\\\n\\r])|(\\\\([ntbrf\\\\'\\\"])|([0-7][0-7?)|([0-3][0-7][0-7])))*)[\\\"\\'](\\@([a-z0-9]+(-[a-z0-9]+)?))?%?)\\s*//) or\n\t\t($class->{'query_string'} =~ s/^\\s*([0-9]+)\\s*//) or\n\t\t($class->{'query_string'} =~ s/^\\s*(0[xX]([0-9\",a-f,A-F])+)\\s*//) or\n\t\t($class->{'query_string'} =~ s/^\\s*(true|false)\\s*//) or\n\t\t($class->{'query_string'} =~ s/^\\s*(null)\\s*//) ) {\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'triples' ) {\n\t\t\tpush @{$class->{triple_pattern}}, $1;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'constraints' ) {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, $1;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n\t\t\tpush @{ $class->{'order_by'} }, $1;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'named_graph' ) {\n\t\t\t$class->{'graph_name'} = $1;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'limit' ) {\n\t\t\t$class->{'limit'} = $1;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'offset' ) {\n\t\t\t$class->{'offset'} = $1;\n\t\t};\n\t\treturn 1;\n\t};\n\treturn 0;\n};\n\nsub GraphPattern($) {\n\tmy($class) = @_;\n\n\tGraphAndPattern $class;\n\twhile( MatchAndEat $class,'UNION' ) { \n\t\tGraphAndPattern $class;\n\n\t\tpush @{$class->{'graphPatterns'}}, 'UNION';\n\t\t};\n\t};\n\nsub GraphAndPattern($) {\n\tmy($class) = @_;\n\n\tpush @{$class->{'graphPatterns'}}, {\n\t\t'triplePatterns' =>\t[],\n\t\t'constraints'\t =>\t[],\n\t\t'optional'\t => \t( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'optional' ) ? 1 : 0\n\t\t};\n\tpush @{ $class->{'graph_patterns_pointer'} }, $#{$class->{'graphPatterns'}};\n\n        while( PatternElement $class ) {\n\t\tMatchAndEat $class,',';\n\t\t};\n\n\tpop @{ $class->{'graph_patterns_pointer'} };\n\t};\n\nsub PatternElement($) {\n\tmy($class) = @_;\n\n\tif( TriplePattern $class ) {\n\t} elsif( GroupGraphPattern $class ) {\n\t} elsif( SourceGraphPattern $class ) {\n\t} elsif( OptionalGraphPattern $class ) {\n\t} elsif( MatchAndEat $class,'and' ) {\n\t\tConstraint $class;\n\n\t\t$class->{'graphPatterns'}->[$#{$class->{'graphPatterns'}}]->{'constraints_optional'} = ( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'optional' ) ? 1 : 0;\n\t} else {\n\t\treturn 0;\n\t\t};\n\treturn 1;\n\t};\n\nsub GroupGraphPattern($) {\n\tmy($class) = @_;\n\n\tif( MatchAndEat $class,'{' ) {\n\t\tGraphPattern $class;\n\n\t\terror $class,\"missing right brace\"\n\t\t\tunless( MatchAndEat $class,'}' );\n\n\t\tpush @{$class->{'graphPatterns'}}, 'AND';\n\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t\t};\n\t};\n\nsub SourceGraphPattern($) {\n\tmy($class) = @_;\n\n\tif( MatchAndEat $class,'graph' ) {\n\t\tpush @{ $class->{'context'} }, 'named_graph';\n\n\t\terror $class,\"malformed GRAPH clause\"\n\t\t\tunless( VarOrURIOrQName $class ); \n\n\t\tPatternElement $class;\n\n\t\tdelete($class->{'graph_name'});\n\n\t\tpop @{ $class->{'context'} };\n\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t\t};\n\t};\n\nsub OptionalGraphPattern($) {\n\tmy($class) = @_;\n\n\tif( MatchAndEat $class,'optional' ) {\n\t\tpush @{ $class->{'context'} }, 'optional';\n\n\t\tPatternElement $class;\n\n\t\tpop @{ $class->{'context'} };\n\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t\t};\n\t};\n\nsub TriplePattern($) {\n\tmy($class) = @_;\n\n\tif( MatchAndEat $class,'(' ) {\n\t\t$class->{triple_pattern}=[ ( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'optional' ) ? 1 : 0 ];\n\n\t\tpush @{ $class->{'context'} }, 'triples';\n\n\t\terror $class,\"malformed subject variable, URI or QName\"\n\t\t\tunless VarOrURIOrQName $class; \n\n\t\tMatchAndEat $class,',';\n\t\terror $class,\"malformed predicate variable, URI or QName\"\n\t\t\tunless VarOrURIOrQName $class; \n\n\t\tMatchAndEat $class,',';\n\t\terror $class,\"malformed object variable, URI, QName or literal\"\n\t\t\tunless VarOrURIOrQNameOrLiteral $class; \n\n\t\tMatchAndEat $class,',';\n\t\tunless( VarOrURIOrQNameOrLiteral $class ) { \n\t\t\tpush @{$class->{triple_pattern}}, $class->{'graph_name'}\n\t\t\t\tif( exists $class->{'graph_name'} );\n\t\t\t};\n\n\t\terror $class,\"missing right round bracket\"\n\t\t\tunless( MatchAndEat $class,')' );\n\n\t\tif(\t( ( $#{ $class->{'context'} } - 1 ) >= 0 ) and\n\t\t\t$class->{'context'}->[ $#{ $class->{'context'} } - 1 ] eq 'construct' and\n\t\t\t$class->{constructPatterns}->[0] ne '*' ) {\n\t\t\tpush @{$class->{constructPatterns}}, $class->{triple_pattern};\n\t\t} else {\n\t\t\tpush @{$class->{'graphPatterns'}->[ $class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}] ]->{triplePatterns}}, $class->{triple_pattern};\n\t\t\t};\n\n\t\tdelete($class->{triple_pattern});\n\n\t\tpop @{ $class->{'context'} };\n\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t\t};\n\t};\n\nsub VarOrURIOrQName($) {\n\tmy($class) = @_;\n\n\treturn ( Var $class or URIOrQName $class );\n};\n\nsub VarOrURIOrQNameOrLiteral($) {\n\tmy($class) = @_;\n\n\treturn ( Var $class or URIOrQName $class or Literal $class );\n};\n\nsub Prefixes($) {\n\tmy($class) = @_;\n\n\twhile( PrefixDecl $class ) {\n\t\tMatchAndEat $class,',';\n\t\t};\n};\n\nsub PrefixDecl($) {\n\tmy($class) = @_;\n\tif($class->{'query_string'} =~ s/^\\s*(\\w[\\w\\d]*)?:\\s+\\<([A-Za-z][^>]*)\\>\\s*//i) {\n\t\treturn 0\n\t\t\tif( $1 eq 'fn' or $1 eq 'op'); \n\t\t$class->{prefixes}->{ ($1) ? $1 : '#default' }=$2;\n\t\treturn 1;\n\t} elsif($class->{'query_string'} =~ s/^\\s*(\\w[\\w\\d]*)\\s+FOR\\s+\\<([A-Za-z][^>]*)\\>\\s*//i) {\n\t\treturn 0\n\t\t\tif(\t( $1 eq 'fn' and $2 ne $class->{prefixes}->{'fn'} ) or\n\t\t\t\t( $1 eq 'op' and $2 ne $class->{prefixes}->{'op'} ) ); \n\t\t$class->{prefixes}->{$1}=$2;\n\t\treturn 1;\n\t\t};\n\treturn 0;\n\t};\n\nsub Constraint($) {\n\tmy($class) = @_;\n\n\tpush @{ $class->{'context'} }, 'constraints';\n\n\tConditionalOrExpression $class;\n\twhile(  MatchAndEat $class,',' or\n                MatchAndEat $class,'and') {\n                ConditionalOrExpression $class;\n        \t};\n\n\tpop @{ $class->{'context'} };\n\t};\n\nsub ConditionalOrExpression($) {\n\tmy($class) = @_;\n\n\tConditionalAndExpression $class;\n\twhile( MatchAndEat $class,'||' ) {\n\t\tConditionalAndExpression $class;\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n\t\t\tpush @{ $class->{'order_by'} }, '||';\n\t\t} else {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '||';\n\t\t\t};\n\t};\n};\n\nsub ConditionalAndExpression($) {\n\tmy($class) = @_;\n\n\tStringEqualityExpression $class;\n\twhile( MatchAndEat $class,'&&' ) {\n\t\tStringEqualityExpression $class;\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                        push @{ $class->{'order_by'} }, '&&';\n                } else {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '&&';\n                        };\n\t};\n};\n\nsub StringEqualityExpression($) {\n\tmy($class) = @_;\n\n\tEqualityExpression $class;\n\tmy $true=1;\n\twhile( $true ) {\n\t\tif( MatchAndEat $class,'eq' ) {\n\t\t\tEqualityExpression $class;\n\t\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                        \tpush @{ $class->{'order_by'} }, 'eq';\n                \t} else {\n\t\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, 'eq';\n                        \t};\n\t\t} elsif( MatchAndEat $class,'ne' ) {\n\t\t\tEqualityExpression $class;\n\t\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                        \tpush @{ $class->{'order_by'} }, 'ne';\n                \t} else {\n\t\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, 'ne';\n                        \t};\n\t\t} elsif(\t( MatchAndEat $class,'=~' ) ||\n\t\t\t\t( MatchAndEat $class,'LIKE' ) ) { \n\t\t\tPatternLiteral $class; \n\t\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                        \tpush @{ $class->{'order_by'} }, '=~';\n                \t} else {\n\t\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '=~';\n                        \t};\n\t\t} elsif( MatchAndEat $class,'!~' ) {\n\t\t\tPatternLiteral $class; \n\t\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                        \tpush @{ $class->{'order_by'} }, '!~';\n                \t} else {\n\t\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '!~';\n                        \t};\n\t\t} else {\n\t\t\t$true=0;\n\t\t};\n\t};\n};\n\nsub PatternLiteral($) {\n\tmy($class) = @_;\n\n\tif( $class->{'query_string'} =~ s/([m]?\\/(.*)\\/[i]?[m]?[s]?[x]?)// ) {\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'constraints' ) {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, $1;\n\t\t} elsif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                       \tpush @{ $class->{'order_by'} }, $1;\n                        };\n\t\t};\n\t};\n\nsub EqualityExpression($) {\n\tmy($class) = @_;\n\n\tRelationalExpression $class;\n\tmy $true=1;\n\twhile( $true ) {\n\t\tif( MatchAndEat $class,'==' ) {\n\t\t\tRelationalExpression $class;\n\t\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                       \t\tpush @{ $class->{'order_by'} }, '==';\n                \t} else {\n\t\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '==';\n                        \t};\n\t\t} elsif( MatchAndEat $class,'!=' ) {\n\t\t\tRelationalExpression $class;\n\t\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                       \t\tpush @{ $class->{'order_by'} }, '!=';\n                \t} else {\n\t\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '!=';\n                        \t};\n\t\t} else {\n\t\t\t$true=0;\n\t\t};\n\t};\n};\n\nsub RelationalExpression($) {\n\tmy($class) = @_;\n\n\tAdditiveExpression $class;\n\tif( MatchAndEat $class,'>=' or MatchAndEat $class,'>=' ) {\n\t\tAdditiveExpression $class;\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                \tpush @{ $class->{'order_by'} }, '>=';\n                } else {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '>=';\n                       \t};\n\t} elsif( MatchAndEat $class,'<=' or MatchAndEat $class,'<=' ) {\n\t\tAdditiveExpression $class;\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                \tpush @{ $class->{'order_by'} }, '<=';\n                } else {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '<=';\n                       \t};\n\t} elsif( MatchAndEat $class,'<' ) {\n\t\tAdditiveExpression $class;\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                \tpush @{ $class->{'order_by'} }, '<';\n                } else {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '<';\n                       \t};\n\t} elsif( MatchAndEat $class,'>' ) {\n\t\tAdditiveExpression $class;\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                \tpush @{ $class->{'order_by'} }, '>';\n                } else {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '>';\n                       \t};\n\t};\n};\n\nsub AdditiveExpression($) {\n\tmy($class) = @_;\n\n\tMultiplicativeExpression $class;\n\tmy $true=1;\n\twhile( $true ) {\n\t\tif( MatchAndEat $class,'+' ) {\n\t\t\tMultiplicativeExpression $class;\n\t\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                \t\tpush @{ $class->{'order_by'} }, '+';\n                \t} else {\n\t\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '+';\n                       \t\t};\n\t\t} elsif( MatchAndEat $class,'-' ) {\n\t\t\tMultiplicativeExpression $class;\n\t\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                \t\tpush @{ $class->{'order_by'} }, '-';\n                \t} else {\n\t\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '-';\n                       \t\t};\n\t\t} else {\n\t\t\t$true=0;\n\t\t};\n\t};\n};\n\nsub MultiplicativeExpression($) {\n\tmy($class) = @_;\n\n\tUnaryExpression $class;\n\tmy $true=1;\n\twhile( $true ) {\n\t\tif( MatchAndEat $class,'*' ) {\n\t\t\tUnaryExpression $class;\n\t\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                \t\tpush @{ $class->{'order_by'} }, '*';\n                \t} else {\n\t\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '*';\n                       \t\t};\n\t\t} elsif( MatchAndEat $class,'/' ) {\n\t\t\tUnaryExpression $class;\n\t\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                \t\tpush @{ $class->{'order_by'} }, '/';\n                \t} else {\n\t\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '/';\n                       \t\t};\n\t\t} elsif( MatchAndEat $class,'%' ) {\n\t\t\tUnaryExpression $class;\n\t\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                \t\tpush @{ $class->{'order_by'} }, '%';\n                \t} else {\n\t\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '%';\n                       \t\t};\n\t\t} else {\n\t\t\t$true=0;\n\t\t};\n\t};\n};\n\nsub UnaryExpression($) {\n\tmy($class) = @_;\n\n\tUnaryExpressionNotPlusMinus $class;\n};\n\nsub UnaryExpressionNotPlusMinus($) {\n\tmy($class) = @_;\n\n\tif( MatchAndEat $class,'~' ) {\n\t\tUnaryExpression $class;\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                \tpush @{ $class->{'order_by'} }, '~';\n                } else {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '~';\n                       \t};\n\t} elsif ( MatchAndEat $class,'!' ) {\n\t\tUnaryExpression $class;\n\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                \tpush @{ $class->{'order_by'} }, '!';\n                } else {\n\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, '!';\n                       \t};\n\t} else {\n\t\tPrimaryExpression $class;\n\t};\n};\n\nsub PrimaryExpression($) {\n\tmy($class) = @_;\n\n\tif( MatchAndEat $class,'(' ) {\n\n\t\tConditionalOrExpression $class;\n\n\t\terror $class,\"missing right round bracket\"\n\t\t\tunless( MatchAndEat $class,')' );\n\n\t} else {\n\t\tunless(\tVar $class or URIOrQName $class or Literal $class ) {\n\t\t\tFunctionCall $class;\n\t\t};\n\t};\n};\n\nsub FunctionCall($) {\n\tmy($class) = @_;\n\n\tif(\t( MatchAndEat $class,'&' ) &&\n\t\t($class->{'query_string'} =~ s/^\\s*([a-zA-Z0-9\\-_$\\.]+)?:([a-zA-Z0-9\\-_$\\.]+)\\s*//) ) {\n\n\t\tmy $qn;\n\t\tif( exists $class->{'prefixes'}->{ ($1) ? $1 : '#default' } ) {\n\t\t\t$qn = $class->{'prefixes'}->{ ($1) ? $1 : '#default' } . $2 ;\n\t\t} else {\n\t\t\terror $class,\"Unsupported function call $1:$2\";\n\t\t\t};\n\n\t\tif( MatchAndEat $class,'(' ) {\n\n\t\t\tArgList $class;\n\n\t\t\terror $class,\"missing right round bracket\"\n\t\t\t\tunless( MatchAndEat $class,')' );\n\n\t\t\tif( $class->{'context'}->[ $#{ $class->{'context'} } ] eq 'order by' ) {\n                \t\tpush @{ $class->{'order_by'} }, ( '&', $qn );\n                \t} else {\n\t\t\t\tpush @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }, ( '&', $qn );\n                       \t\t};\n\t\t\t};\n\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n                };\n\t};\n\nsub ArgList($) {\n\tmy($class) = @_;\n\n\tif( Var $class or URIOrQName $class or Literal $class ) {\n\t\tmy $true=1;\n\t\twhile( $true ) {\n\t\t\tif( MatchAndEat $class,',' ) {\n\n\t\t\t\tunless( Var $class or URIOrQName $class or Literal $class ) {\n\t\t\t\t\t$true=0;\n\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t$true=0;\n\t\t\t};\n\t\t};\n\t};\n};\n\nsub getQueryType {\n\tmy($class) = @_;\n\n\treturn $class->{'queryType'};\n\t};\n\nsub serialize {\n\tmy($class, $fh, $syntax) = @_;\n\n\tif(\t(! $syntax ) ||\n                ( $syntax =~ m/N-Triples/i) ) {\n                return\n\t\t\tif($#{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{constraints} }>=0);\n\t\tforeach my $tp ( @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{triplePatterns} } ) {\n\t\t\treturn\n\t\t\t\tif( ($#{$tp}==3) || \n\t\t\t            (     ($tp->[2] =~ m/^%/) && \n                                          ($tp->[2] =~ m/%$/) ) );\n\t\t\t};\n\n\t\tmy @nt;\n\t\tforeach my $tp ( @{ $class->{'graphPatterns'}->[$class->{'graph_patterns_pointer'}->[$#{$class->{'graph_patterns_pointer'}}]]->{triplePatterns} } ) {\n\t\t\tmy @tp;\n\t\t\tmap {\n\t\t\t\tmy $ff = $class->{'query_string'};\n\t\t\t\t$ff =~ s/^[\\?\\$](.+)$/_:$1/;\n\t\t\t\t$ff =~ s/[\\$:]/-/g;\n\t\t\t\tif(\t($ff =~ m/^<(([^\\:]+)\\:{1,2}([^>]+))>$/) &&\n\t\t\t\t\t(defined $2) &&\n\t\t\t\t\t(exists $class->{prefixes}->{$2}) ) {\n\t\t\t\t\tpush @tp, '<'.$class->{prefixes}->{$2}.$3.'>';\n\t\t\t\t} else {\n\t\t\t\t\tpush @tp, $ff;\n\t\t\t\t\t};\n\t\t\t} @{$tp};\n\t\t\tpush @tp, '.';\n\t\t\tpush @nt, join(' ',@tp);\n\t\t\t};\n\t\tif($fh) {\n\t\t\tprint $fh join(\"\\n\",@nt);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn join(\"\\n\",@nt);\n\t\t\t};\n        } else {\n                croak \"Unknown serialization syntax '$syntax'\";\n                };\n\t};\n\nsub DESTROY {\n\tmy($class) = @_;\n\n};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDQL/Parser.pm",
      "package" : "RDQL::Parser"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n\nuse Carp;\n \n$VERSION = '0.1';\n\nuse Storable qw ( thaw nfreeze ); \n\n$Util::BLOB::Storable_magicnumber = nfreeze(\\'_blob_:');\n$Util::BLOB::Storable_magicnumber_unpacked = unpack(\"H*\", $Util::BLOB::Storable_magicnumber );\nsub deserialise {\n\tmy ($content) = @_;\n\n\tif ($content =~ s/^$Util::BLOB::Storable_magicnumber_unpacked//) {\n\t\t$content = pack(\"H*\", $content );\n        \teval {\n        \t\t$Storable::canonical=1;\n                \t$content = thaw($content);\n        \t\t$Storable::canonical=0;\n                \t};\n                if($@) {\n                \twarn \"Util::BLOB::deserialise: \".$@;\n                        return;\n                        };\n\t\t};\n\treturn $content;\n\t};\n\nsub serialise {\n\tmy ($value) = @_;\n   \n        if(     (defined $value) &&\n                (ref($value)) ) {\n                eval {\n        \t\t$Storable::canonical=1;\n                \t$value = $Util::BLOB::Storable_magicnumber . nfreeze( $value );\n        \t\t$Storable::canonical=0;\n                \t};\n                if($@) {\n                \twarn \"Util::BLOB::serialise: \".$@;\n                        return;\n                        };\n\t\t$value = unpack(\"H*\", $value );\n                };\n\treturn $value;\n        };\n\nsub isBLOB {\n\tmy ($content) = @_;\n\n        if(     (defined $content) &&\n                (ref($content)) ) {\n\t\treturn 1;\n\t} else {\n\t\treturn ($content =~ /^$Util::BLOB::Storable_magicnumber_unpacked/);\n\t\t};\n\t};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/Util/BLOB.pm",
      "package" : "Util::BLOB"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION $AUTOLOAD);\nuse strict;\nuse Carp;\n \n$VERSION = '0.1';\n\nuse RDFStore::Resource;\nuse RDFStore::Model;\nuse RDFStore::Vocabulary::RDF;\nuse RDFStore::Vocabulary::RDFStoreContext;\nuse RDFStore::Statement;\n\n@RDFStore::Object::ISA = qw( RDFStore::Resource ); \n\n%RDFStore::Object::default_prefixes = (\n        'rdf' => { 'namespace' => 'http://www.w3.org/1999/02/22-rdf-syntax-ns#' },\n        'rdfs' => { 'namespace' => 'http://www.w3.org/2000/01/rdf-schema#' },\n        'rss' => { 'namespace' => 'http://purl.org/rss/1.0/' },\n        'daml' => { 'namespace' => 'http://www.daml.org/2001/03/daml+oil#' },\n        'dc' => { 'namespace' => 'http://purl.org/dc/elements/1.1/' },\n        'dcq' => { 'namespace' => 'http://purl.org/dc/terms/' },\n        'foaf' => { 'namespace' => 'http://xmlns.com/foaf/0.1/' },\n        'xsd' => { 'namespace' => 'http://www.w3.org/2001/XMLSchema#' },\n        'owl' => { 'namespace' => 'http://www.w3.org/2002/07/owl#' }\n        );\n\nsub new {\n        my ($pkg, $namespace, $localname, $bnode) = @_;\n\n\tmy $self={ 'prefixes' =>  {}, 'schemas' => {}, 'types' => [] };\n\n        map {\n\t\tmy $x = $_;\n                $self->{ 'prefixes' }->{ $x } = {};\n\n\t\tmap {\n                \t$self->{ 'prefixes' }->{ $x }->{ $_ } = $RDFStore::Object::default_prefixes{ $x }->{ $_ };\n\t\t} keys %{ $RDFStore::Object::default_prefixes{ $x } };\n        } keys %RDFStore::Object::default_prefixes;\n\n\tif( $namespace ) {\n\t\t$self->{'rdf_object'} = $pkg->SUPER::new( $namespace, $localname, $bnode );\n\t} else {\n\t\t$self->{'rdf_object'} = _createbNode( $self );\n\t\t};\n\n\tbless $self, $pkg;\n\t};\n\nsub _createbNode {\n\tmy ($class) = @_;\n\n        $class->{'bnodesCounter'} = 0\n\t\tunless( exists $class->{'bnodesCounter'});\n\t\n        $class->{'timestamp'} = time()\n\t\tunless( exists $class->{'timestamp'});\n\n        $class->{'rand_seed'} = unpack(\"H*\", rand())\n\t\tunless( exists $class->{'rand_seed'});\n\n\treturn new RDFStore::Resource(\n\t\t\t'rdf:object:genidrdfstore' .\n                        'S'.$class->{'rand_seed'} .\n                        'P'. $$.\n                        'T'. $class->{'timestamp'} .\n\t\t\t'N'. $class->{bnodesCounter}++, undef, 1 );\n\t};\n\nsub export {\n\tmy ($class, @prefixes) = @_;\n\n\tfor my $prefix (@prefixes)  {\n\t\tcroak \"Can't find prefix $prefix - perhaps need to call define() method before?\"\n\t\t\tunless(exists $class->{'prefixes'}->{ $prefix });\n\n\t\tno strict;\n\t\t*{\"$prefix\\::AUTOLOAD\"} = sub {\n\t\t\tmy $object = shift;\n\t\t\t(my $prop = $AUTOLOAD) =~ s/^.*:://o;\n\t\t\tif (ref($object)) {\n\t\t\t\t$object->set_or_get( \"$prefix:$prop\", @_ );\n\t\t\t} else {\n\t\t\t\treturn \"$prefix$prop\";\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t};\n\nsub getNamespace {\n\treturn $_[0]->{'rdf_object'}->getNamespace;\n\t};\n\nsub getLocalName {\n\treturn $_[0]->{'rdf_object'}->getLocalName;\n\t};\n\nsub getbNode {\n\treturn $_[0]->{'rdf_object'}->getbNode;\n\t};\n\nsub getLabel {\n\treturn $_[0]->{'rdf_object'}->getLabel;\n\t};\n\nsub getDigest {\n\treturn $_[0]->{'rdf_object'}->getDigest;\n\t};\n\nsub isbNode {\n\treturn $_[0]->{'rdf_object'}->isAnonymous;\n\t};\n\nsub getURI {\n\treturn\n\t\tif($_[0]->{'rdf_object'}->isAnonymous); \n\n\treturn $_[0]->{'rdf_object'}->getLabel;\n\t};\n\nsub getNodeID {\n        return\n                unless($_[0]->{'rdf_object'}->isAnonymous);\n\n        return $_[0]->{'rdf_object'}->getLabel;\n\t};\n\nsub setDomain {\n\tmy ($class, $context) = @_;\n\n\t$class->connect\n\t\tunless($class->isConnected);\n\n\n\t};\n\nsub resetDomain {\n\t};\n\nsub connect {\n\tmy ($class, $model) = @_;\n\n\tif($model and ref($model) and $model->isa(\"RDFStore::Model\")) {\n\t\tif(exists $class->{'model'}) {\n\t\t\tmy $stuff = $class->{'model'}->elements;\n\t\t\twhile ( my $st = $stuff->each ) {\n\t\t\t\t$model->add($st);\n\t\t\t\t};\n\t\t\t};\n\t\t$class->{'model'} = $model;\n\t} elsif($model) {\n\t\t$class->{'model'} = new RDFStore::Model( 'Name' => $model ); \n\t} else {\n\t\t$class->{'model'} = new RDFStore::Model\n\t\t\tunless(exists $class->{'model'}); \n\t\t};\n\n\treturn $class->{'model'};\n\t};\n\nsub disconnect {\n\tmy ($class) = @_;\n\n\tmy $model = new RDFStore::Model; \n\n\tif(exists $class->{'model'}) {\n\t\tmy $stuff = $class->{'model'}->elements;\n\t\twhile ( my $st = $stuff->each ) {\n\t\t\t$model->add($st); \n\t\t\t};\n\t\t};\n\t$class->{'model'} = $model;\n\n\treturn $class->{'model'};\n\t};\n\nsub connection {\n\treturn $_[0]->{'model'};\n\t};\n\nsub isConnected {\n\treturn (exists $_[0]->{'model'});\n\t};\n\nsub deanonymize {\n\tmy ($class, $uri) = @_;\n\n        return\n                unless( $class->{'rdf_object'}->isAnonymous and (! $uri->isAnonymous ) );\n\n\t};\n\nsub anonymize {\n\tmy ($class) = @_;\n\t};\n\nsub define {\n\tmy ($class, %prefixes) = @_;\n\n\tmap {\n        \t$class->{ 'prefixes' }->{ $_ } = $prefixes{ $_ };\n\t} %prefixes;\n\n\tmap {\n\t\tmy $x = $_;\n                $class->{ 'prefixes' }->{ $x } = {}\n\t\t\tunless(exists $class->{ 'prefixes' }->{ $x });\n\n\t\tmy ($content_type, $URI);\n\t\tmap {\n                \t$class->{ 'prefixes' }->{ $x }->{ $_ } = $prefixes{ $x }->{ $_ };\n\t\t\t$content_type = $prefixes{ $x }->{ $_ }\n\t\t\t\tif( $_ eq 'content_type' );\n\t\t\t$URI = $prefixes{ $x }->{ $_ }\n\t\t\t\tif( $_ eq 'URI' );\n\t\t} keys %{ $prefixes{ $x } };\n\n\t\tif( $URI and $content_type ) {\n\t\t\tmy $schema;\n\t\t\teval {\n\t\t\t\t$schema = new RDFStore::Model; \n\t\t\t\t$schema->setContext( $schema->getNodeFactory->createResource( $URI ) );\n\t\t\t\tmy $p = $schema->getReader( $content_type );\n\t\t\t\t$p->parsefile( $URI );\n\t\t\t\t};\n\t\t\tif($@) {\n\t\t\t\tprint STDERR $@;\n\t\t\t\treturn 0;\n\t\t\t\t};\n\t\t\t$class->{ 'prefixes' }->{ $x }->{ 'schema' } = $schema;\n\t\t\t};\n        \t} keys %prefixes;\n\n\treturn 1;\n\t};\n\nsub load {\n\tmy ($class, $input, $syntax) = @_;\n\n\t$class->connect\n\t\tunless($class->isConnected);\n\n\tmy $parser = $class->{'model'}->getReader($syntax);\n\n\treturn\n\t\tunless($parser);\n\n\tif (ref($input) and UNIVERSAL::isa($input, 'RDFStore::Model')) {\n\t\tmy $elements = $input->elements;\n\t\twhile ( my $st = $elements->each ) {\n\t\t\t$class->{'model'}->add( $st );\n\t\t\t};\n\t} elsif (ref($input) and UNIVERSAL::isa($input, 'IO::Handle')) {\n\t\t$parser->readstream( $input );\n\t} else {\n\t\tmy $uri = new URI( $input );\n\t\tif($uri) {\n\t\t\t$parser->readfile( $uri );\n\t\t} else {\n\t\t\t$parser->readstring( $input );\n\t\t\t};\n\t\t};\n\t};\n\nsub set_or_get {\n\tmy ($class, $property, @vals) = @_;\n\n\tif (@vals) {\n\t\t$class->set( $property => shift @vals);\n\t} else {\t\n\t\treturn $class->get($property);\n\t\t};\n\t};\n\nsub set {\n\tmy ($class, %values) = @_;\n\n\t$class->connect\n\t\tunless($class->isConnected);\n\n\tforeach my $property_name ( keys %values ) {\n\t\t$property_name =~ m/^([^:]+):?(.*)/;\n\t\tmy $localname = ($2) ? $2 : $1;\n\t\tmy $namespace = $class->{ 'prefixes' }->{ $1 }->{ 'namespace' }\n\t\t\tif($2);\n\t\tunless(defined $namespace) {\n\t\t\tprint STDERR \"Can not set unknown property '$property_name'\\n\";\n\t\t\treturn;\n\t\t\t};\n\t\tmy $factory = $class->{'model'}->getNodeFactory;\n\t\tmy $property = $factory->createResource( $namespace, $localname );\n\n\t\tmy $property_value = $values{ $property_name };\n\n\t\tif( ref($property_value) and UNIVERSAL::isa($property_value, 'RDFStore::Resource') ) {\n\t\t\tpush @{ $class->{'types'} }, $property_value \n\t\t\t\tif($property->equals( $RDFStore::Vocabulary::RDF::type ));\n\n\n\t\t\t$property_value = $property_value->{'rdf_object'} \n\t\t\t\tif( ref($property_value) and UNIVERSAL::isa($property_value, 'RDFStore::Object') );\n\t\t} else {\n\t\t\tif( ref($property_value) =~ /HASH/ ) {\n\t\t\t\tmy $sub_values =  $property_value;\n\t\t\t\t$property_value = new RDFStore::Object; \n\t\t\t\t$property_value->connect( $class->connection ); \n\t\t\t\t\n\t\t\t\t$property_value->set( %{$sub_values} ); \n\t\t\t\t$property_value = $property_value->{'rdf_object'};\n\t\t\t} elsif( ref($property_value) =~ /ARRAY/ ) {\n\t\t\t\tmy $array_of_values =  $property_value;\n\n\t\t\t\t$property_value = new RDFStore::Object; \n\t\t\t\t$property_value->connect( $class->connection ); \n\t\t\t\t\n\t\t\t\tmy %sub_values=();\n\t\t\t\tmy $i=1;\n\t\t\t\tmap {\n\t\t\t\t\t$sub_values{ 'rdf:_' . $i++ } = $_;\n\t\t\t\t} @{$array_of_values};\n\n\t\t\t\t$property_value->set( %sub_values );\n\t\t\t\t$property_value = $property_value->{'rdf_object'};\n\t\t\t} else {\n\t\t\t\t$property_value = $factory->createLiteral( $property_value );\n\t\t\t\t};\n\t\t\t};\n\n\t\t$class->{'model'}->add( $class->{'rdf_object'}, $property, $property_value ); \n\t\t};\n\t};\n\nsub get {\n\tmy ($class, $property_name) = @_;\n\t \n\t$class->connect\n\t\tunless($class->isConnected);\n\n\t$property_name =~ m/^([^:]+):?(.*)/;\n\tmy $localname = ($2) ? $2 : $1;\n\tmy $namespace = $class->{ 'prefixes' }->{ $1 }->{ 'namespace' }\n\t\tif($2);\n\tunless(defined $namespace) {\n\t\tprint STDERR \"Can not get unknown property '$property_name'\\n\";\n\t\treturn;\n\t\t};\n\n\tmy $factory = $class->{'model'}->getNodeFactory;\n\n\treturn\n\t\tunless($factory);\n\n\tmy $property = $factory->createResource( $namespace, $localname );\n\n\treturn\n\t\tunless($property);\n\n\tmy $values = $class->{'model'}->find( $class->{'rdf_object'}, $property )->elements;\n\n\n\tmy @values;\n\twhile( my $object = $values->each_object ) {\n\t\tpush @values, $object;\n\t\t};\n\n\treturn wantarray ? @values : $values[0];\n\t};\n\nsub dump {\n\tmy($class) = shift;\n\n\t$class->serialize(@_);\n\t};\n\nsub serialize {\n\tmy ($class, $fh, $syntax, $namespaces, $base ) = @_;\n\n\t$class->connect\n\t\tunless($class->isConnected);\n\n\tmy %namespaces = ();\n\tmap {\n\t\t$namespaces{ $class->{'prefixes'}->{ $_ }->{'namespace'} } = $_;\n\t} keys %{ $class->{'prefixes'} };\n\n\treturn $class->{'model'}->serialize( $fh, $syntax, \\%namespaces, $base );\n\t};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Object.pm",
      "package" : "RDFStore::Object"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ( $VERSION %Built_In_Styles );\nuse strict;\n \n$VERSION = '0.2';\n\nuse Carp;\n\neval { require LWP::UserAgent; };\n$RDFStore::Parser::hasLWPUserAgent = ($@) ? 0 : 1;\n\nsub new {\n\tmy ($pkg, %args) = @_;\n\n        my $style = $args{Style};\n\n\tmy $nonexopt = $args{Non_Expat_Options} ||= {};\n\n        $nonexopt->{Style}             = 1;\n        $nonexopt->{Non_Expat_Options} = 1;\n        $nonexopt->{Handlers}          = 1;\n        $nonexopt->{_HNDL_TYPES}       = 1;\n\n        $args{_HNDL_TYPES} = {};\n        $args{_HNDL_TYPES}->{Init} = 1;\n        $args{_HNDL_TYPES}->{Assert} = 1;\n        $args{_HNDL_TYPES}->{Start_XML_Literal} = 1;\n        $args{_HNDL_TYPES}->{Stop_XML_Literal} = 1;\n        $args{_HNDL_TYPES}->{Char_Literal} = 1;\n\t$args{_HNDL_TYPES}->{manage_bNodes} = 1; \n        $args{_HNDL_TYPES}->{Final} = 1;\n\n\t$args{'warnings'} = [];\n\n        $args{'Handlers'} ||= {};\n        my $handlers = $args{'Handlers'};\n        if (defined($style)) {\n                my $stylepkg = $style;\n                if ($stylepkg !~ /::/) {\n                        $stylepkg = \"\\u$style\";\n                        croak \"Undefined style: $style\" \n                                unless defined($Built_In_Styles{$stylepkg});\n                        $stylepkg = 'RDFStore::Parser::NTriples::' . $stylepkg;\n                \t};\n\n                eval \"use $stylepkg;\";\n                if($@) {\n                        warn \"Cannot load parser style '$stylepkg'\" if($pkg->{Warnings});\n                        exit(1);\n                        };\n\n                my $htype;\n                foreach $htype (keys %{$args{_HNDL_TYPES}}) {\n                        unless (defined($handlers->{$htype})) {\n                                my $hname = \"${stylepkg}::$htype\";\n                                if (defined(&$hname)) {\n                                        $handlers->{$htype} = \\&$hname;\n                                        next;\n                                \t};\n                                $hname = \"${stylepkg}::\\L$htype\";\n                                if (defined(&$hname)) {\n                                        $handlers->{$htype} = \\&$hname;\n                                        next;\n                                \t};\n                        \t};\n                \t};\n        \t};\n        $args{Pkg} ||= caller;\n\n\t$args{'options'} = {};\n\n\t$args{'_Source'} = 'STDIN:';\n\n        bless \\%args, $pkg;\n\t};\n\nsub setProperty {\n\tmy ($class, $name, $value) = @_;\n\t\n\t$class->{'options'}->{ $name } = $value;\n\t};\n\nsub getProperty {\n\tmy ($class, $name) = @_;\n\t\n\treturn $class->{'options'}->{ $name };\n\t};\n\nsub setHandlers {\n        my ($class, @handler_pairs) = @_;\n\n        croak(\"Uneven number of arguments to setHandlers method\") \n                if (int(@handler_pairs) & 1);\n\n        my @ret;\n        while (@handler_pairs) {\n                my $type = shift @handler_pairs;\n                my $handler = shift @handler_pairs;\n                unless (defined($class->{_HNDL_TYPES}->{$type})) {\n                        my @types = sort keys %{$class->{_HNDL_TYPES}};\n                        croak(\"Unknown Parser handler type: $type\\n Valid types are : @types\");\n                \t};\n                push(@ret, $type, $class->{Handlers}->{$type});\n                $class->{Handlers}->{$type} = $handler;\n        \t};\n\n        return @ret;\n\t};\n\nsub setSource {\n        my ($class,$file_or_uri)=@_;\n\n\t$class->{'_Source'} = $file_or_uri\n\t\tif(defined $file_or_uri);\n\n        return $file_or_uri;\n\t};\n\nsub getSource {\n\treturn $_[0]->{'_Source'};\n\t};\n\nsub parse { };\n\nsub parsestring { };\n\nsub parsestream { };\n\nsub parsefile {\n\tmy ($class) = shift;\n\n\t$class->setSource( $_[0] );\n\t};\n\nsub read {\n\tmy ($class) = shift;\n\n\t$class->parse( @_ );\n\t};\n\nsub readstring {\n\tmy ($class) = shift;\n\n\t$class->parsestring( @_ );\n\t};\n\nsub readstream {\n\tmy ($class) = shift;\n\n\t$class->parsestream( @_ );\n\t};\n\nsub readfile {\n\tmy ($class) = shift;\n\n\t$class->parsefile( @_ );\n\t};\n\nsub wget {\n        my ($class,$uri) = @_;\n\n        croak \"RDFStore::Parser::wget: input url is not an instance of URI\"\n                unless( (defined $uri) && ($uri->isa(\"URI\")) );\n\n        no strict;\n\n\tif($RDFStore::Parser::hasLWPUserAgent) {\n\t\tmy $ua = LWP::UserAgent->new( timeout => 60 );\n\n\t\tmy %headers = ( \"User-Agent\" => \"rdfstore\\@asemantics.com/$VERSION\" );\n\t\t$headers{'Accept'} = 'application/rdf+xml,application/xml;q=0.9,*/*;q=0.5'\n\t\t\tif($class->isa(\"RDFStore::Parser::SiRPAC\"));\n\n                my $response = $ua->get( $uri->as_string, %headers );\n\n                unless($response) {\n\t\t\tmy $msg = \"RDFStore::Parser::wget: Cannot HTTP GET $uri->as_string\\n\";\n\t\t\tpush @{ $class->{warnings} },$msg;\n\t\t\treturn;\n\t\t\t};\n\n                return $response->content;\n\t} else {\n        \trequire IO::Socket;\n\n        \tlocal($^W) = 0;\n        \tmy $sock = IO::Socket::INET->new(       PeerAddr => $uri->host,\n                                                \tPeerPort => $uri->port,\n                                                \tProto    => 'tcp',\n                                                \tTimeout  => 60) || return undef;\n        \t$sock->autoflush;\n        \tmy $netloc = $uri->host;\n        \t$netloc .= \":\".$uri->port if $uri->port != 80;\n\n        \tmy $path = $uri->as_string;\n\n        \tprint $sock join(\"\\015\\012\" =>\n                    \"GET $path HTTP/1.0\",\n                    \"Host: $netloc\",\n                    \"User-Agent: rdfstore\\@asemantics.com/$VERSION\",\n\t\t    ($class->isa(\"RDFStore::Parser::SiRPAC\")) ? \"Accept: application/rdf+xml,application/xml;q=0.9,*/*;q=0.5\" : \"\",\n                    \"\", \"\");\n\n        \tmy $line = <$sock>;\n\n\t\tif ($line !~ m,^HTTP/\\d+\\.\\d+\\s+(\\d\\d\\d)\\s+(.+)$,m) {\n                \tmy $msg = \"RDFStore::Parser::wget: (10 Did not get HTTP/x.x header back...$line\";\n                \tpush @{ $class->{warnings} },$msg;\n                \twarn $msg;\n                \treturn;\n                \t};\n        \tmy $status = $1;\n        \tmy $reason = $2;\n        \tif ( ($status != 200) && ($status != 302) ) {\n                \tmy $msg = \"Error MSG returned from server: $status $reason\\n\";\n                \tpush @{ $class->{warnings} },$msg;\n\n                \tprint $sock join(\"\\015\\012\" =>\n                                 \"GET $path HTTP/1.1\",\n                                 \"Host: $netloc\",\n                                 \"User-Agent: rdfstore\\@asemantics.com/$VERSION\",\n\t\t    \t\t($class->isa(\"RDFStore::Parser::SiRPAC\")) ? \"Accept: application/rdf+xml,application/xml;q=0.9,*/*;q=0.5\" : \"\",\n                                 \"Connection: close\",\n                                 \"\", \"\");\n\n                \t$line = <$sock>;\n\n                \tif ($line !~ m,^HTTP/\\d+\\.\\d+\\s+(\\d\\d\\d)\\s+(.+)$,m) {\n                        \tmy $msg = \"RDFStore::Parser::wget: Did not get HTTP/x.x header back...$line\";\n                        \tpush @{ $class->{warnings} },$msg;\n                        \twarn $msg;\n                        \treturn;\n                        \t};\n                \t$status = $3;\n                \t$reason = $4;\n\n\t\t\tif ( ($status != 200) && ($status != 302) ) {\n                        \tmy $msg = \"RDFStore::Parser::wget: Error MSG returned from server: $status $reason\\n\";\n                        \tpush @{ $class->{warnings} },$msg;\n                        \treturn;\n                        \t};\n                \t};\n\n        \twhile(<$sock>) {\n                \tchomp;\n                \tif( m,^Location:\\s(.*)$,) {\n                        \tif( (   (exists $class->{HTTP_Location}) &&\n                                \t(defined $class->{HTTP_Location}) && ($class->{HTTP_Location} ne $1)    ) || \n                                        (!(defined $class->{HTTP_Location})) ) {\n                                \t$class->{HTTP_Location} = $1;\n                                \tmy $s = $class->wget(new URI($class->{HTTP_Location}));\n                                \t$sock = $s\n                                        \tif(defined $s);\n                                \tlast;\n                                \t};\n                        \t};\n                \tlast if m/^\\s+$/;\n                \t};\n\n\t\tmy $content='';\n\t\twhile(<$sock>) {\n\t\t\t$content.=$_;\n\t\t\t};\n\n        \treturn $content;\n\t\t};\n        };\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Parser.pm",
      "package" : "RDFStore::Parser"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.41';\n\nuse Carp;\nuse RDFStore; \nuse RDFStore::RDFNode;\n\nsub isbNode {\n\treturn $_[0]->isAnonymous;\n};\n\nsub getURI {\n\treturn\n\t\tif($_[0]->isAnonymous); \n\n\treturn $_[0]->getLabel;\n};\n\nsub getNodeID {\n        return\n                unless($_[0]->isAnonymous);\n\n        return $_[0]->getLabel;\n\t};\n\nsub equals {\n\treturn 0\n                unless(defined $_[1]);\n\n\treturn 0\n                if ( ref($_[1]) =~ /^(SCALAR|ARRAY|HASH|CODE|REF|GLOB|LVALUE)/ ); \n\n\treturn 0\n\t\tunless(\t(defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n\t\t\t($_[1]->isa(\"RDFStore::Resource\")) );\n\n\treturn ( $_[0]->isAnonymous && $_[1]->isAnonymous ) ? ( $_[0]->getNodeID eq $_[1]->getNodeID ) : $_[0]->SUPER::equals($_[1])\n        \tif(\t($_[0]->isAnonymous) ||\n\t\t\t($_[1]->isAnonymous) );\n\n\tunless( $_[0]->getNamespace() ) {\n        \tunless($_[1]->getNamespace()) {\n\t\t\treturn ( $_[0]->getLocalName() eq $_[1]->getLocalName() ) ? 1 : 0;\n\t\t} else { \n\t\t\treturn ($_[0]->getLocalName() eq $_[1]->getURI()) ? 1 : 0;\n\t\t\t};\n\t} else {\n        \tif($_[1]->getNamespace()) {\n\t\t\treturn (\t( $_[0]->getLocalName() eq $_[1]->getLocalName() ) &&\n\t\t\t\t\t( $_[0]->getNamespace() eq $_[1]->getNamespace()) ) ? 1 : 0;\n\t\t} else { \n\t\t\treturn ($_[0]->getURI() eq $_[1]->getURI()) ? 1 : 0;\n\t\t\t};\n\t\t};\n        return $_[0]->SUPER::equals($_[1]);\n};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Resource.pm",
      "package" : "RDFStore::Resource"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.44';\n\nuse Carp;\n\nuse RDFStore;\nuse RDFStore::Digest::Digestable;\nuse RDFStore::Literal;\nuse RDFStore::Resource;\nuse RDFStore::Object;\nuse RDFStore::Statement;\nuse RDFStore::NodeFactory;\nuse RDFStore::Parser::SiRPAC;\nuse RDFStore::Parser::NTriples;\nuse RDFStore::Serializer::RDFXML;\nuse RDFStore::Serializer::NTriples;\nuse RDFStore::Util::Digest;\n\n@RDFStore::Model::ISA = qw( RDFStore::Resource RDFStore::Digest::Digestable );\n\nsub new {\n        my ($pkg,%params) = @_;\n \n        my $self = {};\n \n        $self->{nodeFactory}=(  (exists $params{nodeFactory}) &&\n                                (defined $params{nodeFactory}) &&\n                                (ref($params{nodeFactory})) &&\n                                ($params{nodeFactory}->isa(\"RDFStore::NodeFactory\")) ) ?\n                                $params{nodeFactory} : new RDFStore::NodeFactory();\n\n        $self->{options} = \\%params;\n\n\tmy @params = ();\n\t\n\tif (\t(exists $params{Name}) && \n\t\t(defined $params{Name}) ) {\n\t\tpush @params, $params{Name};\n\t} else {\n\t\tpush @params,undef;\n\t\t};\n\tif (\t(exists $params{Mode}) && \n\t\t(defined $params{Mode}) ) {\n\t\tpush @params, ($params{Mode} eq 'r') ? 1 : 0;\n\t} else {\n\t\tpush @params,0;\n\t\t};\n\tif (\t(exists $params{FreeText}) && \n\t\t(defined $params{FreeText}) ) {\n\t\tpush @params, ($params{FreeText} =~ /(1|on|yes|true)/i) ? 1 : 0;\n\t} else {\n\t\tpush @params,0;\n\t\t};\n\tif (\t(exists $params{Sync}) && \n\t\t(defined $params{Sync}) ) {\n\t\tpush @params, int($params{Sync});\n\t} else {\n\t\tpush @params,0;\n\t\t};\n\tif (\t(\t(exists $params{Host}) && \n\t\t\t(defined $params{Host}) ) ||\n\t\t(\t(exists $params{Port}) && \n\t\t\t(defined $params{Port}) ) ) {\n\t\tpush @params, 1;\n\t} else {\n\t\tpush @params, 0;\n\t\t};\n\tif (\t(exists $params{Host}) && \n\t\t(defined $params{Host}) ) {\n\t\tpush @params, $params{Host};\n\t} else {\n\t\tpush @params,undef;\n\t\t};\n\tif (\t(exists $params{Port}) && \n\t\t(defined $params{Port}) ) {\n\t\tpush @params, $params{Port};\n\t} else {\n\t\tpush @params,undef;\n\t\t};\n\n\t$self->{'rdfstore'} = new RDFStore( @params );\n\n        die \"Cannot connect rdfstore\"\n\t\tunless(\t(defined $self->{rdfstore}) &&\n\t\t\t(ref($self->{rdfstore})) &&\n\t\t\t($self->{rdfstore}->isa(\"RDFStore\")) );\n\n\t$self->{'rdfstore_params'} = \\%params;\n\n        bless $self,$pkg;\n\n\treturn $self;\n};\n\nsub setContext {\n\tmy ($class,$context)=@_;\n\n\t$class->{rdfstore}->set_context( $context );\n\t};\n\nsub resetContext {\n\tmy ($class)=@_;\n\n\t$class->{rdfstore}->reset_context;\n\t};\n\nsub getContext {\n\tmy ($class)=@_;\n\n\tmy $ctx = $class->{rdfstore}->get_context;\n\n\treturn\n\t\tunless($ctx);\n\n        return ($ctx->isbNode) ? $class->{nodeFactory}->createAnonymousResource($ctx->toString) : $class->{nodeFactory}->createResource($ctx->toString);\n\t};\n\nsub getOptions {\n\treturn %{$_[0]->{'options'}};\n\t};\n\nsub isAnonymous {\n        return 0;\n        };\n\nsub getNamespace {\n        return undef;\n\t};\n\nsub getLocalName {\n        return $_[0]->getURI();\n\t};\n\nsub toString {\n        return \"Model[\".$_[0]->getSourceURI().\"]\";\n\t};\n\nsub setSourceURI {\n\t$_[0]->{rdfstore}->set_source_uri( (\t(ref($_[1])) && ($_[1]->isa(\"RDFStore::Resource\")) ) ? $_[1]->toString : $_[1] );\n\t};\n\nsub getSourceURI {\n\t$_[0]->{rdfstore}->get_source_uri;\n\t};\n\n\nsub size {\n\tif(\t(exists $_[0]->{Shared}) &&\n\t\t(defined $_[0]->{Shared}) ) {\n\t\tif(exists $_[0]->{query_iterator}) {\n\t\t\treturn $_[0]->{query_iterator}->size;\n\t\t} else {\n\t\t\treturn $_[0]->{Shared}->size;\n\t\t\t};\n\t};\n\n        $_[0]->{rdfstore}->size;\n\t};\n\nsub isEmpty {\n\tif(\t(exists $_[0]->{Shared}) &&\n\t\t(defined $_[0]->{Shared}) ) {\n\t\tif(exists $_[0]->{query_iterator}) {\n\t\t\treturn ( $_[0]->{query_iterator}->size > 0 ) ? 0 : 1;\n\t\t} else {\n\t\t\treturn $_[0]->{Shared}->isEmpty;\n\t\t\t};\n\t\t};\n        $_[0]->{rdfstore}->is_empty;\n\t};\n\nsub isConnected {\n\tif(\t(exists $_[0]->{Shared}) &&\n\t\t(defined $_[0]->{Shared}) ) {\n\t\treturn $_[0]->{Shared}->isConnected;\n\t\t};\n        $_[0]->{rdfstore}->is_connected;\n\t};\n\nsub isRemote {\n\tif(\t(exists $_[0]->{Shared}) &&\n\t\t(defined $_[0]->{Shared}) ) {\n\t\treturn $_[0]->{Shared}->isRemote;\n\t\t};\n        $_[0]->{rdfstore}->is_remote;\n\t};\n\nsub ifModifiedSince {\n\tif(\t(exists $_[0]->{Shared}) &&\n\t\t(defined $_[0]->{Shared}) ) {\n\t\treturn $_[0]->{Shared}->ifModifiedSince( $_[1] );\n\t\t};\n\n\t&RDFStore::if_modified_since( $_[0]->{'rdfstore_params'}->{'Name'}, $_[1] );\n\t};\n\nsub elements {\n\tmy ($class) = @_;\n\n\tif(\t(exists $class->{Shared}) &&\n\t\t(defined $class->{Shared}) ) {\n\t\tif(exists $class->{query_iterator}) {\n\t\t\tif(\t($class->{query_iterator}->size > 0 ) &&\n\t\t\t\t(defined $class->{query}) &&\n\t\t\t\t(ref($class->{query})=~/ARRAY/) ) {\n                \t\tdelete($class->{query});\n\t\t\t\t};\n\t\t\treturn RDFStore::Model::Iterator->new(\t$class->getNodeFactory, \n\t\t\t\t\t\t\t\t$class->{query_iterator} );\n\t\t} else {\n\t\t\treturn $class->{Shared}->elements;\n\t\t\t};\n\t} else {\n\t\treturn RDFStore::Model::Iterator->new(\t$class->getNodeFactory, \n\t\t\t\t\t\t\t$class->{rdfstore}->elements );\n\t\t};\n\t};\n\nsub namespaces {\n\tmy ($class) = @_;\n\n\tmy %ns_table=();\n\n\tmy $itr = $class->elements;\n        while ( my $p = $itr->each_predicate ) {\n                my $ns_uri = $p->getNamespace;\n\n\t\tnext\n\t\t\tunless(defined $ns_uri);\n\n\t\t$ns_table{ $ns_uri } = 1\n\t\t\tunless(exists $ns_table{ $ns_uri });\n\t\t};\n\n\treturn keys %ns_table;\n\t};\n\nsub contains {\n        return 0\n\t\tunless(\t(defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n                \t($_[1]->isa(\"RDFStore::Statement\")) );\n\n        croak \"Statement context '\".$_[2].\"' is not instance of RDFStore::Resource\"\n                unless( (not(defined $_[2])) ||\n                                (       (defined $_[2]) &&\n                                        (ref($_[2])) &&\n                                        ($_[2]->isa('RDFStore::Resource')) ) );\n\n\tmy $context;\n\tif(defined $_[2]) {\n\t\t$context = $_[2];\n\t} else {\n\t\t$context = $_[1]->context\n\t\t\tif($_[1]->context);\n\t\t};\n\n\tif(\t(exists $_[0]->{Shared}) &&\n\t\t(defined $_[0]->{Shared}) ) {\n\t\tif(exists $_[0]->{query_iterator}) {\n\t\t\treturn 0\n                                if($_[0]->{query_iterator}->size <= 0); \n\n                        return $_[0]->{query_iterator}->contains( $_[1], undef, undef, $context );\n\t\t} else {\n\t\t\treturn ( $_[0]->find( $_[1]->subject, $_[1]->predicate, $_[1]->object, $context )->elements->size == 1 );\n\t\t\t};\n\t\t};\n\n\treturn $_[0]->{rdfstore}->contains( $_[1], undef, undef, $context );\n\t};\n\nsub add {\n        my ($class, $subject,$predicate,$object,$context) = @_;\n\n        croak \"Subject or Statement '\".$subject.\"' is either not instance of RDFStore::Statement or RDFStore::Resource\"\n                unless( (defined $subject) &&\n                        (ref($subject)) &&\n                        (       ($subject->isa('RDFStore::Resource')) ||\n                                ($subject->isa('RDFStore::Statement')) ) );\n\tcroak \"Predicate '\".$predicate.\"' is not instance of RDFStore::Resource\"\n                unless( (not(defined $predicate)) ||\n                        (       (defined $predicate) &&\n                                (ref($predicate)) &&\n                                ($predicate->isa('RDFStore::Resource')) ) );\n        croak \"Object '\".$object.\"' is not instance of RDFStore::RDFNode\"\n                unless( (not(defined $object)) ||\n                        ( ( (defined $object) &&\n                              (ref($object)) &&\n                              ($object->isa('RDFStore::RDFNode'))) ||\n                            ( (defined $object) &&\n                              ($object !~ m/^\\s+$/) ) ) );\n\n        croak \"Statement context '\".$context.\"' is not instance of RDFStore::Resource\"\n        \tunless(\t(not(defined $context)) ||\n                        (       (defined $context) &&\n                        \t(ref($context)) &&\n                                ($context->isa('RDFStore::Resource')) ) );\n\n        if(     (defined $subject) &&\n                (ref($subject)) &&\n                ($subject->isa(\"RDFStore::Statement\")) &&\n\t\t(not(defined $predicate)) &&\n\t\t(not(defined $object)) ) {\n\t\t$context = $subject->context\n\t\t\tunless(defined $context);\n                ($subject,$predicate,$object) = ($subject->subject, $subject->predicate, $subject->object);\n        } elsif(        (defined $object) &&\n                        (!(ref($object))) ) {\n                        $object = $class->{nodeFactory}->createLiteral($object);\n        };\n\n\tif(     (exists $class->{Shared}) &&\n                (defined $class->{Shared}) ) {\n\t\tif(exists $class->{query_iterator}) {\n                        return 0 \n                                if ( $class->{query_iterator}->contains( $subject, $predicate, $object, $context ) );\n                        };\n        \t$class->_copyOnWrite();\n        \t};\n\n\tmy $status = $_[0]->{rdfstore}->insert( $subject, $predicate, $object, $context );\n\n        $class->updateDigest($subject,$predicate,$object,$context); \n\n\treturn $status;\n\t};\n\nsub updateDigest {\n\tdelete $_[0]->{digest};\n\n\t};\n\nsub remove {\n        croak \"Statement '\".$_[1].\"' is not instance of RDFStore::Statement\"\n                unless( (defined $_[1]) &&\n                        (ref($_[1])) &&\n                        ($_[1]->isa('RDFStore::Statement')) );\n\n        croak \"Statement context '\".$_[2].\"' is not instance of RDFStore::Resource\"\n                unless( (not(defined $_[2])) ||\n                                (       (defined $_[2]) &&\n                                        (ref($_[2])) &&\n                                        ($_[2]->isa('RDFStore::Resource')) ) );\n\n\tmy $context;\n        if(defined $_[2]) {\n                $context = $_[2];\n        } else {\n                $context = $_[1]->context\n\t\t\tif($_[1]->context);\n                };\n\n        $_[0]->_copyOnWrite()\n\t\tif(     (exists $_[0]->{Shared}) &&\n                \t(defined $_[0]->{Shared}) );\n \n\tmy $status = $_[0]->{rdfstore}->remove( $_[1], undef, undef, $context );\n\n        $_[0]->updateDigest($_[1]->subject, $_[1]->predicate, $_[1]->object, $context);\n\n\treturn $status;\n\t};\n\nsub isMutable {\n\treturn 1;\n\t};\n\nsub find {\n        my ($class) = shift;\n        my ($subject,$predicate,$object,$context,$words_operator,@words) = @_;\n\n        croak \"Subject '\".$subject.\"' is not instance of RDFStore::Resource\"\n                unless(\t(not(defined $subject)) ||\n                        (       (defined $subject) &&\n                                (ref($subject)) &&\n\t\t\t\t($subject->isa('RDFStore::Resource')) ) );\n        croak \"Predicate '\".$predicate.\"' is not instance of RDFStore::Resource\"\n                unless( (not(defined $predicate)) ||\n                                (       (defined $predicate) &&\n                                        (ref($predicate)) &&\n                                        ($predicate->isa('RDFStore::Resource')) ) );\n        croak \"Object '\".$object.\"' is not instance of RDFStore::RDFNode\"\n                unless( (not(defined $object)) ||\n                                (       (defined $object) &&\n                                        (ref($object)) &&\n                                        ($object->isa('RDFStore::RDFNode')) ) );\n\n        croak \"Statement context '\".$context.\"' is not instance of RDFStore::Resource\"\n                unless( (not(defined $context)) ||\n                                (       (defined $context) &&\n                                        (ref($context)) &&\n                                        ($context->isa('RDFStore::Resource')) ) );\n\n\tif(     (exists $class->{Shared}) &&\n                (defined $class->{Shared}) ) {\n                $class->{Shared}->{sharing_query_iterator} = $class->{query_iterator}->duplicate\n                        if(exists $class->{query_iterator});\n                return $class->{Shared}->find($subject,$predicate,$object,$context,$words_operator,@words);\n        };\n\n\tmy @query = @_;\n\t$class->{query} = \\@query;\n\n        my $res = $class->create(); \n\n\n\t$res->{Shared}=$class;\n\n\t$res->setContext( $context ) \n\t\tif(defined $context);\n\n        if(     (not(defined $subject)) &&\n        \t(not(defined $predicate)) &&\n                (not(defined $object)) &&\n                (not(defined $context)) &&\n\t\t($#words < 0) ) {\n\t\tif ( exists $class->{sharing_query_iterator}) {\n                \t$res->{query_iterator} = $class->{sharing_query_iterator};\n                \tdelete $class->{sharing_query_iterator};\n\n\t\t\treturn $res;\n\t\t} else {\n\t\t\tmy $d = $class->duplicate();\n\t\t\treturn $d;\n\t\t\t};\n\t\t};\n\n\tmy $query = {\t'search_type' => 0, \n\t\t\t\"s\" => [],\n                        \"s_op\" => \"or\",\n                        \"p\" => [],\n                        \"p_op\" => \"or\",\n                        \"o\" => [],\n                        \"o_op\" => \"or\",\n                        \"c\" => [],\n                        \"c_op\" => \"or\",\n                        \"xml:lang\" => [],\n                        \"xml:lang_op\" => \"or\",\n                        \"rdf:datatype\" => [],\n                        \"rdf:datatype_op\" => \"or\"\n                        };\n\n\tmy @qq=();\n\tif($subject) {\n\t\tpush @{$query->{'s'}}, $subject;\n\t\t};\n\tif($predicate) {\n\t\tpush @{$query->{'p'}}, $predicate;\n\t\t};\n\tif($object) {\n\t\tpush @{$query->{'o'}}, $object;\n\t\t};\n\tif($context) {\n\t\tpush @{$query->{'c'}}, $context;\n\t\t};\n\t$query->{'words_op'} = (\t(defined $words_operator) &&\n\t\t\t\t\t($words_operator =~ /(and|&|1)/i) ) ? 'and' :\n\t\t\t\t\t(       (defined $words_operator) &&\n\t\t\t\t\t\t($words_operator =~ /(not|~|2)/i) ) ? 'not' : 'or' ;\n\n\tpush @{$query->{'words'}}, @words;\n\n\tmy $iterator = $class->{rdfstore}->search( $query );\n\n\tif ( exists $class->{sharing_query_iterator}) {\n\t\t$res->{query_iterator} = $class->{sharing_query_iterator}->intersect( $iterator );\n                delete $class->{sharing_query_iterator};\n        } else {\n                $res->{query_iterator} = $iterator;\n                };\n\n        return $res;\n\t};\n\nsub fetch_object {\n        my ($class,$resource,$context) = @_;\n\n        croak \"Resource '\".$resource.\"' is not instance of RDFStore::Resource\"\n                unless(       (defined $resource) &&\n                              (ref($resource)) &&\n\t\t\t      ($resource->isa('RDFStore::Resource')) );\n\n        croak \"Context '\".$context.\"' is not instance of RDFStore::Resource\"\n                unless( (not(defined $context)) ||\n                                (       (defined $context) &&\n                                        (ref($context)) &&\n                                        ($context->isa('RDFStore::Resource')) ) );\n\n\treturn\n\t\tif( $resource->isbNode );\n\n        my $res = $class->create(); \n\n        $res->{Shared}=$class;\n\n        $res->setContext( $context ) \n                if(defined $context);\n\n        $res->{query_iterator} = $class->{rdfstore}->fetch_object( ($resource->isa(\"RDFStore::Object\")) ? $resource->{'rdf_object'} : $resource, $context );\n\n\treturn $res;\n\t};\n\nsub getResource {\n        my ($class,$resource) = @_;\n\n\tmy $object = new RDFStore::Object( $resource );\n\t$object->load( $class->fetch_object( $class->getNodeFactory->createResource($resource) ) );\n\n\treturn $object; \n\t};\n\nsub duplicate {\n\tmy ($class) = @_;\n\n\treturn $class->{Shared}->duplicate\n\t\tif(     (exists $class->{Shared}) &&\n                \t(defined $class->{Shared}) );\n\n        my $new = $class->create();\n\n        $new->{Shared} = $class;\n\n\tmy $sg = $class->getContext;\n\t$new->setContext( $sg )\n        \tif(defined $sg);\n        return $new;\n};\n\nsub create {\n        my($class) = shift;\n\n        my $self = ref($class);\n        my $new = $self->new(); \n\n        return $new;\n\t};\n\nsub getNodeFactory {\n        return $_[0]->{nodeFactory};\n\t};\n\nsub getLabel {\n        return $_[0]->getURI;\n\t};\n\nsub getURI {\n        if($_[0]->isEmpty()) {\n                return $_[0]->{nodeFactory}->createUniqueResource()->toString();\n        } else {\n                return \"urn:rdf:\".\n\t\t\t\t&RDFStore::Util::Digest::getDigestAlgorithm().\"-\".\n                        \tunpack(\"H*\", $_[0]->getDigest() );\n        \t};\n\t};\n\nsub getDigest {\n        unless ( defined $_[0]->{digest} ) {\n                sub digest_sorter {\n                        my @a1 = unpack \"c*\",$a->getDigest();\n                        my @b1 = unpack \"c*\",$b->getDigest();\n                        my $i;\n                        for ($i=0; $i < $#a1 +1; $i++) {\n                                return $a1[$i] - $b1[$i] unless ord $a1[$i] == ord $b1[$i];\n                        };\n                        return 0;\n                };\n                my $t;\n                my $digest_bytes;\n\t\tmy ($el) = $_[0]->elements;\n\t\tmy @sts = ();\n\t\tmy $ss;\n\t\tfor (\t$ss = $el->first;\n\t\t\t$el->hasnext;\n\t\t\t$ss = $el->next ) {\n\t\t\tpush @sts, $ss;\n\t\t\t};\n                for  $t ( sort digest_sorter @sts ){ \n                        $digest_bytes .= $t->getDigest();\n                \t};\n                $_[0]->{digest} = RDFStore::Util::Digest::computeDigest($digest_bytes);\n        \t};\n        return $_[0]->{digest};\n\t};\n\nsub intersect {\n\tmy ($class,$other) = @_;\n\n\treturn\n\t\tunless($other);\n\n\tcroak \"Model '\".$other.\"' is not instance of RDFStore::Model\"\n\t\tunless( (defined $other) && (ref($other)) &&\n\t\t\t($other->isa('RDFStore::Model')) );\n\n\tcroak \"Models can not be intersected\"\n\t\tunless(\t( $class->{Shared} == $class->{Shared} ) ||\n\t\t\t( $class->{rdfstore} == $other->{rdfstore} ) );\n\n        my $res = $class->create(); \n\n        $res->{Shared} = $class; \n\n\tmy $iter = $class->elements->intersect( $other->elements ); \n\n\treturn\n\t\tunless($iter);\n\n\t$res->{query_iterator} = $iter->{iterator};\n\n\tmy $sg = $class->getContext;\n\t$res->setContext( $sg )\n        \tif(defined $sg);\n\n        return $res;\n\t};\n\nsub subtract {\n\tmy ($class,$other) = @_;\n\n\treturn\n\t\tunless($other);\n\n\tcroak \"Model '\".$other.\"' is not instance of RDFStore::Model\"\n\t\tunless( (defined $other) && (ref($other)) &&\n\t\t\t($other->isa('RDFStore::Model')) );\n\n\tcroak \"Models can not be subtracted\"\n\t\tunless(\t( $class->{Shared} == $class->{Shared} ) ||\n\t\t\t( $class->{rdfstore} == $other->{rdfstore} ) );\n\n\tmy $res = $class->create(); \n\n        $res->{Shared} = $class; \n\n        my $iter = $class->elements->subtract( $other->elements );\n\n\treturn\n\t\tunless($iter);\n\n\t$res->{query_iterator} = $iter->{iterator};\n\n        my $sg = $class->getContext;\n        $res->setContext( $sg )\n                if(defined $sg);\n\n        return $res;\n\t};\n\nsub unite {\n\tmy ($class,$other) = @_;\n\n\treturn\n\t\tunless($other);\n\n\tcroak \"Model '\".$other.\"' is not instance of RDFStore::Model\"\n\t\tunless( (defined $other) && (ref($other)) &&\n\t\t\t($other->isa('RDFStore::Model')) );\n\n\tcroak \"Models can not be united\"\n\t\tunless(\t( $class->{Shared} == $class->{Shared} ) ||\n\t\t\t( $class->{rdfstore} == $other->{rdfstore} ) );\n\n\tmy $res = $class->create(); \n\n        $res->{Shared} = $class; \n\n        my $iter = $class->elements->unite( $other->elements );\n\n\treturn\n\t\tunless($iter);\n\n\t$res->{query_iterator} = $iter->{iterator};\n\n        my $sg = $class->getContext;\n        $res->setContext( $sg )\n                if(defined $sg);\n\n        return $res;\n\t};\n\nsub complement {\n\tmy ($class) = @_;\n\n\tmy $res = $class->create(); \n\n        $res->{Shared} = $class; \n\n        my $iter = $class->elements->complement;\n\n\treturn\n\t\tunless($iter);\n\n\t$res->{query_iterator} = $iter->{iterator};\n\n        my $sg = $class->getContext;\n        $res->setContext( $sg )\n                if(defined $sg);\n\n        return $res;\n\t};\n\nsub exor {\n\tmy ($class,$other) = @_;\n\n\treturn\n\t\tunless($other);\n\n\tcroak \"Model '\".$other.\"' is not instance of RDFStore::Model\"\n\t\tunless( (defined $other) && (ref($other)) &&\n\t\t\t($other->isa('RDFStore::Model')) );\n\n\tcroak \"EXOR can not be performed between the two given models\"\n\t\tunless(\t( $class->{Shared} == $class->{Shared} ) ||\n\t\t\t( $class->{rdfstore} == $other->{rdfstore} ) );\n\n\tmy $res = $class->create(); \n\n        $res->{Shared} = $class; \n\n        my $iter = $class->elements->exor( $other->elements ); \n\n\treturn\n\t\tunless($iter);\n\n\t$res->{query_iterator} = $iter->{iterator};\n\n        my $sg = $class->getContext;\n        $res->setContext( $sg )\n                if(defined $sg);\n\n        return $res;\n\t};\n\nsub serialize {\n\tmy ($class, $fh, $syntax, $namespaces, $base ) = @_;\n\n\tmy $serializer;\n\tif(\t(! $syntax ) ||\n\t\t( $syntax =~ m#RDF/XML#i) ) {\n\t\t$serializer = new RDFStore::Serializer::RDFXML;\n\t} elsif( $syntax =~ m/N-Triples/i) {\n\t\t$serializer = new RDFStore::Serializer::NTriples;\n\t} else {\n\t\tcroak \"Unknown serialization syntax '$syntax'\";\n\t\t};\n\n\treturn\n\t\tunless($serializer);\n\n\treturn $serializer->write( $class, $fh, $namespaces, $base );\n};\n\nsub getSerializer {\n\tmy ($class) = shift;\n\n\t$class->getWriter(@_);\n\t};\n\nsub getWriter {\n\tmy ($class, $syntax) = @_;\n\n\tmy $serializer;\n\tif(\t(! $syntax ) ||\n\t\t( $syntax =~ m#RDF/XML#i) ) {\n\t\t$serializer = new RDFStore::Serializer::RDFXML;\n\t} elsif( $syntax =~ m/N-Triples/i) {\n\t\t$serializer = new RDFStore::Serializer::NTriples;\n\t} else {\n\t\tcroak \"Unknown serialization syntax '$syntax'\";\n\t\t};\n\n\t$serializer->{'model'} = $class; \n\n\treturn $serializer;\n\t};\n\nsub getParser {\n\tmy ($class) = shift;\n\n\t$class->getReader(@_);\n\t};\n\nsub getReader {\n\tmy ($class, $syntax) = @_;\n\n\t$class->{'GenidNumber'} = 0\n\t\tunless(exists $class->{'GenidNumber'});\n\n\tmy $parser;\n\tif(\t(! $syntax ) ||\n\t\t( $syntax =~ m#RDF/XML#i) ) {\n\t\t$parser = new RDFStore::Parser::SiRPAC(\n\t\t\t\t\tErrorContext => 3,\n\t\t\t\t\tStyle => 'RDFStore::Parser::Styles::RDFStore::Model',\n\t\t\t\t\tNodeFactory => $class->getNodeFactory,\n\t\t\t\t\tSource  => ($class->getSourceURI ) ? $class->getSourceURI : undef,\n\t\t\t\t\tGenidNumber => $class->{'GenidNumber'},\n\t\t\t\t\t'style_options' => { 'store_options' => { 'sourceModel' => $class } } );\n\t} elsif( $syntax =~ m/N-Triples/i) {\n\t\t$parser = new RDFStore::Parser::NTriples(\n\t\t\t\t\tErrorContext => 3,\n\t\t\t\t\tStyle => 'RDFStore::Parser::Styles::RDFStore::Model',\n\t\t\t\t\tNodeFactory => $class->getNodeFactory,\n\t\t\t\t\tSource  => ($class->getSourceURI ) ? $class->getSourceURI : undef,\n\t\t\t\t\tGenidNumber => $class->{'GenidNumber'},\n\t\t\t\t\t'style_options' => { 'store_options' => { 'sourceModel' => $class } } );\n\t} else {\n\t\tcroak \"Unknown RDF syntax '$syntax'\";\n\t\t};\n\n\treturn $parser;\n\t};\n\nsub _copyOnWrite {\n\tmy($class) = @_;\n \n\treturn\n        \tunless( (exists $class->{Shared}) &&\n                \t(defined $class->{Shared}) );\n\n                \n        my ($shares) = $class->elements;\n\n        delete($class->{query});\n        if(exists $class->{query_iterator}) {\n\t\tdelete($class->{query_iterator});\n\t\t};\n\n        delete($class->{Shared});\n\n\tmy $ss;\n\tfor (\t$ss = $shares->first;\n\t\t$shares->hasnext;\n\t\t$ss = $shares->next ) {\n                $class->add($ss); \n        \t};\n\n};\n\npackage RDFStore::Model::Iterator;\n\nuse vars qw ( $VERSION );\nuse strict;\n\n$VERSION = '0.1';\n\nsub new {\n\tmy ($pkg,$factory,$iterator) = @_;\n\n\treturn\n                unless(\t(defined $iterator) &&\n\t\t\t(ref($iterator)) &&\n\t\t\t($iterator->isa(\"RDFStore::Iterator\")) &&\n\t\t\t(defined $factory) &&\n\t\t\t(ref($factory)) &&\n\t\t\t($factory->isa(\"RDFStore::NodeFactory\")) );\n\n        return \tbless {\n\t\t\tfactory => \t$factory,\n\t\t\titerator => \t$iterator\n\t\t},$pkg;\n\t};\n\nsub size {\n\treturn $_[0]->{iterator}->size;\n\t};\n\nsub duplicate {\n\treturn $_[0]->{iterator}->duplicate;\n\t};\n\nsub hasnext {\n\treturn $_[0]->{iterator}->hasnext;\n\t};\n\nsub remove {\n\treturn $_[0]->{iterator}->remove;\n\t};\n\nsub intersect {\n\treturn\n\t\tunless(\t(defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n\t\t\t($_[1]->isa(\"RDFStore::Model::Iterator\")) );\n\n\treturn new RDFStore::Model::Iterator(\t$_[0]->{factory},\n\t\t\t\t\t\t$_[0]->{iterator}->intersect( $_[1]->{iterator} ) );\n\t};\n\nsub unite {\n\treturn\n\t\tunless(\t(defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n\t\t\t($_[1]->isa(\"RDFStore::Model::Iterator\")) );\n\n\treturn new RDFStore::Model::Iterator(\t$_[0]->{factory},\n\t\t\t\t\t\t$_[0]->{iterator}->unite( $_[1]->{iterator} ) );\n\t};\n\nsub subtract {\n\treturn\n\t\tunless(\t(defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n\t\t\t($_[1]->isa(\"RDFStore::Model::Iterator\")) );\n\n\treturn new RDFStore::Model::Iterator(\t$_[0]->{factory},\n\t\t\t\t\t\t$_[0]->{iterator}->subtract( $_[1]->{iterator} ) );\n\t};\n\nsub complement {\n\treturn\n\t\tunless(\t(defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n\t\t\t($_[1]->isa(\"RDFStore::Model::Iterator\")) );\n\n\treturn new RDFStore::Model::Iterator(\t$_[0]->{factory},\n\t\t\t\t\t\t$_[0]->{iterator}->complement( $_[1]->{iterator} ) );\n\t};\n\nsub exor {\n\treturn\n\t\tunless(\t(defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n\t\t\t($_[1]->isa(\"RDFStore::Model::Iterator\")) );\n\n\treturn new RDFStore::Model::Iterator(\t$_[0]->{factory},\n\t\t\t\t\t\t$_[0]->{iterator}->exor( $_[1]->{iterator} ) );\n\t};\n\nsub next {\n\tmy ($st) = $_[0]->{iterator}->next;\n\n\treturn\n\t\tunless($st);\n\n\treturn $_[0]->{factory}->createStatement(\n\t\t\t( $st->subject->isbNode ) ? \n\t\t\t\t$_[0]->{factory}->createAnonymousResource( $st->subject->toString ) : \n\t\t\t\t$_[0]->{factory}->createResource( $st->subject->toString ),\n\t\t\t( $st->predicate->isbNode ) ? \n\t\t\t\t$_[0]->{factory}->createAnonymousResource( $st->predicate->toString ) : \n\t\t\t\t$_[0]->{factory}->createResource( $st->predicate->toString ),\n\t\t\t( $st->object->isa(\"RDFStore::Literal\") ) ?\n\t\t\t\t$_[0]->{factory}->createLiteral(\t$st->object->getLabel,\n\t\t\t\t\t\t\t\t\t$st->object->getParseType,\n\t\t\t\t\t\t\t\t\t$st->object->getLang,\n\t\t\t\t\t\t\t\t\t$st->object->getDataType ) :\n\t\t\t( $st->object->isbNode ) ? \n\t\t\t\t$_[0]->{factory}->createAnonymousResource( $st->object->toString ) : \n\t\t\t\t$_[0]->{factory}->createResource( $st->object->toString ),\n\t\t\t( $st->context ) ?  ( $st->context->isbNode ) ? \n\t\t\t\t\t\t$_[0]->{factory}->createAnonymousResource( $st->context->toString ) : \n\t\t\t\t\t\t$_[0]->{factory}->createResource( $st->context->toString ) : undef );\n\t};\n\nsub next_subject {\n\tmy ($n) = $_[0]->{iterator}->next_subject;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n\t\t\t$_[0]->{factory}->createAnonymousResource( $n->toString ) : \n\t\t\t$_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub next_predicate {\n\tmy ($n) = $_[0]->{iterator}->next_predicate;\n\n        return\n                unless($n); \n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub next_object {\n\tmy ($n) = $_[0]->{iterator}->next_object;\n\n        return\n                unless($n); \n\n\treturn ( $n->isa(\"RDFStore::Literal\") ) ?\n               \t$_[0]->{factory}->createLiteral(\t$n->getLabel,\n                                                        $n->getParseType,\n                                                        $n->getLang,\n                                                        $n->getDataType ) :\n               ( $n->isbNode ) ?\n                \t$_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub next_context {\n\tmy ($n) = $_[0]->{iterator}->next_context;\n\n        return\n                unless($n); \n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub current {\n\tmy ($st) = $_[0]->{iterator}->current;\n\n        return\n                unless($st);\n\n\treturn $_[0]->{factory}->createStatement(\n                        ( $st->subject->isbNode ) ?\n                                $_[0]->{factory}->createAnonymousResource( $st->subject->toString ) :\n                                $_[0]->{factory}->createResource( $st->subject->toString ),\n                        ( $st->predicate->isbNode ) ? \n                                $_[0]->{factory}->createAnonymousResource( $st->predicate->toString ) :\n                                $_[0]->{factory}->createResource( $st->predicate->toString ),\n                        ( $st->object->isa(\"RDFStore::Literal\") ) ?\n                                $_[0]->{factory}->createLiteral(        $st->object->getLabel,\n                                                                        $st->object->getParseType,\n                                                                        $st->object->getLang,\n                                                                        $st->object->getDataType ) :\n                        ( $st->object->isbNode ) ? \n                                $_[0]->{factory}->createAnonymousResource( $st->object->toString ) : \n                                $_[0]->{factory}->createResource( $st->object->toString ), \n                        ( $st->context ) ?  ( $st->context->isbNode ) ?                  \n                                                $_[0]->{factory}->createAnonymousResource( $st->context->toString ) :\n                                                $_[0]->{factory}->createResource( $st->context->toString ) : undef );\n\t};\n\nsub current_subject {\n\tmy ($n) = $_[0]->{iterator}->current_subject;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub current_predicate {\n\tmy ($n) = $_[0]->{iterator}->current_predicate;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub current_object {\n\tmy ($n) = $_[0]->{iterator}->current_object;\n\n        return\n                unless($n);\n\n        return ( $n->isa(\"RDFStore::Literal\") ) ?\n                $_[0]->{factory}->createLiteral(        $n->getLabel,\n                                                        $n->getParseType,\n                                                        $n->getLang,\n                                                        $n->getDataType ) :\n               ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub current_context {  \n\tmy ($n) = $_[0]->{iterator}->current_context;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n        };\n\nsub first {\n\tmy ($st) = $_[0]->{iterator}->first;\n\n        return\n                unless($st);\n\n\treturn $_[0]->{factory}->createStatement(\n                        ( $st->subject->isbNode ) ?\n                                $_[0]->{factory}->createAnonymousResource( $st->subject->toString ) :\n                                $_[0]->{factory}->createResource( $st->subject->toString ),\n                        ( $st->predicate->isbNode ) ? \n                                $_[0]->{factory}->createAnonymousResource( $st->predicate->toString ) :\n                                $_[0]->{factory}->createResource( $st->predicate->toString ),\n                        ( $st->object->isa(\"RDFStore::Literal\") ) ?\n                                $_[0]->{factory}->createLiteral(        $st->object->getLabel,\n                                                                        $st->object->getParseType,\n                                                                        $st->object->getLang,\n                                                                        $st->object->getDataType ) :\n                        ( $st->object->isbNode ) ? \n                                $_[0]->{factory}->createAnonymousResource( $st->object->toString ) : \n                                $_[0]->{factory}->createResource( $st->object->toString ), \n                        ( $st->context ) ?  ( $st->context->isbNode ) ?                  \n                                                $_[0]->{factory}->createAnonymousResource( $st->context->toString ) :\n                                                $_[0]->{factory}->createResource( $st->context->toString ) : undef );\n\t};\n\nsub first_subject {\n\tmy ($n) = $_[0]->{iterator}->first_subject;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub first_predicate {\n\tmy ($n) = $_[0]->{iterator}->first_predicate;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub first_object {\n\tmy ($n) = $_[0]->{iterator}->first_object;\n\n        return\n                unless($n);\n\n        return ( $n->isa(\"RDFStore::Literal\") ) ?\n                $_[0]->{factory}->createLiteral(        $n->getLabel,\n                                                        $n->getParseType,\n                                                        $n->getLang,\n                                                        $n->getDataType ) :\n               ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub first_context {  \n\tmy ($n) = $_[0]->{iterator}->first_context;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n        };\n\nsub each {\n\tmy ($st) = $_[0]->{iterator}->each;\n\n        return\n                unless($st);\n\n\treturn $_[0]->{factory}->createStatement(\n                        ( $st->subject->isbNode ) ?\n                                $_[0]->{factory}->createAnonymousResource( $st->subject->toString ) :\n                                $_[0]->{factory}->createResource( $st->subject->toString ),\n                        ( $st->predicate->isbNode ) ? \n                                $_[0]->{factory}->createAnonymousResource( $st->predicate->toString ) :\n                                $_[0]->{factory}->createResource( $st->predicate->toString ),\n                        ( $st->object->isa(\"RDFStore::Literal\") ) ?\n                                $_[0]->{factory}->createLiteral(        $st->object->getLabel,\n                                                                        $st->object->getParseType,\n                                                                        $st->object->getLang,\n                                                                        $st->object->getDataType ) :\n                        ( $st->object->isbNode ) ? \n                                $_[0]->{factory}->createAnonymousResource( $st->object->toString ) : \n                                $_[0]->{factory}->createResource( $st->object->toString ), \n                        ( $st->context ) ?  ( $st->context->isbNode ) ?                  \n                                                $_[0]->{factory}->createAnonymousResource( $st->context->toString ) :\n                                                $_[0]->{factory}->createResource( $st->context->toString ) : undef );\n\t};\n\nsub each_subject {\n\tmy ($n) = $_[0]->{iterator}->each_subject;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub each_predicate {\n\tmy ($n) = $_[0]->{iterator}->each_predicate;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub each_object {\n\tmy ($n) = $_[0]->{iterator}->each_object;\n\n        return\n                unless($n);\n\n        return ( $n->isa(\"RDFStore::Literal\") ) ?\n                $_[0]->{factory}->createLiteral(        $n->getLabel,\n                                                        $n->getParseType,\n                                                        $n->getLang,\n                                                        $n->getDataType ) :\n               ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub each_context {  \n\tmy ($n) = $_[0]->{iterator}->each_context;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n        };\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Model.pm",
      "package" : "RDFStore::Model"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.41';\n\nuse Carp;\nuse RDFStore; \nuse RDFStore::Digest::Digestable;\n\nsub toString {\n\treturn $_[0]->getLabel();\n};\n\nsub equals {\n\treturn 0\n                unless( (defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n                        ($_[1]->isa(\"RDFStore::RDFNode\")) );\n\n        return ( $_[0]->getDigest() eq $_[1]->getDigest() ) ? 1 : 0\n\t\tif($_[1]->can('getDigest'));\n\n        return ( $_[0]->getLabel() eq $_[1]->getLabel() ) ? 1 : 0;\n};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/RDFNode.pm",
      "package" : "RDFStore::RDFNode"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n\nuse Carp;\n \n$VERSION = '0.42';\n\nuse Carp;\nuse RDFStore; \nuse RDFStore::RDFNode;\n\nsub equals {\n\treturn 0\n                unless(defined $_[1]);\n\n\treturn 0\n\t\tif ( ref($_[1]) =~ /^(SCALAR|ARRAY|HASH|CODE|REF|GLOB|LVALUE)/ ); \n\n\tmy $label1 = $_[0]->getLabel();\n        my $label2;\n\tif(\t($_[1]) &&\n\t\t(ref($_[1])) && \n\t\t($_[1]->isa(\"RDFStore::Literal\")) ) {\n\t\t$label2 = $_[1]->getLabel();\n\t} else {\n\t\t$label2 = $_[1];\n\t\t};\n\n        return ($label1 eq $label2) ? 1 : 0;\n\t};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Literal.pm",
      "package" : "RDFStore::Literal"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.4';\n\nuse Carp;\nuse RDFStore;\nuse RDFStore::VirtualModel;\nuse RDFStore::Resource;\nuse RDFStore::Literal;\nuse RDFStore::Statement;\nuse RDFStore::NodeFactory;\nuse RDFStore::Vocabulary::RDF;\nuse RDFStore::Vocabulary::RDFS;\n\n@RDFStore::SchemaModel::ISA = qw( RDFStore::VirtualModel );\n\nsub new {\n\tmy ($pkg,$factory_or_instances,$instances_or_closure,$closure) = @_;\n\n    \tmy $self = $pkg->SUPER::new();\n\n\tif ( \t(defined $factory_or_instances) && \n\t\t(ref($factory_or_instances)) && \n\t\t($factory_or_instances->isa(\"RDFStore::Model\")) ) {\n\t\t$self->{nodeFactory}=new RDFStore::NodeFactory();\n\t\t$self->{instances}=$factory_or_instances;\n\t\tif(\t(defined $instances_or_closure) && \n\t\t\t(ref($instances_or_closure)) && \n\t\t\t($instances_or_closure->isa(\"RDFStore::Model\")) ) {\n\t\t\t$self->{closure}=$instances_or_closure;\n\t\t\t};\n\t} elsif(\t(defined $factory_or_instances) && \n\t\t\t(ref($factory_or_instances)) &&\n\t\t\t($factory_or_instances->isa(\"RDFStore::NodeFactory\")) ) {\n\t\t$self->{nodeFactory}=$factory_or_instances;\n\t\tif (\t(defined $instances_or_closure) && \n\t\t\t(ref($instances_or_closure)) && \n\t\t\t($instances_or_closure->isa(\"RDFStore::Model\")) ) {\n\t\t\t$self->{instances}=$instances_or_closure;\n\t\t\t};\n\t\tif(\t(defined $closure) && \n\t\t\t(ref($closure)) && \n\t\t\t($closure->isa(\"RDFStore::Model\")) ) {\n\t\t\t$self->{closure}=$closure;\n\t\t\t};\n\t} else {\n\t\t$self->{nodeFactory}=new RDFStore::NodeFactory();\n\t\tif (\t(defined $instances_or_closure) && \n\t\t\t(ref($instances_or_closure)) && \n\t\t\t($instances_or_closure->isa(\"RDFStore::Model\")) ) {\n\t\t\t$self->{instances}=$instances_or_closure;\n\t\t\t};\n\t\tif(\t(defined $closure) && \n\t\t\t(ref($closure)) && \n\t\t\t($closure->isa(\"RDFStore::Model\")) ) {\n\t\t\t$self->{closure}=$closure;\n\t\t\t};\n\t\t};\n\n\twarn \"Missing ground or schema model\" and return\n\t\tunless( defined $self->{instances} and defined $self->{closure} );\n\n    \tbless $self,$pkg;\n\t};\n\nsub getNamespace {\n        return $_[0]->{instances}->getNamespace();\n\t};\n\nsub getLocalName {\n\treturn $_[0]->{instances}->getLocalName();\n\t};\n\nsub getLabel {\n\treturn $_[0]->{instances}->getLabel();\n\t};\n\nsub getURI {\n\treturn $_[0]->{instances}->getURI();\n\t};\n\nsub getGroundModel {\n\treturn $_[0]->{instances};\n\t};\n\nsub setSourceURI {\n\t$_[0]->{instances}->setSourceURI($_[1]);\n\t};\n\nsub getSourceURI {\n\treturn $_[0]->{instances}->getSourceURI();\n\t};\n\nsub setContext {\n\treturn $_[0]->{instances}->setContext($_[1]);\n\t};\n\nsub resetContext {\n\treturn $_[0]->{instances}->resetContext;\n\t};\n\nsub getContext {\n\treturn $_[0]->{instances}->getContext;\n\t};\n\nsub getOptions {\n\treturn $_[0]->{instances}->getOptions;\n\t};\n\nsub isAnonymous {\n\treturn 0;\n\t};\n\nsub isConnected {\n\treturn $_[0]->{instances}->isConnected;\n\t};\n\nsub isRemote {\n\treturn $_[0]->{instances}->isRemote;\n\t};\n\nsub namespaces {\n\treturn $_[0]->{instances}->namespaces;\n\t};\n\nsub size {\n\treturn -1; \n\t};\n\nsub isEmpty {\n\treturn $_[0]->{instances}->isEmpty();\n\t};\n\nsub isMutable {\n\t$_[0]->{instances}->isMutable();\n\t};\n\nsub elements {\n\tmy ($class) = @_;\n\n        return RDFStore::SchemaModel::Iterator->new(\t$class->getNodeFactory,\n        \t\t\t\t\t\t$class->{instances}->{rdfstore}->elements,\n        \t\t\t\t\t\t$class->{closure}->{rdfstore}->elements );\n\t};\n\nsub contains {\n\treturn 0\n                unless( (defined $_[1]) &&\n                        (ref($_[1])) &&\n                        ($_[1]->isa(\"RDFStore::Statement\")) );\n\n        croak \"Statement context '\".$_[2].\"' is not instance of RDFStore::Resource\"\n                unless(\t(not(defined $_[2])) ||\n                        (       (defined $_[2]) &&\n                        \t(ref($_[2])) &&\n                                ($_[2]->isa('RDFStore::Resource')) ) );\n\n        my $context;\n        if(defined $_[2]) {\n                $context = $_[2];\n        } else {\n                $context = $_[1]->context\n                        if($_[1]->context);\n                };\n\n\treturn !($_[0]->find(\t$_[1]->subject(),\n\t\t\t\t$_[1]->predicate(),\n\t\t\t\t$_[1]->object(),\n\t\t\t\t$context\n\t\t\t\t)->isEmpty());\n};\n\nsub add {\n\tmy ( $class ) = shift;\n\n\t$class->{instances}->add(@_);\n\t};\n\nsub remove {\n\tmy ( $class ) = shift;\n\n\t$class->{instances}->remove(@_);\n\t};\n\nsub find {\n\tmy ($class) = shift;\n        my ($subject,$predicate,$object,$context,$words_operator,@words) = @_;\n\n        croak \"Subject '\".$subject.\"' is not instance of RDFStore::Resource\"\n                unless( (not(defined $subject)) ||\n                        (       (defined $subject) &&\n                                (ref($subject)) &&\n                                ($subject->isa('RDFStore::Resource')) ) );\n        croak \"Predicate '\".$predicate.\"' is not instance of RDFStore::Resource\"\n                unless( (not(defined $predicate)) ||\n                                (       (defined $predicate) &&\n                                        (ref($predicate)) &&\n                                        ($predicate->isa('RDFStore::Resource')) ) );\n        croak \"Object '\".$object.\"' is not instance of RDFStore::RDFNode\"\n                unless( (not(defined $object)) ||\n                                (       (defined $object) &&\n                                        (ref($object)) &&\n                                        ($object->isa('RDFStore::RDFNode')) ) );\n\n        croak \"Statement context '\".$context.\"' is not instance of RDFStore::Resource\"\n                unless( (not(defined $context)) ||\n                                (       (defined $context) &&\n                                        (ref($context)) &&\n                                        ($context->isa('RDFStore::Resource')) ) );\n\n\n\tmy $res;\n\n\tif ((defined $object) && ($RDFStore::Vocabulary::RDF::type->equals($predicate))) {\n\t\t$res = $class->{instances}->find($subject,$predicate,$object,$context,$words_operator,@words);\n\n\t\tmy $subclass = $class->{closure}->find(undef,$RDFStore::Vocabulary::RDFS::subClassOf,$object)->elements; \n\t\twhile ( my $s = $subclass->each_subject ) {\n\t\t\tmy $subclass_type = $class->{instances}->find( $subject,$RDFStore::Vocabulary::RDF::type,$s ); \n\t\t\twhile ( my $s1 = $subclass_type->each ) {\n\t\t\t\t$res->add( $s1 );\n\t\t\t\t};\n\t\t\t};\n\t} elsif($RDFStore::Vocabulary::RDFS::subClassOf->equals($predicate)) {\n\t\t$res = $class->{closure}->find($subject,$predicate,$object,undef,$words_operator,@words); \n\t} elsif(defined $predicate) {\n\t\t$res = $class->{instances}->find($subject,$predicate,$object,$context,$words_operator,@words);\n\n\t\tmy $subprop = $class->{closure}->find(undef, $RDFStore::Vocabulary::RDFS::subPropertyOf,$predicate)->elements;\n\t\twhile ( my $s = $subprop->each_subject ) {\n\t\t\tmy $subprop_type = $class->{instances}->find( $subject,$s, $predicate ); \n\t\t\twhile ( my $s1 = $subprop_type->each ) {\n\t\t\t\t$res->add( $s1 );\n\t\t\t\t};\n\t\t\t};\n\t} else {\n\t\t$res = $class->{instances}->find($subject,$predicate,$object,$context,$words_operator,@words);\n\t\t};\n\n        return $res;\n};\n\nsub duplicate {\n\treturn new RDFStore::SchemaModel($_[0]->{nodeFactory},$_[0]->{instances}->duplicate(), $_[0]->{closure});\n\t};\n\nsub create {\n\treturn new RDFStore::SchemaModel($_[0]->{instances}->create(), $_[0]->{closure});\n\t};\n\nsub getNodeFactory {\n\treturn $_[0]->{nodeFactory};\t\n\t};\n\nsub toString {\n\treturn \"[RDFSchemaModel \".$_[0]->{instances}->getSourceURI().\"]\";\n\t};\n\nsub intersect {\n\tmy ($class,$other) = @_;\n\n        return\n                unless($other);\n\n        croak \"Model '\".$other.\"' is not instance of RDFStore::SchemaModel\"\n                unless( (defined $other) && (ref($other)) &&\n                        ($other->isa('RDFStore::Model')) );\n\n        croak \"Models can not be intersected\"\n                unless( (\t( $class->{instances}->{Shared} == $class->{instances}->{Shared} ) &&\n                \t\t( $class->{closure}->{Shared} == $class->{closure}->{Shared} ) ) ||\n                        (\t( $class->{instances}->{rdfstore} == $other->{instances}->{rdfstore} ) &&\n\t\t\t\t( $class->{closure}->{rdfstore} == $other->{closure}->{rdfstore} ) ) );\n\n        my $res = $class->create(); \n\n        $res->{Shared} = $class; \n\n        $res->{query_iterator} = $class->elements->intersect( $other->elements ); \n\n        my $sg = $class->getContext;\n        $res->setContext( $sg )\n                if(defined $sg);\n\n        return $res;\n\t};\n\nsub subtract {\n\t};\n\nsub unite {\n\t};\n\nsub complement {\n\t};\n\nsub exor {\n\t};\n\nsub serialize {\n\t};\n\nsub computeRDFSClosure {\n\tcroak \"Model \".$_[1].\" is not instance of RDFStore::Model\"\n                unless( (defined $_[1]) && (ref($_[1])) &&\n                        ($_[1]->isa('RDFStore::Model')) );\n\n\tmy $closure = $_[0]->computeClosure($_[1],$RDFStore::Vocabulary::RDFS::subClassOf);\n    \t$closure->unite($_[0]->computeClosure($_[1],$RDFStore::Vocabulary::RDFS::subPropertyOf)); \n\treturn $closure;\n\t};\n\nsub computeClosure {\n\tmy ($class, $model, $property, $allowLoops ) = @_;\n\n\tcroak \"Model \".$model.\" is not instance of RDFStore::Model\"\n                unless( (defined $model) && (ref($model)) &&\n                        ($model->isa('RDFStore::Model')) );\n\n\tcroak \"Property \".$property.\" is not instance of RDFStore::Resource\"\n                unless( (defined $property) && (ref($property)) &&\n                        ($property->isa('RDFStore::Resource')) );\n\n\t$allowLoops = 0\n\t\tunless( ($allowLoops) && (int($allowLoops)) );\n\n\tmy $closure = $model->create(); \n\n\tmy $all = $model->find(undef, $property, undef)->elements;\n\n\tmy %processedNodes = ();\n\tmy %stack = ();\n\twhile ( my $o = $all->each_object ) {\n      \t\tif(\t(!(exists $processedNodes{ $o->toString })) &&\n\t\t\t($o->isa(\"RDFStore::Resource\")) ) {\n\t\t\t%stack = ();\n\t\t\tcroak \"[RDFSchemaModel] found invalid loop in transitive closure of \",$property->getLabel,\" Loop node: \",$o->getLabel\n\t\t\t\tif(\t($class->traverseClosure( \\%processedNodes, $o, $property, \\%stack, $closure, $model, 0)) &&\n\t\t\t\t\t(!($allowLoops)) );\n      \t\t\t};\n    \t\t};\n\n\treturn $closure;\n\t};\n\nsub traverseClosure {\n\tmy ($class, $processedNodes, $object, $property, $stack, $closure, $model, $depth ) = @_;\n\n\tcroak \"Hash \".$processedNodes.\" is not an HASH reference\"\n                unless( (defined $processedNodes) &&\n                        (ref($processedNodes) =~ /HASH/) );\n\n\tcroak \"Resource \".$object.\" is not instance of RDFStore::Resource\"\n                unless( (defined $object) && (ref($object)) &&\n                        ($object->isa('RDFStore::Resource')) );\n\n\tcroak \"Resource \".$property.\" is not instance of RDFStore::Resource\"\n                unless( (defined $property) && (ref($property)) &&\n                        ($property->isa('RDFStore::Resource')) );\n\n\tcroak \"Hash \".$stack.\" is not an HASH reference\"\n                unless( (defined $stack) &&\n                        (ref($stack) =~ /HASH/) );\n\n\tcroak \"Model \".$closure.\" is not instance of RDFStore::Model\"\n                unless( (defined $closure) && (ref($closure)) &&\n                        ($closure->isa('RDFStore::Model')) );\n\n\tcroak \"Model \".$model.\" is not instance of RDFStore::Model\"\n                unless( (defined $model) && (ref($model)) &&\n                        ($model->isa('RDFStore::Model')) );\n\n\tcroak \"Integer \".$depth.\" is not a valid INTEGER \"\n                unless( ($depth == 0) || ( (defined $depth) && (int($depth))) );\n\n\t$processedNodes->{ $object->toString } = 1;\n\n\tmy $isOnStack = (exists $stack->{ $object->toString });\n\tmy $isLoop = $isOnStack;\n\tif(!($isOnStack)) {\n\t\t$stack->{ $object->toString } = 1;\n\n\t\tmy $children = $model->find(undef, $property, undef)->elements;\n\n\t\twhile ( my $s = $children->each_subject ) {\n        \t\t$isLoop |= $_[0]->traverseClosure($processedNodes, $s, $property, $stack, $closure, $model, $depth+1 );\n      \t\t\t};\n\n\t\tdelete $stack->{ $object->toString }\n\t\t\tif(!($isLoop));\n\t\t};\n\n    \tif(!($isOnStack)) {\n\t\twhile ( my ($k,$parent) = each %{$stack} ) {\n\t\t\tmy $factory = $model->getNodeFactory();\n      \t\t\t$closure->add( $factory->createStatement($object, $property, $factory->createResource($parent)) );\n\t\t\t};\n    \t\t};\n\n\treturn $isLoop;\n\t};\n\nsub validateRawSchema {\n\tmy ($class, $instances_model, $schema_model) = @_;\n\n\tcroak \"Model \".$instances_model.\" is not instance of RDFStore::Model\"\n                unless( (defined $instances_model) && (ref($instances_model)) &&\n                        ($instances_model->isa('RDFStore::Model')) );\n\n\tcroak \"Model \".$schema_model.\" is not instance of RDFStore::Model\"\n                unless( (defined $schema_model) && (ref($schema_model)) &&\n                        ($schema_model->isa('RDFStore::Model')) );\n\n\tmy $closure = $class->computeRDFSClosure($schema_model);\n\n\tmy $schema = new RDFStore::SchemaModel($schema_model, $closure); \n\tmy $instances = new RDFStore::SchemaModel($instances_model, $closure);\n\n\t$class->validate($instances, $schema);\n\t};\n\nsub getOrd {\n\tcroak \"Resource \".$_[1].\" is not instance of RDFStore::Resource\"\n                unless( (defined $_[1]) && (ref($_[1])) &&\n                        ($_[1]->isa('RDFStore::Resource')) );\n\n\treturn -1\n\t\tunless(defined $_[1]);\n\n\tmy $uri = $_[1]->toString();\n\n\treturn -1\n\t\tif(!((defined $uri) && ($uri =~ m|^$RDFStore::Vocabulary::RDF::_Namespace|)));\n                  \n\tmy $pos;\n\tif (\t($uri =~ m|#$|g) ||\n\t\t($uri =~ m|:$|g) ||\n\t\t($uri =~ m|\\/$|g) ) {\n\t\t$pos=pos($uri);\n\t} else {\n\t\t$pos=length($uri);\n\t\t};\n\n\tif(($pos > 0) && ($pos + 1 < length($uri))) {\n        \tmy $n = unpack(\"i*\",substring($uri,$pos + 1));\n        \treturn $n\n\t\t\tif($n >= 1);\n    \t\t};\n\n\treturn -1;\n\t};\n\nsub validate {\n\tmy ($class, $instances, $schema ) = @_;\n\n\tcroak \"Model \".$instances.\" is not instance of RDFStore::Model\"\n                unless( (defined $instances) && (ref($instances)) &&\n                        ($instances->isa('RDFStore::Model')) );\n\n\tcroak \"Model \".$schema.\" is not instance of RDFStore::SchemaModel\"\n                unless( (defined $schema) && (ref($schema)) &&\n                        ($schema->isa('RDFStore::SchemaModel')) );\n\n\tmy %containers = (); \n\tmy @errors = ();\n\tmy $ele = $instances->elements;\n\twhile ( my $t = $ele->each ) {\n\t\tif($RDFStore::Vocabulary::RDF::type->equals($t->predicate())) {\n\t\t\tif($t->object()->isa(\"RDFStore::Literal\")) {\n          \t\t\t$class->invalid( \\@errors, $t, \"Literals cannot be used for typing - object must be a RDF resource of some kind\" );\n\t\t\t\t};\n        \t\tmy $res = $schema->find( $t->object(), $RDFStore::Vocabulary::RDF::type, $RDFStore::Vocabulary::RDFS::Class );\n\t\t\tif($res->isEmpty()) {\n          \t\t\tif($class->noSchema(\\@errors, $t->object())) {\n\t\t\t\t\tlast;\n\t\t\t\t} else {\n            \t\t\t\t$class->invalid( \\@errors, $t, $t->object->toString . \" must be an instance of \". $RDFStore::Vocabulary::RDFS::Class->toString );\n        \t\t\t\t};\n        \t\t\t};\n\t\t} elsif($class->getOrd($t->predicate()) > 0) {\n\t\t\t$containers{ $t->subject->toString }= $t;\n\t\t} else {\n\t\t\tmy @expected = ();\n\n\t\t\tmy $domains = $schema->find( $t->predicate(), $RDFStore::Vocabulary::RDFS::domain, undef );\n        \t\tif(!($domains->isEmpty())) {\n          \t\t\tmy $domainOK = 0;\n\t\t\t\tmy $dd = $domains->elements;\n\t\t\t\twhile( my $o = $dd->each_object ) {\n            \t\t\t\tpush @expected, $o;\n            \t\t\t\tif(!($instances->find($t->subject(),$RDFStore::Vocabulary::RDF::type, $o)->isEmpty())) {\n              \t\t\t\t\t$domainOK = 1;\n\t\t\t\t\t\tlast;\n            \t\t\t\t\t};\n          \t\t\t\t};\n          \t\t\tif(!($domainOK)) {\n            \t\t\t\tif($class->noSchema(\\@errors, $t->subject())) {\n\t\t\t\t\t\tlast;\n\t\t\t\t\t} else {\n              \t\t\t\t\t$class->invalid( \\@errors, $t, \"Subject must be instance of \".join(' or ', map { $_->toString } @expected ) );\n          \t\t\t\t\t};\n          \t\t\t\t};\n        \t\t\t};\n\t\t\t@expected=();\n\n\t\t\tmy $ranges = $schema->find( $t->predicate(), $RDFStore::Vocabulary::RDFS::range, undef );\n        \t\tif($ranges->size() == 1) { \n          \t\t\tmy $rangeOK = 0;\n\t\t\t\tmy $rr = $ranges->elements;\n\t\t\t\twhile( my $o = $rr->each_object ) {\n            \t\t\t\tpush @expected, $o;\n            \t\t\t\tif($RDFStore::Vocabulary::RDFS::Literal->equals($o)) {\n              \t\t\t\t\tif( $t->object()->isa(\"RDFStore::Literal\")) {\n\t\t\t\t\t\t\t$rangeOK = 1;\n                \t\t\t\t\tlast;\n              \t\t\t\t\t} else {\n                \t\t\t\t\t$class->invalid( \\@errors, $t, $t->object() .\" must be a literal\");\n\t\t\t\t\t\t\t};\n\t\t\t\t\t} elsif (\t($t->object()->isa(\"RDFStore::Resource\")) &&\n\t\t\t\t\t\t\t(!($instances->find( $t->object(), $RDFStore::Vocabulary::RDF::type, $o )->isEmpty())) ) {\n\t\t\t\t\t\t$rangeOK = 1;\n\t\t\t\t\t\tlast;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\tif(!($rangeOK)) {\n\t\t\t\t\tif($class->noSchema(\\@errors,$t->object())) {\n\t\t\t\t\t\tlast;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$class->invalid( \\@errors, $t, \"Object must be instance of \".join(' or ', map { $_->toString } @expected ) );\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n        \t\t} elsif($ranges->size() > 1) {\n          \t\t\t$class->invalid( \\@errors, undef, \"Invalid schema. Multiple ranges for \".$t->predicate->toString );\n      \t\t\t\t};\n      \t\t\t};\n    \t\t};\n\n\tcroak \"InvalidModel \".join(' , ', @errors)\n\t\tif(scalar(@errors)>0);\n\t};\n\nsub noSchema {\n \treturn 0;\n\t};\n\nsub invalid {\n\tcroak \"Parameter \".$_[1].\" is not an ARRAY reference\"\n                unless( (defined $_[1]) &&\n                        (ref($_[1])=~ /ARRAY/) );\n\tcroak \"Statement \".$_[2].\" is not instance of RDFStore::Statement\"\n                unless( (defined $_[2]) && (ref($_[2])) &&\n                        ($_[2]->isa('RDFStore::Statement')) );\n\n\tif(scalar(@{$_[1]}) > 0) {\n\t\tpush @{$_[1]},\"\\n\";\n    \t\tif(defined $_[2]) {\n      \t\t\tpush @{$_[1]},\"Invalid statement:\\n\\t\".$_[2].\".\\n\\t\";\n    \t\t\t};\n    \t\t};\n\n\tpush @{$_[1]},$_[3];\n\t};\n\npackage RDFStore::SchemaModel::Iterator;\n\nuse vars qw ( $VERSION );\nuse strict;\n\n$VERSION = '0.1';\n\nsub new {\n\tmy ($pkg,$factory,$iterator) = @_;\n\n\treturn\n                unless( (defined $iterator) && (defined $factory) );\n\n        return \tbless {\n\t\t\tfactory => \t$factory,\n\t\t\titerator => \t$iterator\n\t\t},$pkg;\n\t};\n\nsub size {\n\treturn $_[0]->{iterator}->size;\n\t};\n\nsub duplicate {\n\treturn $_[0]->{iterator}->duplicate;\n\t};\n\nsub hasnext {\n\treturn $_[0]->{iterator}->hasnext;\n\t};\n\nsub remove {\n\treturn $_[0]->{iterator}->remove;\n\t};\n\nsub intersect {\n\treturn\n\t\tunless(\t(defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n\t\t\t($_[1]->isa(\"RDFStore::SchemaModel::Iterator\")) );\n\n\treturn new RDFStore::SchemaModel::Iterator(\t$_[0]->{factory},\n\t\t\t\t\t\t$_[0]->{iterator}->intersect( $_[1]->{iterator} ) );\n\t};\n\nsub unite {\n\treturn\n\t\tunless(\t(defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n\t\t\t($_[1]->isa(\"RDFStore::SchemaModel::Iterator\")) );\n\n\treturn new RDFStore::SchemaModel::Iterator(\t$_[0]->{factory},\n\t\t\t\t\t\t$_[0]->{iterator}->unite( $_[1]->{iterator} ) );\n\t};\n\nsub subtract {\n\treturn\n\t\tunless(\t(defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n\t\t\t($_[1]->isa(\"RDFStore::SchemaModel::Iterator\")) );\n\n\treturn new RDFStore::SchemaModel::Iterator(\t$_[0]->{factory},\n\t\t\t\t\t\t$_[0]->{iterator}->subtract( $_[1]->{iterator} ) );\n\t};\n\nsub complement {\n\treturn\n\t\tunless(\t(defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n\t\t\t($_[1]->isa(\"RDFStore::SchemaModel::Iterator\")) );\n\n\treturn new RDFStore::SchemaModel::Iterator(\t$_[0]->{factory},\n\t\t\t\t\t\t$_[0]->{iterator}->complement( $_[1]->{iterator} ) );\n\t};\n\nsub exor {\n\treturn\n\t\tunless(\t(defined $_[1]) &&\n\t\t\t(ref($_[1])) &&\n\t\t\t($_[1]->isa(\"RDFStore::SchemaModel::Iterator\")) );\n\n\treturn new RDFStore::SchemaModel::Iterator(\t$_[0]->{factory},\n\t\t\t\t\t\t$_[0]->{iterator}->exor( $_[1]->{iterator} ) );\n\t};\n\nsub next {\n\tmy ($st) = $_[0]->{iterator}->next;\n\n\treturn\n\t\tunless($st);\n\n\treturn $_[0]->{factory}->createStatement(\n\t\t\t( $st->subject->isbNode ) ? \n\t\t\t\t$_[0]->{factory}->createAnonymousResource( $st->subject->toString ) : \n\t\t\t\t$_[0]->{factory}->createResource( $st->subject->toString ),\n\t\t\t( $st->predicate->isbNode ) ? \n\t\t\t\t$_[0]->{factory}->createAnonymousResource( $st->predicate->toString ) : \n\t\t\t\t$_[0]->{factory}->createResource( $st->predicate->toString ),\n\t\t\t( $st->object->isa(\"RDFStore::Literal\") ) ?\n\t\t\t\t$_[0]->{factory}->createLiteral(\t$st->object->getLabel,\n\t\t\t\t\t\t\t\t\t$st->object->getParseType,\n\t\t\t\t\t\t\t\t\t$st->object->getLang,\n\t\t\t\t\t\t\t\t\t$st->object->getDataType ) :\n\t\t\t( $st->object->isbNode ) ? \n\t\t\t\t$_[0]->{factory}->createAnonymousResource( $st->object->toString ) : \n\t\t\t\t$_[0]->{factory}->createResource( $st->object->toString ),\n\t\t\t( $st->context ) ?  ( $st->context->isbNode ) ? \n\t\t\t\t\t\t$_[0]->{factory}->createAnonymousResource( $st->context->toString ) : \n\t\t\t\t\t\t$_[0]->{factory}->createResource( $st->context->toString ) : undef );\n\t};\n\nsub next_subject {\n\tmy ($n) = $_[0]->{iterator}->next_subject;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n\t\t\t$_[0]->{factory}->createAnonymousResource( $n->toString ) : \n\t\t\t$_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub next_predicate {\n\tmy ($n) = $_[0]->{iterator}->next_predicate;\n\n        return\n                unless($n); \n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub next_object {\n\tmy ($n) = $_[0]->{iterator}->next_object;\n\n        return\n                unless($n); \n\n\treturn ( $n->isa(\"RDFStore::Literal\") ) ?\n               \t$_[0]->{factory}->createLiteral(\t$n->getLabel,\n                                                        $n->getParseType,\n                                                        $n->getLang,\n                                                        $n->getDataType ) :\n               ( $n->isbNode ) ?\n                \t$_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub next_context {\n\tmy ($n) = $_[0]->{iterator}->next_context;\n\n        return\n                unless($n); \n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub current {\n\tmy ($st) = $_[0]->{iterator}->current;\n\n        return\n                unless($st);\n\n\treturn $_[0]->{factory}->createStatement(\n                        ( $st->subject->isbNode ) ?\n                                $_[0]->{factory}->createAnonymousResource( $st->subject->toString ) :\n                                $_[0]->{factory}->createResource( $st->subject->toString ),\n                        ( $st->predicate->isbNode ) ? \n                                $_[0]->{factory}->createAnonymousResource( $st->predicate->toString ) :\n                                $_[0]->{factory}->createResource( $st->predicate->toString ),\n                        ( $st->object->isa(\"RDFStore::Literal\") ) ?\n                                $_[0]->{factory}->createLiteral(        $st->object->getLabel,\n                                                                        $st->object->getParseType,\n                                                                        $st->object->getLang,\n                                                                        $st->object->getDataType ) :\n                        ( $st->object->isbNode ) ? \n                                $_[0]->{factory}->createAnonymousResource( $st->object->toString ) : \n                                $_[0]->{factory}->createResource( $st->object->toString ), \n                        ( $st->context ) ?  ( $st->context->isbNode ) ?                  \n                                                $_[0]->{factory}->createAnonymousResource( $st->context->toString ) :\n                                                $_[0]->{factory}->createResource( $st->context->toString ) : undef );\n\t};\n\nsub current_subject {\n\tmy ($n) = $_[0]->{iterator}->current_subject;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub current_predicate {\n\tmy ($n) = $_[0]->{iterator}->current_predicate;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub current_object {\n\tmy ($n) = $_[0]->{iterator}->current_object;\n\n        return\n                unless($n);\n\n        return ( $n->isa(\"RDFStore::Literal\") ) ?\n                $_[0]->{factory}->createLiteral(        $n->getLabel,\n                                                        $n->getParseType,\n                                                        $n->getLang,\n                                                        $n->getDataType ) :\n               ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub current_context {  \n\tmy ($n) = $_[0]->{iterator}->current_context;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n        };\n\nsub first {\n\tmy ($st) = $_[0]->{iterator}->first;\n\n        return\n                unless($st);\n\n\treturn $_[0]->{factory}->createStatement(\n                        ( $st->subject->isbNode ) ?\n                                $_[0]->{factory}->createAnonymousResource( $st->subject->toString ) :\n                                $_[0]->{factory}->createResource( $st->subject->toString ),\n                        ( $st->predicate->isbNode ) ? \n                                $_[0]->{factory}->createAnonymousResource( $st->predicate->toString ) :\n                                $_[0]->{factory}->createResource( $st->predicate->toString ),\n                        ( $st->object->isa(\"RDFStore::Literal\") ) ?\n                                $_[0]->{factory}->createLiteral(        $st->object->getLabel,\n                                                                        $st->object->getParseType,\n                                                                        $st->object->getLang,\n                                                                        $st->object->getDataType ) :\n                        ( $st->object->isbNode ) ? \n                                $_[0]->{factory}->createAnonymousResource( $st->object->toString ) : \n                                $_[0]->{factory}->createResource( $st->object->toString ), \n                        ( $st->context ) ?  ( $st->context->isbNode ) ?                  \n                                                $_[0]->{factory}->createAnonymousResource( $st->context->toString ) :\n                                                $_[0]->{factory}->createResource( $st->context->toString ) : undef );\n\t};\n\nsub first_subject {\n\tmy ($n) = $_[0]->{iterator}->first_subject;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub first_predicate {\n\tmy ($n) = $_[0]->{iterator}->first_predicate;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub first_object {\n\tmy ($n) = $_[0]->{iterator}->first_object;\n\n        return\n                unless($n);\n\n        return ( $n->isa(\"RDFStore::Literal\") ) ?\n                $_[0]->{factory}->createLiteral(        $n->getLabel,\n                                                        $n->getParseType,\n                                                        $n->getLang,\n                                                        $n->getDataType ) :\n               ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub first_context {  \n\tmy ($n) = $_[0]->{iterator}->first_context;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n        };\n\nsub each {\n\tmy ($st) = $_[0]->{iterator}->each;\n\n        return\n                unless($st);\n\n\treturn $_[0]->{factory}->createStatement(\n                        ( $st->subject->isbNode ) ?\n                                $_[0]->{factory}->createAnonymousResource( $st->subject->toString ) :\n                                $_[0]->{factory}->createResource( $st->subject->toString ),\n                        ( $st->predicate->isbNode ) ? \n                                $_[0]->{factory}->createAnonymousResource( $st->predicate->toString ) :\n                                $_[0]->{factory}->createResource( $st->predicate->toString ),\n                        ( $st->object->isa(\"RDFStore::Literal\") ) ?\n                                $_[0]->{factory}->createLiteral(        $st->object->getLabel,\n                                                                        $st->object->getParseType,\n                                                                        $st->object->getLang,\n                                                                        $st->object->getDataType ) :\n                        ( $st->object->isbNode ) ? \n                                $_[0]->{factory}->createAnonymousResource( $st->object->toString ) : \n                                $_[0]->{factory}->createResource( $st->object->toString ), \n                        ( $st->context ) ?  ( $st->context->isbNode ) ?                  \n                                                $_[0]->{factory}->createAnonymousResource( $st->context->toString ) :\n                                                $_[0]->{factory}->createResource( $st->context->toString ) : undef );\n\t};\n\nsub each_subject {\n\tmy ($n) = $_[0]->{iterator}->each_subject;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub each_predicate {\n\tmy ($n) = $_[0]->{iterator}->each_predicate;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub each_object {\n\tmy ($n) = $_[0]->{iterator}->each_object;\n\n        return\n                unless($n);\n\n        return ( $n->isa(\"RDFStore::Literal\") ) ?\n                $_[0]->{factory}->createLiteral(        $n->getLabel,\n                                                        $n->getParseType,\n                                                        $n->getLang,\n                                                        $n->getDataType ) :\n               ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n\t};\n\nsub each_context {  \n\tmy ($n) = $_[0]->{iterator}->each_context;\n\n        return\n                unless($n);\n\n        return ( $n->isbNode ) ?\n                        $_[0]->{factory}->createAnonymousResource( $n->toString ) :\n                        $_[0]->{factory}->createResource( $n->toString );\n        };\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/SchemaModel.pm",
      "package" : "RDFStore::SchemaModel"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.42';\n\nuse Carp;\nuse RDFStore::Literal;\nuse RDFStore::Resource;\nuse RDFStore::Statement;\nuse RDFStore::Util::Digest;\n\nsub new {\n\tmy ( $pkg, $nodesCounter, $bnodesCounter, $timestamp, $rand_seed ) = @_;\n\n\t$nodesCounter = 0\n\t\tunless($nodesCounter);\n\t$bnodesCounter = 0\n\t\tunless($bnodesCounter);\n\t$timestamp = time()\n\t\tunless($timestamp);\n\t$rand_seed = unpack(\"H*\", rand())\n\t\tunless($rand_seed);\n\n    \tbless {\n\t\t'nodesCounter' => $nodesCounter,\n\t\t'bnodesCounter' => $bnodesCounter,\n\t\t'timestamp' => $timestamp,\n\t\t'rand_seed' => $rand_seed\n\t\t}, $pkg;\n\t};\n\nsub createResource {\n\tif(defined $_[2]) {\n\t\treturn new RDFStore::Resource($_[1],$_[2]) or\n\t\t\treturn;\n\t} else {\n\t\treturn ($_[1]) ? new RDFStore::Resource($_[1]) : undef;\n\t\t};\n\t};\n\nsub createAnonymousResource {\n\tif(defined $_[1]) {\n\t\treturn new RDFStore::Resource($_[1], undef, 1);\n\t} else {\n\t\treturn new RDFStore::Resource(\n\t\t\t'rdfnodeIDgenidrdfstore' .\n\t\t\t'S'.$_[0]->{'rand_seed'} .\n\t\t\t'P'. $$.\n\t\t\t'T'. $_[0]->{'timestamp'} .\n\t\t\t'N'. $_[0]->{bnodesCounter}++, undef, 1 );\n\t\t};\n\t};\n\nsub createbNode {\n\tmy ($class) = shift;\n\n\treturn $class->createAnonymousResource(@_);\n\t};\n\nsub createLiteral {\n\tmy ($class) = shift;\n\n\treturn new RDFStore::Literal(@_);\n\t};\n\nsub createStatement {\n\treturn ( \t(defined $_[1]) && \n\t\t\t(defined $_[2]) && \n\t\t\t(defined $_[3]) ) ? new RDFStore::Statement($_[1], $_[2], $_[3], (defined $_[4]) ? $_[4] : undef ) :\n\t\t\tundef;\n\t};\n\nsub createReifiedStatement {\n\treturn ( \t(defined $_[1]) && \n\t\t\t(defined $_[2]) && \n\t\t\t(defined $_[3]) ) ? \n\t\t\t\tnew RDFStore::Statement( $_[1], $_[2], $_[3], \n\t\t\t\t\t\t\t\t\t( (defined $_[4]) ? $_[4] : undef ), 1, \n\t\t\t\t\t\t\t\t\t( (defined $_[5]) ? $_[5] : undef ) ) : undef;\n\t};\n\nsub createUniqueResource {\n\treturn new RDFStore::Resource(\n\t\t\t'rdfresourcerdfstore' .\n\t\t\t'S'.$_[0]->{'rand_seed'} .\n\t\t\t'P'. $$.\n\t\t\t'T'. $_[0]->{'timestamp'} .\n\t\t\t'N'. $_[0]->{nodesCounter}++ );\n\t};\n\nsub createOrdinal {\n\tmy ($class,$i) = @_;\n\n\tif($i < 1) {\n\t\tcroak \"Attempt to construct invalid ordinal resource\";\n\t} else {\n\t\treturn $class->createResource(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\", \"_\" . $i); \n\t\t};\n\t};\n\nsub createNTriple {\n        my ($class, $ntriple) = @_;\n\n        chomp( $ntriple );\n        $ntriple =~ s/^[\\x20\\x09]+//;   \n        $ntriple =~ s/[\\x20\\x09]+$//;   \n\n        if ($ntriple =~ m/[^\\x20-\\x7e\\x0d\\x0a\\x09]/) {\n                warn 'Invalid character(s) found';\n                return undef;\n                };\n\n\tunless ($ntriple =~ s/\\.$//) {\n\t\twarn 'Syntax error: missing trailing full stop';\n\t\treturn undef;\n\t\t};\n\n        my ($subject, $predicate, $object, $context );\n\n        if ($ntriple =~ s/^<([^>]*)>[\\x20\\x09]+//) {\n\t\t$subject = $class->createResource( $1 );\n        } elsif ($ntriple =~  s/^_:([A-Za-z][A-Za-z0-9]*)[\\x20\\x09]+//) {\n\t\t$subject = $class->createbNode( $1 );\n        } else {\n                warn 'Syntax error in <subject> token';\n\t\treturn undef;\n                };\n\n        if ($ntriple =~  s/^<([^>]*)>[\\x20\\x09]+//) {\n\t\t$predicate = $class->createResource( $1 );\n        } else {\n                warn 'Syntax error in <predicate> token';\n\t\treturn undef;\n                };\n\n        if ($ntriple =~  s/^<([^>]*)>[\\x20\\x09]+//) {\n\t\t$object = $class->createResource( $1 );\n        } elsif ($ntriple =~  s/^_:([A-Za-z][A-Za-z0-9]*)[\\x20\\x09]+//) {\n\t\t$object = $class->createbNode( $1 );\n        } elsif ($ntriple =~  s/\"([^\"]*)\"\\@([a-z0-9]+(-[a-z0-9]+)?)\\^\\^<([^>]*)>[\\x20\\x09]+//) {\n\t\tif ( $4 eq 'http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral' ) {\n\t\t\t$object = $class->createLiteral( $1, 1, $2, $4 );\n\t\t} else {\n\t\t\t$object = $class->createLiteral( $1, undef, $2, $4 );\n\t\t\t};\n        } elsif ($ntriple =~  s/\"([^\"]*)\"\\^\\^<([^>]*)>[\\x20\\x09]+//) {\n\t\tif ( $2 eq 'http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral' ) {\n\t\t\t$object = $class->createLiteral( $1, 1, undef, $2 );\n\t\t} else {\n\t\t\t$object = $class->createLiteral( $1, undef, undef, $2 );\n\t\t\t};\n        } elsif ($ntriple =~  s/\"([^\"]*)\"\\@([a-z0-9]+(-[a-z0-9]+)?)[\\x20\\x09]+//) {\n\t\t$object = $class->createLiteral( $1, undef, $2 );\n        } elsif ($ntriple =~  s/\"([^\"]*)\"[\\x20\\x09]+//) {\n\t\t$object = $class->createLiteral( $1 );\n        } else {\n                warn 'Syntax error in <object> token';\n\t\treturn undef;\n                };\n\n\tif ( length($ntriple) ) {\n        \tif ($ntriple =~ s/^<([^>]*)>[\\x20\\x09]+//) {\n\t\t\t$context = $class->createResource( $1 );\n        \t} elsif ($ntriple =~  s/^_:([A-Za-z][A-Za-z0-9]*)[\\x20\\x09]+//) {\n\t\t\t$context = $class->createbNode( $1 );\n        \t} else {\n                \twarn 'Trash found after <object> token'; \n\t\t\treturn undef;\n                \t};\n\t\t};\n\n        return $class->createStatement( $subject, $predicate, $object, $context );\n};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/NodeFactory.pm",
      "package" : "RDFStore::NodeFactory"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.42';\n\nuse Carp;\nuse RDFStore; \nuse RDFStore::Resource;\n\nsub isAnonymous {\n\treturn 0;\n\t};\n\nsub getNamespace {\n        return undef;\n};\n\nsub getLocalName {\n        return $_[0]->getLabel();\n};\n\nsub getURI {\n\treturn $_[0]->getLabel();\n};\n\nsub equals {\n\treturn 0\n\t\tunless(defined $_[1]);\n\n\tif( $_[0]->context and $_[1]->context ) {\n\t\treturn\t(\t($_[0]->subject->getLabel eq $_[1]->subject->getLabel) &&\n\t\t\t\t($_[0]->predicate->getLabel eq $_[1]->predicate->getLabel) &&\n\t\t\t\t($_[0]->object->getLabel eq $_[1]->object->getLabel) &&\n\t\t\t\t($_[0]->context->getLabel eq $_[1]->context->getLabel) );\n\t} else {\n\t\treturn\t(\t($_[0]->subject->getLabel eq $_[1]->subject->getLabel) &&\n\t\t\t\t($_[0]->predicate->getLabel eq $_[1]->predicate->getLabel) &&\n\t\t\t\t($_[0]->object->getLabel eq $_[1]->object->getLabel) );\n\t\t};\n};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Statement.pm",
      "package" : "RDFStore::Statement"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.1';\n\nuse Carp;\n\nuse RDFStore::Vocabulary::RDF;\nuse RDFStore::Vocabulary::RDFS;\nuse RDFStore::Vocabulary::DC;\nuse RDFStore::Vocabulary::DCQ;\nuse RDFStore::Vocabulary::DCT;\nuse RDFStore::Vocabulary::DAML;\nuse RDFStore::Vocabulary::RDFStoreContext;\n\nsub new {\n        my ($pkg) = @_;\n\n        my $self = {};\n\n        $self->{Namespaces} = {};\n\t$self->{Namespaces}->{ $RDFStore::Vocabulary::RDF::_Namespace } = 'rdf';\n\t$self->{Namespaces}->{ $RDFStore::Vocabulary::RDFS::_Namespace } = 'rdfs';\n\t$self->{Namespaces}->{ $RDFStore::Vocabulary::DC::_Namespace } = 'dc';\n\t$self->{Namespaces}->{ $RDFStore::Vocabulary::DCQ::_Namespace } = 'dcq';\n\t$self->{Namespaces}->{ $RDFStore::Vocabulary::DCT::_Namespace } = 'dct';\n\t$self->{Namespaces}->{ $RDFStore::Vocabulary::DAML::_Namespace } = 'daml';\n\t$self->{Namespaces}->{ $RDFStore::Vocabulary::RDFStoreContext::_Namespace } = 'rdfstore';\n\n\t$self->{string} = '';\n\n\t$self->{'options'} = {};\n\n\tbless $self,$pkg;\n\n\treturn $self;\n\t};\n\nsub setProperty {\n\tmy ($class, $name, $value) = @_;\n\t\n\t$class->{'options'}->{ $name } = $value;\n\t};\n\nsub getProperty {\n\tmy ($class, $name) = @_;\n\t\n\treturn $class->{'options'}->{ $name };\n\t};\n\nsub setNamespacePrefix {\n\tmy ($class, $ns_uri, $ns_prefix ) = @_;\n\t\n\t$class->{Namespaces}->{ $ns_uri } = $ns_prefix;\n\t};\n\nsub getNamespacePrefix {\n\tmy ($class, $ns_uri ) = @_;\n\t\n\treturn $class->{Namespaces}->{ $ns_uri };\n\t};\n\nsub serialize {\n\tmy ($class) = shift;\n\n\treturn $class->write( @_ );\n\t};\n\nsub write {\n\tmy ($class, $model, $fh, $namespaces, $base ) = @_;\n\n\tcroak \"Model is not defined\"\n                unless( (defined $model) && (ref($model)) &&\n                        ($model->isa('RDFStore::Model')) );\n\n\t$class->{'ioref'} = \\$fh\n\t\tif( defined $fh );\n\n\tif (\t( defined $namespaces ) &&\n\t\t(ref($namespaces) =~ /HASH/) ) {\n\t\tforeach my $ns_uri ( keys %{$namespaces} ) {\n\t\t\t$class->setNamespacePrefix( $ns_uri, $namespaces->{ $ns_uri } );\n\t\t\t};\n\t\t};\n\n\t$class->{string} = '';\n\t};\n\nsub printContent {\n\tmy ($class) = shift;\n\n\tif(exists $class->{'ioref'}) {\n\t\tprint ${ $class->{'ioref'} } (@_);\n\t} else {\n\t\t$class->{string} .= join('',@_);\n\t\t};\n\t};\n\nsub returnContent {\n\treturn (exists $_[0]->{'ioref'}) ? 1 : $_[0]->{string};\n\t};\n\nsub xml_escape {      \n\tmy $class = shift;\n\tmy $text  = shift;\n\n\t$text =~ s/\\&/\\&amp;/g;\n\t$text =~ s/</\\&lt;/g;\n\tforeach (@_) {\n\t\tcroak \"xml_escape: '$_' isn't a single character\" if length($_) > 1;\n\n\t\tif ($_ eq '>') {\n\t\t\t$text =~ s/>/\\&gt;/g;\n\t\t} elsif ($_ eq '\"') {\n\t\t\t$text =~ s/\\\"/\\&quot;/g;\n\t\t} elsif ($_ eq \"'\") {\n\t\t\t$text =~ s/\\'/\\&apos;/g;\n\t\t} else {\n\t\t\tmy $rep = '&#' . sprintf('x%X', ord($_)) . ';';\n\t\t\tif (/\\W/) {\n\t\t\t\tmy $ptrn = \"\\\\$_\";\n\t\t\t\t$text =~ s/$ptrn/$rep/g;\n\t\t\t} else {\n\t\t\t\t$text =~ s/$_/$rep/g;\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\treturn $text;\n\t};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Serializer.pm",
      "package" : "RDFStore::Serializer"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.4';\n\nuse Carp;\nuse RDFStore::Model;\n\n@RDFStore::VirtualModel::ISA = qw( RDFStore::Model );\n\nsub new {\n\tmy ($pkg) = shift;\n\tbless $pkg->SUPER::new(@_), $pkg;\n};\n\nsub getGroundModel {\n};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/VirtualModel.pm",
      "package" : "RDFStore::VirtualModel"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse strict;\nuse Carp;\nuse vars qw($VERSION);\n\nuse RDFStore; \n\nrequire Exporter;\n\n@RDFStore::Util::UTF8::ISA = qw(Exporter);\n\n@RDFStore::Util::UTF8::EXPORT_OK = qw( cp_to_utf8 utf8_to_cp is_utf8 to_utf8 to_utf8_foldedcase utf8lc ); \n\n$VERSION = '0.1';\n\nsub utf8lc {\n\tto_utf8_foldedcase( @_ );\n\t};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Util/UTF8.pm",
      "package" : "RDFStore::Util::UTF8"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse strict;\nuse Carp;\nuse vars qw($VERSION);\n\nuse RDFStore; \n\n$VERSION = '0.1';\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Util/Digest.pm",
      "package" : "RDFStore::Util::Digest"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n\n$VERSION = '0.1';\n\nsub new {\n        bless {} , shift;\n};\n\nsub getDigest {\n};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Digest/Digestable.pm",
      "package" : "RDFStore::Digest::Digestable"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\tuse vars qw($VERSION %Built_In_Styles $RDF_SYNTAX_NS $RDFMS_parseType_Literal);\n\tuse strict;\n\tuse Carp qw(carp croak cluck confess);\n\tuse URI;\n\tuse URI::Escape;\n\t\n\tuse RDFStore::Util::UTF8 qw( cp_to_utf8 );\n\n\tuse RDFStore::Parser;\n\t@RDFStore::Parser::NTriples::ISA = qw( RDFStore::Parser );\n\nBEGIN {\n\trequire XML::Parser::Expat;\n    \t$VERSION = '0.1';\n    \tcroak \"XML::Parser::Expat.pm version 2 or higher is needed to process rdf:parseType='Literal' XML content\"\n\t\tunless $XML::Parser::Expat::VERSION =~ /^2\\./;\n\t};\n\n$RDFStore::Parser::NTriples::RDF_SYNTAX_NS=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n$RDFStore::Parser::NTriples::RDFMS_parseType_Literal = $RDFStore::Parser::NTriples::RDF_SYNTAX_NS . \"XMLLiteral\";\n\nsub new {\n\tmy ($pkg) = shift;\n\n        my $self = $pkg->SUPER::new(@_);\n\n        bless $self,$pkg;\n\t};\n\nsub parse {\n\tmy $class = shift;\n\n\t$class->SUPER::parse( @_ );\n\n\tmy $arg = shift;\n\tmy $file_or_uri = shift;\n\n  \t$class->{iReificationCounter}= ( ($class->{GenidNumber}) && (int($class->{GenidNumber})) ) ? $class->{GenidNumber} : 0;\n\n\tif(\t(exists $class->{Source}) && \n\t\t\t(defined $class->{Source}) &&\n\t\t\t( (!(ref($class->{Source}))) || (!($class->{Source}->isa(\"URI\"))) )\t) {\n\t\tif(-e $class->{Source}) {\n\t\t\t$class->{Source}=URI->new('file:'.$class->{Source});\n\t\t} else {\n\t\t\t$class->{Source}=URI->new($class->{Source});\n\t\t};\n\t} elsif(defined $file_or_uri) {\n\t\tif( (ref($file_or_uri)) && ($file_or_uri->isa(\"URI\")) ) {\n\t\t\t$class->{Source}=$file_or_uri;\n\t\t} elsif(-e $file_or_uri) {\n\t\t\t$class->{Source}=URI->new('file:'.$file_or_uri);\n\t\t} else {\n\t\t\t$class->{Source}=undef; \n\t\t};\n\t};\n\tif(     (exists $class->{Source}) &&\n                (defined $class->{Source}) ) {\n                $class->{sSource}= $class->setSource(\n                        (       (ref($class->{Source})) &&\n                                ($class->{Source}->isa(\"URI\")) ) ? $class->{Source}->as_string :\n                                $class->{Source} );\n        \t};\n\n\tcroak \"Missing NodeFactory\"\n\t\tunless(\t(defined $class->{NodeFactory}) && \n\t\t\t($class->{NodeFactory}->isa(\"RDFStore::NodeFactory\")) );\n\t$class->{nodeFactory} = $class->{NodeFactory};\n\t$class->{Warnings} = ( defined $class->{Warnings} && $class->{Warnings} =~ m/off|0|no|hide/ ) ? 0 : 1; \n\n    \tmy %handlers = %{$class->{Handlers}}\n\t\tif( (defined $class->{Handlers}) && (ref($class->{Handlers}) =~ /HASH/) );\n\n    \tmy $init = delete $handlers{Init};\n\tmy $final = delete $handlers{Final};\n\n    \t&$init($class) \n\t\tif defined($init);\n\n\tmy $result;\n\tmy $ioref;\n\tif (defined $arg) {\n    \t\tif (ref($arg) and UNIVERSAL::isa($arg, 'IO::Handler')) {\n      \t\t\t$ioref = $arg;\n    \t\t} else {\n      \t\t\teval {\n        \t\t\t$ioref = *{$arg}{IO};\n      \t\t\t\t};    \n      \t\t\tundef $@;\n    \t\t\t};\n  \t\t};\n\n\teval {\n\t\tif (defined($ioref)) {\n    \t\t\tmy $delim = $class->{Stream_Delimiter};\n    \t\t\tmy $prev_rs;\n   \n    \t\t\t$prev_rs = ref($ioref)->input_record_separator(\"\\n$delim\\n\")\n      \t\t\t\tif defined($delim);\n   \n\t\t\twhile ( <$arg> ) {\n        \t\t\t$result = $class->_pp_NTriple($_); \n\t\t\t\t};\n   \n    \t\t\tref($ioref)->input_record_separator($prev_rs)\n      \t\t\t\tif defined($delim);\n  \t\t} else {\n\t\t\tmap {\n\t\t\t\t$result = $class->_pp_NTriple( $_ . ' . ' );\n\t\t\t} split(/\\.[\\n\\r]+/, $arg );\n  \t\t\t};\n\t\t};\n\n        my $err = $@;\n        if($err) {\n                croak $err;\n        \t};\n\n        if (defined $final) {\n                $result = &$final($class);\n        \t};\n\n        return $result;\n\t};\n\nsub _pp_NTriple {\n        my ($class, $ntriple) = @_;\n\n        chomp( $ntriple );\n        $ntriple =~ s/^[\\x20\\x09]+//; \n        $ntriple =~ s/[\\x20\\x09]+$//; \n\n\treturn if($ntriple =~ /^#/); \n\treturn unless ($ntriple =~/\\S/); \n\n        if ($ntriple =~ m/[^\\x20-\\x7e\\x0d\\x0a\\x09]/) {\n                die 'Invalid character(s) found at \"'.$&.'\" in \"'.$ntriple.'\"';\n                };\n\n\tunless ($ntriple =~ s/\\.\\s?$//) {\n\t\tdie 'Syntax error: missing trailing full stop in \"'.$ntriple.'\"';\n\t\t};\n\n\t$ntriple =~ s/\\\\[uU]([0-9a-fA-F]{4,8})/&cp_to_utf8(hex($1))/xeg;\n\n        my ($subject, $predicate, $object, $context );\n\n        if ($ntriple =~ s/^<([^>]*)>[\\x20\\x09]+//) {\n\t\t$subject = $class->{nodeFactory}->createResource( $1 );\n        } elsif ($ntriple =~  s/^_:([A-Za-z][A-Za-z0-9]*)[\\x20\\x09]+//) {\n\t\t$subject = $class->{nodeFactory}->createbNode( $1 );\n        } else {\n                die 'Syntax error in <subject> token in \"'.$ntriple.'\"';\n                };\n\n        if ($ntriple =~  s/^<([^>]*)>[\\x20\\x09]+//) {\n\t\t$predicate = $class->{nodeFactory}->createResource( $1 );\n        } elsif ($ntriple =~  s/^_:([A-Za-z][A-Za-z0-9]*)[\\x20\\x09]+//) { \n\t\twarn \"found bArcs in ntriple\" if($class->{Warnings});\n\t\t$predicate = $class->{nodeFactory}->createbNode( $1 );\n        } else {\n                die 'Syntax error in <predicate> token in \"'.$ntriple.'\"';\n                };\n\n        if ($ntriple =~  s/^<([^>]*)>[\\x20\\x09]*//) {\n\t\t$object = $class->{nodeFactory}->createResource( $1 );\n        } elsif ($ntriple =~  s/^_:([A-Za-z][A-Za-z0-9]*)[\\x20\\x09]*//) {\n\t\t$object = $class->{nodeFactory}->createbNode( $1 );\n        } elsif ($ntriple =~  s/^\"(.*)\"\\@([a-z0-9]+(-[a-z0-9]+)?)\\^\\^<([^>]*)>[\\x20\\x09]*//s) { \n\t\tif ( $4 eq $RDFStore::Parser::NTriples::RDFMS_parseType_Literal ) {\n\t\t\t$object = $class->{nodeFactory}->createLiteral( $1, 1, $2, $4 );\n\t\t} else {\n\t\t\t$object = $class->{nodeFactory}->createLiteral( $1, undef, $2, $4 );\n\t\t\t};\n        } elsif ($ntriple =~  s/^\"(.*)\"\\^\\^<([^>]*)>[\\x20\\x09]*//s) {\n\t\tif ( $2 eq $RDFStore::Parser::NTriples::RDFMS_parseType_Literal ) {\n\t\t\t$object = $class->{nodeFactory}->createLiteral( $1, 1, undef, $2 );\n\t\t} else {\n\t\t\t$object = $class->{nodeFactory}->createLiteral( $1, undef, undef, $2 );\n\t\t\t};\n        } elsif ($ntriple =~  s/^\"(.*)\"\\@([a-z0-9]+(-[a-z0-9]+)?)[\\x20\\x09]*//s) {\n\t\t$object = $class->{nodeFactory}->createLiteral( $1, undef, $2 );\n        } elsif ($ntriple =~  s/^\"(.*)\"[\\x20\\x09]*//s) {\n\t\t$object = $class->{nodeFactory}->createLiteral( $1 );\n        } else {\n                die 'Syntax error in <object> token in \"'.$ntriple.'\"';\n                };\n\n\tif ( length($ntriple) ) {\n        \tif ($ntriple =~ s/^<([^>]*)>[\\x20\\x09]*//) {\n\t\t\t$context = $class->{nodeFactory}->createResource( $1 );\n        \t} elsif ($ntriple =~  s/^_:([A-Za-z][A-Za-z0-9]*)[\\x20\\x09]*//) {\n\t\t\t$context = $class->{nodeFactory}->createbNode( $1 );\n        \t} elsif ($ntriple !~  s/^\\s*\\.//) { \n                \tdie 'Trash found after <object> token in \"'.$ntriple.'\"'; \n                \t};\n\t\t};\n\n        return $class->addTriple( $subject, $predicate, $object, $context );\n\t};\n\nsub getReificationCounter {\n\treturn $_[0]->{iReificationCounter};\n\t};\n\nsub parsestring {\n\tmy $class = shift;\n\n\t$class->SUPER::parsestring( @_ );\n\n\tmy $string = shift;\n\n\treturn $class->parse($string,undef,@_);\n\t};\n\nsub parsestream {\n        my $class = shift;\n\n\t$class->SUPER::parsestream( @_ );\n\n        my $arg = shift;\n        my $namespace = shift;\n\n\tmy $ret;\n\teval {\n\t\t$ret = $class->parse($arg, $namespace,@_);\n\t\t};\n\tmy $err = $@;\n\n\tcroak $err\n\t\tif $err;\n\n\treturn $ret;\n        };\n\nsub parsefile {\n\tmy $class = shift;\n\n\t$class->SUPER::parsefile( @_ );\n\n\tmy $file = shift;\n\n\tif( (defined $file) && ($file ne '') ) {\n\t\tmy $ret;\n\t\tmy $file_uri;\n\t\tmy $scheme;\n\t\t$scheme='file:'\n\t\t\tif( (-e $file) || (!($file =~ /^\\w+:/)) );\n                $file_uri= URI->new(((defined $scheme) ? $scheme : '' ).$file);\n\t\tif (\t(defined $file_uri) && (defined $file_uri->scheme)\t&&\n\t\t\t($file_uri->scheme ne 'file') ) {\n  \t\t\tmy $content = $class->wget($file_uri);\n\t\t\tif(defined $content) {\n\t\t\t\teval {\n\t\t\t\t\t$ret = $class->parsestring($content, $file_uri,@_);\n    \t\t\t\t};\n    \t\t\t\tmy $err = $@;\n    \t\t\t\tcroak $err \t\n\t\t\t\t\tif $err;\n                        } else {\n\t\t\t\tcroak \"Cannot fetch '$file_uri'\";\n\t\t\t\t};\n    \t\t} else {\n\t\t\tmy $filename= $file_uri->file;\n\n\t\t\tlocal(*FILE);\n\t\t\topen(FILE, $filename) \n\t\t\t\tor  croak \"Couldn't open $filename:\\n$!\";\n\t\t\tbinmode(FILE);\n\t\t\teval {\n\t\t\t\t$ret = $class->parse(*FILE,$file_uri,@_);\n    \t\t\t\t};\n    \t\t\tmy $err = $@;\n    \t\t\tclose(FILE);\n    \t\t\tcroak $err \t\n\t\t\t\tif $err;\n\t\t\t};\n\t\treturn $ret;\n  \t\t};\n\t};\n\nsub addTriple {\n        my ($class,$subject,$predicate,$object,$context) = @_;\n\n\n\t$subject = $class->{nodeFactory}->createResource($class->{sSource})\n\t\tunless( (defined $subject) && ($subject->toString()) && (length($subject->toString())>0) );\n\n        my $assert = $class->{Handlers}->{Assert}\n\t\tif(ref($class->{Handlers}) =~ /HASH/);\n        if (defined($assert)) {\n        \treturn &$assert($class, $class->{nodeFactory}->createStatement($subject,$predicate,$object,$context) );\n\t} else {\n\t\treturn;\n\t\t};\n\t};\n\nsub newReificationID {\n\tmy ($class) = @_;\n\n\n\treturn 'genid' . $class->{iReificationCounter}++;\n\t};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Parser/NTriples.pm",
      "package" : "RDFStore::Parser::NTriples"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\n\tuse vars qw($VERSION %Built_In_Styles $RDF_SYNTAX_NS $RDF_SCHEMA_NS $RDFX_NS $XMLSCHEMA_prefix $XMLSCHEMA $XML_space $XML_lang $XMLNS $RDFMS_parseType $RDFMS_type $RDFMS_about $RDFMS_bagID $RDFMS_resource $RDFMS_aboutEach $RDFMS_ID $RDFMS_RDF $RDFMS_Description $RDFMS_Seq $RDFMS_Alt $RDFMS_Bag $RDFMS_predicate $RDFMS_subject $RDFMS_object $RDFMS_Statement $RDFMS_nodeID $RDFMS_datatype $RDFMS_first $RDFMS_rest $RDFMS_nil $RDFSTORESCHEMA $RDFSTORESCHEMA_prefix $RDFSTORE_context $RDFSTORE_contextnodeID $RDFSTORE_EmptyContext );\n\tuse strict;\n\tuse Carp qw(carp croak cluck confess);\n\tuse URI;\n\tuse URI::Escape;\n\n\tuse RDFStore::Parser;\n        @RDFStore::Parser::SiRPAC::ISA = qw( RDFStore::Parser );\n\nBEGIN\n{\n\trequire XML::Parser::Expat;\n    \t$VERSION = '0.44';\n    \tcroak \"XML::Parser::Expat.pm version 2 or higher is needed\"\n\t\tunless $XML::Parser::Expat::VERSION =~ /^2\\./;\n}\n\n$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n$RDFStore::Parser::SiRPAC::RDF_SCHEMA_NS=\"http://www.w3.org/2000/01/rdf-schema#\";\n$RDFStore::Parser::SiRPAC::XMLSCHEMA_prefix=\"xml\";\n$RDFStore::Parser::SiRPAC::XMLSCHEMA=\"http://www.w3.org/XML/1998/namespace\";\n$RDFStore::Parser::SiRPAC::XML_space=$RDFStore::Parser::SiRPAC::XMLSCHEMA.\"space\";\n$RDFStore::Parser::SiRPAC::XML_base=$RDFStore::Parser::SiRPAC::XMLSCHEMA.\"base\";\n$RDFStore::Parser::SiRPAC::XML_lang=$RDFStore::Parser::SiRPAC::XMLSCHEMA.\"lang\";\n$RDFStore::Parser::SiRPAC::XMLNS=\"xmlns\";\n$RDFStore::Parser::SiRPAC::RDFMS_parseType = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"parseType\";\n$RDFStore::Parser::SiRPAC::RDFMS_type = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"type\";\n$RDFStore::Parser::SiRPAC::RDFMS_about = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"about\";\n$RDFStore::Parser::SiRPAC::RDFMS_bagID = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"bagID\";\n$RDFStore::Parser::SiRPAC::RDFMS_resource = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"resource\";\n$RDFStore::Parser::SiRPAC::RDFMS_aboutEach = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"aboutEach\";\n$RDFStore::Parser::SiRPAC::RDFMS_ID = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"ID\";\n$RDFStore::Parser::SiRPAC::RDFMS_RDF = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"RDF\";\n$RDFStore::Parser::SiRPAC::RDFMS_Description = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"Description\";\n$RDFStore::Parser::SiRPAC::RDFMS_Seq = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"Seq\";\n$RDFStore::Parser::SiRPAC::RDFMS_Alt = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"Alt\";\n$RDFStore::Parser::SiRPAC::RDFMS_Bag = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"Bag\";\n$RDFStore::Parser::SiRPAC::RDFMS_predicate = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"predicate\";\n$RDFStore::Parser::SiRPAC::RDFMS_subject = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"subject\";\n$RDFStore::Parser::SiRPAC::RDFMS_object = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"object\";\n$RDFStore::Parser::SiRPAC::RDFMS_Statement = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"Statement\";\n$RDFStore::Parser::SiRPAC::RDFMS_nodeID = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"nodeID\";\n$RDFStore::Parser::SiRPAC::RDFMS_datatype = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"datatype\";\n$RDFStore::Parser::SiRPAC::RDFMS_rest = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"rest\";\n$RDFStore::Parser::SiRPAC::RDFMS_first = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"first\";\n$RDFStore::Parser::SiRPAC::RDFMS_nil = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS . \"nil\";\n\n$RDFStore::Parser::SiRPAC::RDFSTORESCHEMA_prefix=\"rdfstore\";\n$RDFStore::Parser::SiRPAC::RDFSTORESCHEMA=\"http://rdfstore.sourceforge.net/contexts/\";\n$RDFStore::Parser::SiRPAC::RDFSTORE_context=$RDFStore::Parser::SiRPAC::RDFSTORESCHEMA.\"context\";\n$RDFStore::Parser::SiRPAC::RDFSTORE_contextnodeID=$RDFStore::Parser::SiRPAC::RDFSTORESCHEMA.\"contextnodeID\";\n$RDFStore::Parser::SiRPAC::RDFSTORE_EmptyContext=$RDFStore::Parser::SiRPAC::RDFSTORESCHEMA.\"EmptyContext\";\n\nsub new {\n\tmy ($pkg) = shift;\n\n        my $self = $pkg->SUPER::new(@_);\n\n        bless $self,$pkg;\n\t};\n\nsub parse {\n\tmy $class = shift;\n\n\t$class->SUPER::parse( @_ );\n\n\tmy $arg  = shift;\n\tmy $file_or_uri = shift;\n\n\tmy @expat_options = ();\n\tmy ($key, $val);\n\twhile (($key, $val) = each %{$class}) {\n\t\tpush(@expat_options, $key, $val) \n\t\t\tunless exists $class->{Non_Expat_Options}->{$key};\n      \t}\n\n\tmy @parser_parameters=(\t@expat_options,\n\t\t\t\t@_,\n\t\t\t\t( Namespaces => 1 ) ); \n\n    \tmy $first;\n\tif(exists $class->{'ExpatNB_Stream_Parsing'}) {\n\t\t$first = new XML::Parser::ExpatNB(@parser_parameters);\n\t\t$first->{_State_} = 1;\n\t} else {\n\t\t$first = new XML::Parser::Expat(@parser_parameters);\n\t\t};\n\n\t$first->{SiRPAC} = {};\n\n\t$first->{warnings} = $class->{warnings};\n\n\t$first->{SiRPAC}->{parser} = $class;\n\n  \t$first->{SiRPAC}->{elementStack} = [];\n  \t$first->{SiRPAC}->{root}='';\n  \t$first->{SiRPAC}->{EXPECT_Element}='';\n  \t$first->{SiRPAC}->{iReificationCounter}= ( ($class->{GenidNumber}) && (int($class->{GenidNumber})) ) ? $class->{GenidNumber} : 0;\n\t$class->{iReificationCounter} = \\$first->{SiRPAC}->{iReificationCounter};\n  \t$first->{SiRPAC}->{'timestamp'}=time();\n  \t$first->{SiRPAC}->{'rand_seed'}=unpack(\"H*\", rand());\n\tif(\t(exists $class->{Source}) && \n\t\t\t(defined $class->{Source}) &&\n\t\t\t( (!(ref($class->{Source}))) || (!($class->{Source}->isa(\"URI\"))) )\t) {\n\t\tif(-e $class->{Source}) {\n\t\t\t$class->{Source}=URI->new('file:'.$class->{Source});\n\t\t} else {\n\t\t\t$class->{Source}=URI->new($class->{Source});\n\t\t};\n\t} elsif(\t(defined $file_or_uri) && (ref($file_or_uri)) &&\n\t\t($file_or_uri->isa(\"URI\"))\t) {\n\t\t$class->{Source}=$file_or_uri;\n\t} else {\n\t\t$class->{Source}='STDIN:';\n\t\t};\n\n  \t$first->{'sSource'}= $class->setSource( ( (ref($class->{Source})) && ($class->{Source}->isa(\"URI\")) ) ?\n\t\t\t\t\t\t\t$class->{Source}->as_string :\n\t\t\t\t\t\t\t$class->{Source} );\n\n\t$first->base( $first->{'sSource'} );\n\n  \t$first->{SiRPAC}->{bCreateBags}=( ($class->{bCreateBags}) && (int($class->{bCreateBags})) ) ? $class->{bCreateBags} : 0;\n\n  \t$first->{SiRPAC}->{parseElementStack} = [];\n  \t$first->{SiRPAC}->{parseTypeStack} = [];\n  \t$first->{SiRPAC}->{scanMode} = 'SKIPPING';\n\t$first->{SiRPAC}->{sLiteral} = '';\n\tcroak \"Missing NodeFactory\"\n\t\tunless(\t(defined $class->{NodeFactory}) && \n\t\t\t($class->{NodeFactory}->isa(\"RDFStore::NodeFactory\")) );\n  \t$first->{SiRPAC}->{nodeFactory} = $class->{NodeFactory};\n\t$first->{SiRPAC}->{bases} = {};\n\t$first->{SiRPAC}->{langs} = {};\n\t$first->{SiRPAC}->{'xml:lang'} = '';\n\n\t$first->{SiRPAC}->{'contexts'} = {};\n\t$first->{SiRPAC}->{'rdfstore:context'} = ''; \n\n    \tmy %handlers = %{$class->{Handlers}}\n\t\tif( (defined $class->{Handlers}) && (ref($class->{Handlers}) =~ /HASH/) );\n\n    \tmy $init = delete $handlers{Init};\n    \tmy $final = delete $handlers{Final};\n\n    \t$first->setHandlers(\tStart => \\&RDFXML_StartElementHandler,\n\t\t\t\tEnd => \\&RDFXML_EndElementHandler,\n\t\t\t\tChar => \\&RDFXML_CharacterDataHandler );\n\n    \t&$init($first) \n\t\tif defined($init);\n\n\tmy $result;\n\tmy @result=();\n\n\tmy $ioref;\n\tif (\t(exists $class->{'ExpatNB_Stream_Parsing'}) &&\n\t\t(defined $arg) ) {\n    \t\tif (ref($arg) and UNIVERSAL::isa($arg, 'IO::Handle')) {\n      \t\t\t$ioref = $arg;\n    \t\t} elsif (tied($arg)) {\n      \t\t\tmy $c = ref($arg);\n      \t\t\tno strict 'refs';\n      \t\t\t$ioref = $arg if defined &{\"${c}::TIEHANDLE\"};\n    \t\t} else {\n      \t\t\teval { $ioref = *{$arg}{IO}; };\n      \t\t\tundef $@;\n    \t\t\t};\n  \t\t};\n\n\teval {\n\t\tif (\t(exists $class->{'ExpatNB_Stream_Parsing'}) &&\n\t\t\t(defined($ioref)) ) {\n\t\t\tmy $bytes=0;\n        \t\twhile(<$ioref>) {\n\t\t\t\ts/\\s+\\<\\?xml/\\<\\?xml/mig;\n\t\t\t\t$bytes+=length($_);\n                \t\t$first->parse_more($_);\n        \t\t\t};\n\t\t\tif($bytes==0) {\n                        \tdie \"Cannot parse RDF in $ioref: empty input (0 bytes read)\";\n                \t} else {\n        \t\t\t$result = $first->parse_done();\n                \t\t};\n\t\t} else {\n    \t\t\t$result = $first->parse($arg);\n\t\t\t};\n\t\t};\n\n\tmy $err = $@;\n\tif($err) {\n\t\t$first->release\n\t\t\tunless(\t(exists $class->{'ExpatNB_Stream_Parsing'}) &&\n\t\t\t\t(defined($ioref)) );\n\t\tmy $source = $first->{'sSource'};\n\t\t$err =~ s/ at line/ in $source at line/;\n\t\tcroak $err;\n\t\t};\n\n\t$first->{parser_parameters} = \\@parser_parameters;\n\n\tif ( (defined $result) and (defined $final) ) {\n    \t\tif(wantarray) {\n      \t\t\t@result = &$final($first);\n    \t\t} else {\n\t\t\t$result = &$final($first);\n    \t\t};\n\t};\n\t$first->release\n\t\tunless(\t(exists $class->{'ExpatNB_Stream_Parsing'}) &&\n\t\t\t(defined($ioref)) );\n\n\treturn unless defined wantarray;\n\treturn wantarray ? @result : $result;\n};\n\nsub warnings {\n\treturn @{ $_[0]->{warnings} };\n\t};\n\nsub getReificationCounter {\n\treturn ${$_[0]->{iReificationCounter}};\n\t};\n\nsub parsestream {\n\tmy $class = shift;\n\n\t$class->SUPER::parsestream( @_ );\n\n\tmy $arg = shift;\n\tmy $namespace = shift;\n\n\t$class->{'ExpatNB_Stream_Parsing'} = 1;\n\n\treturn $class->parse($arg,$namespace,@_);\n\t};\n\nsub parsestring {\n\tmy ($class) = shift;\n\n\t$class->SUPER::parsestring( @_ );\n\n\treturn $class->parse(@_);\n\t};\n\nsub parsefile {\n\tmy $class = shift;\n\n\t$class->SUPER::parsefile( @_ );\n\n\tmy $file = shift;\n\n\tif( (defined $file) && ($file ne '') ) {\n\t\tmy $ret;\n\t\tmy @ret=();\n\t\tmy $file_uri;\n\t\tmy $scheme;\n\t\t$scheme='file:'\n\t\t\tif( (-e $file) || (!($file =~ /^\\w+:/)) );\n                $file_uri= URI->new(((defined $scheme) ? $scheme : '' ).$file);\n\t\tif (\t(defined $file_uri) && (defined $file_uri->scheme)\t&&\n\t\t\t($file_uri->scheme ne 'file') ) {\n  \t\t\tmy $content = $class->wget($file_uri);\n\t\t\tif(defined $content) {\n\t\t\t\tif (wantarray) { \t\n\t\t\t\t\teval {\n\t\t\t\t\t\t@ret = $class->parsestring($content, $file_uri,@_);\n    \t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\teval {\n\t\t\t\t\t\t$ret = $class->parsestring($content, $file_uri,@_);\n    \t\t\t\t\t};\n\t\t\t\t};\n    \t\t\t\tmy $err = $@;\n    \t\t\t\tcroak $err \t\n\t\t\t\t\tif $err;\n                        } else {\n\t\t\t\tcroak \"Cannot fetch '$file_uri'\";\n\t\t\t};\n    \t\t} else {\n\t\t\tmy $filename= $file_uri->file;\n\n\t\t\tlocal(*FILE);\n\t\t\topen(FILE, $filename) \n\t\t\t\tor  croak \"Couldn't open $filename:\\n$!\";\n\t\t\tbinmode(FILE);\n\t\t\tif (wantarray) { \t\n\t\t\t\teval {\n\t\t\t\t\t@ret = $class->parse(*FILE,$file_uri,@_);\n    \t\t\t\t};\n\t\t\t} else {\n\t\t\t\teval {\n\t\t\t\t\t$ret = $class->parse(*FILE,$file_uri,@_);\n    \t\t\t\t};\n\t\t\t};\n    \t\t\tmy $err = $@;\n    \t\t\tclose(FILE);\n    \t\t\tcroak $err \t\n\t\t\t\tif $err;\n\t\t};\n\t\treturn unless defined wantarray;\n\t\treturn wantarray ? @ret : $ret;\n  \t};\n};\n\nsub getAttributeValue {\n\tmy ($expat,$attlist, $elName) = @_;\n\n\n  \treturn\n\t\tif( (ref($attlist) =~ /ARRAY/) && (!@{$attlist}) );\n\tmy $n;\n\tfor($n=0; $n<=$#{$attlist}; $n+=2) {\n    \t\tmy $attname;\n\t\tif(ref($attlist->[$n]) =~ /ARRAY/) {\n    \t\t\t$attname = $attlist->[$n]->[0];\n    \t\t\t$attname .= $attlist->[$n]->[1]\n\t\t\t\tif(defined $attlist->[$n]->[1]);\n\t\t} else {\n\t\t\t$attname = $attlist->[$n];\n\t\t};\n\n    \t\treturn $attlist->[$n+1]\n\t\t\tif ($attname eq $elName);\n  \t};\n  \treturn;\n}\n\nsub RDFXML_StartElementHandler {\n\tmy $expat = shift;\n\tmy $tag = shift;\n\tmy @attlist = @_;\n\n\tmy @rdf_attlist;\n\n\tmy $xml_tag = $tag; \n\n\tmy $sNamespace = $expat->namespace($tag);\n\n\tmy $parseLiteral = (($expat->{SiRPAC}->{scanMode} ne 'SKIPPING') && (parseLiteral($expat)));\n\n\tif(not(defined $sNamespace)) {\t\t\t\n\t\tmy ($prefix,$suffix) = split(':',$tag);\n\t\tif($prefix eq $RDFStore::Parser::SiRPAC::XMLSCHEMA_prefix) {\n\t\t\t$sNamespace = $RDFStore::Parser::SiRPAC::XMLSCHEMA;\n\t\t\t$tag = $expat->generate_ns_name($suffix,$sNamespace);\n\t\t} else {\n\t\t\tif( (defined $prefix) && (defined $suffix) ) {\n\t\t\t\tdie rdfcroak($expat,\"Unresolved namespace prefix '$prefix' for '$suffix'\");\n\t\t\t} else {\n\t\t\t\tunless($parseLiteral) {\n\t\t\t\t\tmy $msg = rdfwarn($expat,\"Using node element '$tag' without a namespace is forbidden.\");\n\t\t\t\t\tpush @{ $expat->{warnings} },$msg;\n\t\t\t\t\twarn $msg;\n\t\t\t\t\treturn;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n        \t};\n\n\tmy $newElement;\n\n\tmy $setScanModeElement = 0;\n\tif($expat->{SiRPAC}->{scanMode} eq 'SKIPPING') {\n\t\tif( $sNamespace.$tag eq $RDFStore::Parser::SiRPAC::RDFMS_RDF ) {\n                        $expat->{SiRPAC}->{scanMode} = 'RDF';\n                        $setScanModeElement = 1;\n\t\t} else { \n                        $expat->{SiRPAC}->{scanMode} = 'TOP_DESCRIPTION';\n                        $setScanModeElement = 1;\n                \t};\n\t} elsif($expat->{SiRPAC}->{scanMode} eq 'RDF') {\n\t\t$expat->{SiRPAC}->{scanMode} = 'DESCRIPTION';\n\t\t$setScanModeElement = 1;\n\t\t};\n\n\tmy $xml_atts=0;\n\tmy $rdf_atts=0;\n\tmy $rdfstore_atts=0;\n\tif($expat->{SiRPAC}->{scanMode} ne 'SKIPPING') {\n\t\tmy $n;\n\t\tfor($n=0; $n<=$#attlist; $n+=2) {\n    \t\t\tmy $attname = $attlist[$n];\n\t\t\tmy $namespace = $expat->namespace($attname);\n\n\t\t\tif (\t(defined $attlist[$n+1]) &&\n\t\t\t\t( $attlist[$n+1] ne '' ) &&\n\t\t\t\t( ( $RDFStore::Parser::SiRPAC::XMLSCHEMA_prefix.':'.'base' eq $attname ) ||\n\t\t\t\t  ( $RDFStore::Parser::SiRPAC::XML_base eq $attname ) ||\n\t\t\t\t  (\t( defined $namespace ) &&\n\t\t\t\t\t( $namespace eq $RDFStore::Parser::SiRPAC::XMLSCHEMA ) &&\n\t\t\t\t\t( $attname eq 'base' ) ) ) ) {\n\t\t\t\t$expat->{SiRPAC}->{bases}->{ join('', ( $expat->context, $xml_tag ) ) } = $expat->base;\n\t\t\t\t$expat->base( $attlist[$n+1] );\n\t\t\t\t$xml_atts++;\n\n\t\t\t\tnext;\n\t\t\t\t};\n\n\t\t\tif (\t(defined $attlist[$n+1]) &&\n\t\t\t\t( ( $RDFStore::Parser::SiRPAC::XMLSCHEMA_prefix.':'.'lang' eq $attname ) ||\n\t\t\t\t  ( $RDFStore::Parser::SiRPAC::XML_lang eq $attname ) ||\n\t\t\t\t  (\t( defined $namespace ) &&\n\t\t\t\t\t( $namespace eq $RDFStore::Parser::SiRPAC::XMLSCHEMA ) &&\n\t\t\t\t\t( $attname eq 'lang' ) ) ) ) {\n\t\t\t\t$expat->{SiRPAC}->{langs}->{ join('', ( $expat->context, $xml_tag ) ) } = $expat->{SiRPAC}->{'xml:lang'};\n\t\t\t\t$expat->{SiRPAC}->{'xml:lang'} = $attlist[$n+1];\n\t\t\t\t$xml_atts++;\n\n\t\t\t\tnext;\n\t\t\t\t};\n\n\t\t\tif (\t(defined $attlist[$n+1]) &&\n\t\t\t\t( ( $RDFStore::Parser::SiRPAC::RDFSTORESCHEMA_prefix.':'.'context' eq $attname ) ||\n\t\t\t\t  ( $RDFStore::Parser::SiRPAC::RDFSTORE_context eq $attname ) ||\n\t\t\t\t  (\t( defined $namespace ) &&\n\t\t\t\t\t( $namespace eq $RDFStore::Parser::SiRPAC::RDFSTORESCHEMA ) &&\n\t\t\t\t\t( $attname eq 'context' ) ) ) ) {\n\t\t\t\t$expat->{SiRPAC}->{'contexts'}->{ join('', ( $expat->context, $xml_tag ) ) } = $expat->{SiRPAC}->{'rdfstore:context'};\n\t\t\t\tmy $ctx;\n\t\t\t\tunless( $attlist[$n+1] eq $RDFStore::Parser::SiRPAC::RDFSTORE_EmptyContext ) { \n\t\t\t\t\tmy $ctx_uri = normalizeResourceIdentifier($expat, $attlist[$n+1]);\n\t\t\t\t\t$ctx = $expat->{SiRPAC}->{nodeFactory}->createResource( $ctx_uri );\n\t\t\t\t\t};\n\t\t\t\t$expat->{SiRPAC}->{'rdfstore:context'} = $ctx;\n\t\t\t\t$rdfstore_atts++;\n\n\t\t\t\t};\n\n\t\t\tif (\t(defined $attlist[$n+1]) &&\n\t\t\t\t( ( $RDFStore::Parser::SiRPAC::RDFSTORESCHEMA_prefix.':'.'contextnodeID' eq $attname ) ||\n\t\t\t\t  ( $RDFStore::Parser::SiRPAC::RDFSTORE_contextnodeID eq $attname ) ||\n\t\t\t\t  (\t( defined $namespace ) &&\n\t\t\t\t\t( $namespace eq $RDFStore::Parser::SiRPAC::RDFSTORESCHEMA ) &&\n\t\t\t\t\t( $attname eq 'contextnodeID' ) ) ) ) {\n\t\t\t\t$expat->{SiRPAC}->{'contexts'}->{ join('', ( $expat->context, $xml_tag ) ) } = $expat->{SiRPAC}->{'rdfstore:context'};\n\t\t\t\tmy $ctx = $expat->{SiRPAC}->{nodeFactory}->createAnonymousResource($attlist[$n+1])\n\t\t\t\t\tif(\t(defined $attlist[$n+1]) &&\n\t\t\t\t\t\t($attlist[$n+1] ne '') &&\n\t\t\t\t\t\t($attlist[$n+1] !~ m/^\\s+$/m) ); \n\t\t\t\t$expat->{SiRPAC}->{'rdfstore:context'} = $ctx;\n\t\t\t\t$rdfstore_atts++;\n\n\t\t\t\t};\n\n\t\t\tif (\t( $attname =~ m/^xml/ ) ||\n                        \t(\t( defined $namespace ) &&\n                                \t( $namespace eq $RDFStore::Parser::SiRPAC::XMLSCHEMA ) ) ) {\n\t\t\t\tnext;\n\t\t\t\t};\n\n\t\t\tif (\t(defined $attlist[$n+1]) &&\n\t\t\t\t(\t( defined $namespace ) &&\n\t\t\t\t\t( $namespace.$attname eq $RDFStore::Parser::SiRPAC::RDFMS_datatype ) ) ) {\n\t\t\t\t$expat->{SiRPAC}->{'rdf:datatype'} = normalizeResourceIdentifier($expat, $attlist[$n+1]);\n\n\t\t\t\tnext;\n\t\t\t\t};\n\t\t\t\t\t\n\t\t\tunless(\t(defined $namespace) &&\n\t\t\t\t($namespace ne '') ) { \n\t\t\t\tmy ($prefix,$suffix) = split(':',$attname);\n\t\t\t\tif( (defined $prefix) && (defined $suffix) ) {\n\t\t\t\t\tif($prefix eq $RDFStore::Parser::SiRPAC::XMLSCHEMA_prefix) {\n\t\t\t\t\t\t$namespace = $RDFStore::Parser::SiRPAC::XMLSCHEMA;\n\t\t\t\t\t\tpush @rdf_attlist, [$namespace,$suffix];\n\t\t\t\t\t\tpush @rdf_attlist, $attlist[$n+1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdie rdfcroak($expat,\"Unresolved namespace prefix '$prefix' for '$suffix'\");\n\t\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tif(\t($attname eq 'resource') \t|| \n\t\t\t\t\t\t($attname eq 'ID') \t\t|| \n\t\t\t\t\t\t($attname eq 'about') \t\t|| \n\t\t\t\t\t\t($attname eq 'aboutEach') \t|| \n\t\t\t\t\t\t($attname eq 'bagID')\t\t||\n\t\t\t\t\t\t($attname eq 'nodeID')\t\t||\n\t\t\t\t\t\t($attname eq 'datatype')\t||\n\t\t\t\t\t\t($attname eq 'parseType')\t||\n\t\t\t\t\t\t($attname eq 'type') ) {\n\n\t\t\t\t\t\tmy $msg = rdfwarn($expat,\"Unqualified use of 'rdf:$attname' attribute has been deprecated - see http://www.w3.org/2000/03/rdf-tracking/#rdf-ns-prefix-confusion\");\n\t\t\t\t\t\tpush @{ $expat->{warnings} },$msg;\n\t\t\t\t\t\twarn $msg;\n\n\t\t\t\t\t\t$namespace = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdie rdfcroak($expat,\"Using property attribute '$attname' without a namespace is forbidden.\")\n\t\t\t\t\t\t\tunless($parseLiteral);\n                                        \t};\n\t\t\t\t\tpush @rdf_attlist, [$namespace,$attname];\n\t\t\t\t\tpush @rdf_attlist, $attlist[$n+1];\n\t\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tpush @rdf_attlist, [$namespace,$attname];\n\t\t\t\tpush @rdf_attlist, $attlist[$n+1];\n\t\t\t\t};\n\n\t\t\t$rdf_atts++\n\t\t\t\tif(\t($namespace eq $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS) &&\n\t\t\t\t\t($attname ne 'nodeID') ); \n  \t\t\t};\n\t\t};\n\n\tif($parseLiteral) {\n\t\t$newElement =  RDFStore::Parser::SiRPAC::Element->new($sNamespace,$tag,\\@rdf_attlist, $expat->{SiRPAC}->{'xml:lang'}, $expat->{SiRPAC}->{'rdf:datatype'}, $expat->{SiRPAC}->{'rdfstore:context'});\n\t} else {\n\t\t$newElement =  RDFStore::Parser::SiRPAC::Element->new($sNamespace,$tag,\\@rdf_attlist, $expat->{SiRPAC}->{'xml:lang'}, $expat->{SiRPAC}->{'rdf:datatype'}, $expat->{SiRPAC}->{'rdfstore:context'});\n\t};\n\n\t$expat->{SiRPAC}->{EXPECT_Element} = $newElement\n\t\tif($setScanModeElement);\n\n\tmy $sLiteralValue;\n\tif($expat->{SiRPAC}->{scanMode} ne 'SKIPPING') {\n\n\t\n       \t\tmy $sResource;\n       \t\t$sResource = getAttributeValue($expat,$newElement->{attlist}, $RDFStore::Parser::SiRPAC::RDFMS_resource);\n\t\tif (defined $sResource) {\n       \t \t\t$newElement->{sResource} = normalizeResourceIdentifier($expat,$sResource);\n\t\t} else {\n       \t\t\t$sResource = getAttributeValue($expat,$newElement->{attlist}, $RDFStore::Parser::SiRPAC::RDFMS_nodeID);\n\t\t\tif (defined $sResource) {\n       \t \t\t\t$sResource = 'rdf:nodeID:'.$sResource;\n       \t \t\t\t$newElement->{sResource} = $sResource;\n\t\t\t\t};\n\t\t\t};\n\n\t\tmy $sAboutEach = getAttributeValue($expat,$newElement->{attlist},\n                                $RDFStore::Parser::SiRPAC::RDFMS_aboutEach);\n                $newElement->{sAboutEach} = $sAboutEach\n                        if(defined $sAboutEach);\n\n        \tmy $sAbout = getAttributeValue($expat,$newElement->{attlist}, $RDFStore::Parser::SiRPAC::RDFMS_about);\n\t\tmy $bnode=0;\n        \tif(defined $sAbout) {\n        \t\t$newElement->{sAbout} = normalizeResourceIdentifier($expat,$sAbout);\n\t\t} else {\n        \t\t$sAbout = getAttributeValue($expat,$newElement->{attlist}, $RDFStore::Parser::SiRPAC::RDFMS_nodeID);\n\t\t\tif ( defined $sAbout ) {\n        \t\t\t$sAbout = 'rdf:nodeID:'.$sAbout;\n        \t\t\t$newElement->{sAbout} = $sAbout;\n\t\t\t\t$bnode=1;\n\t\t\t\t};\n        \t\t};\n\n        \tmy $sBagID = getAttributeValue($expat,$newElement->{attlist},\n\t\t\t\t$RDFStore::Parser::SiRPAC::RDFMS_bagID);\n\n        \tif (defined $sBagID) {\n        \t\t$newElement->{sBagID} = normalizeResourceIdentifier($expat,$sBagID);\n\t\t\t$sBagID = $newElement->{sBagID};\n        \t\t};\n\n        \tmy $sID = getAttributeValue($expat,$newElement->{attlist},\n\t\t\t\t$RDFStore::Parser::SiRPAC::RDFMS_ID);\n        \tif (defined $sID) {\n        \t\t$newElement->{sID} = normalizeResourceIdentifier($expat,'#'.$sID);\n\t\t\t$sID = $newElement->{sID};\n        \t\t};\n\t\tif(defined $sAboutEach) {\n\t\t\tdie rdfcroak($expat,\"aboutEach is not supported on stream parsing \");\n\t\t\t};\n\n\t\tif(\t(defined $sID) && \n\t\t\t(defined $sAbout) &&\n\t\t\t(! $bnode) ) {\n\t\t\tdie rdfcroak($expat,\"A description block cannot use both 'ID' and 'about' attributes - see <a href=\\\"http://www.w3.org/TR/REC-rdf-syntax/#idAboutAttr\\\">[6.5]</a>\");\n\t\t\t};\n\n\t\t$sLiteralValue = getAttributeValue($expat,$newElement->{attlist},\n\t\t\t\t$RDFStore::Parser::SiRPAC::RDFMS_parseType);\n\n\t\tif(\t(defined $sLiteralValue) &&\n\t\t\t($sLiteralValue eq 'Resource') &&\n\t\t\t( (scalar(@{$newElement->{attlist}})/2) > ($xml_atts+$rdfstore_atts+$rdf_atts+1) ) ) {\n\t\t\tdie rdfcroak($expat,\"Property attributes and the rdf:nodeID attribute are not permitted on a description using rdf:parseType='Resource'.\");\n\t\t\t};\n\n\t\tif (\t(defined $sLiteralValue) && \n\t\t\t($sLiteralValue ne 'Resource') && \n\t\t\t($sLiteralValue ne 'Collection') ) {\n\n\t\t\tif(scalar(@{$expat->{SiRPAC}->{elementStack}})>0) {\n\t\t\t\tmy $e = $expat->{SiRPAC}->{elementStack}->[$#{$expat->{SiRPAC}->{elementStack}}];\n\t\t\t\tpush @{$e->{children}},$newElement;\n\t\t\t};\n\t\t\tpush @{$expat->{SiRPAC}->{elementStack}},$newElement;\n\t\t\tpush @{$expat->{SiRPAC}->{parseElementStack}},$newElement;\n\t\t\t$expat->{SiRPAC}->{sLiteral} = '';\n\n                \treturn;\n\t\t};\n\t\tif($parseLiteral) {\n\n\t\t\tmy $start_literal = $expat->{SiRPAC}->{parser}->{Handlers}->{Start_XML_Literal}\n\t\t\t\tif(ref($expat->{SiRPAC}->{parser}->{Handlers}) =~ /HASH/);\n\t\t\t$expat->{SiRPAC}->{sLiteral} .= &$start_literal($expat,$xml_tag,@attlist)\n\t\t\t\tif(defined $start_literal);\n\t\t\tpush @{$expat->{SiRPAC}->{elementStack}},$newElement;\n\t\t\treturn;\n        \t};\n        };\n\n\tif (\t(scalar(@{$expat->{SiRPAC}->{elementStack}})>0) &&\n\t\t(!$setScanModeElement) ) {\n\t\tmy $e = $expat->{SiRPAC}->{elementStack}->[$#{$expat->{SiRPAC}->{elementStack}}];\n\t\tpush @{$e->{children}},$newElement;\n\t};\n\n\tpush @{$expat->{SiRPAC}->{elementStack}},$newElement;\n\n\tif ( (defined $sLiteralValue) && ($sLiteralValue eq 'Collection') ) {\n\t\t$newElement->{isCollection} = 1;\n\t\t$expat->{SiRPAC}->{sLiteral} = '';\n\t} elsif ( (defined $sLiteralValue) && ($sLiteralValue eq 'Resource') ) {\n\t\tpush @{$expat->{SiRPAC}->{parseElementStack}},$newElement;\n\t\t$expat->{SiRPAC}->{sLiteral} = '';\n\n                my $desc = RDFStore::Parser::SiRPAC::Element->new(undef,$RDFStore::Parser::SiRPAC::RDFMS_Description,\n\t\t\t\t\t\t\t\t\\@rdf_attlist, $expat->{SiRPAC}->{'xml:lang'}, \n\t\t\t\t\t\t\t\t$expat->{SiRPAC}->{'rdf:datatype'}, $expat->{SiRPAC}->{'rdfstore:context'});\n\n\t\tif(scalar(@{$expat->{SiRPAC}->{elementStack}})>0) {\n                \tmy $e = $expat->{SiRPAC}->{elementStack}->[$#{$expat->{SiRPAC}->{elementStack}}];\n                \tpush @{$e->{children}},$desc;\n        \t};\n\t\tpush @{$expat->{SiRPAC}->{elementStack}},$desc;\n\t};\n};\n\nsub RDFXML_EndElementHandler {\n\tmy $expat = shift;\n\tmy $tag = shift;\n\n\tmy $ccc = join('', $expat->context, $tag );\n\n    \tmy $bParseLiteral = parseLiteral($expat);\n    \t$expat->{SiRPAC}->{root} = pop @{$expat->{SiRPAC}->{elementStack}};\n\n\tif($expat->{SiRPAC}->{scanMode} eq 'SKIPPING') {\n\t\tif ( exists $expat->{SiRPAC}->{bases}->{ $ccc } ) {\n\t\t\t$expat->base( $expat->{SiRPAC}->{bases}->{ $ccc } ); \n\t\t\tdelete( $expat->{SiRPAC}->{bases}->{ $ccc } );\n\t\t\t};\n\t\tif ( exists $expat->{SiRPAC}->{langs}->{ $ccc } ) {\n\t\t\t$expat->{SiRPAC}->{'xml:lang'} = $expat->{SiRPAC}->{langs}->{ $ccc }; \n\t\t\tdelete( $expat->{SiRPAC}->{langs}->{ $ccc } );\n\t\t\t};\n\t\tif ( exists $expat->{SiRPAC}->{'contexts'}->{ $ccc } ) {\n\t\t\t$expat->{SiRPAC}->{'rdfstore:context'} = $expat->{SiRPAC}->{'contexts'}->{ $ccc }; \n\t\t\tdelete( $expat->{SiRPAC}->{'contexts'}->{ $ccc } );\n\t\t\t};\n\t\tdelete($expat->{SiRPAC}->{'rdf:datatype'});\n\n\t\treturn;\n\t\t};\n\n\tif ($bParseLiteral) {\n                my $pe = $expat->{SiRPAC}->{parseElementStack}->[$#{$expat->{SiRPAC}->{parseElementStack}}];\n\t\tif($pe != $expat->{SiRPAC}->{root}) {\n\t\t\tmy $stop_literal = $expat->{SiRPAC}->{parser}->{Handlers}->{Stop_XML_Literal}\n\t\t\t\tif(ref($expat->{SiRPAC}->{parser}->{Handlers}) =~ /HASH/);\n\t\t\t$expat->{SiRPAC}->{sLiteral} .= &$stop_literal($expat,$tag)\n\t\t\t\tif(defined $stop_literal);\n\t\t} else {\n\t\t\tpush @{$expat->{SiRPAC}->{root}->{children}},RDFStore::Parser::SiRPAC::DataElement->new($expat->{SiRPAC}->{sLiteral}, 1, $expat->{SiRPAC}->{'xml:lang'}, $expat->{SiRPAC}->{'rdf:datatype'},$expat->{SiRPAC}->{'rdfstore:context'});\n                \tpop @{$expat->{SiRPAC}->{parseElementStack}};\n\t\t\t};\n\t} elsif(parseResource($expat)) {\n\t\tif(scalar(@{$expat->{SiRPAC}->{elementStack}})>0) {\n                \tmy $pe = $expat->{SiRPAC}->{parseElementStack}->[$#{$expat->{SiRPAC}->{parseElementStack}}];\n                \tmy $e = $expat->{SiRPAC}->{elementStack}->[$#{$expat->{SiRPAC}->{elementStack}}];\n            \t\tif ($pe == $e) {\n                \t\t$e = pop @{$expat->{SiRPAC}->{elementStack}};\n                \t\tpop @{$expat->{SiRPAC}->{parseElementStack}};\n            \t\t};\n\t\t};\n\t};\n\n\tif($expat->{SiRPAC}->{scanMode} eq 'RDF') {\n\t\t$expat->{SiRPAC}->{scanMode} = 'SKIPPING';\n\n\t\tif ( exists $expat->{SiRPAC}->{bases}->{ $ccc } ) {\n\t\t\t$expat->base( $expat->{SiRPAC}->{bases}->{ $ccc } ); \n\t\t\tdelete( $expat->{SiRPAC}->{bases}->{ $ccc } );\n\t\t\t};\n\t\tif ( exists $expat->{SiRPAC}->{langs}->{ $ccc } ) {\n\t\t\t$expat->{SiRPAC}->{'xml:lang'} = $expat->{SiRPAC}->{langs}->{ $ccc }; \n\t\t\tdelete( $expat->{SiRPAC}->{langs}->{ $ccc } );\n\t\t\t};\n\t\tif ( exists $expat->{SiRPAC}->{'contexts'}->{ $ccc } ) {\n                        $expat->{SiRPAC}->{'rdfstore:context'} = $expat->{SiRPAC}->{'contexts'}->{ $ccc }; \n                        delete( $expat->{SiRPAC}->{'contexts'}->{ $ccc } );\n                        };\n\t\tdelete($expat->{SiRPAC}->{'rdf:datatype'});\n\n\t\treturn;\n\t\t};\n\n\tif($expat->{SiRPAC}->{EXPECT_Element} != $expat->{SiRPAC}->{root}) {\n\t\tif ( exists $expat->{SiRPAC}->{bases}->{ $ccc } ) {\n\t\t\t$expat->base( $expat->{SiRPAC}->{bases}->{ $ccc } ); \n\t\t\tdelete( $expat->{SiRPAC}->{bases}->{ $ccc } );\n\t\t\t};\n\t\tif ( exists $expat->{SiRPAC}->{langs}->{ $ccc } ) {\n\t\t\t$expat->{SiRPAC}->{'xml:lang'} = $expat->{SiRPAC}->{langs}->{ $ccc }; \n\t\t\tdelete( $expat->{SiRPAC}->{langs}->{ $ccc } );\n\t\t\t};\n\t\tif ( exists $expat->{SiRPAC}->{'contexts'}->{ $ccc } ) {\n                        $expat->{SiRPAC}->{'rdfstore:context'} = $expat->{SiRPAC}->{'contexts'}->{ $ccc }; \n                        delete( $expat->{SiRPAC}->{'contexts'}->{ $ccc } );\n                        };\n\t\tdelete($expat->{SiRPAC}->{'rdf:datatype'});\n\n\t\treturn;\n\t\t};\n\n\tif($expat->{SiRPAC}->{scanMode} eq 'TOP_DESCRIPTION') {\n\t\tprocessXML($expat,$expat->{SiRPAC}->{EXPECT_Element});\n\t\t$expat->{SiRPAC}->{scanMode} = 'SKIPPING';\n\t} elsif($expat->{SiRPAC}->{scanMode} eq 'DESCRIPTION') {\n\t\tprocessXML($expat,$expat->{SiRPAC}->{EXPECT_Element});\n\t\t$expat->{SiRPAC}->{scanMode} = 'RDF';\n\t\t};\n\n\tif ( exists $expat->{SiRPAC}->{bases}->{ $ccc } ) {\n\t\t$expat->base( $expat->{SiRPAC}->{bases}->{ $ccc } ); \n\t\tdelete( $expat->{SiRPAC}->{bases}->{ $ccc } );\n\t\t};\n\tif ( exists $expat->{SiRPAC}->{langs}->{ $ccc } ) {\n\t\t$expat->{SiRPAC}->{'xml:lang'} = $expat->{SiRPAC}->{langs}->{ $ccc }; \n\t\tdelete( $expat->{SiRPAC}->{langs}->{ $ccc } );\n\t\t};\n\tif ( exists $expat->{SiRPAC}->{'contexts'}->{ $ccc } ) {\n\t\t$expat->{SiRPAC}->{'rdfstore:context'} = $expat->{SiRPAC}->{'contexts'}->{ $ccc }; \n                delete( $expat->{SiRPAC}->{'contexts'}->{ $ccc } );\n                };\n\tdelete($expat->{SiRPAC}->{'rdf:datatype'});\n\t};\n\nsub RDFXML_CharacterDataHandler {\n\tmy $expat = shift;\n\tmy $text = shift;\n   \n\tif(parseLiteral($expat)) {\n\t\tmy $char_literal = $expat->{SiRPAC}->{parser}->{Handlers}->{Char_Literal}\n\t\t\tif(ref($expat->{SiRPAC}->{parser}->{Handlers}) =~ /HASH/);\n\t\t$expat->{SiRPAC}->{sLiteral} .= &$char_literal($expat,$text)\n\t\t\tif(defined $char_literal);\n\n        \treturn;\n    \t};\n\n    \tmy $e = $expat->{SiRPAC}->{elementStack}->[$#{$expat->{SiRPAC}->{elementStack}}];\n\n\tmy $bHasData = 0;\n        my $dN;\n        my $dataNode;\n        foreach $dN (@{$e->{children}}) {\n                if($dN->isa('RDFStore::Parser::SiRPAC::DataElement')) {\n                        $bHasData = 1;\n                        $dataNode=$dN;\n                        last;\n                };\n        };\n\n        if(!$bHasData) {\n                push @{$e->{children}},RDFStore::Parser::SiRPAC::DataElement->new($text, 0, $expat->{SiRPAC}->{'xml:lang'}, $expat->{SiRPAC}->{'rdf:datatype'},$expat->{SiRPAC}->{'rdfstore:context'});\n        } else {\n                $dataNode->{sContent} .= $text;\n                $dataNode->{tag} = \"[DATA: \" . $dataNode->{sContent} . \"]\";\n        \t};\n\t};\n\nsub processXML {\n\tmy ($expat,$ele) = @_;\n\n\tif($ele->name() eq $RDFStore::Parser::SiRPAC::RDFMS_RDF) {\n\t\tmy $c;\n\t\tforeach $c (@{$ele->{children}}) {\n\t\t\tif($c->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Description) {\n\t\t\t\tprocessDescription($expat,$c,0,\n\t\t\t\t\t$expat->{SiRPAC}->{bCreateBags}, $expat->{SiRPAC}->{bCreateBags});\n\t\t\t} elsif( \t($c->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Seq) ||\n\t\t\t\t\t($c->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Alt) ||\n\t\t\t\t\t($c->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Bag)\t)  {\n\t\t\t\tprocessContainer($expat,$c);\n\t\t\t} elsif( \t(!($c->name() eq $RDFStore::Parser::SiRPAC::RDFMS_resource)) && \n\t\t\t\t\t(!($c->name() eq $RDFStore::Parser::SiRPAC::RDFMS_nodeID)) &&\n\t\t\t\t\t(length($c->name())>0) ) {\n\t\t\t\tprocessTypedNode($expat,$c);\n\t\t\t};\n\t\t};\n\t} elsif($ele->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Description) {\n\t\tprocessDescription($expat,$ele,0,\n\t\t\t$expat->{SiRPAC}->{bCreateBags}, $expat->{SiRPAC}->{bCreateBags});\n\t} else {\n\t\tprocessTypedNode($expat,$ele);\n\t\t};\n\n\t};\n\nsub processDescription {\n\tmy ($expat,$ele,$inPredicate,$reify,$createBag) = @_;\n\n\n\treturn $ele->{sID}\n\t\tif($ele->{bDone});\n\n\tmy $iChildCount=1;\n\tmy $bOnce=1;\n\t\n\tmy ($sID,$sBagid,$sAbout,$sAboutEach) = (\n\t\t\t\t\t\t\t\t\t$ele->{sID},\n\t\t\t\t\t\t\t\t\t$ele->{sBagID},\n\t\t\t\t\t\t\t\t\t$ele->{sAbout},\n\t\t\t\t\t\t\t\t\t$ele->{sAboutEach} );\n\tmy $target = (defined $ele->{vTargets}->[0]) ? $ele->{vTargets}->[0] : undef;\n\n\tmy $targetIsContainer=0;\n\tmy $sTargetAbout='';\n\tmy $sTargetBagid='';\n\tmy $sTargetID='';\n\n\tif (defined $target) {\n      \t\tmy $sTargetAbout = $target->{sAbout};\n      \t\tmy $sTargetID    = $target->{sID};\n      \t\tmy $sTargetBagid = $target->{sBagID};\n\n      \t\tif ( ((defined $sTargetBagid) && ($sTargetBagid ne '')) && \n\t\t\t((defined $sAbout) && ($sAbout ne '')) ) {\n        \t\t$targetIsContainer = ($sAbout =~ /^.$sTargetBagid/);\n      \t\t} else {\n        \t\tif (\t((defined $sTargetID) && ($sTargetID ne '')) &&\n            \t\t\t((defined $sAbout) && ($sAbout ne '')) &&\n\t\t\t\t($sAbout =~ /^.$sTargetID/) &&\n\t\t\t\t( \t($target->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Seq) ||\n                                        ($target->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Alt) ||\n                                        ($target->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Bag) )\t)  {\n          \t\t\t$targetIsContainer = 1;\n        \t\t};\n      \t\t};\n    \t};\n\n\texpandAttributes($expat,$ele,$ele,0);\n\n\tif( ((defined $sAboutEach) && ($sAboutEach ne '')) && (defined $target) ) {\n      \t\tif( \t($target->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Seq) ||\n                        ($target->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Alt) ||\n                        ($target->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Bag) ) {\n\t\t\tmy $ele1;\n\t\t\tforeach $ele1 (@{$target->{children}}) {\n          \t\t\tif( \t($ele1->name() =~ /^$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS/) &&\n\t\t\t\t\t( ($ele1->localName() =~ /li$/) || ($ele1->localName() =~ /_/) ) ) {\n            \t\t\t\tmy $sResource = $ele1->{sResource};\n            \t\t\t\tif((defined $sResource) && ($sResource ne '')) {\n              \t\t\t\t\tmy $newDescription =  RDFStore::Parser::SiRPAC::Element->new(undef,$RDFStore::Parser::SiRPAC::RDFMS_Description, undef, $expat->{SiRPAC}->{'xml:lang'}, $expat->{SiRPAC}->{'rdf:datatype'}, $expat->{SiRPAC}->{'rdfstore:context'});\n\t\t\t\t\t\t$newDescription->{sAbout} = $sResource;\n\t\t\t\t\t\n\t\t\t\t\t\tmy $ele2;\n\t\t\t\t\t\tforeach $ele2 (@{$ele->{children}}) {\n\t\t\t\t\t\t\tif (defined $newDescription) {\n                  \t\t\t\t\t\tpush @{$newDescription->{children}},$ele2;\n                \t\t\t\t\t};\n              \t\t\t\t\t};\n\n                \t\t\t\tprocessDescription($expat,$newDescription,0,0,0)\n\t\t\t\t\t\t\tif (defined $newDescription);\n            \t\t\t\t} else {\n\t\t\t\t\t\tmy $ele2;\n\t\t\t\t\t\tforeach $ele2 (@{$ele1->{children}}) {\n              \t\t\t\t\t\tmy $newNode =  RDFStore::Parser::SiRPAC::Element->new(undef,$RDFStore::Parser::SiRPAC::RDFMS_Description, undef, $expat->{SiRPAC}->{'xml:lang'}, $expat->{SiRPAC}->{'rdf:datatype'}, $expat->{SiRPAC}->{'rdfstore:context'});\n\t\t\t\t\t\t\tmy $ele3;\n\t\t\t\t\t\t\tforeach $ele3 (@{$ele->{children}}) {\n\t\t\t\t\t\t\t\tif (defined $newNode) {\n                  \t\t\t\t\t\t\tpush @{$newNode->{children}},$ele3;\n\t\t\t\t\t\t\t\t};\n              \t\t\t\t\t\t};\n                \t\t\t\t\tpush @{$newNode->{vTargets}},$ele2;\n\n               \t\t\t\t\t\tprocessDescription($expat,$newNode,1,0,0);\n       \t\t\t\t\t\t};\n       \t\t\t\t\t};\n\t\t\t\t} elsif( \t(!($ele1->name() eq $RDFStore::Parser::SiRPAC::RDFMS_resource)) &&\n\t\t\t\t\t\t(!($ele1->name() eq $RDFStore::Parser::SiRPAC::RDFMS_nodeID)) &&\n\t\t\t\t\t\t(length($ele1->name())>0) ) {\n              \t\t\t\tmy $newNode =  RDFStore::Parser::SiRPAC::Element->new(undef,$RDFStore::Parser::SiRPAC::RDFMS_Description, undef, $expat->{SiRPAC}->{'xml:lang'}, $expat->{SiRPAC}->{'rdf:datatype'}, $expat->{SiRPAC}->{'rdfstore:context'});\n\t\t\t\t\tmy $ele2;\n\t\t\t\t\tforeach $ele2 (@{$ele->{children}}) {\n\t\t\t\t\t\tif (defined $newNode) {\n                  \t\t\t\t\tpush @{$newNode->{children}},$ele2;\n\t\t\t\t\t\t};\n              \t\t\t\t};\n                \t\t\tpush @{$newNode->{vTargets}},$ele1;\n                \t\t\tprocessDescription($expat,$newNode,1,0,0);\n          \t\t\t};\n        \t\t};\n\t\t} elsif($target->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Description) {\n                \tprocessDescription($expat,$target,0,$reify,$createBag);\n\t\t\tmy $ele1;\n\t\t\tforeach $ele1 (@{$target->{children}}) {\n              \t\t\tmy $newNode =  RDFStore::Parser::SiRPAC::Element->new(undef,$RDFStore::Parser::SiRPAC::RDFMS_Description, undef, $expat->{SiRPAC}->{'xml:lang'}, $expat->{SiRPAC}->{'rdf:datatype'}, $expat->{SiRPAC}->{'rdfstore:context'});\n\t\t\t\tmy $ele2;\n\t\t\t\tforeach $ele2 (@{$ele->{children}}) {\n\t\t\t\t\tif (defined $newNode) {\n                  \t\t\t\tpush @{$newNode->{children}},$ele2;\n\t\t\t\t\t};\n              \t\t\t};\n                \t\tpush @{$newNode->{vTargets}},$ele1;\n                \t\tprocessDescription($expat,$newNode,1,0,0);\n        \t\t};\n\t \t};\n      \t\treturn;\n    \t};\n\n\tmy $paCounter = 1;\n\tmy $n;\n\tforeach $n (@{$ele->{children}}) {\n\t\tif(     (defined $n->name()) &&\n                        ($n->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Description) ) {\n                        die rdfcroak($expat,\"Cannot nest a Description inside another Description\");\n                } elsif(        (defined $n->name()) &&\n                                ($n->name() =~ /^$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS/) &&\n                                ( ($n->localName() =~ /li$/) || ($n->localName() =~ /_/) ) ) {\n\t\t\tmy $id;\n\t\t\tif(\t(defined $sID) &&\n\t\t\t\t($sID ne '') ) {\n\t\t\t\t$id = $sID;\n\t\t\t} elsif(\t(defined $sAbout) &&\n\t\t\t\t\t($sAbout ne '') ) {\n\t\t\t\t$id = $sAbout;\n\t\t\t} else {\n\t\t\t\tmy $nodeID = getAttributeValue($expat, $ele->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_nodeID);\n                                if ( defined $nodeID ) {\n                                \t$ele->{sID} = 'rdf:nodeID:'.$nodeID;\n                                } else {\n                                        $ele->{sID} = newReificationID($expat)\n                                        };\n\t\t\t\t$id = $ele->{sID};\n\t\t\t\t$sID = $id;\n\t\t\t\t};\n\t\t\tmy $isli = ($n->localName() =~ /li$/) ? 1 : 0;\n                        if($n->localName() =~ m/_(\\d+)$/) {\n                                $n->{tag} = \"_\".$1;\n                        } else {\n                                $n->{tag} = \"_\".$paCounter;\n                                };\n                        processPredicate($expat,$n,$ele,$id,$reify);\n\n                        $paCounter++\n\t\t\t\tif($isli);\n                } elsif(        (defined $n->name()) &&\n      \t\t\t\t(!($n->name() eq $RDFStore::Parser::SiRPAC::RDFMS_resource)) && \n      \t\t\t\t(!($n->name() eq $RDFStore::Parser::SiRPAC::RDFMS_nodeID)) &&\n\t\t\t\t(length($n->name())>0) ) {\n        \t\tmy $sChildID;\n\t\t\tif ( (defined $target) && ($targetIsContainer) ) {\n          \t\t\t$sChildID = processPredicate($expat,$n,$ele,\n                                       ((defined $target->{sBagID}) ? $target->{sBagID} : $target->{sID}),0);\n          \t\t\t$ele->{sID} = normalizeResourceIdentifier($expat,$sChildID);\n\t\t\t\t$createBag=0;\n        \t\t} elsif(defined $target) {\n          \t\t\t$sChildID = processPredicate($expat,$n,$ele,\n                                       ((defined $target->{sBagID}) ? $target->{sBagID} : $target->{sID}),$reify);\n          \t\t\t$ele->{sID} = normalizeResourceIdentifier($expat,$sChildID);\n        \t\t} elsif( (not(defined $target)) && (!($inPredicate)) ) {\n\t\t\t\tmy $pl = getAttributeValue($expat, $n->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_parseType);\n\t\t\t\tdie rdfcroak($expat,\"Can not specify an rdf:parseType of 'Literal' and an rdf:resource attribute at the same time for predicate '\".$n->name().\"' - see http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Jun/0134.html\")\n\t\t\t\t\tif(\t(defined $pl) &&\n\t\t\t\t\t\t($pl eq 'Literal') &&\n\t\t\t\t\t\t( (getAttributeValue($expat, $n->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_resource)) ||\n\t\t\t\t\t\t  (getAttributeValue($expat, $n->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_nodeID)) ) );\n\n\t\t\t\tmy $nodeID = getAttributeValue($expat, $ele->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_nodeID);\n\t\t\t\tif ( defined $nodeID ) {\n          \t\t\t\tif(not(((defined $ele->{sID}) && ($ele->{sID} ne '')))) {\n          \t\t\t\t\t$ele->{sID} = 'rdf:nodeID:'.$nodeID;\t\n\t\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tmy $about = getAttributeValue($expat, $ele->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_about);\n\t\t\t\t\tif( $about =~ /^rdf:nodeID:/ ) {\n\t\t\t\t\t\t$ele->{sID} = $about;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$ele->{sID} = newReificationID($expat)\n          \t\t\t\t\t\tif(not(((defined $ele->{sID}) && ($ele->{sID} ne ''))));\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n          \t\t\tif (not(((defined $sAbout) && ($sAbout ne '')))) {\n            \t\t\t\tif ((defined $sID) && ($sID ne '')) {\n\t\t\t\t\t\t$sAbout=$sID;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$sAbout=$ele->{sID};\n\t\t\t\t\t};\n\t\t\t\t};\n\n          \t\t\t$sChildID = processPredicate($expat,$n,$ele,\n\t\t\t\t\t\t$sAbout,\n\t\t\t\t\t\t( ((defined $sBagid) && ($sBagid ne '')) ? 1 : $reify));\n        \t\t} elsif( (not(defined $target)) && ($inPredicate) ) {\n          \t\t\tif (not(((defined $sAbout) && ($sAbout ne '')))) {\n            \t\t\t\tif ((defined $sID) && ($sID ne '')) {\n          \t\t\t\t\t$ele->{sID} = normalizeResourceIdentifier($expat,$sID);\n\t\t\t\t\t\t$sAbout=$sID;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmy $nodeID = getAttributeValue($expat, $ele->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_nodeID);\n                                \t\tif ( defined $nodeID ) {\n          \t\t\t\t\t\tif(not(((defined $ele->{sID}) && ($ele->{sID} ne '')))) {\n                                        \t\t\t$ele->{sID} = 'rdf:nodeID:'.$nodeID;\n\t\t\t\t\t\t\t\t};\n                                \t\t} else {\n          \t\t\t\t\t\t$ele->{sID} = newReificationID($expat)\n          \t\t\t\t\t\t\tif(not(((defined $ele->{sID}) && ($ele->{sID} ne ''))));\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t$sAbout=$ele->{sID};\n\t\t\t\t\t};\n\t\t\t\t} else {\n          \t\t\t\t$ele->{sID} = $sAbout;\n\t\t\t\t\t};\n\t\t\t\t\t\n          \t\t\t$sChildID = processPredicate($expat,$n,$ele,$sAbout,0);\n\t\t\t\t};\n\n        \t\tif( ((defined $sBagid) && ($sBagid ne '')) || ($expat->{SiRPAC}->{bCreateBags} && $createBag) ) {\n          \t\t\tmy $sNamespace = $RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS;\n          \t\t\tif( ($bOnce) && ((defined $sChildID) && ($sChildID ne '')) ) {\n            \t\t\t\t$bOnce = 0;\n\t\t\t\t\tmy $nodeID = getAttributeValue($expat, $ele->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_nodeID);\n                                \tif ( defined $nodeID ) {\n            \t\t\t\t\tif(not(((defined $ele->{sBagID}) && ($ele->{sBagID} ne '')))) {\n                                        \t\t$ele->{sBagID} = 'rdf:nodeID:'.$nodeID;\n\t\t\t\t\t\t\t};\n                                \t} else {\n              \t\t\t\t\t$ele->{sBagID} = newReificationID($expat)\n            \t\t\t\t\t\tif(not(((defined $ele->{sBagID}) && ($ele->{sBagID} ne ''))));\n\t\t\t\t\t\t};\n          \t\t\t\t$ele->{sID} = normalizeResourceIdentifier($expat,$ele->{sBagID})\n          \t\t\t\t\tif(not(((defined $ele->{sID}) && ($ele->{sID} ne ''))));\n\n\t\t\t            \taddTriple(\t$expat,\n\t\t\t\t\t\t\tbuildResource( $expat,$sNamespace,'type'),\n                       \t\t\t\t\tbuildResource( $expat,$ele->{sBagID}),\n\t\t\t\t\t\t\tbuildResource( $expat,$sNamespace,'Bag'),\n\t\t\t\t\t\t\t$ele->{'context'}\n\t\t\t\t\t\t);\n          \t\t\t};\n\t\t\t\tif ((defined $sChildID) && ($sChildID ne '')) {\n\t\t\t            \taddTriple(\t$expat,\n\t\t\t\t\t\t\tbuildResource( $expat,$sNamespace,\"_\".$iChildCount),\n                       \t\t\t\t\tbuildResource( $expat,$ele->{sBagID}),\n\t\t\t\t\t\t\tbuildResource( $expat,$sChildID),\n\t\t\t\t\t\t\t$ele->{'context'}\n\t\t\t\t\t\t );\n            \t\t\t\t$iChildCount++;\n          \t\t\t};\n        \t\t};\n\t\t};\n    \t};\n\n\t$ele->{bDone} = 1;\n\n\treturn $ele->{sID};\n\t};\n\nsub addTriple {\n\tmy ($expat,$predicate,$subject,$object, $context) = @_;\n\n\n        carp \"Predicate null when subject=\".$subject->toString.\" and object=\".$object->toString\n                unless(defined $predicate);\n\n        carp \"Subject null when predicate=\".$predicate->toString.\" and object=\".$object->toString\n                unless(defined $subject);\n\n\tcarp \"Object null when predicate=\".$predicate->toString.\" and subject=\".$subject->toString\n        \tunless(defined $object);\n\n\t$subject = buildResource( $expat,$expat->{'sSource'})\n\t\tunless(\t(defined $subject) && \n\t\t\t($subject->toString()) && \n\t\t\t(length($subject->toString())>0) );\n\n\tif(\t(defined $object) &&\n\t\t(ref($object)) && \n\t\t($object->isa(\"RDFStore::Resource\")) ) {\n\t\t$object = buildResource( $expat,$expat->{'sSource'})\n\t\t\tunless( (defined $object) &&\n\t\t\t\t($object->toString()) && \n\t\t\t\t(length($object->toString())>0) );\n\t\t};\n\n\treturn\n\t\tif(\t($predicate->toString eq $RDFStore::Parser::SiRPAC::RDFSTORE_context) ||\n\t\t\t($predicate->toString eq $RDFStore::Parser::SiRPAC::RDFSTORE_contextnodeID) );\n\n        my $assert = $expat->{SiRPAC}->{parser}->{Handlers}->{Assert}\n\t\tif(ref($expat->{SiRPAC}->{parser}->{Handlers}) =~ /HASH/);\n        if (defined($assert)) {\n        \treturn &$assert($expat, \n\t\t\t\t$expat->{SiRPAC}->{nodeFactory}->createStatement($subject,$predicate,$object, $context) ); \n\t} else {\n\t\treturn;\n\t\t};\n\t};\n\nsub newReificationID {\n\tmy ($expat) = @_;\n\n\n\treturn  'rdf:nodeID:genidrdfstore' .\n\t\t'S'.$expat->{SiRPAC}->{'rand_seed'} .\n\t\t'P'. $$. \n\t\t'T'. $expat->{SiRPAC}->{'timestamp'} .\n\t\t'N'. $expat->{SiRPAC}->{iReificationCounter}++;\n\t};\n\nsub processTypedNode {\n\tmy ($expat,$typedNode) = @_;\n\n\n\tmy $sID = $typedNode->{sID};\n\tmy $sBagID = $typedNode->{sBagID};\n\tmy $sAbout = $typedNode->{sAbout};\n\n\tmy $target = (defined $typedNode->{vTargets}->[0]) ? $typedNode->{vTargets}->[0] : undef;\n\n    \tmy $sAboutEach = $typedNode->{sAboutEach};\n\n\tif ( (defined $typedNode->{sResource}) && ($typedNode->{sResource} ne '') && ($typedNode->{sResource} !~ /^rdf:nodeID:/) ) {\n      \t\tdie rdfcroak($expat,\"'resource' attribute not allowed for a typedNode '\".$typedNode->name().\"' - see <a href=\\\"http://www.w3.org/TR/REC-rdf-syntax/#typedNode\\\">[6.13]</a>\");\n\t\t};\n\n\tmy $n;\n\tfor($n=0; $n<=$#{$typedNode->{attlist}}; $n+=2) {\n    \t\tmy $sAttribute = $typedNode->{attlist}->[$n]->[0].$typedNode->{attlist}->[$n]->[1];\n    \t\tmy $sValue = getAttributeValue($expat, $typedNode->{attlist},$sAttribute);\n\t\tif ( defined $sValue ) {\n\t\t\t$sValue =~ s/^([ ])+//g;\n\t\t\t$sValue =~ s/([ ])+$//g;\n\t\t\t};\n\n\t\tif ( \t(!($sAttribute =~ /^$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS/)) &&\n\t\t\t(!($sAttribute =~ m|^$RDFStore::Parser::SiRPAC::XMLSCHEMA|)) ) {\n        \t\tif(\t(defined $sValue) &&\n\t\t\t\t(length($sValue) > 0) ) {\n              \t\t\tmy $newPredicate =  RDFStore::Parser::SiRPAC::Element->new(\n\t\t\t\t\t\t\t$typedNode->{attlist}->[$n]->[0],\n\t\t\t\t\t\t\t$typedNode->{attlist}->[$n]->[1],[\n\t\t\t\t\t\t\t[undef,$RDFStore::Parser::SiRPAC::RDFMS_ID], \n\t\t\t\t\t\t\t(\t((defined $sAbout) && ($sAbout ne '')) ?  $sAbout : \n\t\t\t\t\t\t\t\t(defined $sID) ?  ( $sID =~ /^#/ ) ? $sID : '#'.$sID :\n\t\t\t\t\t\t\t\t'' ),\n\t\t\t\t\t\t\t[undef,$RDFStore::Parser::SiRPAC::RDFMS_bagID],\n\t\t\t\t\t\t\t(defined $sBagID) ? ( $sBagID =~ /^#/ ) ? $sBagID : '#'.$sBagID : ''\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t$expat->{SiRPAC}->{'xml:lang'}, \n\t\t\t\t\t\t\t\t$expat->{SiRPAC}->{'rdf:datatype'},\n\t\t\t\t\t\t\t\t$expat->{SiRPAC}->{'rdfstore:context'});\n\t\t\t\t\n\t\t\t\tmy $newData =  RDFStore::Parser::SiRPAC::DataElement->new($sValue, 0, $expat->{SiRPAC}->{'xml:lang'}, $expat->{SiRPAC}->{'rdf:datatype'}, $expat->{SiRPAC}->{'rdfstore:context'});\n\t\t\t\tpush @{$newPredicate->{children}},$newData;\n\t\t\t\tpush @{$typedNode->{children}},$newPredicate;\n\n\t\t\t\tmy @rr;\n\t\t\t\tmy $i;\n\t\t\t\tfor($i=0; $i<=$#{$typedNode->{attlist}}; $i+=2) {\n\t\t\t\t\tmy $a = $typedNode->{attlist}->[$i]->[0].$typedNode->{attlist}->[$i]->[1];\n\t\t\t\t\tif($a eq $sAttribute) {\n\t\t\t\t\t\tnext;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpush @rr,($typedNode->{attlist}->[$i],$typedNode->{attlist}->[$i+1]);\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t$typedNode->{attlist} = \\@rr;\n        \t\t\t};\n      \t\t\t};\n    \t};\n\n\tmy $sObject;\n\tmy $nodeID;\n    \tif(defined $target) {\n\t\t$sObject = ( (((defined $target->{sBagID}) && ($target->{sBagID} ne ''))) ? $target->{sBagID} : $target->{sID});\n\t} elsif((defined $sAbout) && ($sAbout ne '')){ \n      \t\t$sObject = $sAbout;\n    \t} elsif((defined $sID) && ($sID ne '')) {\n      \t\t$sObject = $sID;\n    \t} else {\n\t\t$nodeID = getAttributeValue($expat, $typedNode->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_nodeID);\n                if ( defined $nodeID ) {\n                \t$sObject = 'rdf:nodeID:'.$nodeID;\n\t\t} else {\n      \t\t\t$sObject = newReificationID($expat);\n\t\t\t};\n\t};\n\n\t$typedNode->{sID} = normalizeResourceIdentifier($expat,$sObject);\n\n\tif ( \t((defined $sAboutEach) && ($sAboutEach ne '')) &&\n        \t(scalar(@{$typedNode->{vTargets}})>0) ) {\n              \t\tmy $newPredicate =  RDFStore::Parser::SiRPAC::Element->new($RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'type', undef, $expat->{SiRPAC}->{'xml:lang'}, $expat->{SiRPAC}->{'rdf:datatype'}, $expat->{SiRPAC}->{'rdfstore:context'});\n\t\t\tmy $newData = RDFStore::Parser::SiRPAC::DataElement->new($typedNode->name(), 0, $expat->{SiRPAC}->{'xml:lang'}, $expat->{SiRPAC}->{'rdf:datatype'}, $expat->{SiRPAC}->{'rdfstore:context'});\n\t\t\tpush @{$newPredicate->{children}},$newData;\n\t\t\tpush @{$typedNode->{children}},$newPredicate;\n    \t} else {\n      \t\taddTriple(\t$expat,\n\t\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'type'),\n\t\t\t\tbuildResource( $expat,$typedNode->{sID}),\n\t\t\t\tbuildResource( $expat,$typedNode->namespace,$typedNode->localName),\n\t\t\t\t$typedNode->{'context'}\n\t\t\t);\n    \t};\n\n    \tmy $sDesc = processDescription($expat,$typedNode, 0, $expat->{SiRPAC}->{bCreateBags}, 0);\n\n    \treturn $sObject;\n};\n\nsub processContainer {\n\tmy ($expat,$n) = @_;\n\n\n\tmy $sID = $n->{sID};\n      \t$sID = $n->{sAbout}\n    \t\tunless((defined $sID) && ($sID ne ''));\n\tmy $nodeID = getAttributeValue($expat, $n->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_nodeID);\n\tif( defined $nodeID ) {\n        \t$sID = 'rdf:nodeID:'.$nodeID\n    \t\t\tunless((defined $sID) && ($sID ne ''));\n        } else {\n      \t\t$sID = newReificationID($expat)\n    \t\t\tunless((defined $sID) && ($sID ne ''));\n\t\t};\n\n\tif(!($n->{bDone})) {\n      \t\tif($n->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Seq) {\n\t\t\taddTriple(\t$expat,\n\t\t\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'type'),\n\t\t\t\t\tbuildResource( $expat,$sID),\n\t\t\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'Seq'),\n\t\t\t\t\t$n->{'context'}\n\t\t\t\t);\n      \t\t} elsif($n->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Alt) {\n\t\t\taddTriple(\t$expat,\n\t\t\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'type'),\n\t\t\t\t\tbuildResource( $expat,$sID),\n\t\t\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'Alt'),\n\t\t\t\t\t$n->{'context'}\n\t\t\t\t);\n      \t\t} elsif($n->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Bag) {\n\t\t\taddTriple(\t$expat,\n\t\t\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'type'),\n\t\t\t\t\tbuildResource( $expat,$sID),\n\t\t\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'Bag'),\n\t\t\t\t\t$n->{'context'}\n\t\t\t\t);\n      \t\t};\n\t\t$n->{bDone} = 1;\n    \t};\n\n\texpandAttributes($expat,$n,$n,0);\n\n\tif( \t(scalar(@{$n->{children}})<=0) &&\n      \t\t($n->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Alt) ) {\n      \t\tdie rdfcroak($expat,\"An RDF:Alt container must have at least one nested listitem\");\n    \t};\n\n\tmy $iCounter = 1;\n\tmy $n2;\n\tmy $object_elements=1;\n\tforeach $n2 (@{$n->{children}}) {\n\t\tif (\t(defined $n2) &&\n\t\t\t(defined $n2->name()) &&\n\t\t\t(defined $n2->localName()) &&\n\t\t\t($n2->name() =~ /^$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS/) &&\n\t\t\t( ($n2->localName() =~ /li$/) || ($n2->localName() =~ /_/) ) ) {\n\t\t\tmy $isli = ($n2->localName() =~ /li$/) ? 1 : 0;\n\t\t\tif($n2->localName() =~ m/_(\\d+)$/) {\n\t\t\t\t$n2->{tag} = \"_\".$1;\n\t\t\t} else {\n\t\t\t\t$n2->{tag} = \"_\".$iCounter;\n\t\t\t\t};\n\t\t\tprocessPredicate($expat,$n2,$n,$sID,0); \n\n        \t\t$iCounter++\n\t\t\t\tif($isli);\n\n\t\t\t$object_elements++;\n\t\t} elsif ($n2->isa('RDFStore::Parser::SiRPAC::DataElement')) {\n                        my $sValue = $n2->{sContent};\n\n                        my $trimstring = $sValue;\n                        $trimstring =~ s/^\\s+//mg;\n                        $trimstring =~ s/\\s+$//mg;\n                        if(     ($object_elements > 1) &&\n                                (defined $trimstring) && \n                                (length($trimstring)>0) ) {\n                                die rdfcroak($expat,\"Expected whitespace found: \". $sValue);\n                                return;   \n                                };\n      \t\t} else {\n\t\t\tprocessPredicate($expat,$n2,$n,$sID,0); \n\n\t\t\t$object_elements++;\n      \t\t\t};\n    \t\t};\n\treturn $sID;\n};\n\nsub buildResource {\n\tmy ($expat, $ns, $ln) = @_;\n\n\tmy $factory = $expat->{SiRPAC}->{nodeFactory};\n\n\tif ( !$ln and ( $ns =~ s/^rdf:nodeID:// ) ) {\n        \tmy $manage_bnodes = $expat->{SiRPAC}->{parser}->{Handlers}->{manage_bNodes}\n\t\t\tif(ref($expat->{SiRPAC}->{parser}->{Handlers}) =~ /HASH/);\n        \tif (defined($manage_bnodes)) {\n        \t\treturn &$manage_bnodes($expat, $factory, $ns);\n\t\t} else {\n\t\t\treturn $factory->createAnonymousResource( $ns );\n\t\t\t};\n\t} else {\n\t\treturn $factory->createResource( $ns, $ln );\n\t\t};\n\t};\n\nsub buildLiteral {\n\tmy ($factory) = shift;\n\n\treturn $factory->createLiteral( @_ );\n\t};\n\nsub rdfwarn {\n\tmy ($expat, $message) = @_;\n\n\tmy $source = $expat->{'sSource'};\n\tmy $line = $expat->current_line;\n\tmy $column = $expat->current_column;\n\tmy $byte = $expat->current_byte;\n\t$message .= \" in $source at line $line, column $column, byte $byte\";\n\n\treturn $message;\n\t};\n\nsub rdfcroak {\n\tmy ($expat, $message) = @_;\n\n\tmy $source = $expat->{'sSource'};\n\tmy $eclines = $expat->{ErrorContext};\n\tmy $line = $expat->current_line;\n\tmy $column = $expat->current_column;\n\tmy $byte = $expat->current_byte;\n\t$message .= \" at line $line, column $column, byte $byte\"; \n\t$message .= \":\\n\" . $expat->position_in_context($eclines)\n\t\tif defined($eclines);\n\n\treturn $message;\n\t};\n\nsub processPredicate {\n\tmy ($expat,$predicate,$description,$sTarget,$reify) = @_;\n\n\n\tmy $sStatementID = $predicate->{sID};\n\tmy $sBagID       = $predicate->{sBagID};\n    \tmy $sResource    = $predicate->{sResource};\n\n\n        my $d = RDFStore::Parser::SiRPAC::Element->new(undef,$RDFStore::Parser::SiRPAC::RDFMS_Description, undef, $expat->{SiRPAC}->{'xml:lang'}, $expat->{SiRPAC}->{'rdf:datatype'}, $expat->{SiRPAC}->{'rdfstore:context'});\n    \tif(expandAttributes($expat,$d,$predicate,1,$sResource)) {\n      \t\tif(scalar(@{$predicate->{children}})>0) {\n        \t\tdie rdfcroak($expat,$predicate->name().\" must be an empty element since it uses propAttr grammar production - see <a href=\\\"http://www.w3.org/TR/REC-rdf-syntax/#propertyElt\\\">[6.12]</a>\");\n        \t\treturn;\n      \t\t};\n\n      \t\tif ((defined $sStatementID) && ($sStatementID ne '')) {\n        \t\tpush @{$d->{attlist}},[undef,$RDFStore::Parser::SiRPAC::RDFMS_about];\n        \t\tpush @{$d->{attlist}},$sStatementID;\n      \t\t} elsif ((defined $sResource) && ($sResource ne '')) {\n        \t\tpush @{$d->{attlist}},[undef,$RDFStore::Parser::SiRPAC::RDFMS_about];\n        \t\tpush @{$d->{attlist}},$sResource;\n      \t\t} else {\n\t\t\tmy $nodeID = getAttributeValue($expat, $predicate->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_nodeID); \n\t\t\tif( defined $nodeID ) {\n                        \t$sStatementID = 'rdf:nodeID:'.$nodeID;\n                        } else {\n\t\t\t\t$sStatementID = newReificationID($expat);\n\t\t\t\t};\n        \t\tpush @{$d->{attlist}},[undef,$RDFStore::Parser::SiRPAC::RDFMS_nodeID]; \n        \t\tpush @{$d->{attlist}},$sStatementID;\n      \t\t};\n\n\t\tif ((defined $sBagID) && ($sBagID ne '')) {\n        \t\tpush @{$d->{attlist}},[undef,$RDFStore::Parser::SiRPAC::RDFMS_bagID];\n        \t\tpush @{$d->{attlist}},$sBagID;\n        \t\t$d->{sBagID} = $sBagID;\n      \t\t};\n\n          \tprocessDescription($expat,$d, 0,0,$expat->{SiRPAC}->{bCreateBags});\n    \t};\n\tmy $predicate_target = (defined $predicate->{vTargets}->[0]) ? $predicate->{vTargets}->[0] : undef;\n    \tif( ((defined $sResource) && ($sResource ne '')) && (scalar(@{$predicate->{children}})<=0) ) {\n      \t\tif (not(defined $predicate_target)) {\n        \t\tif (\t($reify) ||\n\t\t\t\t(       (defined $predicate->{sID}) &&\n                                \t($predicate->{sID} ne '') ) ) {\n          \t\t\t$sStatementID = reify(\t$expat,\n\t\t\t\t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n\t\t\t\t\t\t\tbuildResource( $expat,$sTarget),\n\t\t\t\t\t\t\tbuildResource( $expat,$sResource),\n\t\t\t\t\t\t\t$predicate->{sID},\n\t\t\t\t\t\t\t$predicate);\n\t\t\t\t$predicate->{sID} = normalizeResourceIdentifier($expat,$sStatementID);\n        \t\t} else {\n\t\t\t\taddTriple(\t$expat,\n                     \t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n                     \t\t\t\tbuildResource( $expat,$sTarget),\n                     \t\t\t\tbuildResource( $expat,$sResource),\n\t\t\t\t\t\t$predicate->{'context'}\n\t\t\t\t\t );\n        \t\t};\n      \t\t} else {\n\t\t\tif (    ($reify) ||\n                                (       (defined $predicate->{sID}) &&\n                                        ($predicate->{sID} ne '') ) ) {\n          \t\t\t$sStatementID = reify(\t$expat, \n\t\t\t\t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n\t\t\t\t\t\t\tbuildResource( $expat,$sTarget),\n\t\t\t\t\t\t\tbuildResource( $expat,$predicate_target->{sID}),\n\t\t\t\t\t\t\t$predicate->{sID},\n\t\t\t\t\t\t\t$predicate);\n\t\t\t\t$predicate->{sID} = normalizeResourceIdentifier($expat,$sStatementID);\n        \t\t} else {\n          \t\t\taddTriple( \t$expat,\n                     \t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n                     \t\t\t\tbuildResource( $expat,$sTarget),\n                     \t\t\t\tbuildResource( $expat,$predicate_target->{sID}),\n\t\t\t\t\t\t$predicate->{'context'}\n\t\t\t\t\t);\n        \t\t};\n      \t\t};\n      \t\treturn $predicate->{sID};\n    \t};\n                                    \n    \tif ( ((defined $sResource) && ($sResource ne '')) && (defined $predicate_target) ) {\n      \t\t$sStatementID = processDescription ($expat,$predicate_target,1,0,0);\n\t\tif (    ($reify) ||\n                        (       (defined $predicate->{sID}) &&\n                        \t($predicate->{sID} ne '') ) ) {\n          \t\t$sStatementID = reify(\t$expat, \n\t\t\t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n\t\t\t\t\t\tbuildResource( $expat,$sTarget),\n\t\t\t\t\t\tbuildResource( $expat,$sStatementID),\n\t\t\t\t\t\t$predicate->{sID},\n\t\t\t\t\t\t$predicate);\n\t\t\t$predicate->{sID} = normalizeResourceIdentifier($expat,$sStatementID);\n        \t} else {\n          \t\taddTriple( \t$expat,\n                     \t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n                     \t\t\tbuildResource( $expat,$sTarget),\n                     \t\t\tbuildResource( $expat,$sStatementID),\n\t\t\t\t\t$predicate->{'context'}\n\t\t\t\t );\n        \t};\n\t\treturn $sStatementID;\n    \t};\n\n\tif (scalar(@{$predicate->{children}})<=0) {\n\t\tmy $sObject;\n\t\tif($predicate->{isCollection}) {\n\t\t\t$sObject = buildResource( $expat, $RDFStore::Parser::SiRPAC::RDFMS_nil );\n\t\t} else {\n\t\t\t$sObject = (\t(exists $d->{sID}) && \n\t\t\t\t\t(defined $d->{sID}) &&\n\t\t\t\t\t($d->{sID} ne '') ) ? \n\t\t\t\t\tbuildResource( $expat, $d->{sID} ) :\n\t\t\t\t\tbuildLiteral( $expat->{SiRPAC}->{nodeFactory},'', $d->{'parse_type'}, $d->{'lang'}, $d->{'rdf:datatype'} );\n\t\t\t};\n        \tif(\t($reify) || \n\t\t\t(\t(defined $predicate->{sID}) &&\n\t\t\t\t($predicate->{sID} ne '') ) ) {\n          \t\t$sStatementID = reify(\t$expat, \n\t\t\t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n\t\t\t\t\t\tbuildResource( $expat,$sTarget),\n\t\t\t\t\t\t$sObject,\n\t\t\t\t\t\t$predicate->{sID},\n\t\t\t\t\t\t$predicate);\n        \t} else {\n          \t\taddTriple( \t$expat,\n                     \t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n                     \t\t\tbuildResource( $expat,$sTarget),\n\t\t\t\t\t$sObject,\n\t\t\t\t\t$predicate->{'context'}\n\t\t\t\t );\n\t\t\t};\n\t\t};\n\tmy $n2;\n\tmy $j=0;\n        my $currentID;\n\tmy $collectionID;\n\tmy $object_elements=1;\n\tforeach $n2 (@{$predicate->{children}}) {\n\t\tif(\t(defined $n2->name()) &&\n\t\t\t($n2->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Description) ) {\n\n\t\t\tdie rdfcroak($expat,\"Only one object node allowed inside predicate '\".$predicate->{tag}.\"'\")\n\t\t\t\tif(\t($object_elements > 1) &&\n\t\t\t\t\t(! $predicate->{isCollection}) );\n\n\t\t\tif(\t($j>0) &&\n\t\t\t\t(! $predicate->{isCollection}) ) {\n                                die rdfcroak($expat,\" Syntax error when processing start element rdf:Description which is not a RDF Collection. rdf:Description elements generally may only occur to describe an object.\");\n                                return;\n\t\t\t\t};\n\n\t\t\t$sStatementID = processDescription ($expat,$n2, 1,0,0);\n\t\t\t$collectionID = newReificationID($expat)\n\t\t\t\tif($predicate->{isCollection});\n\t\t\tunless(\t(defined $sStatementID) &&\n\t\t\t\t($sStatementID ne '') ) {\n      \t\t\t\t$sStatementID = $n2->{sAbout};\n\t\t\t\tunless(\t(defined $sStatementID) &&\n\t\t\t\t\t($sStatementID ne '') ) {\n\t\t\t\t\tmy $nodeID = getAttributeValue($expat, $n2->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_nodeID);\n                                \tif ( defined $nodeID ) {\n                                        \t$sStatementID = 'rdf:nodeID:'.$nodeID;\n                                \t} else {\n\t\t\t\t\t\tif($predicate->{isCollection}) {\n\t\t\t\t\t\t\t$sStatementID = $collectionID;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$sStatementID = newReificationID($expat);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t};\n\n        \t\t$n2->{sID} = normalizeResourceIdentifier($expat,$sStatementID);\n\n                        if($j==0) { \n        \t\t\tif(\t($reify) || \n\t\t\t\t\t(\t(defined $predicate->{sID}) &&\n\t\t\t\t\t\t($predicate->{sID} ne '') ) ) {\n          \t\t\t\t$sStatementID = reify(\t$expat, \n\t\t\t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n\t\t\t\t\t\tbuildResource( $expat,$sTarget),\n\t\t\t\t\t\tbuildResource( $expat,($predicate->{isCollection}) ? $collectionID : $sStatementID),\n\t\t\t\t\t\t$predicate->{sID},\n\t\t\t\t\t\t$predicate);\n        \t\t\t} else {\n          \t\t\t\taddTriple( \t$expat,\n                     \t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n                     \t\t\t\tbuildResource( $expat,$sTarget),\n\t\t\t\t\t\tbuildResource( $expat,($predicate->{isCollection}) ? $collectionID : $sStatementID),\n\t\t\t\t\t\t$predicate->{'context'} );\n        \t\t\t\t};\n                                };\n\n\t\t\tif($predicate->{isCollection}) {\n                        \tif($currentID) {\n                                \taddTriple(      $expat,\n                                                buildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'rest'),\n                                                buildResource( $expat,$currentID),\n\t\t\t\t\t\tbuildResource( $expat,$collectionID),\n\t\t\t\t\t\t$predicate->{'context'} \n                                                );\n                                \t};\n                        \t$currentID=$collectionID;\n\t\t\t\taddTriple(\t$expat,\n\t\t\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'first'),\n\t\t\t\t\tbuildResource( $expat,$collectionID),\n\t\t\t\t\tbuildResource( $expat,$sStatementID),\n\t\t\t\t\t$predicate->{'context'} \n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t$j++;\n\n\t\t\t$object_elements++;\n      \t\t} elsif ($n2->isa('RDFStore::Parser::SiRPAC::DataElement')) {\n        \t\tmy $sValue = $n2->{sContent};\n\t\t\tmy $trimstring = $sValue;\n                        $trimstring =~ s/^\\s+//mg;\n                        $trimstring =~ s/\\s+$//mg;\n                        if(     ( $object_elements > 1 ) &&\n\t\t\t\t(! $predicate->{isCollection} ) &&\n                                (defined $trimstring) &&\n                                (length($trimstring)>0) ) {\n                                die rdfcroak($expat,\"Expected whitespace found: \". $sValue);\n                                return;\n                                };\n\n                        $sTarget = $predicate->{sResource}\n                                if (    (exists $predicate->{sResource}) &&\n                                        (defined $predicate->{sResource}) &&\n                                        ($predicate->{sResource} ne '') );\n\n\t\t\tif(\t(     (defined $trimstring) &&\n                                \t(length($trimstring)>0) ) ||\n\t\t\t\t($#{$predicate->{children}} == 0 ) ) {\n                        \tif(     ($reify) ||\n                        \t\t(       (defined $predicate->{sID}) &&\n                                        \t($predicate->{sID} ne '') ) ) {\n                        \t\t$sStatementID = reify(  $expat,\n                                \t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n                                                        \tbuildResource( $expat,$sTarget),\n\t\t\t\t\t\t\t\t($predicate->{isCollection}) ? \n\t\t\t\t\t\t\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDFMS_nil) :\n\t\t\t\t\t\t\t\t\t($predicate->name() eq $RDFStore::Parser::SiRPAC::RDFMS_type) ?\n\t\t\t\t\t\t\t\t\t\tbuildResource( $expat,$sValue) :\n                                                        \t\t\tbuildLiteral( $expat->{SiRPAC}->{nodeFactory}, $sValue, $n2->{'parse_type'}, $n2->{'lang'}, $n2->{'rdf:datatype'} ),\n                                                        \t$predicate->{sID},\n\t\t\t\t\t\t\t\t$predicate); \n                                \t$predicate->{sID} = normalizeResourceIdentifier($expat,$sStatementID);\n                         \t} else {\n                         \t\taddTriple (     $expat,\n                                \t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n                                                \tbuildResource( $expat,$sTarget),\n\t\t\t\t\t\t\t($predicate->{isCollection}) ? \n\t\t\t\t\t\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDFMS_nil) :\n\t\t\t\t\t\t\t\t($predicate->name() eq $RDFStore::Parser::SiRPAC::RDFMS_type) ?\n\t\t\t\t\t\t\t\t\tbuildResource( $expat,$sValue) :\n                                                        \t\tbuildLiteral( $expat->{SiRPAC}->{nodeFactory}, $sValue, $n2->{'parse_type'}, $n2->{'lang'}, $n2->{'rdf:datatype'} ),\n\t\t\t\t\t\t\t$predicate->{'context'}\n                                                \t); \n                \t\t\t};\n\n\t\t\t\t$object_elements++;\n\t\t\t\t};\n      \t\t} elsif( \t($n2->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Seq) ||\n                            \t($n2->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Alt) ||\n                                ($n2->name() eq $RDFStore::Parser::SiRPAC::RDFMS_Bag) ) {\n\n\t\t\tdie rdfcroak($expat,\"Only one object node allowed inside predicate '\".$predicate->{tag}.\"'\")\n\t\t\t\tif(\t($object_elements > 1) &&\n\t\t\t\t\t(! $predicate->{isCollection}) );\n\n\t\t\tmy $sContainerID = processContainer($expat,$n2);\n        \t\t$sStatementID = $sContainerID;\n\n\t\t\tmy $description_target = (defined $description->{vTargets}->[0]) ? $description->{vTargets}->[0] : undef;\n        \t\tif (defined $description_target) {\n\t\t\t\tif (    ($reify) ||\n\t\t\t\t\t(       (defined $predicate->{sID}) &&\n                                        \t($predicate->{sID} ne '') ) ) {\n          \t\t\t\t$sStatementID = reify(\t$expat, \n\t\t\t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n\t\t\t\t\t\tbuildResource( $expat,$description_target->{sAbout}),\n\t\t\t\t\t\tbuildResource( $expat,$sContainerID),\n\t\t\t\t\t\t$predicate->{sID},\n\t\t\t\t\t\t$predicate);\n\t\t\t\t\t$predicate->{sID} = normalizeResourceIdentifier($expat,$sStatementID);\n        \t\t\t} else {\n\t\t\t\t\taddTriple(\t$expat,\n\t\t\t\t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n\t\t\t\t\t\t\tbuildResource( $expat,$description_target->{sAbout}),\n\t\t\t\t\t\t\tbuildResource( $expat,$sContainerID),\n\t\t\t\t\t\t\t$predicate->{'context'}\n\t\t\t\t\t\t );\n        \t\t\t};\n        \t\t} else {\n\t\t\t\tif (    ($reify) ||\n\t\t\t\t\t(       (defined $predicate->{sID}) &&\n                                        \t($predicate->{sID} ne '') ) ) {\n          \t\t\t\t$sStatementID = reify(\t$expat, \n\t\t\t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n\t\t\t\t\t\tbuildResource( $expat,$sTarget),\n\t\t\t\t\t\tbuildResource( $expat,$sContainerID),\n\t\t\t\t\t\t$predicate->{sID},\n\t\t\t\t\t\t$predicate);\n\t\t\t\t\t$predicate->{sID} = normalizeResourceIdentifier($expat,$sStatementID);\n        \t\t\t} else {\n\t\t\t\t\taddTriple(\t$expat,\n\t\t\t\t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n\t\t\t\t\t\t\tbuildResource( $expat,$sTarget),\n\t\t\t\t\t\t\tbuildResource( $expat,$sContainerID),\n\t\t\t\t\t\t\t$predicate->{'context'}\n\t\t\t\t\t\t );\n        \t\t\t};\n        \t\t};\n\t\t\n\t\t\t$object_elements++;\n      \t\t} elsif( \t(!($n2->name() eq $RDFStore::Parser::SiRPAC::RDFMS_resource)) && \n\t\t\t\t(!($n2->name() eq $RDFStore::Parser::SiRPAC::RDFMS_nodeID)) &&\n\t\t\t\t(length($n2->name())>0) ) {\n\n\t\t\tdie rdfcroak($expat,\"Only one object node allowed inside predicate '\".$predicate->{tag}.\"'\")\n\t\t\t\tif(\t($object_elements > 1) &&\n\t\t\t\t\t(! $predicate->{isCollection}) );\n\n        \t\t$sStatementID = processTypedNode($expat,$n2);\n                        if($predicate->{isCollection}) {\n\t\t\t\t$collectionID = newReificationID($expat);\n\n                                if($currentID) {\n                                        addTriple(      $expat,\n                                                buildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'rest'),\n                                                buildResource( $expat,$currentID),\n                                                buildResource( $expat,$collectionID),\n\t\t\t\t\t\t$predicate->{'context'} \n                                                );\n\t\t\t\t} else { \n          \t\t\t\taddTriple ( \t$expat,\n                     \t\t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n                     \t\t\t\tbuildResource( $expat,$sTarget),\n\t\t\t\t\t\tbuildResource( $expat,$collectionID),\n\t\t\t\t\t\t$predicate->{'context'} \n\t\t\t\t\t \t);\n                                        };\n\n                                $currentID=$collectionID;\n                                addTriple(      $expat,\n                                        buildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'first'),\n                                        buildResource( $expat,$collectionID),\n                                        buildResource( $expat,$sStatementID),\n\t\t\t\t\t$predicate->{'context'} \n                                        );\n\t\t\t} else {\n          \t\t\taddTriple ( \t$expat,\n                     \t\t\tbuildResource( $expat,$predicate->namespace,$predicate->localName),\n                     \t\t\tbuildResource( $expat,$sTarget),\n\t\t\t\t\tbuildResource( $expat,$sStatementID),\n\t\t\t\t\t$predicate->{'context'}\n\t\t\t\t\t );\n                                };\n\t\t\t$j++;\n\n\t\t\t$object_elements++;\n      \t\t\t};\n    \t\t};\n\n\tif(\t($j>0) && \n\t\t($predicate->{isCollection}) ) {\n        \taddTriple(      $expat,\n                \t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'rest'),\n                                buildResource( $expat,$currentID),\n               \t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'nil'),\n\t\t\t\t$predicate->{'context'} \n                                );\n\t\t};\n\n\treturn $sStatementID;\n\t};\n\nsub reify {\n\tmy ($expat,$predicate,$subject,$object,$sNodeID,$ele) = @_;\n\n\tmy $nodeID = getAttributeValue($expat, $ele->{attlist},$RDFStore::Parser::SiRPAC::RDFMS_nodeID); \n\tif ( defined $nodeID ) {\n        \t$sNodeID = 'rdf:nodeID:'.$nodeID\n    \t\t\tif(not(((defined $sNodeID) && ($sNodeID ne ''))));\n        } else {\n\t\t$sNodeID = newReificationID($expat)\n    \t\t\tif(not(((defined $sNodeID) && ($sNodeID ne ''))));\n\t\t};\n\n\n    \taddTriple($expat,$predicate, $subject, $object, $ele->{'context'});\n\n    \tif (\t($predicate eq $RDFStore::Parser::SiRPAC::RDFMS_subject) ||\n    \t\t($predicate eq $RDFStore::Parser::SiRPAC::RDFMS_predicate) ||\n    \t\t($predicate eq $RDFStore::Parser::SiRPAC::RDFMS_object) ||\n    \t\t($predicate eq $RDFStore::Parser::SiRPAC::RDFMS_type) ) {\n      \t\treturn;\n    \t};\n\n    \taddTriple(\t$expat,\n\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'predicate'),\n\t\t\tbuildResource( $expat,$sNodeID),\t\n\t\t\t$predicate,\n\t\t\t$ele->{'context'} );\n\n    \taddTriple(\t$expat,\n\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'subject'),\n\t\t\tbuildResource( $expat,$sNodeID),\t\n\t\t\t(length($subject->toString()) == 0) ?\n\t\t\t\tbuildResource( $expat,$expat->{'sSource'}.'#' ) :\n\t\t\t\t$subject,\n\t\t\t$ele->{'context'}\n\t\t\t);\n\n    \taddTriple(\t$expat,\n\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'object'),\n\t\t\tbuildResource( $expat,$sNodeID),\t\n\t\t\t$object,\n\t\t\t$ele->{'context'});\n\n    \taddTriple(\t$expat,\n\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'type'),\n\t\t\tbuildResource( $expat,$sNodeID),\t\n\t\t\tbuildResource( $expat,$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS,'Statement'),\n\t\t\t$ele->{'context'}\n\t\t\t);\n\n\treturn $sNodeID;\n};\n\nsub expandAttributes {\n\tmy ($expat,$parent,$ele,$predicateNode,$resourceValue) = @_;\n\n\n\tmy $foundAbbreviation = 0;\n\tmy $resourceFound = 0;\n\t\n  \tmy $count=0;\n\twhile ($count<=$#{$ele->{attlist}}) {\n    \t\tmy $sAttribute = ( (defined $ele->{attlist}->[$count++]->[0]) ? $ele->{attlist}->[$count-1]->[0] : '').( (defined $ele->{attlist}->[$count-1]->[1]) ? $ele->{attlist}->[$count-1]->[1] : '');\n    \t\tmy $sValue = getAttributeValue($expat, $ele->{attlist},$sAttribute);\n\n\n\t\t$count++;\n      \t\tif ($sAttribute =~ m|^$RDFStore::Parser::SiRPAC::XMLSCHEMA|) {\n        \t\tnext;\n      \t\t\t};\n\n      \t\tif (\t($sAttribute =~ /^$RDFStore::Parser::SiRPAC::RDF_SYNTAX_NS/) &&\n          \t\t(!($ele->{attlist}->[$count-2]->[1]=~ /^_/)) && \n          \t\t(!($ele->{attlist}->[$count-2]->[1] =~ /^value$/)) &&\n          \t\t(!($ele->{attlist}->[$count-2]->[1] =~ /^type$/)) ) {\n\n        \t\tif(\t($ele->{attlist}->[$count-2]->[1] =~ /resource$/) && \n\t\t\t\t($predicateNode) ) {\n          \t\t\t$resourceFound = 1;\n          \t\t\tnext;\n        \t\t\t};\n \n\t\t\tnext\n\t\t\t\tif(\t($ele->{attlist}->[$count-2]->[1] =~ /ID$/) ||\n            \t\t\t\t($ele->{attlist}->[$count-2]->[1] =~ /bagID$/) ||\n            \t\t\t\t($ele->{attlist}->[$count-2]->[1] =~ /about$/) ||\n            \t\t\t\t($ele->{attlist}->[$count-2]->[1] =~ /aboutEach$/) ||\n            \t\t\t\t($ele->{attlist}->[$count-2]->[1] =~ /datatype$/) ||\n            \t\t\t\t($ele->{attlist}->[$count-2]->[1] =~ /parseType$/) );\n\t\t};\n\t\t\n\n      \t\t$foundAbbreviation = 1;\n\n\t\tmy $newElement =  RDFStore::Parser::SiRPAC::Element->new($ele->{attlist}->[$count-2]->[0],$ele->{attlist}->[$count-2]->[1], undef, $ele->{'lang'}, $ele->{'rdf:datatype'}, $ele->{'context'});\n\n\t\tmy $newData = RDFStore::Parser::SiRPAC::DataElement->new($sValue, 0, $ele->{'lang'}, $ele->{'rdf:datatype'}, $ele->{'context'});\n        \tpush @{$newElement->{children}},$newData;\n        \tpush @{$parent->{children}},$newElement;\n\t\t};\n\n    \tif(\t($resourceFound) && (defined $resourceValue) ) {\n\t\tmy $i=0;\n        \tforeach $i (0..$#{$parent->{children}}) {\n        \t\t$parent->{children}->[$i]->{sResource}= $resourceValue;\n        \t}; \n\t};\n\n\n\treturn $foundAbbreviation;\n};\n\nsub parseLiteral {\n\tmy ($expat) = @_;\n\n\n\tforeach(reverse @{$expat->{SiRPAC}->{elementStack}}) {\t\n\t\tmy $sParseType = getAttributeValue(\t$expat,\n\t\t\t\t\t\t\t$_->{attlist},\n\t\t\t\t\t\t\t$RDFStore::Parser::SiRPAC::RDFMS_parseType );\n\t\treturn 1\n\t\t\tif(\t(defined $sParseType) && \n\t\t\t\t($sParseType ne \"Resource\") &&\n\t\t\t\t($sParseType ne \"Collection\") );\n\t\t};\n    \treturn 0;       \n\t};\n\nsub parseResource {\n\tmy ($expat) = @_;\n\n\n\tforeach(reverse @{$expat->{SiRPAC}->{elementStack}}) {\t\n\t\tmy $sParseType = getAttributeValue(\t$expat,\n\t\t\t\t\t\t\t$_->{attlist},\n\t\t\t\t\t\t\t$RDFStore::Parser::SiRPAC::RDFMS_parseType );\n\t\treturn 1\n\t\t\tif(\t(defined $sParseType) &&\n\t\t\t\t($sParseType eq \"Resource\") );\n\t\t};\n    \treturn 0;       \n\t};\n\nsub normalizeResourceIdentifier {\n\tmy ($expat,$sURI) = @_;\n\n\treturn $sURI\n\t\tif ( $sURI =~ /^rdf:nodeID:/ ); \n\n\n\tmy $xml_base = $expat->base; \n\n\tmy $URL = URI->new($sURI);\n        if(\t(defined $URL->scheme) &&\n\t\t( $URL->scheme ne 'file') ) {\n\t\treturn $sURI;\n\t} elsif(\t(defined $sURI) && \n\t\t\t(\t(defined $xml_base) &&\n\t\t\t\t($xml_base ne '') ) ) {\n\t\t$xml_base =~ s/#.*$//;\n\n\t\tmy $vURI = ($sURI !~ m/^#/) ? $sURI : '';\n\n\t\tmy $absoluteURL;\n\t\tif( $xml_base =~ m/^(http|file):/ ) {\n\t\t\tmy $path = new URI( $xml_base );\n                        $path = $path->path\n\t\t\t\tif($path);\n                        $vURI = $1 . $vURI \n\t\t\t\tif(\t($vURI ne $sURI) &&\n\t\t\t\t\t($path =~ m/([^\\/]+\\.[^\\/]+)$/) );\n\n\t\t\tlocal $URI::ABS_REMOTE_LEADING_DOTS = 1;\n\n\t\t\t$absoluteURL = URI->new( $vURI )->abs( $xml_base ); \n\t\t} else {\n\t\t\t$absoluteURL = $xml_base . $vURI;\n\t\t\t};\n\t\tif(defined $absoluteURL) {\n\t\t\treturn $absoluteURL.( ($sURI !~ m/^#/) ? '' : $sURI );\n\t\t} else {\n\t\t\tcarp \"Cannot combine $xml_base with $sURI\";\n\t    \t\t};\n        } else {\n\t\t$sURI = '#'.$sURI\n\t\t\tunless($sURI =~ /^#/);\n\t\treturn $sURI;\n\t\t};\n\t};\n\npackage RDFStore::Parser::SiRPAC::Element;\n{\n\tsub new {\n\t\tmy ($pkg, $namespace, $tag, $attlist, $lang, $datatype, $context) = @_;\n\n\t\t$attlist = []\n\t\t\tunless(defined $attlist);\n\n\n\t\tmy $self =  {\n\t\t\t\ttag\t\t=>\t$tag,\n\t\t\t\tsNamespace\t=>\t$namespace,\n\t\t\t\tattlist\t\t=>\t$attlist,\n\t\t\t\tchildren\t=>\t[],\n\t\t\t\tvTargets\t=>\t[],\n\t\t\t\tbDone\t\t=>\t0,\n\t\t\t\tisCollection\t=>\t0,\n\t\t\t\t'lang'\t\t=>      $lang, \n\t\t\t\t'rdf:datatype'  =>\t$datatype, \n\t\t\t\t'context'\t=> \t$context \n\t\t\t};\n\t\tbless $self,$pkg;\n\t};\n\n\tsub name {\n\t\treturn (defined $_[0]->{sNamespace}) ?\n\t\t\t\t$_[0]->{sNamespace}.$_[0]->{tag} :\n\t\t\t\t$_[0]->{tag};\n\t};\n\n\tsub localName {\n\t\treturn $_[0]->{tag};\n\t};\n\n\tsub namespace {\n\t\treturn $_[0]->{sNamespace};\n\t};\n};\n\npackage RDFStore::Parser::SiRPAC::DataElement;\n{\n\t@RDFStore::Parser::SiRPAC::DataElement::ISA = qw( RDFStore::Parser::SiRPAC::Element );\n\tsub new {\n\t\tmy ($pkg, $text, $parsetype, $lang, $datatype, $context) = @_;\n\n\n\t\tmy $self = $pkg->SUPER::new(undef,$text,undef,$lang, $datatype, $context);\n\n\t\tdelete $self->{sNamespace}; \n\t\tdelete $self->{attlist}; \n\n\t\t$self->{'parse_type'} = (\t$parsetype or \n\t\t\t\t\t\t$datatype eq 'http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral' ) ? 1 : 0; \n\t\t$self->{tag} = \"[DATA: \" . $text . \"]\";\n\t\t$self->{sContent} = $text; \n\t\tbless $self,$pkg;\n\t};\n\n\tsub name { };\n\tsub localName { };\n\tsub namespace { };\n};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Parser/SiRPAC.pm",
      "package" : "RDFStore::Parser::SiRPAC"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.41';\n\nuse RDFStore::Model;\nuse RDFStore::Vocabulary::OWL;\nuse Carp;\n\nsub Init {\n    my $expat = shift;\n\n\tmy $context;\n\tif(\t(exists $expat->{'style_options'}->{'store_options'}->{'Context'}) &&\n\t\t(ref($expat->{'style_options'}->{'store_options'}->{'Context'})) &&\n\t\t($expat->{'style_options'}->{'store_options'}->{'Context'}->isa(\"RDFStore::Resource\")) ) {\n\t\t$context = $expat->{'style_options'}->{'store_options'}->{'Context'};\n\t\tdelete($expat->{'style_options'}->{'store_options'}->{'Context'});\n\t\t};\n\n\tif(\t(exists $expat->{'style_options'}->{'delete'}) &&\n\t\t(defined $expat->{'style_options'}->{'delete'}) ) {\n\t\tmy $storename = $expat->{'style_options'}->{'store_options'}->{'Name'};\n\t\tmy $in_context = ($context) ? \" in context '\".$context->toString.\"'\" : '';\n\t\tmy $yes = ( ($expat->{'style_options'}->{'confirm'}) && ($expat->{'style_options'}->{'confirm'} =~ m/1|yes|on/) ) ? 1 : 0;\n\t\tconfirm(\"\\n*WARNINIG* This operation can not be undone!!\\n\\nAre you sure you want to remove statements from '$storename' database$in_context? (^C to kill, any key to continue)\\n\\n\")\n\t\t\tunless($yes);\n\t\t};\n\n\n\tmy $not_override = (exists $expat->{'RDFStore_model'}) ? 1 : 0 ;\n\tif(     (exists $expat->{'style_options'}->{'store_options'}->{'sourceModel'}) &&\n                (ref($expat->{'style_options'}->{'store_options'}->{'sourceModel'})) &&\n                ($expat->{'style_options'}->{'store_options'}->{'sourceModel'}->isa(\"RDFStore::Model\")) ) {\n\t\t$expat->{'RDFStore_model'} = $expat->{'style_options'}->{'store_options'}->{'sourceModel'}\n\t\t\tunless($not_override);\n\t} else {\n\t\t$expat->{'RDFStore_model'} = new RDFStore::Model( \n\t\t\t\t\tnodeFactory => $expat->{'NodeFactory'}, \n\t\t\t\t\t%{$expat->{'style_options'}->{'store_options'}} )\n\t\t\tunless($not_override);\n\t\t};\n\n\tunless($not_override) {\n\t\t$expat->{'RDFStore_model'}->setContext($context)\n\t\t\tif(defined $context);\n\t\t$expat->{'RDFStore_model'}->setSourceURI($expat->{'sSource'})\n\t\t\tif(\t(exists $expat->{'sSource'}) && \n\t\t\t\t(defined $expat->{'sSource'}) );\n\t\t};\n\t$expat->{'imports'} = {}\n\t\tunless(exists $expat->{'imports'});\n\t};\n\nsub Final {\n    my $expat = shift;\n\n\treturn $expat->{'RDFStore_model'};\n};\n\nsub Assert {\n\tmy ($expat,$st) = @_;\n\n\tif(\t(exists $expat->{'style_options'}->{'delete'}) &&\n\t\t(defined $expat->{'style_options'}->{'delete'}) ) {\n\t\tif($expat->{'RDFStore_model'}->remove($st)) {\n\t\t\tprint \"Removed statement \".$st->toString,\"\\n\"\n\t\t\t\tif( (defined $st) && (ref($st)) && ($st->isa(\"RDFStore::Statement\")) && (defined $expat->{'style_options'}->{'seevalues'}) );\n\t\t\t};\n\t} else {\n\t\tif($expat->{'RDFStore_model'}->add($st)) {\n\t\t\tprint \"Added statement \".$st->toString,\"\\n\"\n\t\t\t\tif( (defined $st) && (ref($st)) && ($st->isa(\"RDFStore::Statement\")) && (defined $expat->{'style_options'}->{'seevalues'}) );\n\t\t\t};\n\t\t};\n\n\tif(\t(defined $expat->{'style_options'}->{'owl:imports'}) &&\n\t\t($st->predicate->equals($RDFStore::Vocabulary::OWL::imports)) && \n\t\t($st->object->toString ne $expat->{'Source'}) && \n\t\t(! exists $expat->{'imports'}->{ $st->object->toString } ) ) {\n\t\tmy $current_ctx = $expat->{'RDFStore_model'}->getContext;\n\t\t$expat->{'RDFStore_model'}->setContext( $st->object ); \n\t\tmy $owl_p = new RDFStore::Parser::SiRPAC(\n\t\t\t\tStyle => 'RDFStore::Parser::Styles::RDFStore::Model',\n                                NodeFactory => $expat->{'RDFStore_model'}->getNodeFactory,\n                                Source  => $st->object->toString,\n\t\t\t\tstore => {\n\t\t\t\t\t'seevalues' => $expat->{'style_options'}->{'seevalues'},\n\t\t\t\t\t'delete' => (     (exists $expat->{'style_options'}->{'delete'}) &&\n\t\t\t\t\t\t\t(defined $expat->{'style_options'}->{'delete'}) ) ? $expat->{'style_options'}->{'delete'} : undef,\n\t\t\t\t\t'confirm' => (    (exists $expat->{'style_options'}->{'confirm'}) &&\n\t\t\t\t\t\t\t(defined $expat->{'style_options'}->{'confirm'}) ) ? $expat->{'style_options'}->{'confirm'} : undef\n\t\t\t\t\t},\n\t\t\t\tRDFStore_model => $expat->{'RDFStore_model'}, \n\t\t\t\timports => $expat->{'imports'}\n\t\t\t\t);\n\n\t\teval {\n\t\t\t$owl_p->parsefile( $st->object->toString );\n\t\t\t};\n\n\t\t$expat->{'RDFStore_model'}->setContext( $current_ctx )\n\t\t\tif($current_ctx); \n\n\t\t$expat->{'imports'}->{ $st->object->toString } = ($@) ? 2 : 1; \n\t\t};\n};\n\nsub Start_XML_Literal {\n\tmy $expat = shift;\n\tmy $el = shift;\n\n\t$expat->{'XML_Literal_processed_namespaces'} = {}\n\t\tunless(exists $expat->{'XML_Literal_processed_namespaces'});\n\n\tmy @current_ns_prefixes = $expat->current_ns_prefixes;\n\n\tmy $ns_index = 1;\n\n\tmy $xmlcn='';\n\tmy $elns = $expat->namespace($el);\n\tif (defined $elns) {\n\t\tmy $pfx;\n\t\tfor my $p ( @current_ns_prefixes ) {\n\t\t\tif( $expat->expand_ns_prefix($p) eq $elns ) {\n\t\t\t\t$pfx = $p;\t\n\t\t\t\tlast;\n\t\t\t\t};\n\t\t\t};\n\t\t$pfx = 'n' . $ns_index++\n\t\t\tunless($pfx);\n\n\t\tif( exists $expat->{'XML_Literal_processed_namespaces'}->{ $pfx.$elns } ) {\n\t\t\t$xmlcn .= \"<$el\";\n\t\t} else {\n\t\t\t$xmlcn .= ( $pfx eq '#default' ) ? \"<$el xmlns=\\\"$elns\\\"\" : \"<$pfx:$el xmlns:$pfx=\\\"$elns\\\"\";\n\t\t\t$expat->{'XML_Literal_processed_namespaces'}->{ $pfx.$elns } = 1;\n\t\t\t};\n\t} else {\n\t\t$xmlcn .= \"<$el\";\n\t\t};\n\n\tif (@_) {\n\t\tfor (my $i = 0; $i < @_; $i += 2) {\n\t\t\tmy $nm = $_[$i];\n\t\t\tmy $ns = $expat->namespace($nm);\n\t\t\t$_[$i] = defined($ns) ? \"$ns\\01$nm\" : \"\\01$nm\";\n\t\t\t};\n\n    \t\tmy %atts = @_;\n\t\tmy @ids = sort keys %atts;\n\t\tforeach my $id (@ids) {\n\t\t\tmy ($ns, $nm) = split(/\\01/, $id);\n\t\t\tmy $val = $expat->xml_escape($atts{$id}, '\"', \"\\x9\", \"\\xA\", \"\\xD\");\n\t\t\tif (length($ns)) {\n\t\t\t\tmy $pfx;\n\t\t\t\tfor my $p ( @current_ns_prefixes ) {\n\t\t\t\t\tif( $expat->expand_ns_prefix($p) eq $ns ) {\n\t\t\t\t\t\t$pfx = $p;\t\n\t\t\t\t\t\tlast;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t$pfx = 'n' . $ns_index++\n\t\t\t\t\tunless($pfx);\n\n\t\t\t\tif( exists $expat->{'XML_Literal_processed_namespaces'}->{ $pfx.$ns } ) {\n\t\t\t\t\t$xmlcn .= \" $nm=\\\"$val\\\"\";\n\t\t\t\t} else {\n\t\t\t\t\t$xmlcn .= \" $pfx:$nm=\\\"$val\\\" xmlns:$pfx=\\\"$ns\\\"\"; \n\t\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t$xmlcn .= \" $nm=\\\"$val\\\"\";\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\n\t$xmlcn .= '>';\n\n\treturn $xmlcn;\n\t};\n\nsub Stop_XML_Literal {\n\tmy ($expat,$el) = @_;\n\n\tmy @current_ns_prefixes = $expat->current_ns_prefixes;\n\n\tmy $elns = $expat->namespace($el);\n\tif (defined $elns) {\n\t\tmy $pfx;\n\t\tfor my $p ( @current_ns_prefixes ) {\n\t\t\tif( $expat->expand_ns_prefix($p) eq $elns ) {\n\t\t\t\t$pfx = $p;\t\n\t\t\t\tlast;\n\t\t\t\t};\n\t\t\t};\n\t\t$pfx = 'n1' \n\t\t\tunless($pfx);\n\t\treturn ( $pfx eq '#default' ) ? \"</$el>\" : \"</$pfx:$el>\";\n\t} else {\n\t\treturn \"</$el>\";\n\t\t};\n\t};\n\nsub Char_Literal {\n\tmy ($expat,$literal_text) = @_;\n\n\treturn $expat->xml_escape($literal_text, '>', \"\\xD\");\t\n\t};\n\nsub confirm {\n        my ($msg) = @_;\n\n        print $msg;\n\n        return <STDIN>;\n        };\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Parser/Styles/RDFStore/Model.pm",
      "package" : "RDFStore::Parser::Styles::RDFStore::Model"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.1';\n\nuse Carp;\n\nsub Final {\n\tmy $expat = shift;\n\n\treturn 1;\n\t};\n\nsub Assert {\n\tmy ($expat,$st) = @_;\n\n\tprint $st->toString.\"\\n\"\n\t\tif( (defined $st) && (ref($st)) && ($st->isa(\"RDFStore::Statement\")) && (defined $expat->{'style_options'}->{'seevalues'}) );\n\t};\n\nsub Start_XML_Literal {\n\tmy $expat = shift;\n\tmy $el = shift;\n\n\t$expat->{'XML_Literal_processed_namespaces'} = {}\n\t\tunless(exists $expat->{'XML_Literal_processed_namespaces'});\n\n\tmy @current_ns_prefixes = $expat->current_ns_prefixes;\n\n\tmy $ns_index = 1;\n\n\tmy $xmlcn='';\n\tmy $elns = $expat->namespace($el);\n\tif (defined $elns) {\n\t\tmy $pfx;\n\t\tfor my $p ( @current_ns_prefixes ) {\n\t\t\tif( $expat->expand_ns_prefix($p) eq $elns ) {\n\t\t\t\t$pfx = $p;\t\n\t\t\t\tlast;\n\t\t\t\t};\n\t\t\t};\n\t\t$pfx = 'n' . $ns_index++\n\t\t\tunless($pfx);\n\n\t\tif( exists $expat->{'XML_Literal_processed_namespaces'}->{ $pfx.$elns } ) {\n\t\t\t$xmlcn .= \"<$el\";\n\t\t} else {\n\t\t\t$xmlcn .= ( $pfx eq '#default' ) ? \"<$el xmlns=\\\"$elns\\\"\" : \"<$pfx:$el xmlns:$pfx=\\\"$elns\\\"\";\n\t\t\t$expat->{'XML_Literal_processed_namespaces'}->{ $pfx.$elns } = 1;\n\t\t\t};\n\t} else {\n\t\t$xmlcn .= \"<$el\";\n\t\t};\n\n\tif (@_) {\n\t\tfor (my $i = 0; $i < @_; $i += 2) {\n\t\t\tmy $nm = $_[$i];\n\t\t\tmy $ns = $expat->namespace($nm);\n\t\t\t$_[$i] = defined($ns) ? \"$ns\\01$nm\" : \"\\01$nm\";\n\t\t\t};\n\n    \t\tmy %atts = @_;\n\t\tmy @ids = sort keys %atts;\n\t\tforeach my $id (@ids) {\n\t\t\tmy ($ns, $nm) = split(/\\01/, $id);\n\t\t\tmy $val = $expat->xml_escape($atts{$id}, '\"', \"\\x9\", \"\\xA\", \"\\xD\");\n\t\t\tif (length($ns)) {\n\t\t\t\tmy $pfx;\n\t\t\t\tfor my $p ( @current_ns_prefixes ) {\n\t\t\t\t\tif( $expat->expand_ns_prefix($p) eq $ns ) {\n\t\t\t\t\t\t$pfx = $p;\t\n\t\t\t\t\t\tlast;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t$pfx = 'n' . $ns_index++\n\t\t\t\t\tunless($pfx);\n\n\t\t\t\tif( exists $expat->{'XML_Literal_processed_namespaces'}->{ $pfx.$ns } ) {\n\t\t\t\t\t$xmlcn .= \" $nm=\\\"$val\\\"\";\n\t\t\t\t} else {\n\t\t\t\t\t$xmlcn .= \" $pfx:$nm=\\\"$val\\\" xmlns:$pfx=\\\"$ns\\\"\"; \n\t\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t$xmlcn .= \" $nm=\\\"$val\\\"\";\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\n\t$xmlcn .= '>';\n\n\treturn $xmlcn;\n\t};\n\nsub Stop_XML_Literal {\n\tmy ($expat,$el) = @_;\n\n\tmy @current_ns_prefixes = $expat->current_ns_prefixes;\n\n\tmy $elns = $expat->namespace($el);\n\tif (defined $elns) {\n\t\tmy $pfx;\n\t\tfor my $p ( @current_ns_prefixes ) {\n\t\t\tif( $expat->expand_ns_prefix($p) eq $elns ) {\n\t\t\t\t$pfx = $p;\t\n\t\t\t\tlast;\n\t\t\t\t};\n\t\t\t};\n\t\t$pfx = 'n1' \n\t\t\tunless($pfx);\n\t\treturn ( $pfx eq '#default' ) ? \"</$el>\" : \"</$pfx:$el>\";\n\t} else {\n\t\treturn \"</$el>\";\n\t\t};\n\t};\n\nsub Char_Literal {\n\tmy ($expat,$literal_text) = @_;\n\n\treturn $expat->xml_escape($literal_text, '>', \"\\xD\");\t\n\t};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Parser/Styles/RDFStore/Statement.pm",
      "package" : "RDFStore::Parser::Styles::RDFStore::Statement"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ( $VERSION $Ontology $Class $Thing $Nothing $equivalentClass $disjointWith $equivalentProperty $sameAs $differentFrom $AllDifferent $distinctMembers $unionOf $intersectionOf $complementOf $oneOf $Restriction $onProperty $allValuesFrom $hasValue $someValuesFrom $minCardinality $maxCardinality $cardinality $ObjectProperty $DatatypeProperty $inverseOf $TransitiveProperty $SymmetricProperty $FunctionalProperty $InverseFunctionalProperty $AnnotationProperty $OntologyProperty $imports $versionInfo $priorVersion $backwardCompatibleWith $incompatibleWith $DeprecatedClass $DeprecatedProperty $DataRange );\n$VERSION='0.41';\nuse strict;\nuse RDFStore::Model;\nuse Carp;\n\n\n$RDFStore::Vocabulary::OWL::_Namespace= \"http://www.w3.org/2002/07/owl#\";\nuse RDFStore::NodeFactory;\n&setNodeFactory(new RDFStore::NodeFactory());\n\nsub createResource {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\n\treturn $_[0]->createResource($RDFStore::Vocabulary::OWL::_Namespace,$_[1]);\n};\nsub setNodeFactory {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\t$RDFStore::Vocabulary::OWL::Ontology = createResource($_[0], \"Ontology\");\n\t$RDFStore::Vocabulary::OWL::Class = createResource($_[0], \"Class\");\n\t$RDFStore::Vocabulary::OWL::Thing = createResource($_[0], \"Thing\");\n\t$RDFStore::Vocabulary::OWL::Nothing = createResource($_[0], \"Nothing\");\n\t$RDFStore::Vocabulary::OWL::equivalentClass = createResource($_[0], \"equivalentClass\");\n\t$RDFStore::Vocabulary::OWL::disjointWith = createResource($_[0], \"disjointWith\");\n\t$RDFStore::Vocabulary::OWL::equivalentProperty = createResource($_[0], \"equivalentProperty\");\n\t$RDFStore::Vocabulary::OWL::sameAs = createResource($_[0], \"sameAs\");\n\t$RDFStore::Vocabulary::OWL::differentFrom = createResource($_[0], \"differentFrom\");\n\t$RDFStore::Vocabulary::OWL::AllDifferent = createResource($_[0], \"AllDifferent\");\n\t$RDFStore::Vocabulary::OWL::distinctMembers = createResource($_[0], \"distinctMembers\");\n\t$RDFStore::Vocabulary::OWL::unionOf = createResource($_[0], \"unionOf\");\n\t$RDFStore::Vocabulary::OWL::intersectionOf = createResource($_[0], \"intersectionOf\");\n\t$RDFStore::Vocabulary::OWL::complementOf = createResource($_[0], \"complementOf\");\n\t$RDFStore::Vocabulary::OWL::oneOf = createResource($_[0], \"oneOf\");\n\t$RDFStore::Vocabulary::OWL::Restriction = createResource($_[0], \"Restriction\");\n\t$RDFStore::Vocabulary::OWL::onProperty = createResource($_[0], \"onProperty\");\n\t$RDFStore::Vocabulary::OWL::allValuesFrom = createResource($_[0], \"allValuesFrom\");\n\t$RDFStore::Vocabulary::OWL::hasValue = createResource($_[0], \"hasValue\");\n\t$RDFStore::Vocabulary::OWL::someValuesFrom = createResource($_[0], \"someValuesFrom\");\n\t$RDFStore::Vocabulary::OWL::minCardinality = createResource($_[0], \"minCardinality\");\n\t$RDFStore::Vocabulary::OWL::maxCardinality = createResource($_[0], \"maxCardinality\");\n\t$RDFStore::Vocabulary::OWL::cardinality = createResource($_[0], \"cardinality\");\n\t$RDFStore::Vocabulary::OWL::ObjectProperty = createResource($_[0], \"ObjectProperty\");\n\t$RDFStore::Vocabulary::OWL::DatatypeProperty = createResource($_[0], \"DatatypeProperty\");\n\t$RDFStore::Vocabulary::OWL::inverseOf = createResource($_[0], \"inverseOf\");\n\t$RDFStore::Vocabulary::OWL::TransitiveProperty = createResource($_[0], \"TransitiveProperty\");\n\t$RDFStore::Vocabulary::OWL::SymmetricProperty = createResource($_[0], \"SymmetricProperty\");\n\t$RDFStore::Vocabulary::OWL::FunctionalProperty = createResource($_[0], \"FunctionalProperty\");\n\t$RDFStore::Vocabulary::OWL::InverseFunctionalProperty = createResource($_[0], \"InverseFunctionalProperty\");\n\t$RDFStore::Vocabulary::OWL::AnnotationProperty = createResource($_[0], \"AnnotationProperty\");\n\t$RDFStore::Vocabulary::OWL::OntologyProperty = createResource($_[0], \"OntologyProperty\");\n\t$RDFStore::Vocabulary::OWL::imports = createResource($_[0], \"imports\");\n\t$RDFStore::Vocabulary::OWL::versionInfo = createResource($_[0], \"versionInfo\");\n\t$RDFStore::Vocabulary::OWL::priorVersion = createResource($_[0], \"priorVersion\");\n\t$RDFStore::Vocabulary::OWL::backwardCompatibleWith = createResource($_[0], \"backwardCompatibleWith\");\n\t$RDFStore::Vocabulary::OWL::incompatibleWith = createResource($_[0], \"incompatibleWith\");\n\t$RDFStore::Vocabulary::OWL::DeprecatedClass = createResource($_[0], \"DeprecatedClass\");\n\t$RDFStore::Vocabulary::OWL::DeprecatedProperty = createResource($_[0], \"DeprecatedProperty\");\n\t$RDFStore::Vocabulary::OWL::DataRange = createResource($_[0], \"DataRange\");\n};\nsub END {\n\t$RDFStore::Vocabulary::OWL::Ontology = undef;\n\t$RDFStore::Vocabulary::OWL::Class = undef;\n\t$RDFStore::Vocabulary::OWL::Thing = undef;\n\t$RDFStore::Vocabulary::OWL::Nothing = undef;\n\t$RDFStore::Vocabulary::OWL::equivalentClass = undef;\n\t$RDFStore::Vocabulary::OWL::disjointWith = undef;\n\t$RDFStore::Vocabulary::OWL::equivalentProperty = undef;\n\t$RDFStore::Vocabulary::OWL::sameAs = undef;\n\t$RDFStore::Vocabulary::OWL::differentFrom = undef;\n\t$RDFStore::Vocabulary::OWL::AllDifferent = undef;\n\t$RDFStore::Vocabulary::OWL::distinctMembers = undef;\n\t$RDFStore::Vocabulary::OWL::unionOf = undef;\n\t$RDFStore::Vocabulary::OWL::intersectionOf = undef;\n\t$RDFStore::Vocabulary::OWL::complementOf = undef;\n\t$RDFStore::Vocabulary::OWL::oneOf = undef;\n\t$RDFStore::Vocabulary::OWL::Restriction = undef;\n\t$RDFStore::Vocabulary::OWL::onProperty = undef;\n\t$RDFStore::Vocabulary::OWL::allValuesFrom = undef;\n\t$RDFStore::Vocabulary::OWL::hasValue = undef;\n\t$RDFStore::Vocabulary::OWL::someValuesFrom = undef;\n\t$RDFStore::Vocabulary::OWL::minCardinality = undef;\n\t$RDFStore::Vocabulary::OWL::maxCardinality = undef;\n\t$RDFStore::Vocabulary::OWL::cardinality = undef;\n\t$RDFStore::Vocabulary::OWL::ObjectProperty = undef;\n\t$RDFStore::Vocabulary::OWL::DatatypeProperty = undef;\n\t$RDFStore::Vocabulary::OWL::inverseOf = undef;\n\t$RDFStore::Vocabulary::OWL::TransitiveProperty = undef;\n\t$RDFStore::Vocabulary::OWL::SymmetricProperty = undef;\n\t$RDFStore::Vocabulary::OWL::FunctionalProperty = undef;\n\t$RDFStore::Vocabulary::OWL::InverseFunctionalProperty = undef;\n\t$RDFStore::Vocabulary::OWL::AnnotationProperty = undef;\n\t$RDFStore::Vocabulary::OWL::OntologyProperty = undef;\n\t$RDFStore::Vocabulary::OWL::imports = undef;\n\t$RDFStore::Vocabulary::OWL::versionInfo = undef;\n\t$RDFStore::Vocabulary::OWL::priorVersion = undef;\n\t$RDFStore::Vocabulary::OWL::backwardCompatibleWith = undef;\n\t$RDFStore::Vocabulary::OWL::incompatibleWith = undef;\n\t$RDFStore::Vocabulary::OWL::DeprecatedClass = undef;\n\t$RDFStore::Vocabulary::OWL::DeprecatedProperty = undef;\n\t$RDFStore::Vocabulary::OWL::DataRange = undef;\n};\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Vocabulary/OWL.pm",
      "package" : "RDFStore::Vocabulary::OWL"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ( $VERSION $Collection $Dataset $Event $Image $InteractiveResource $Service $Software $Sound $Text $PhysicalObject $StillImage $MovingImage );\n$VERSION='0.41';\nuse strict;\nuse RDFStore::Model;\nuse Carp;\n\n\n$RDFStore::Vocabulary::DCT::_Namespace= \"http://purl.org/dc/dcmitype/\";\nuse RDFStore::NodeFactory;\n&setNodeFactory(new RDFStore::NodeFactory());\n\nsub createResource {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\n\treturn $_[0]->createResource($RDFStore::Vocabulary::DCT::_Namespace,$_[1]);\n};\nsub setNodeFactory {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\t$RDFStore::Vocabulary::DCT::Collection = createResource($_[0], \"Collection\");\n\t$RDFStore::Vocabulary::DCT::Dataset = createResource($_[0], \"Dataset\");\n\t$RDFStore::Vocabulary::DCT::Event = createResource($_[0], \"Event\");\n\t$RDFStore::Vocabulary::DCT::Image = createResource($_[0], \"Image\");\n\t$RDFStore::Vocabulary::DCT::InteractiveResource = createResource($_[0], \"InteractiveResource\");\n\t$RDFStore::Vocabulary::DCT::Service = createResource($_[0], \"Service\");\n\t$RDFStore::Vocabulary::DCT::Software = createResource($_[0], \"Software\");\n\t$RDFStore::Vocabulary::DCT::Sound = createResource($_[0], \"Sound\");\n\t$RDFStore::Vocabulary::DCT::Text = createResource($_[0], \"Text\");\n\t$RDFStore::Vocabulary::DCT::PhysicalObject = createResource($_[0], \"PhysicalObject\");\n\t$RDFStore::Vocabulary::DCT::StillImage = createResource($_[0], \"StillImage\");\n\t$RDFStore::Vocabulary::DCT::MovingImage = createResource($_[0], \"MovingImage\");\n};\nsub END {\n\t$RDFStore::Vocabulary::DCT::Collection = undef;\n\t$RDFStore::Vocabulary::DCT::Dataset = undef;\n\t$RDFStore::Vocabulary::DCT::Event = undef;\n\t$RDFStore::Vocabulary::DCT::Image = undef;\n\t$RDFStore::Vocabulary::DCT::InteractiveResource = undef;\n\t$RDFStore::Vocabulary::DCT::Service = undef;\n\t$RDFStore::Vocabulary::DCT::Software = undef;\n\t$RDFStore::Vocabulary::DCT::Sound = undef;\n\t$RDFStore::Vocabulary::DCT::Text = undef;\n\t$RDFStore::Vocabulary::DCT::PhysicalObject = undef;\n\t$RDFStore::Vocabulary::DCT::StillImage = undef;\n\t$RDFStore::Vocabulary::DCT::MovingImage = undef;\n};\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Vocabulary/DCT.pm",
      "package" : "RDFStore::Vocabulary::DCT"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ( $VERSION $channel $image $item $items $textinput $title $link $url $description $name );\n$VERSION='0.41';\nuse strict;\nuse RDFStore::Model;\nuse Carp;\n\n\n$RDFStore::Vocabulary::RSS::_Namespace= \"http://purl.org/rss/1.0/\";\nuse RDFStore::NodeFactory;\n&setNodeFactory(new RDFStore::NodeFactory());\n\nsub createResource {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\n\treturn $_[0]->createResource($RDFStore::Vocabulary::RSS::_Namespace,$_[1]);\n};\nsub setNodeFactory {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\t$RDFStore::Vocabulary::RSS::channel = createResource($_[0], \"channel\");\n\t$RDFStore::Vocabulary::RSS::image = createResource($_[0], \"image\");\n\t$RDFStore::Vocabulary::RSS::item = createResource($_[0], \"item\");\n\t$RDFStore::Vocabulary::RSS::items = createResource($_[0], \"items\");\n\t$RDFStore::Vocabulary::RSS::textinput = createResource($_[0], \"textinput\");\n\t$RDFStore::Vocabulary::RSS::title = createResource($_[0], \"title\");\n\t$RDFStore::Vocabulary::RSS::link = createResource($_[0], \"link\");\n\t$RDFStore::Vocabulary::RSS::url = createResource($_[0], \"url\");\n\t$RDFStore::Vocabulary::RSS::description = createResource($_[0], \"description\");\n\t$RDFStore::Vocabulary::RSS::name = createResource($_[0], \"name\");\n};\nsub END {\n\t$RDFStore::Vocabulary::RSS::channel = undef;\n\t$RDFStore::Vocabulary::RSS::image = undef;\n\t$RDFStore::Vocabulary::RSS::item = undef;\n\t$RDFStore::Vocabulary::RSS::items = undef;\n\t$RDFStore::Vocabulary::RSS::textinput = undef;\n\t$RDFStore::Vocabulary::RSS::title = undef;\n\t$RDFStore::Vocabulary::RSS::link = undef;\n\t$RDFStore::Vocabulary::RSS::url = undef;\n\t$RDFStore::Vocabulary::RSS::description = undef;\n\t$RDFStore::Vocabulary::RSS::name = undef;\n};\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Vocabulary/RSS.pm",
      "package" : "RDFStore::Vocabulary::RSS"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ( $VERSION $title $creator $subject $description $publisher $contributor $date $type $format $identifier $source $language $relation $coverage $rights );\n$VERSION='0.41';\nuse strict;\nuse RDFStore::Model;\nuse Carp;\n\n\n$RDFStore::Vocabulary::DC::_Namespace= \"http://purl.org/dc/elements/1.1/\";\nuse RDFStore::NodeFactory;\n&setNodeFactory(new RDFStore::NodeFactory());\n\nsub createResource {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\n\treturn $_[0]->createResource($RDFStore::Vocabulary::DC::_Namespace,$_[1]);\n};\nsub setNodeFactory {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\t$RDFStore::Vocabulary::DC::title = createResource($_[0], \"title\");\n\t$RDFStore::Vocabulary::DC::creator = createResource($_[0], \"creator\");\n\t$RDFStore::Vocabulary::DC::subject = createResource($_[0], \"subject\");\n\t$RDFStore::Vocabulary::DC::description = createResource($_[0], \"description\");\n\t$RDFStore::Vocabulary::DC::publisher = createResource($_[0], \"publisher\");\n\t$RDFStore::Vocabulary::DC::contributor = createResource($_[0], \"contributor\");\n\t$RDFStore::Vocabulary::DC::date = createResource($_[0], \"date\");\n\t$RDFStore::Vocabulary::DC::type = createResource($_[0], \"type\");\n\t$RDFStore::Vocabulary::DC::format = createResource($_[0], \"format\");\n\t$RDFStore::Vocabulary::DC::identifier = createResource($_[0], \"identifier\");\n\t$RDFStore::Vocabulary::DC::source = createResource($_[0], \"source\");\n\t$RDFStore::Vocabulary::DC::language = createResource($_[0], \"language\");\n\t$RDFStore::Vocabulary::DC::relation = createResource($_[0], \"relation\");\n\t$RDFStore::Vocabulary::DC::coverage = createResource($_[0], \"coverage\");\n\t$RDFStore::Vocabulary::DC::rights = createResource($_[0], \"rights\");\n};\nsub END {\n\t$RDFStore::Vocabulary::DC::title = undef;\n\t$RDFStore::Vocabulary::DC::creator = undef;\n\t$RDFStore::Vocabulary::DC::subject = undef;\n\t$RDFStore::Vocabulary::DC::description = undef;\n\t$RDFStore::Vocabulary::DC::publisher = undef;\n\t$RDFStore::Vocabulary::DC::contributor = undef;\n\t$RDFStore::Vocabulary::DC::date = undef;\n\t$RDFStore::Vocabulary::DC::type = undef;\n\t$RDFStore::Vocabulary::DC::format = undef;\n\t$RDFStore::Vocabulary::DC::identifier = undef;\n\t$RDFStore::Vocabulary::DC::source = undef;\n\t$RDFStore::Vocabulary::DC::language = undef;\n\t$RDFStore::Vocabulary::DC::relation = undef;\n\t$RDFStore::Vocabulary::DC::coverage = undef;\n\t$RDFStore::Vocabulary::DC::rights = undef;\n};\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Vocabulary/DC.pm",
      "package" : "RDFStore::Vocabulary::DC"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ( $VERSION $Context $EmptyContext );\n$VERSION='0.41';\nuse strict;\nuse RDFStore::Model;\nuse Carp;\n\n\n$RDFStore::Vocabulary::RDFStoreContext::_Namespace= \"http://rdfstore.sourceforge.net/contexts/\";\nuse RDFStore::NodeFactory;\n&setNodeFactory(new RDFStore::NodeFactory());\n\nsub createResource {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\n\treturn $_[0]->createResource($RDFStore::Vocabulary::RDFStoreContext::_Namespace,$_[1]);\n};\nsub setNodeFactory {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\t$RDFStore::Vocabulary::RDFStoreContext::Context = createResource($_[0], \"Context\");\n\t$RDFStore::Vocabulary::RDFStoreContext::EmptyContext = createResource($_[0], \"EmptyContext\");\n};\nsub END {\n\t$RDFStore::Vocabulary::RDFStoreContext::Context = undef;\n\t$RDFStore::Vocabulary::RDFStoreContext::EmptyContext = undef;\n};\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Vocabulary/RDFStoreContext.pm",
      "package" : "RDFStore::Vocabulary::RDFStoreContext"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ( $VERSION $Resource $Class $subClassOf $subPropertyOf $comment $Literal $label $domain $range $seeAlso $isDefinedBy $Container $ContainerMembershipProperty $member $Datatype );\n$VERSION='0.41';\nuse strict;\nuse RDFStore::Model;\nuse Carp;\n\n\n$RDFStore::Vocabulary::RDFS::_Namespace= \"http://www.w3.org/2000/01/rdf-schema#\";\nuse RDFStore::NodeFactory;\n&setNodeFactory(new RDFStore::NodeFactory());\n\nsub createResource {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\n\treturn $_[0]->createResource($RDFStore::Vocabulary::RDFS::_Namespace,$_[1]);\n};\nsub setNodeFactory {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\t$RDFStore::Vocabulary::RDFS::Resource = createResource($_[0], \"Resource\");\n\t$RDFStore::Vocabulary::RDFS::Class = createResource($_[0], \"Class\");\n\t$RDFStore::Vocabulary::RDFS::subClassOf = createResource($_[0], \"subClassOf\");\n\t$RDFStore::Vocabulary::RDFS::subPropertyOf = createResource($_[0], \"subPropertyOf\");\n\t$RDFStore::Vocabulary::RDFS::comment = createResource($_[0], \"comment\");\n\t$RDFStore::Vocabulary::RDFS::Literal = createResource($_[0], \"Literal\");\n\t$RDFStore::Vocabulary::RDFS::label = createResource($_[0], \"label\");\n\t$RDFStore::Vocabulary::RDFS::domain = createResource($_[0], \"domain\");\n\t$RDFStore::Vocabulary::RDFS::range = createResource($_[0], \"range\");\n\t$RDFStore::Vocabulary::RDFS::seeAlso = createResource($_[0], \"seeAlso\");\n\t$RDFStore::Vocabulary::RDFS::isDefinedBy = createResource($_[0], \"isDefinedBy\");\n\t$RDFStore::Vocabulary::RDFS::Container = createResource($_[0], \"Container\");\n\t$RDFStore::Vocabulary::RDFS::ContainerMembershipProperty = createResource($_[0], \"ContainerMembershipProperty\");\n\t$RDFStore::Vocabulary::RDFS::member = createResource($_[0], \"member\");\n\t$RDFStore::Vocabulary::RDFS::Datatype = createResource($_[0], \"Datatype\");\n};\nsub END {\n\t$RDFStore::Vocabulary::RDFS::Resource = undef;\n\t$RDFStore::Vocabulary::RDFS::Class = undef;\n\t$RDFStore::Vocabulary::RDFS::subClassOf = undef;\n\t$RDFStore::Vocabulary::RDFS::subPropertyOf = undef;\n\t$RDFStore::Vocabulary::RDFS::comment = undef;\n\t$RDFStore::Vocabulary::RDFS::Literal = undef;\n\t$RDFStore::Vocabulary::RDFS::label = undef;\n\t$RDFStore::Vocabulary::RDFS::domain = undef;\n\t$RDFStore::Vocabulary::RDFS::range = undef;\n\t$RDFStore::Vocabulary::RDFS::seeAlso = undef;\n\t$RDFStore::Vocabulary::RDFS::isDefinedBy = undef;\n\t$RDFStore::Vocabulary::RDFS::Container = undef;\n\t$RDFStore::Vocabulary::RDFS::ContainerMembershipProperty = undef;\n\t$RDFStore::Vocabulary::RDFS::member = undef;\n\t$RDFStore::Vocabulary::RDFS::Datatype = undef;\n};\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Vocabulary/RDFS.pm",
      "package" : "RDFStore::Vocabulary::RDFS"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ( $VERSION $Person $Agent $Document $Organization $Project $Group $Image $PersonalProfileDocument $OnlineAccount $OnlineGamingAccount $OnlineEcommerceAccount $OnlineChatAccount $mbox $mbox_sha1sum $gender $geekcode $dnaChecksum $sha1 $based_near $title $nick $jabberID $aimChatID $icqChatID $yahooChatID $msnChatID $name $firstName $givenname $surname $family_name $phone $homepage $page $weblog $tipjar $plan $made $maker $img $depiction $depicts $thumbnail $myersBriggs $workplaceHomepage $workInfoHomepage $schoolHomepage $knows $interest $topic_interest $publications $currentProject $pastProject $fundedBy $logo $topic $primaryTopic $theme $holdsAccount $accountServiceHomepage $accountName $member $membershipClass );\n$VERSION='0.41';\nuse strict;\nuse RDFStore::Model;\nuse Carp;\n\n\n$RDFStore::Vocabulary::FOAF::_Namespace= \"http://xmlns.com/foaf/0.1/\";\nuse RDFStore::NodeFactory;\n&setNodeFactory(new RDFStore::NodeFactory());\n\nsub createResource {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\n\treturn $_[0]->createResource($RDFStore::Vocabulary::FOAF::_Namespace,$_[1]);\n};\nsub setNodeFactory {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\t$RDFStore::Vocabulary::FOAF::Person = createResource($_[0], \"Person\");\n\t$RDFStore::Vocabulary::FOAF::Agent = createResource($_[0], \"Agent\");\n\t$RDFStore::Vocabulary::FOAF::Document = createResource($_[0], \"Document\");\n\t$RDFStore::Vocabulary::FOAF::Organization = createResource($_[0], \"Organization\");\n\t$RDFStore::Vocabulary::FOAF::Project = createResource($_[0], \"Project\");\n\t$RDFStore::Vocabulary::FOAF::Group = createResource($_[0], \"Group\");\n\t$RDFStore::Vocabulary::FOAF::Image = createResource($_[0], \"Image\");\n\t$RDFStore::Vocabulary::FOAF::PersonalProfileDocument = createResource($_[0], \"PersonalProfileDocument\");\n\t$RDFStore::Vocabulary::FOAF::OnlineAccount = createResource($_[0], \"OnlineAccount\");\n\t$RDFStore::Vocabulary::FOAF::OnlineGamingAccount = createResource($_[0], \"OnlineGamingAccount\");\n\t$RDFStore::Vocabulary::FOAF::OnlineEcommerceAccount = createResource($_[0], \"OnlineEcommerceAccount\");\n\t$RDFStore::Vocabulary::FOAF::OnlineChatAccount = createResource($_[0], \"OnlineChatAccount\");\n\t$RDFStore::Vocabulary::FOAF::mbox = createResource($_[0], \"mbox\");\n\t$RDFStore::Vocabulary::FOAF::mbox_sha1sum = createResource($_[0], \"mbox_sha1sum\");\n\t$RDFStore::Vocabulary::FOAF::gender = createResource($_[0], \"gender\");\n\t$RDFStore::Vocabulary::FOAF::geekcode = createResource($_[0], \"geekcode\");\n\t$RDFStore::Vocabulary::FOAF::dnaChecksum = createResource($_[0], \"dnaChecksum\");\n\t$RDFStore::Vocabulary::FOAF::sha1 = createResource($_[0], \"sha1\");\n\t$RDFStore::Vocabulary::FOAF::based_near = createResource($_[0], \"based_near\");\n\t$RDFStore::Vocabulary::FOAF::title = createResource($_[0], \"title\");\n\t$RDFStore::Vocabulary::FOAF::nick = createResource($_[0], \"nick\");\n\t$RDFStore::Vocabulary::FOAF::jabberID = createResource($_[0], \"jabberID\");\n\t$RDFStore::Vocabulary::FOAF::aimChatID = createResource($_[0], \"aimChatID\");\n\t$RDFStore::Vocabulary::FOAF::icqChatID = createResource($_[0], \"icqChatID\");\n\t$RDFStore::Vocabulary::FOAF::yahooChatID = createResource($_[0], \"yahooChatID\");\n\t$RDFStore::Vocabulary::FOAF::msnChatID = createResource($_[0], \"msnChatID\");\n\t$RDFStore::Vocabulary::FOAF::name = createResource($_[0], \"name\");\n\t$RDFStore::Vocabulary::FOAF::firstName = createResource($_[0], \"firstName\");\n\t$RDFStore::Vocabulary::FOAF::givenname = createResource($_[0], \"givenname\");\n\t$RDFStore::Vocabulary::FOAF::surname = createResource($_[0], \"surname\");\n\t$RDFStore::Vocabulary::FOAF::family_name = createResource($_[0], \"family_name\");\n\t$RDFStore::Vocabulary::FOAF::phone = createResource($_[0], \"phone\");\n\t$RDFStore::Vocabulary::FOAF::homepage = createResource($_[0], \"homepage\");\n\t$RDFStore::Vocabulary::FOAF::page = createResource($_[0], \"page\");\n\t$RDFStore::Vocabulary::FOAF::weblog = createResource($_[0], \"weblog\");\n\t$RDFStore::Vocabulary::FOAF::tipjar = createResource($_[0], \"tipjar\");\n\t$RDFStore::Vocabulary::FOAF::plan = createResource($_[0], \"plan\");\n\t$RDFStore::Vocabulary::FOAF::made = createResource($_[0], \"made\");\n\t$RDFStore::Vocabulary::FOAF::maker = createResource($_[0], \"maker\");\n\t$RDFStore::Vocabulary::FOAF::img = createResource($_[0], \"img\");\n\t$RDFStore::Vocabulary::FOAF::depiction = createResource($_[0], \"depiction\");\n\t$RDFStore::Vocabulary::FOAF::depicts = createResource($_[0], \"depicts\");\n\t$RDFStore::Vocabulary::FOAF::thumbnail = createResource($_[0], \"thumbnail\");\n\t$RDFStore::Vocabulary::FOAF::myersBriggs = createResource($_[0], \"myersBriggs\");\n\t$RDFStore::Vocabulary::FOAF::workplaceHomepage = createResource($_[0], \"workplaceHomepage\");\n\t$RDFStore::Vocabulary::FOAF::workInfoHomepage = createResource($_[0], \"workInfoHomepage\");\n\t$RDFStore::Vocabulary::FOAF::schoolHomepage = createResource($_[0], \"schoolHomepage\");\n\t$RDFStore::Vocabulary::FOAF::knows = createResource($_[0], \"knows\");\n\t$RDFStore::Vocabulary::FOAF::interest = createResource($_[0], \"interest\");\n\t$RDFStore::Vocabulary::FOAF::topic_interest = createResource($_[0], \"topic_interest\");\n\t$RDFStore::Vocabulary::FOAF::publications = createResource($_[0], \"publications\");\n\t$RDFStore::Vocabulary::FOAF::currentProject = createResource($_[0], \"currentProject\");\n\t$RDFStore::Vocabulary::FOAF::pastProject = createResource($_[0], \"pastProject\");\n\t$RDFStore::Vocabulary::FOAF::fundedBy = createResource($_[0], \"fundedBy\");\n\t$RDFStore::Vocabulary::FOAF::logo = createResource($_[0], \"logo\");\n\t$RDFStore::Vocabulary::FOAF::topic = createResource($_[0], \"topic\");\n\t$RDFStore::Vocabulary::FOAF::primaryTopic = createResource($_[0], \"primaryTopic\");\n\t$RDFStore::Vocabulary::FOAF::theme = createResource($_[0], \"theme\");\n\t$RDFStore::Vocabulary::FOAF::holdsAccount = createResource($_[0], \"holdsAccount\");\n\t$RDFStore::Vocabulary::FOAF::accountServiceHomepage = createResource($_[0], \"accountServiceHomepage\");\n\t$RDFStore::Vocabulary::FOAF::accountName = createResource($_[0], \"accountName\");\n\t$RDFStore::Vocabulary::FOAF::member = createResource($_[0], \"member\");\n\t$RDFStore::Vocabulary::FOAF::membershipClass = createResource($_[0], \"membershipClass\");\n};\nsub END {\n\t$RDFStore::Vocabulary::FOAF::Person = undef;\n\t$RDFStore::Vocabulary::FOAF::Agent = undef;\n\t$RDFStore::Vocabulary::FOAF::Document = undef;\n\t$RDFStore::Vocabulary::FOAF::Organization = undef;\n\t$RDFStore::Vocabulary::FOAF::Project = undef;\n\t$RDFStore::Vocabulary::FOAF::Group = undef;\n\t$RDFStore::Vocabulary::FOAF::Image = undef;\n\t$RDFStore::Vocabulary::FOAF::PersonalProfileDocument = undef;\n\t$RDFStore::Vocabulary::FOAF::OnlineAccount = undef;\n\t$RDFStore::Vocabulary::FOAF::OnlineGamingAccount = undef;\n\t$RDFStore::Vocabulary::FOAF::OnlineEcommerceAccount = undef;\n\t$RDFStore::Vocabulary::FOAF::OnlineChatAccount = undef;\n\t$RDFStore::Vocabulary::FOAF::mbox = undef;\n\t$RDFStore::Vocabulary::FOAF::mbox_sha1sum = undef;\n\t$RDFStore::Vocabulary::FOAF::gender = undef;\n\t$RDFStore::Vocabulary::FOAF::geekcode = undef;\n\t$RDFStore::Vocabulary::FOAF::dnaChecksum = undef;\n\t$RDFStore::Vocabulary::FOAF::sha1 = undef;\n\t$RDFStore::Vocabulary::FOAF::based_near = undef;\n\t$RDFStore::Vocabulary::FOAF::title = undef;\n\t$RDFStore::Vocabulary::FOAF::nick = undef;\n\t$RDFStore::Vocabulary::FOAF::jabberID = undef;\n\t$RDFStore::Vocabulary::FOAF::aimChatID = undef;\n\t$RDFStore::Vocabulary::FOAF::icqChatID = undef;\n\t$RDFStore::Vocabulary::FOAF::yahooChatID = undef;\n\t$RDFStore::Vocabulary::FOAF::msnChatID = undef;\n\t$RDFStore::Vocabulary::FOAF::name = undef;\n\t$RDFStore::Vocabulary::FOAF::firstName = undef;\n\t$RDFStore::Vocabulary::FOAF::givenname = undef;\n\t$RDFStore::Vocabulary::FOAF::surname = undef;\n\t$RDFStore::Vocabulary::FOAF::family_name = undef;\n\t$RDFStore::Vocabulary::FOAF::phone = undef;\n\t$RDFStore::Vocabulary::FOAF::homepage = undef;\n\t$RDFStore::Vocabulary::FOAF::page = undef;\n\t$RDFStore::Vocabulary::FOAF::weblog = undef;\n\t$RDFStore::Vocabulary::FOAF::tipjar = undef;\n\t$RDFStore::Vocabulary::FOAF::plan = undef;\n\t$RDFStore::Vocabulary::FOAF::made = undef;\n\t$RDFStore::Vocabulary::FOAF::maker = undef;\n\t$RDFStore::Vocabulary::FOAF::img = undef;\n\t$RDFStore::Vocabulary::FOAF::depiction = undef;\n\t$RDFStore::Vocabulary::FOAF::depicts = undef;\n\t$RDFStore::Vocabulary::FOAF::thumbnail = undef;\n\t$RDFStore::Vocabulary::FOAF::myersBriggs = undef;\n\t$RDFStore::Vocabulary::FOAF::workplaceHomepage = undef;\n\t$RDFStore::Vocabulary::FOAF::workInfoHomepage = undef;\n\t$RDFStore::Vocabulary::FOAF::schoolHomepage = undef;\n\t$RDFStore::Vocabulary::FOAF::knows = undef;\n\t$RDFStore::Vocabulary::FOAF::interest = undef;\n\t$RDFStore::Vocabulary::FOAF::topic_interest = undef;\n\t$RDFStore::Vocabulary::FOAF::publications = undef;\n\t$RDFStore::Vocabulary::FOAF::currentProject = undef;\n\t$RDFStore::Vocabulary::FOAF::pastProject = undef;\n\t$RDFStore::Vocabulary::FOAF::fundedBy = undef;\n\t$RDFStore::Vocabulary::FOAF::logo = undef;\n\t$RDFStore::Vocabulary::FOAF::topic = undef;\n\t$RDFStore::Vocabulary::FOAF::primaryTopic = undef;\n\t$RDFStore::Vocabulary::FOAF::theme = undef;\n\t$RDFStore::Vocabulary::FOAF::holdsAccount = undef;\n\t$RDFStore::Vocabulary::FOAF::accountServiceHomepage = undef;\n\t$RDFStore::Vocabulary::FOAF::accountName = undef;\n\t$RDFStore::Vocabulary::FOAF::member = undef;\n\t$RDFStore::Vocabulary::FOAF::membershipClass = undef;\n};\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Vocabulary/FOAF.pm",
      "package" : "RDFStore::Vocabulary::FOAF"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ( $VERSION $Class $Datatype $Thing $Nothing $equivalentTo $Property $sameClassAs $samePropertyAs $sameIndividualAs $disjointWith $differentIndividualFrom $unionOf $List $disjointUnionOf $intersectionOf $complementOf $oneOf $Restriction $onProperty $toClass $hasValue $hasClass $minCardinality $maxCardinality $cardinality $hasClassQ $minCardinalityQ $maxCardinalityQ $cardinalityQ $ObjectProperty $DatatypeProperty $inverseOf $TransitiveProperty $UniqueProperty $UnambiguousProperty $nil $first $rest $item $Ontology $versionInfo $imports $subPropertyOf $Literal $type $value $subClassOf $domain $range $label $comment $seeAlso $isDefinedBy );\n$VERSION='0.41';\nuse strict;\nuse RDFStore::Model;\nuse Carp;\n\n\n$RDFStore::Vocabulary::DAML::_Namespace= \"http://www.daml.org/2001/03/daml+oil#\";\nuse RDFStore::NodeFactory;\n&setNodeFactory(new RDFStore::NodeFactory());\n\nsub createResource {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\n\treturn $_[0]->createResource($RDFStore::Vocabulary::DAML::_Namespace,$_[1]);\n};\nsub setNodeFactory {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\t$RDFStore::Vocabulary::DAML::Class = createResource($_[0], \"Class\");\n\t$RDFStore::Vocabulary::DAML::Datatype = createResource($_[0], \"Datatype\");\n\t$RDFStore::Vocabulary::DAML::Thing = createResource($_[0], \"Thing\");\n\t$RDFStore::Vocabulary::DAML::Nothing = createResource($_[0], \"Nothing\");\n\t$RDFStore::Vocabulary::DAML::equivalentTo = createResource($_[0], \"equivalentTo\");\n\t$RDFStore::Vocabulary::DAML::Property = createResource($_[0], \"Property\");\n\t$RDFStore::Vocabulary::DAML::sameClassAs = createResource($_[0], \"sameClassAs\");\n\t$RDFStore::Vocabulary::DAML::samePropertyAs = createResource($_[0], \"samePropertyAs\");\n\t$RDFStore::Vocabulary::DAML::sameIndividualAs = createResource($_[0], \"sameIndividualAs\");\n\t$RDFStore::Vocabulary::DAML::disjointWith = createResource($_[0], \"disjointWith\");\n\t$RDFStore::Vocabulary::DAML::differentIndividualFrom = createResource($_[0], \"differentIndividualFrom\");\n\t$RDFStore::Vocabulary::DAML::unionOf = createResource($_[0], \"unionOf\");\n\t$RDFStore::Vocabulary::DAML::List = createResource($_[0], \"List\");\n\t$RDFStore::Vocabulary::DAML::disjointUnionOf = createResource($_[0], \"disjointUnionOf\");\n\t$RDFStore::Vocabulary::DAML::intersectionOf = createResource($_[0], \"intersectionOf\");\n\t$RDFStore::Vocabulary::DAML::complementOf = createResource($_[0], \"complementOf\");\n\t$RDFStore::Vocabulary::DAML::oneOf = createResource($_[0], \"oneOf\");\n\t$RDFStore::Vocabulary::DAML::Restriction = createResource($_[0], \"Restriction\");\n\t$RDFStore::Vocabulary::DAML::onProperty = createResource($_[0], \"onProperty\");\n\t$RDFStore::Vocabulary::DAML::toClass = createResource($_[0], \"toClass\");\n\t$RDFStore::Vocabulary::DAML::hasValue = createResource($_[0], \"hasValue\");\n\t$RDFStore::Vocabulary::DAML::hasClass = createResource($_[0], \"hasClass\");\n\t$RDFStore::Vocabulary::DAML::minCardinality = createResource($_[0], \"minCardinality\");\n\t$RDFStore::Vocabulary::DAML::maxCardinality = createResource($_[0], \"maxCardinality\");\n\t$RDFStore::Vocabulary::DAML::cardinality = createResource($_[0], \"cardinality\");\n\t$RDFStore::Vocabulary::DAML::hasClassQ = createResource($_[0], \"hasClassQ\");\n\t$RDFStore::Vocabulary::DAML::minCardinalityQ = createResource($_[0], \"minCardinalityQ\");\n\t$RDFStore::Vocabulary::DAML::maxCardinalityQ = createResource($_[0], \"maxCardinalityQ\");\n\t$RDFStore::Vocabulary::DAML::cardinalityQ = createResource($_[0], \"cardinalityQ\");\n\t$RDFStore::Vocabulary::DAML::ObjectProperty = createResource($_[0], \"ObjectProperty\");\n\t$RDFStore::Vocabulary::DAML::DatatypeProperty = createResource($_[0], \"DatatypeProperty\");\n\t$RDFStore::Vocabulary::DAML::inverseOf = createResource($_[0], \"inverseOf\");\n\t$RDFStore::Vocabulary::DAML::TransitiveProperty = createResource($_[0], \"TransitiveProperty\");\n\t$RDFStore::Vocabulary::DAML::UniqueProperty = createResource($_[0], \"UniqueProperty\");\n\t$RDFStore::Vocabulary::DAML::UnambiguousProperty = createResource($_[0], \"UnambiguousProperty\");\n\t$RDFStore::Vocabulary::DAML::nil = createResource($_[0], \"nil\");\n\t$RDFStore::Vocabulary::DAML::first = createResource($_[0], \"first\");\n\t$RDFStore::Vocabulary::DAML::rest = createResource($_[0], \"rest\");\n\t$RDFStore::Vocabulary::DAML::item = createResource($_[0], \"item\");\n\t$RDFStore::Vocabulary::DAML::Ontology = createResource($_[0], \"Ontology\");\n\t$RDFStore::Vocabulary::DAML::versionInfo = createResource($_[0], \"versionInfo\");\n\t$RDFStore::Vocabulary::DAML::imports = createResource($_[0], \"imports\");\n\t$RDFStore::Vocabulary::DAML::subPropertyOf = createResource($_[0], \"subPropertyOf\");\n\t$RDFStore::Vocabulary::DAML::Literal = createResource($_[0], \"Literal\");\n\t$RDFStore::Vocabulary::DAML::type = createResource($_[0], \"type\");\n\t$RDFStore::Vocabulary::DAML::value = createResource($_[0], \"value\");\n\t$RDFStore::Vocabulary::DAML::subClassOf = createResource($_[0], \"subClassOf\");\n\t$RDFStore::Vocabulary::DAML::domain = createResource($_[0], \"domain\");\n\t$RDFStore::Vocabulary::DAML::range = createResource($_[0], \"range\");\n\t$RDFStore::Vocabulary::DAML::label = createResource($_[0], \"label\");\n\t$RDFStore::Vocabulary::DAML::comment = createResource($_[0], \"comment\");\n\t$RDFStore::Vocabulary::DAML::seeAlso = createResource($_[0], \"seeAlso\");\n\t$RDFStore::Vocabulary::DAML::isDefinedBy = createResource($_[0], \"isDefinedBy\");\n};\nsub END {\n\t$RDFStore::Vocabulary::DAML::Class = undef;\n\t$RDFStore::Vocabulary::DAML::Datatype = undef;\n\t$RDFStore::Vocabulary::DAML::Thing = undef;\n\t$RDFStore::Vocabulary::DAML::Nothing = undef;\n\t$RDFStore::Vocabulary::DAML::equivalentTo = undef;\n\t$RDFStore::Vocabulary::DAML::Property = undef;\n\t$RDFStore::Vocabulary::DAML::sameClassAs = undef;\n\t$RDFStore::Vocabulary::DAML::samePropertyAs = undef;\n\t$RDFStore::Vocabulary::DAML::sameIndividualAs = undef;\n\t$RDFStore::Vocabulary::DAML::disjointWith = undef;\n\t$RDFStore::Vocabulary::DAML::differentIndividualFrom = undef;\n\t$RDFStore::Vocabulary::DAML::unionOf = undef;\n\t$RDFStore::Vocabulary::DAML::List = undef;\n\t$RDFStore::Vocabulary::DAML::disjointUnionOf = undef;\n\t$RDFStore::Vocabulary::DAML::intersectionOf = undef;\n\t$RDFStore::Vocabulary::DAML::complementOf = undef;\n\t$RDFStore::Vocabulary::DAML::oneOf = undef;\n\t$RDFStore::Vocabulary::DAML::Restriction = undef;\n\t$RDFStore::Vocabulary::DAML::onProperty = undef;\n\t$RDFStore::Vocabulary::DAML::toClass = undef;\n\t$RDFStore::Vocabulary::DAML::hasValue = undef;\n\t$RDFStore::Vocabulary::DAML::hasClass = undef;\n\t$RDFStore::Vocabulary::DAML::minCardinality = undef;\n\t$RDFStore::Vocabulary::DAML::maxCardinality = undef;\n\t$RDFStore::Vocabulary::DAML::cardinality = undef;\n\t$RDFStore::Vocabulary::DAML::hasClassQ = undef;\n\t$RDFStore::Vocabulary::DAML::minCardinalityQ = undef;\n\t$RDFStore::Vocabulary::DAML::maxCardinalityQ = undef;\n\t$RDFStore::Vocabulary::DAML::cardinalityQ = undef;\n\t$RDFStore::Vocabulary::DAML::ObjectProperty = undef;\n\t$RDFStore::Vocabulary::DAML::DatatypeProperty = undef;\n\t$RDFStore::Vocabulary::DAML::inverseOf = undef;\n\t$RDFStore::Vocabulary::DAML::TransitiveProperty = undef;\n\t$RDFStore::Vocabulary::DAML::UniqueProperty = undef;\n\t$RDFStore::Vocabulary::DAML::UnambiguousProperty = undef;\n\t$RDFStore::Vocabulary::DAML::nil = undef;\n\t$RDFStore::Vocabulary::DAML::first = undef;\n\t$RDFStore::Vocabulary::DAML::rest = undef;\n\t$RDFStore::Vocabulary::DAML::item = undef;\n\t$RDFStore::Vocabulary::DAML::Ontology = undef;\n\t$RDFStore::Vocabulary::DAML::versionInfo = undef;\n\t$RDFStore::Vocabulary::DAML::imports = undef;\n\t$RDFStore::Vocabulary::DAML::subPropertyOf = undef;\n\t$RDFStore::Vocabulary::DAML::Literal = undef;\n\t$RDFStore::Vocabulary::DAML::type = undef;\n\t$RDFStore::Vocabulary::DAML::value = undef;\n\t$RDFStore::Vocabulary::DAML::subClassOf = undef;\n\t$RDFStore::Vocabulary::DAML::domain = undef;\n\t$RDFStore::Vocabulary::DAML::range = undef;\n\t$RDFStore::Vocabulary::DAML::label = undef;\n\t$RDFStore::Vocabulary::DAML::comment = undef;\n\t$RDFStore::Vocabulary::DAML::seeAlso = undef;\n\t$RDFStore::Vocabulary::DAML::isDefinedBy = undef;\n};\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Vocabulary/DAML.pm",
      "package" : "RDFStore::Vocabulary::DAML"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.41';\nuse Carp;\n\nuse RDFStore::Vocabulary::RDFS;\nuse RDFStore::Vocabulary::DC;\nuse RDFStore::Vocabulary::DAML;\n\nsub new {\n\tmy ($pkg) = @_;\n\n    \tmy $self = {};\n\n\t$self->{LICENSE} = qq|# *\n# *     Copyright (c) 2000-2004 Alberto Reggiori <areggiori\\@webweaving.org>\n# *                        Dirk-Willem van Gulik <dirkx\\@webweaving.org>\n# *\n# * NOTICE\n# *\n# * This product is distributed under a BSD/ASF like license as described in the 'LICENSE'\n# * file you should have received together with this source code. If you did not get a\n# * a copy of such a license agreement you can pick up one at:\n# *\n# *     http://rdfstore.sourceforge.net/LICENSE\n# *\n|;\n\t$self->{DEFAULT_PACKAGE_CLASS} = \"UnspecifiedClass\";\n\t$self->{NS_IMPORT} = \"use RDFStore::Model;\\nuse Carp;\\n\";\n\t$self->{DEFAULT_NODE_FACTORY} = \"RDFStore::NodeFactory\";\n\t$self->{NS_COMMENT} = \"# \\n\" .\n\t\t\"# This package provides convenient access to schema information.\\n\".\n\t\t\"# DO NOT MODIFY THIS FILE.\\n\".\n\t\t\"# It was generated automatically by RDFStore::Vocabulary::Generator\\n#\\n\";\n\t$self->{NS_NSDEF} = \"# Namespace URI of this schema\";\n\t$self->{NS_ID} = \"_Namespace\";\n\n\t$self->{reservedWords}=[\"package\",\"use\",\"require\",\"BEGIN\",\"END\",\"sub\",\"my\",\"local\",$self->{NS_ID}];\n\n    \tbless $self,$pkg;\n};\n\nsub createVocabulary {\n\tcroak \"Model \".$_[2].\" is not an instance of RDFStore::Model\"\n\t\tunless( (defined $_[2]) &&\n                \t(ref($_[2])) && ($_[2]->isa(\"RDFStore::Model\")) );\n\n\tmy $packageName = '';\n\tmy $className = '';\n\n\t$_[5] = $_[0]->{DEFAULT_NODE_FACTORY}\n\t\tunless(defined $_[5]);\n\n\tif($_[1] =~ /::/) {\n\t\tmy @info = split(\"::\",$_[1]);\n\t\t$className = pop @info;\n\t\t$packageName = join(\"::\",@info);\n\t} else {\n\t\t$packageName = $_[1];\n\t\t$className = $packageName;\n\t};\n\n\tprint \"Creating interface \" . $className . \" within package \". $packageName .  ( (defined $_[4]) ? \" in \". $_[4] : \"\"),\"\\n\";\n\n\tmy $packageDirectory;\n\tif(!(defined $_[4])) {\n\t\t$packageDirectory=undef;\n\t} else {\n\t\t$packageName = \"\"\n\t\t\tif(!(defined $packageName));\n\n\t\tcroak \"Invalid output directory: \".$_[4]\n\t\t\tunless(-d $_[4]);\n\n\t\t$packageDirectory = $packageName;\n\t\t$packageDirectory = ''\n\t\t\tunless($packageDirectory =~ s/\\:\\:/\\//g);\n\t\t$packageDirectory = $_[4].$packageDirectory;\n\t\t`mkdir -p $packageDirectory`;\n\t};\n    \n\tmy $out;\n\tif( defined $_[4] ) {\n\t\topen(OUT,\">\".$packageDirectory.\"/\".$className.\".pm\");\n\t\t$out=*OUT;\n\t} else {\n\t\t$out = *STDOUT;\n\t};\n\n\t$_[0]->dumpVocabulary( $out, ($packageName eq $className) ? $packageName : $packageName.'::'.$className , $className, $_[2], $_[3], $_[5] );\n\tclose($out);\n};\n\nsub toPerlName {\n\tmy $reserved=0;\n\tmap { $reserved=1 if($_ eq $_[1]); } @{$_[0]->{reservedWords}};\n\treturn \"_\".$_[1]\n\t\tif($reserved);\n\n\t$_[1] =~ s/[\\+\\-\\.]/_/g;\n\t$_[1] =~ s/^\\d(.*)/_$1/g;\n\treturn $_[1];\n};\n\nsub dumpVocabulary {\n\tmy @els;\n\tmy ($ee) = $_[4]->elements;\n\tfor ( my $e = $ee->first; $ee->hasnext; $e= $ee->next ) {\n\t\tpush @els,$e->subject();\n\t\tpush @els,$e->object()\n\t\t\tif($e->object->isa(\"RDFStore::Resource\"));\n\t};\n\n        my $r1;\n        my @v1;\n        my @pname;\n        my $ns_match = $_[5];\n        $ns_match =~ s/\\+/\\\\\\+/g;\n        foreach $r1 ( @els ) {\n                my $res = $r1->toString();\n                if($res =~ /^$ns_match/) {\n                        my $name=substr($res,length($_[5]));\n                        if(length($name) > 0) { \n                                my $isthere=0;\n                                map { $isthere=1 if($_ eq $name); } @v1;\n                                unless($isthere) {\n\t\t\t\t\tpush @v1,$name;\n        \t\t\t\tpush @pname,'$'.$_[0]->toPerlName($name);\n\t\t\t\t};\n                \t};\n        \t};\n        };\n\n\tmy $out=$_[1]; \n\tprint $out $_[0]->{LICENSE},\"\\n\";\n\tprint $out \"package \".$_[2].\";\\n{\\n\";\n\tprint $out \"use vars qw ( \\$VERSION \".join(\" \",@pname).\" );\\n\\$VERSION='$VERSION';\\nuse strict;\\n\";\n\tprint $out $_[0]->{NS_IMPORT},\"\\n\";\n\tprint $out $_[0]->{NS_COMMENT},\"\\n\";\n\tprint $out $_[0]->{NS_NSDEF},\"\\n\";\n\tprint $out '$'.$_[2].'::'.$_[0]->{NS_ID}.'= \"'.$_[5].'\";'.\"\\n\";\n\tprint $out \"use $_[6];\\n\";\n\tprint $out '&setNodeFactory(new '.$_[6].\"());\\n\";\n\n\tprint $out '\nsub createResource {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\n\treturn $_[0]->createResource($'.$_[2].'::_Namespace,$_[1]);\n};\nsub setNodeFactory {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n';\n\n\n        my $r;\n        my @v;\n\tmy $destructors='';\n\tforeach $r ( @els ) {\n\t\tmy $res = $r->toString();\n\t\tif($res =~ /^$ns_match/) {\n\t\t\tmy $name=substr($res,length($_[5]));\n\t\t\tif(length($name) > 0) { \n\t\t\t\tmy $isthere=0;\n\t\t\t\tmap { $isthere=1 if($_ eq $name); } @v;\n\t\t\t\tunless($isthere) {\n\t\t\t\t\tpush @v,$name;\n\t\t\t\t\tmy $pname = $_[0]->toPerlName($name);\n\t\t\t\t\tmy $tComment = $_[4]->find($r, $RDFStore::Vocabulary::RDFS::comment, undef )->elements->first;\n\t\t\t\t\t$tComment= $_[4]->find($r, $RDFStore::Vocabulary::DAML::comment, undef )->elements->first\n\t\t\t\t\t\tunless(\t(defined $tComment) &&\n\t\t\t\t\t\t\t(ref($tComment)) &&\n\t\t\t\t\t\t\t($tComment->isa(\"RDFStore::Statement\")) );\n\t\t\t\t\t$tComment = $_[4]->find($r, $RDFStore::Vocabulary::DC::description, undef )->elements->first\n\t\t\t\t\t\tunless(\t(defined $tComment) &&\n\t\t\t\t\t\t\t(ref($tComment)) &&\n\t\t\t\t\t\t\t($tComment->isa(\"RDFStore::Statement\")) );\n\t\t\t\t\tif(defined $tComment) {\n\t\t\t\t\t\t$tComment = $tComment->object->toString;\n\t\t\t\t\t\t$tComment =~ s/\\s/ /g;\n\t\t\t\t\t\tprint $out \"\\t# $tComment\\n\";\n          \t\t\t\t};\n\t\t\t\t\tprint $out \"\\t\\$$_[2]::\".$pname.' = createResource($_[0], \"'.$name.\"\\\");\\n\";\n\t\t\t\t\t$destructors .= \"\\t\\$$_[2]::\".$pname.\" = undef;\\n\";\n\t\t\t\t};\n          \t\t};\n        \t};\n        };\n\tprint $out \"};\\n\";\n\tprint $out \"sub END {\\n\";\n\tprint $out $destructors;\n\tprint $out \"};\\n1;\\n};\";\n};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Vocabulary/Generator.pm",
      "package" : "RDFStore::Vocabulary::Generator"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ( $VERSION $audience $alternative $tableOfContents $abstract $created $valid $available $issued $modified $extent $medium $isVersionOf $hasVersion $isReplacedBy $replaces $isRequiredBy $requires $isPartOf $hasPart $isReferencedBy $references $isFormatOf $hasFormat $conformsTo $spatial $temporal $mediator $dateAccepted $dateCopyrighted $dateSubmitted $educationLevel $accessRights $bibliographicCitation $license $rightsHolder $SubjectScheme $DateScheme $FormatScheme $LanguageScheme $SpatialScheme $TemporalScheme $TypeScheme $IdentifierScheme $RelationScheme $SourceScheme $LCSH $MESH $DDC $LCC $UDC $DCMIType $IMT $ISO639_2 $RFC1766 $URI $Point $ISO3166 $Box $TGN $Period $W3CDTF $RFC3066 );\n$VERSION='0.41';\nuse strict;\nuse RDFStore::Model;\nuse Carp;\n\n\n$RDFStore::Vocabulary::DCQ::_Namespace= \"http://purl.org/dc/terms/\";\nuse RDFStore::NodeFactory;\n&setNodeFactory(new RDFStore::NodeFactory());\n\nsub createResource {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\n\treturn $_[0]->createResource($RDFStore::Vocabulary::DCQ::_Namespace,$_[1]);\n};\nsub setNodeFactory {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\t$RDFStore::Vocabulary::DCQ::audience = createResource($_[0], \"audience\");\n\t$RDFStore::Vocabulary::DCQ::alternative = createResource($_[0], \"alternative\");\n\t$RDFStore::Vocabulary::DCQ::tableOfContents = createResource($_[0], \"tableOfContents\");\n\t$RDFStore::Vocabulary::DCQ::abstract = createResource($_[0], \"abstract\");\n\t$RDFStore::Vocabulary::DCQ::created = createResource($_[0], \"created\");\n\t$RDFStore::Vocabulary::DCQ::valid = createResource($_[0], \"valid\");\n\t$RDFStore::Vocabulary::DCQ::available = createResource($_[0], \"available\");\n\t$RDFStore::Vocabulary::DCQ::issued = createResource($_[0], \"issued\");\n\t$RDFStore::Vocabulary::DCQ::modified = createResource($_[0], \"modified\");\n\t$RDFStore::Vocabulary::DCQ::extent = createResource($_[0], \"extent\");\n\t$RDFStore::Vocabulary::DCQ::medium = createResource($_[0], \"medium\");\n\t$RDFStore::Vocabulary::DCQ::isVersionOf = createResource($_[0], \"isVersionOf\");\n\t$RDFStore::Vocabulary::DCQ::hasVersion = createResource($_[0], \"hasVersion\");\n\t$RDFStore::Vocabulary::DCQ::isReplacedBy = createResource($_[0], \"isReplacedBy\");\n\t$RDFStore::Vocabulary::DCQ::replaces = createResource($_[0], \"replaces\");\n\t$RDFStore::Vocabulary::DCQ::isRequiredBy = createResource($_[0], \"isRequiredBy\");\n\t$RDFStore::Vocabulary::DCQ::requires = createResource($_[0], \"requires\");\n\t$RDFStore::Vocabulary::DCQ::isPartOf = createResource($_[0], \"isPartOf\");\n\t$RDFStore::Vocabulary::DCQ::hasPart = createResource($_[0], \"hasPart\");\n\t$RDFStore::Vocabulary::DCQ::isReferencedBy = createResource($_[0], \"isReferencedBy\");\n\t$RDFStore::Vocabulary::DCQ::references = createResource($_[0], \"references\");\n\t$RDFStore::Vocabulary::DCQ::isFormatOf = createResource($_[0], \"isFormatOf\");\n\t$RDFStore::Vocabulary::DCQ::hasFormat = createResource($_[0], \"hasFormat\");\n\t$RDFStore::Vocabulary::DCQ::conformsTo = createResource($_[0], \"conformsTo\");\n\t$RDFStore::Vocabulary::DCQ::spatial = createResource($_[0], \"spatial\");\n\t$RDFStore::Vocabulary::DCQ::temporal = createResource($_[0], \"temporal\");\n\t$RDFStore::Vocabulary::DCQ::mediator = createResource($_[0], \"mediator\");\n\t$RDFStore::Vocabulary::DCQ::dateAccepted = createResource($_[0], \"dateAccepted\");\n\t$RDFStore::Vocabulary::DCQ::dateCopyrighted = createResource($_[0], \"dateCopyrighted\");\n\t$RDFStore::Vocabulary::DCQ::dateSubmitted = createResource($_[0], \"dateSubmitted\");\n\t$RDFStore::Vocabulary::DCQ::educationLevel = createResource($_[0], \"educationLevel\");\n\t$RDFStore::Vocabulary::DCQ::accessRights = createResource($_[0], \"accessRights\");\n\t$RDFStore::Vocabulary::DCQ::bibliographicCitation = createResource($_[0], \"bibliographicCitation\");\n\t$RDFStore::Vocabulary::DCQ::license = createResource($_[0], \"license\");\n\t$RDFStore::Vocabulary::DCQ::rightsHolder = createResource($_[0], \"rightsHolder\");\n\t$RDFStore::Vocabulary::DCQ::SubjectScheme = createResource($_[0], \"SubjectScheme\");\n\t$RDFStore::Vocabulary::DCQ::DateScheme = createResource($_[0], \"DateScheme\");\n\t$RDFStore::Vocabulary::DCQ::FormatScheme = createResource($_[0], \"FormatScheme\");\n\t$RDFStore::Vocabulary::DCQ::LanguageScheme = createResource($_[0], \"LanguageScheme\");\n\t$RDFStore::Vocabulary::DCQ::SpatialScheme = createResource($_[0], \"SpatialScheme\");\n\t$RDFStore::Vocabulary::DCQ::TemporalScheme = createResource($_[0], \"TemporalScheme\");\n\t$RDFStore::Vocabulary::DCQ::TypeScheme = createResource($_[0], \"TypeScheme\");\n\t$RDFStore::Vocabulary::DCQ::IdentifierScheme = createResource($_[0], \"IdentifierScheme\");\n\t$RDFStore::Vocabulary::DCQ::RelationScheme = createResource($_[0], \"RelationScheme\");\n\t$RDFStore::Vocabulary::DCQ::SourceScheme = createResource($_[0], \"SourceScheme\");\n\t$RDFStore::Vocabulary::DCQ::LCSH = createResource($_[0], \"LCSH\");\n\t$RDFStore::Vocabulary::DCQ::MESH = createResource($_[0], \"MESH\");\n\t$RDFStore::Vocabulary::DCQ::DDC = createResource($_[0], \"DDC\");\n\t$RDFStore::Vocabulary::DCQ::LCC = createResource($_[0], \"LCC\");\n\t$RDFStore::Vocabulary::DCQ::UDC = createResource($_[0], \"UDC\");\n\t$RDFStore::Vocabulary::DCQ::DCMIType = createResource($_[0], \"DCMIType\");\n\t$RDFStore::Vocabulary::DCQ::IMT = createResource($_[0], \"IMT\");\n\t$RDFStore::Vocabulary::DCQ::ISO639_2 = createResource($_[0], \"ISO639_2\");\n\t$RDFStore::Vocabulary::DCQ::RFC1766 = createResource($_[0], \"RFC1766\");\n\t$RDFStore::Vocabulary::DCQ::URI = createResource($_[0], \"URI\");\n\t$RDFStore::Vocabulary::DCQ::Point = createResource($_[0], \"Point\");\n\t$RDFStore::Vocabulary::DCQ::ISO3166 = createResource($_[0], \"ISO3166\");\n\t$RDFStore::Vocabulary::DCQ::Box = createResource($_[0], \"Box\");\n\t$RDFStore::Vocabulary::DCQ::TGN = createResource($_[0], \"TGN\");\n\t$RDFStore::Vocabulary::DCQ::Period = createResource($_[0], \"Period\");\n\t$RDFStore::Vocabulary::DCQ::W3CDTF = createResource($_[0], \"W3CDTF\");\n\t$RDFStore::Vocabulary::DCQ::RFC3066 = createResource($_[0], \"RFC3066\");\n};\nsub END {\n\t$RDFStore::Vocabulary::DCQ::audience = undef;\n\t$RDFStore::Vocabulary::DCQ::alternative = undef;\n\t$RDFStore::Vocabulary::DCQ::tableOfContents = undef;\n\t$RDFStore::Vocabulary::DCQ::abstract = undef;\n\t$RDFStore::Vocabulary::DCQ::created = undef;\n\t$RDFStore::Vocabulary::DCQ::valid = undef;\n\t$RDFStore::Vocabulary::DCQ::available = undef;\n\t$RDFStore::Vocabulary::DCQ::issued = undef;\n\t$RDFStore::Vocabulary::DCQ::modified = undef;\n\t$RDFStore::Vocabulary::DCQ::extent = undef;\n\t$RDFStore::Vocabulary::DCQ::medium = undef;\n\t$RDFStore::Vocabulary::DCQ::isVersionOf = undef;\n\t$RDFStore::Vocabulary::DCQ::hasVersion = undef;\n\t$RDFStore::Vocabulary::DCQ::isReplacedBy = undef;\n\t$RDFStore::Vocabulary::DCQ::replaces = undef;\n\t$RDFStore::Vocabulary::DCQ::isRequiredBy = undef;\n\t$RDFStore::Vocabulary::DCQ::requires = undef;\n\t$RDFStore::Vocabulary::DCQ::isPartOf = undef;\n\t$RDFStore::Vocabulary::DCQ::hasPart = undef;\n\t$RDFStore::Vocabulary::DCQ::isReferencedBy = undef;\n\t$RDFStore::Vocabulary::DCQ::references = undef;\n\t$RDFStore::Vocabulary::DCQ::isFormatOf = undef;\n\t$RDFStore::Vocabulary::DCQ::hasFormat = undef;\n\t$RDFStore::Vocabulary::DCQ::conformsTo = undef;\n\t$RDFStore::Vocabulary::DCQ::spatial = undef;\n\t$RDFStore::Vocabulary::DCQ::temporal = undef;\n\t$RDFStore::Vocabulary::DCQ::mediator = undef;\n\t$RDFStore::Vocabulary::DCQ::dateAccepted = undef;\n\t$RDFStore::Vocabulary::DCQ::dateCopyrighted = undef;\n\t$RDFStore::Vocabulary::DCQ::dateSubmitted = undef;\n\t$RDFStore::Vocabulary::DCQ::educationLevel = undef;\n\t$RDFStore::Vocabulary::DCQ::accessRights = undef;\n\t$RDFStore::Vocabulary::DCQ::bibliographicCitation = undef;\n\t$RDFStore::Vocabulary::DCQ::license = undef;\n\t$RDFStore::Vocabulary::DCQ::rightsHolder = undef;\n\t$RDFStore::Vocabulary::DCQ::SubjectScheme = undef;\n\t$RDFStore::Vocabulary::DCQ::DateScheme = undef;\n\t$RDFStore::Vocabulary::DCQ::FormatScheme = undef;\n\t$RDFStore::Vocabulary::DCQ::LanguageScheme = undef;\n\t$RDFStore::Vocabulary::DCQ::SpatialScheme = undef;\n\t$RDFStore::Vocabulary::DCQ::TemporalScheme = undef;\n\t$RDFStore::Vocabulary::DCQ::TypeScheme = undef;\n\t$RDFStore::Vocabulary::DCQ::IdentifierScheme = undef;\n\t$RDFStore::Vocabulary::DCQ::RelationScheme = undef;\n\t$RDFStore::Vocabulary::DCQ::SourceScheme = undef;\n\t$RDFStore::Vocabulary::DCQ::LCSH = undef;\n\t$RDFStore::Vocabulary::DCQ::MESH = undef;\n\t$RDFStore::Vocabulary::DCQ::DDC = undef;\n\t$RDFStore::Vocabulary::DCQ::LCC = undef;\n\t$RDFStore::Vocabulary::DCQ::UDC = undef;\n\t$RDFStore::Vocabulary::DCQ::DCMIType = undef;\n\t$RDFStore::Vocabulary::DCQ::IMT = undef;\n\t$RDFStore::Vocabulary::DCQ::ISO639_2 = undef;\n\t$RDFStore::Vocabulary::DCQ::RFC1766 = undef;\n\t$RDFStore::Vocabulary::DCQ::URI = undef;\n\t$RDFStore::Vocabulary::DCQ::Point = undef;\n\t$RDFStore::Vocabulary::DCQ::ISO3166 = undef;\n\t$RDFStore::Vocabulary::DCQ::Box = undef;\n\t$RDFStore::Vocabulary::DCQ::TGN = undef;\n\t$RDFStore::Vocabulary::DCQ::Period = undef;\n\t$RDFStore::Vocabulary::DCQ::W3CDTF = undef;\n\t$RDFStore::Vocabulary::DCQ::RFC3066 = undef;\n};\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Vocabulary/DCQ.pm",
      "package" : "RDFStore::Vocabulary::DCQ"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ( $VERSION $type $Property $Statement $subject $predicate $object $Bag $Seq $Alt $value $List $nil $first $rest $XMLLiteral );\n$VERSION='0.41';\nuse strict;\nuse RDFStore::Model;\nuse Carp;\n\n\n$RDFStore::Vocabulary::RDF::_Namespace= \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\nuse RDFStore::NodeFactory;\n&setNodeFactory(new RDFStore::NodeFactory());\n\nsub createResource {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\n\treturn $_[0]->createResource($RDFStore::Vocabulary::RDF::_Namespace,$_[1]);\n};\nsub setNodeFactory {\n\tcroak \"Factory \".$_[0].\" is not an instance of RDFStore::NodeFactory\"\n\t\tunless( (defined $_[0]) &&\n                \t( (ref($_[0])) && ($_[0]->isa(\"RDFStore::NodeFactory\")) ) );\n\t$RDFStore::Vocabulary::RDF::type = createResource($_[0], \"type\");\n\t$RDFStore::Vocabulary::RDF::Property = createResource($_[0], \"Property\");\n\t$RDFStore::Vocabulary::RDF::Statement = createResource($_[0], \"Statement\");\n\t$RDFStore::Vocabulary::RDF::subject = createResource($_[0], \"subject\");\n\t$RDFStore::Vocabulary::RDF::predicate = createResource($_[0], \"predicate\");\n\t$RDFStore::Vocabulary::RDF::object = createResource($_[0], \"object\");\n\t$RDFStore::Vocabulary::RDF::Bag = createResource($_[0], \"Bag\");\n\t$RDFStore::Vocabulary::RDF::Seq = createResource($_[0], \"Seq\");\n\t$RDFStore::Vocabulary::RDF::Alt = createResource($_[0], \"Alt\");\n\t$RDFStore::Vocabulary::RDF::value = createResource($_[0], \"value\");\n\t$RDFStore::Vocabulary::RDF::List = createResource($_[0], \"List\");\n\t$RDFStore::Vocabulary::RDF::nil = createResource($_[0], \"nil\");\n\t$RDFStore::Vocabulary::RDF::first = createResource($_[0], \"first\");\n\t$RDFStore::Vocabulary::RDF::rest = createResource($_[0], \"rest\");\n\t$RDFStore::Vocabulary::RDF::XMLLiteral = createResource($_[0], \"XMLLiteral\");\n};\nsub END {\n\t$RDFStore::Vocabulary::RDF::type = undef;\n\t$RDFStore::Vocabulary::RDF::Property = undef;\n\t$RDFStore::Vocabulary::RDF::Statement = undef;\n\t$RDFStore::Vocabulary::RDF::subject = undef;\n\t$RDFStore::Vocabulary::RDF::predicate = undef;\n\t$RDFStore::Vocabulary::RDF::object = undef;\n\t$RDFStore::Vocabulary::RDF::Bag = undef;\n\t$RDFStore::Vocabulary::RDF::Seq = undef;\n\t$RDFStore::Vocabulary::RDF::Alt = undef;\n\t$RDFStore::Vocabulary::RDF::value = undef;\n\t$RDFStore::Vocabulary::RDF::List = undef;\n\t$RDFStore::Vocabulary::RDF::nil = undef;\n\t$RDFStore::Vocabulary::RDF::first = undef;\n\t$RDFStore::Vocabulary::RDF::rest = undef;\n\t$RDFStore::Vocabulary::RDF::XMLLiteral = undef;\n};\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Vocabulary/RDF.pm",
      "package" : "RDFStore::Vocabulary::RDF"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.2';\n\nuse Carp;\n\nuse RDFStore::Serializer;\nuse RDFStore::Vocabulary::RSS;\n\n@RDFStore::Serializer::RDFStore::Vocabulary::RSS::ISA = qw( RDFStore::Serializer );\n\nsub new {\n\tmy ($pkg) = shift;\n\n\tmy $self = $pkg->SUPER::new(@_);\n\n\t$self->setNamespacePrefix( $RDFStore::Vocabulary::RSS::_Namespace ) = 'rss';\n\n\tbless $self,$pkg;\n\t};\n\nsub write {\n\tmy ($class, $model, $fh, $namespaces, $base ) = @_;\n\n\t$model = $class->{'model'}\n                unless($model);\n\n\tmy $ctx = $model->getContext();\n\t$model->resetContext();\n\n\t$class->SUPER::write( $model, $fh, $namespaces );\n\n        $class->{subjects_done} = {};\n\n        $class->printContent( \"<\" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":RDF\" );\n        $class->printContent( \"\\n\\txmlns:\" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \"='\". $RDFStore::Vocabulary::RDF::_Namespace . \"'\");\n\n        $class->printContent( \"\\n\\txmlns:\" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDFStoreContext::_Namespace) . \"='\". $RDFStore::Vocabulary::RDFStoreContext::_Namespace . \"'\");\n\n        $class->printContent( \"\\n\\txml:base='$base'\")\n\t\tif(\t(defined $base) &&\n\t\t\t($base ne '') );\n\n        my $cc=0;\n\tforeach my $ns ( $model->namespaces ) {\n\t\tnext\n\t\t\tif( $ns eq $RDFStore::Vocabulary::RDF::_Namespace );\n\n\t\t$class->setNamespacePrefix( $ns, 'voc'.($cc++) )\n\t\t\tunless( $class->getNamespacePrefix( $ns ) );\n\n        \t$class->printContent( \"\\n\\txmlns:\" . $class->getNamespacePrefix($ns) . \"='\". $ns . \"'\");\n                };\n        $class->printContent( \">\");\n\n\tmy $itr = $model->elements;\n\twhile ( my $st = $itr->each ) {\n                $class->_processDescription( $model, $st );\n                };\n\n\t$class->printContent( \"\\n</\" .    $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":RDF>\" );\n\n        $class->{subjects_done} = {};\n\n        $model->setContext( $ctx )\n\t\tif($ctx);\n\n        return $class->returnContent;\n\t};\n\nsub _processDescription {\n\tmy ($class, $model, $statement ) = @_;\n\n\tmy $context = $statement->context;\n        my $ctx = $context->toString\n\t\tif($context);\n\n\treturn\n                if(exists $class->{subjects_done}->{ $statement->subject->toString . $ctx });\n\n        $class->{subjects_done}->{ $statement->subject->toString . $ctx } = 1; \n\n        my $itr = $model->find( $statement->subject, undef, undef, $context )->elements;\n\n        return\n                unless($itr->size > 0 );\n\n        $class->printContent( \"\\n<\" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":Description \" );\n        if ( $statement->subject->isbNode ) {\n                $class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":nodeID='\" . $statement->subject->getLabel );\n        } else {\n                $class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":about='\" . $class->xml_escape( $statement->subject->getURI,\"'\" ) );\n                };\n\tif ( $context ) {\n        \tif ( $context->isbNode ) {\n                \t$class->printContent( \"' \" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDFStoreContext::_Namespace) . \":contextnodeID='\" . $context->getLabel );\n        \t} else {\n                \t$class->printContent( \"' \" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDFStoreContext::_Namespace) . \":context='\" . $class->xml_escape( $context->getURI,\"'\" ) );\n                \t};\n\t\t};\n        $class->printContent(\"'>\");\n\t\n\tif (\t($statement->subject->isa(\"RDFStore::Statement\")) &&\n\t\t(! $model->contains( $statement->subject) ) ) { \n\t\t$class->printContent( \"\\n\\t<\" .     $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":type \" .\n                                                $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":resource='\".$RDFStore::Vocabulary::RDF::_Namespace .\"Statement' />\");\n\n                $class->printContent( \"\\n\\t<\" .   $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":subject \");\n\t\tif ( $statement->subject->subject->isbNode ) {\n                \t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":nodeID='\" . $statement->subject->subject->getLabel );\n        \t} else {\n                \t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":resource='\" . $class->xml_escape( $statement->subject->subject->getURI,\"'\" ) );\n                \t};\n                $class->printContent( \"' />\");\n                $class->printContent( \"\\n\\t<\" .   $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":predicate \");\n                $class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":resource='\" . $class->xml_escape( $statement->subject->predicate->getURI,\"'\" ) . \"' />\" );\n\n                $class->printContent( \"\\n\\t<\" .   $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":object \");\n\t\tif( $statement->subject->object->isa(\"RDFStore::Resource\") ) {\n\t\t\tif ( $statement->subject->object->isbNode ) {\n                \t\t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":nodeID='\" . $statement->subject->object->getLabel );\n        \t\t} else {\n                \t\t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":resource='\" . $class->xml_escape( $statement->subject->object->getURI,\"'\" ) );\n                \t\t};\n                \t$class->printContent( \"' />\");\n                } else {\n        \t\t$class->printContent( \"xml:lang='\" . $statement->subject->object->getLang . \"'\")\n\t\t\t\tif($statement->subject->object->getLang);\n\t\t\t$class->printContent( \" rdf:datatype='\" . $statement->object->getDataType . \"'\")\n                                if($statement->object->getDataType);\n\t\t\tif($statement->subject->object->getParseType) {\n        \t\t\t$class->printContent( \" \" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":parseType='Literal'>\");\n        \t\t\t$class->printContent( $statement->subject->object->getLabel );\n\t\t\t} else {\n\t\t\t\t$class->printContent( \" rdf:datatype='\" . $statement->subject->object->getDataType . \"'\")\n\t\t\t\t\tif($statement->subject->object->getDataType);\n        \t\t\t$class->printContent( \">\" . $class->xml_escape( $statement->subject->object->getLabel ) );\n\t\t\t\t};\n                \t$class->printContent( \"</\" .   $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":object>\");\n                \t};\n\t\t};\n\t\n\twhile ( my $st = $itr->each ) {\n        \t$class->printContent( \"\\n\\t<\" . $class->getNamespacePrefix( $st->predicate->getNamespace ).\":\".$st->predicate->getLocalName );\n        \t$class->printContent( \" \" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":ID='\" . $st->getURI . \"'\" )\n\t\t\tif( $st->isReified );\n\n\t\tif( $st->object->isa(\"RDFStore::Resource\") ) {\n        \t\t$class->printContent( \" \" );\n\t\t\tif ( $st->object->isbNode ) {\n                \t\t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":nodeID='\" . $st->object->getLabel );\n        \t\t} else {\n                \t\t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":resource='\" . $class->xml_escape( $st->object->getURI,\"'\" ) );\n                \t\t};\n        \t\t$class->printContent( \"' />\" );\n\t\t} else {\n        \t\t$class->printContent( \" xml:lang='\" . $st->object->getLang . \"'\")\n\t\t\t\tif($st->object->getLang);\n\t\t\tif($st->object->getParseType) {\n        \t\t\t$class->printContent( \" \" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":parseType='Literal'>\");\n        \t\t\t$class->printContent( $st->object->getLabel );\n\t\t\t} else {\n\t\t\t\t$class->printContent( \" rdf:datatype='\" . $st->object->getDataType . \"'\")\n\t\t\t\t\tif($st->object->getDataType);\n        \t\t\t$class->printContent( \">\" . $class->xml_escape( $st->object->getLabel ) );\n\t\t\t\t};\n        \t\t$class->printContent( \"</\" . $class->getNamespacePrefix( $st->predicate->getNamespace ) .\":\".$st->predicate->getLocalName . \">\" );\n\t\t\t};\n\t\t};\n        $class->printContent( \"\\n</\" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":Description>\" );\n\n\tif ($statement->subject->isa(\"RDFStore::Statement\")) {\n\t\tif (\t($statement->subject->subject->isa(\"RDFStore::Statement\")) &&\n\t\t\t(! $model->contains( $statement->subject->subject) ) ) {\n\t\t\t$class->_processDescription( $model, $statement->subject );\n\t\t\t};\n\t\tif (\t($statement->subject->object->isa(\"RDFStore::Statement\")) &&\n\t\t\t(! $model->contains( $statement->subject->object) ) ) {\n\t\t\t$class->_processDescription( $model, $statement->object );\n\t\t\t};\n\t\t};\n\t};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Serializer/RSS.pm",
      "package" : "RDFStore::Serializer::RSS"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.2';\n\nuse Carp;\n\nuse RDFStore::Serializer;\n\n@RDFStore::Serializer::RDFXML::ISA = qw( RDFStore::Serializer );\n\nsub new {\n\tmy ($pkg) = shift;\n\n\tmy $self = $pkg->SUPER::new(@_);\n\n\tbless $self,$pkg;\n\t};\n\nsub write {\n\tmy ($class, $model, $fh, $namespaces, $base ) = @_;\n\n\t$model = $class->{'model'}\n\t\tunless($model);\n\n\tmy $ctx = $model->getContext();\n\t$model->resetContext();\n\n\t$class->SUPER::write( $model, $fh, $namespaces );\n\n\t$class->{subjects_done} = {};\n\n        $class->printContent( \"<\" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":RDF\" );\n        $class->printContent( \"\\n\\txmlns:\" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \"='\". $RDFStore::Vocabulary::RDF::_Namespace . \"'\");\n\t\n        $class->printContent( \"\\n\\txmlns:\" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDFStoreContext::_Namespace) . \"='\". $RDFStore::Vocabulary::RDFStoreContext::_Namespace . \"'\");\n\n        $class->printContent( \"\\n\\txml:base='$base'\")\n\t\tif(\t(defined $base) &&\n\t\t\t($base ne '') );\n\n        my $cc=0;\n\tforeach my $ns ( $model->namespaces ) {\n\t\tnext\n\t\t\tif( $ns eq $RDFStore::Vocabulary::RDF::_Namespace );\n\n\t\t$class->setNamespacePrefix( $ns, 'voc'.($cc++) )\n\t\t\tunless( $class->getNamespacePrefix( $ns ) );\n\n        \t$class->printContent( \"\\n\\txmlns:\" . $class->getNamespacePrefix($ns) . \"='\". $ns . \"'\");\n                };\n        $class->printContent( \">\");\n\n\tmy $itr = $model->elements;\n\twhile ( my $st = $itr->each ) {\n\t\t$class->_processDescription( $model, $st );\n\t\t};\n\n\t$class->printContent( \"\\n</\" .    $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":RDF>\" );\n\n\t$class->{subjects_done} = {};\n\n\t$model->setContext( $ctx )\n\t\tif($ctx);\n\n        return $class->returnContent;\n\t};\n\nsub _processDescription {\n\tmy ($class, $model, $statement ) = @_;\n\n\tmy $context = $statement->context;\n\tmy $ctx = $context->toString\n\t\tif($context);\n\n\treturn\n\t\tif(exists $class->{subjects_done}->{ $statement->subject->toString . $ctx });\n\n\t$class->{subjects_done}->{ $statement->subject->toString . $ctx } = 1; \n\n\tmy $itr = $model->find( $statement->subject, undef, undef, $context )->elements;\n\n\treturn\n\t\tunless($itr->size > 0 );\n\n        $class->printContent( \"\\n<\" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":Description \" );\n\tif ( $statement->subject->isbNode ) {\n        \t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":nodeID='\" . $statement->subject->getLabel );\n        } else {\n        \t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":about='\" . $class->xml_escape( $statement->subject->getURI,\"'\" ) );\n        \t};\n\tif ( $context ) {\n\t\tif ( $context->isbNode ) {\n        \t\t$class->printContent( \"' \" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDFStoreContext::_Namespace) . \":contextnodeID='\" . $context->getLabel );\n        \t} else {\n        \t\t$class->printContent( \"' \" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDFStoreContext::_Namespace) . \":context='\" . $class->xml_escape( $context->getURI,\"'\" ) );\n        \t\t};\n\t\t};\n        $class->printContent(\"'>\");\n\t\n\tif (\t($statement->subject->isa(\"RDFStore::Statement\")) &&\n\t\t(! $model->contains( $statement->subject) ) ) { \n\t\t$class->printContent( \"\\n\\t<\" .     $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":type \" .\n                                                $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":resource='\".$RDFStore::Vocabulary::RDF::_Namespace .\"Statement' />\");\n\n                $class->printContent( \"\\n\\t<\" .   $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":subject \");\n\t\tif ( $statement->subject->subject->isbNode ) {\n                \t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":nodeID='\" . $statement->subject->subject->getLabel );\n        \t} else {\n                \t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":resource='\" . $class->xml_escape( $statement->subject->subject->getURI,\"'\" ) );\n                \t};\n                $class->printContent( \"' />\");\n                $class->printContent( \"\\n\\t<\" .   $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":predicate \");\n                $class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":resource='\" . $class->xml_escape( $statement->subject->predicate->getURI,\"'\" ) . \"' />\" );\n\n                $class->printContent( \"\\n\\t<\" .   $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":object \");\n\t\tif( $statement->subject->object->isa(\"RDFStore::Resource\") ) {\n\t\t\tif ( $statement->subject->object->isbNode ) {\n                \t\t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":nodeID='\" . $statement->subject->object->getLabel );\n        \t\t} else {\n                \t\t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":resource='\" . $class->xml_escape( $statement->subject->object->getURI,\"'\" ) );\n                \t\t};\n                \t$class->printContent( \"' />\");\n                } else {\n        \t\t$class->printContent( \"xml:lang='\" . $statement->subject->object->getLang . \"'\")\n\t\t\t\tif($statement->subject->object->getLang);\n\t\t\tif($statement->subject->object->getParseType) {\n        \t\t\t$class->printContent( \" \" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":parseType='Literal'>\");\n        \t\t\t$class->printContent( $statement->subject->object->getLabel );\n\t\t\t} else {\n        \t\t\t$class->printContent( \" rdf:datatype='\" . $statement->subject->object->getDataType . \"'\")\n\t\t\t\t\tif($statement->subject->object->getDataType);\n        \t\t\t$class->printContent( \">\" . $class->xml_escape( $statement->subject->object->getLabel ) );\n\t\t\t\t};\n                \t$class->printContent( \"</\" .   $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":object>\");\n                \t};\n\t\t};\n\t\n\twhile ( my $st = $itr->each ) {\n        \t$class->printContent( \"\\n\\t<\" . $class->getNamespacePrefix( $st->predicate->getNamespace ).\":\".$st->predicate->getLocalName );\n        \t$class->printContent( \" \" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":ID='\" . $st->getURI . \"'\" )\n\t\t\tif( $st->isReified );\n\n\t\tif( $st->object->isa(\"RDFStore::Resource\") ) {\n        \t\t$class->printContent( \" \" );\n\t\t\tif ( $st->object->isbNode ) {\n                \t\t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":nodeID='\" . $st->object->getLabel );\n        \t\t} else {\n                \t\t$class->printContent( $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":resource='\" . $class->xml_escape( $st->object->getURI,\"'\" ) );\n                \t\t};\n        \t\t$class->printContent( \"' />\" );\n\t\t} else {\n        \t\t$class->printContent( \" xml:lang='\" . $st->object->getLang . \"'\")\n\t\t\t\tif($st->object->getLang);\n\t\t\tif($st->object->getParseType) {\n        \t\t\t$class->printContent( \" \" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":parseType='Literal'>\");\n        \t\t\t$class->printContent( $st->object->getLabel );\n\t\t\t} else {\n        \t\t\t$class->printContent( \" rdf:datatype='\" . $st->object->getDataType . \"'\")\n\t\t\t\t\tif($st->object->getDataType);\n        \t\t\t$class->printContent( \">\" . $class->xml_escape( $st->object->getLabel ) );\n\t\t\t\t};\n        \t\t$class->printContent( \"</\" . $class->getNamespacePrefix( $st->predicate->getNamespace ) .\":\".$st->predicate->getLocalName . \">\" );\n\t\t\t};\n\t\t};\n        $class->printContent( \"\\n</\" . $class->getNamespacePrefix($RDFStore::Vocabulary::RDF::_Namespace) . \":Description>\" );\n\n\tif ($statement->subject->isa(\"RDFStore::Statement\")) {\n\t\tif (\t($statement->subject->subject->isa(\"RDFStore::Statement\")) &&\n\t\t\t(! $model->contains( $statement->subject->subject) ) ) {\n\t\t\t$class->_processDescription( $model, $statement->subject );\n\t\t\t};\n\t\tif (\t($statement->subject->object->isa(\"RDFStore::Statement\")) &&\n\t\t\t(! $model->contains( $statement->subject->object) ) ) {\n\t\t\t$class->_processDescription( $model, $statement->object );\n\t\t\t};\n\t\t};\n\t};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Serializer/RDFXML.pm",
      "package" : "RDFStore::Serializer::RDFXML"
   },
   {
      "PPI" : "PPI::Statement::Compound",
      "bad" : "{\nuse vars qw ($VERSION);\nuse strict;\n \n$VERSION = '0.1';\n\nuse Carp;\n\nuse RDFStore::Serializer;\nuse RDFStore;\n\n@RDFStore::Serializer::NTriples::ISA = qw( RDFStore::Serializer );\n\nsub new {\n\tmy ($pkg) = shift;\n\n\tmy $self = $pkg->SUPER::new(@_);\n\n\tbless $self,$pkg;\n\t};\n\nsub write {\n\tmy ($class, $model, $fh, $namespaces ) = @_;\n\n\t$model = $class->{'model'}\n                unless($model);\n\n\t$class->SUPER::write( $model, $fh, $namespaces );\n\n\tmy $itr = $model->elements;\n\twhile ( my $st = $itr->each ) {\n\t\t$class->printContent( $st->toString . \"\\n\" );\n                };\n\n        return $class->returnContent;\n\t};\n\n1;\n}",
      "file" : "/var/tmp/arv_9ZTUPm/RDFStore-0.51/lib/RDFStore/Serializer/NTriples.pm",
      "package" : "RDFStore::Serializer::NTriples"
   }
]
