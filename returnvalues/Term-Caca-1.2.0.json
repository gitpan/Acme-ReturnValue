[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method export( :$format = 'caca' ) {\n\n    croak \"format '$format' not supported\" unless $format ~~ @export_formats;\n\n    my $export = _export( $self->canvas, $format eq 'text' ? 'ansi' : $format );\n\n    $export =~ s/\\e\\[?.*?[\\@-~]//g if $format eq 'text';\n    \n    return $export;\n}\n\n\n\n\nmethod set_ansi_color( $foreground, $background ) {\n    _set_ansi_color( $self->canvas, $foreground, $background );\n\n    return $self;\n}\n\n\nmethod set_color( $foreground, $background ) {\n    if ( exists $COLORS{uc $foreground} ) {\n        return $self->set_ansi_color( \n            map { $COLORS{uc $_} } $foreground, $background \n        );\n    }\n\n    _set_color( $self->canvas, map { _arg_to_color( $_ ) } $foreground, $background );\n\n    return $self;\n}\n\nsub _arg_to_color {\n    my $arg = shift;\n\n    return hex $arg unless ref $arg;\n\n    return hex sprintf \"%x%x%x%x\", @$arg;\n}\n\n\nsub get_feature {\n  my ($self, $feature) = @_;\n  $feature ||= 0;\n  return _get_feature($feature);\n}\n\nsub set_feature {\n  my ($self, $feature) = @_;\n  $feature ||= 0;\n  _get_feature($feature);\n}\n\nsub get_feature_name {\n  my ($self, $feature) = @_;\n  $feature ||= 0;\n  return _get_feature_name($feature);\n}\n\nsub DESTROY {\n    my $self = shift;\n  _free_display( $self->{display} ) if $self->{display};\n}\n\n\nmethod text ( $coord, $text ) {\n    length $text > 1 \n        ? _putstr( $self->canvas, @$coord, $text )\n        : _putchar( $self->canvas, @$coord, $text );        \n\n    return $self;\n}\n\n\nmethod char ( $coord, $char ) {\n    _putchar( $self->canvas, @$coord, substr $char, 0, 1 );\n\n    return $self;\n}\n\n\nmethod line ( $pa, $pb, :$char = undef ) {\n    defined ( $char ) \n    ?  _draw_line($self->canvas, @$pa, @$pb, $char)\n    : _draw_thin_line($self->canvas,  @$pa, @$pb );\n\n    return $self;\n}\n\n\nmethod polyline( $points, :$char = undef, :$close = 0 ) {\n    my @x = map { $_->[0] } @$points;\n    my @y = map { $_->[1] } @$points;\n    my $n = @x - !$close;\n\n    $char ? _draw_polyline( $self->canvas, \\@x, \\@y, $n, $char )\n          : _draw_thin_polyline( $self->canvas, \\@x, \\@y, $n );\n\n    return $self;\n}\n\n\nmethod circle ( $center, $radius, :$char = undef, :$fill = undef ) {\n    $char //= $fill;\n\n    my @args = ( $self->canvas, @$center, $radius );\n\n    if ( not defined $char ) {\n        _draw_thin_ellipse( @args, $radius );\n    }\n    else {\n        if ( defined $fill ) {\n            _fill_ellipse( @args, $radius, $char );\n        }\n        else {\n            _draw_circle( @args, $char );\n        }\n    }\n\n  return $self;\n}\n\n\nmethod ellipse ( $center, $rx, $ry, :$char = undef, :$fill = undef ) {\n    $char //= $fill;\n\n    if ( defined $fill ) {\n        _fill_ellipse($self->canvas,@$center,$rx,$ry,$char);\n    }\n    elsif( defined $char ) {\n        _draw_ellipse($self->canvas,@$center,$rx,$ry,$char);\n    }\n    else {\n        _draw_thin_ellipse($self->canvas,@$center,$rx,$ry);\n    }\n\n  return $self;\n}\n\n\n\nmethod box  ( $center, $width, $height, :$char = undef, :$fill = undef ){\n  $char //= $fill;\n\n  my @args = ( $self->canvas, @$center, $width, $height );\n\n  if ( defined $fill ) {\n    _fill_box(@args, $char);\n  }\n  elsif( defined $char ) {\n    _draw_box(@args, $char);\n  }\n  else {\n    _draw_thin_box(@args);\n  }\n\n  return $self;\n}\n\n\nmethod triangle  ( $pa, $pb, $pc, :$char = undef, :$fill = undef ){\n  $char //= $fill;\n\n  my @args = ( $self->canvas, @$pa, @$pb, @$pc );\n\n  if ( defined $fill ) {\n    _fill_triangle(@args, $char);\n  }\n  elsif( defined $char ) {\n    _draw_triangle(@args, $char);\n  }\n  else {\n    _draw_thin_triangle(@args);\n  }\n\n  return $self;\n}\n\n\nmethod wait_for_event ( :$mask = $ANY_EVENT, :$timeout = 0 ) {\n  my $event = _get_event( $self->display, $mask, int($timeout*1_000_000), defined wantarray )\n      or return;\n\n  given ( _get_event_type( $event ) ) {\n    when ( $KEY_PRESS ) {\n        return Term::Caca::Event::Key::Press->new( event => $event );\n    }\n    when ( $KEY_RELEASE ) {\n        return Term::Caca::Event::Key::Release->new( event => $event );\n    }\n    when ( $MOUSE_MOTION ) {\n        return Term::Caca::Event::Mouse::Motion->new( event => $event );\n    }\n    when ( $MOUSE_PRESS ) {\n        return Term::Caca::Event::Mouse::Button::Press->new( event => $event );\n    }\n    when ( $MOUSE_RELEASE ) {\n        return Term::Caca::Event::Mouse::Button::Release->new( event => $event );\n    }\n    when ( $RESIZE ) {\n        return Term::Caca::Event::Resize->new( event => $event );\n    }\n    when ( $QUIT ) {\n        return Term::Caca::Event::Quit->new( event => $event );\n    }\n    default {\n        return;\n    }\n  }\n\n}\n\n'end of Term::Caca'",
      "file" : "/var/tmp/arv_2nlZhd/Term-Caca-1.2.0/lib/Term/Caca.pm",
      "package" : "Term::Caca"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method _event { $self->{event} }\n\nsub DESTROY {\n    my $self = shift;\n\n    Term::Caca::_free_event($self->_event) if $self->_event;\n}\n\n1",
      "file" : "/var/tmp/arv_2nlZhd/Term-Caca-1.2.0/lib/Term/Caca/Event.pm",
      "package" : "Term::Caca::Event"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method width {\n    return Term::Caca::_get_event_resize_width( $self->_event );\n}\n\nmethod height {\n    return Term::Caca::_get_event_resize_height( $self->_event );\n}\n\nmethod size {\n    return( $self->width, $self->height );\n}\n\n1",
      "file" : "/var/tmp/arv_2nlZhd/Term-Caca-1.2.0/lib/Term/Caca/Event/Resize.pm",
      "package" : "Term::Caca::Event::Resize"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method char {\n    return Term::Caca::_get_event_key_ch( $self->_event );\n}\n\n1",
      "file" : "/var/tmp/arv_2nlZhd/Term-Caca-1.2.0/lib/Term/Caca/Event/Key.pm",
      "package" : "Term::Caca::Event::Key"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method x {\n    return Term::Caca::_get_event_mouse_x( $self->_event );\n}\n\nmethod y {\n    return Term::Caca::_get_event_mouse_y( $self->_event );\n}\n\nmethod pos {\n    return ( $self->x, $self->y );\n}\n\n1",
      "file" : "/var/tmp/arv_2nlZhd/Term-Caca-1.2.0/lib/Term/Caca/Event/Mouse/Motion.pm",
      "package" : "Term::Caca::Event::Mouse::Motion"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method index {\n    return Term::Caca::_get_event_mouse_button( $self->_event );\n}\n\nmethod left { return 1 == $self->index }\nmethod right { return 3 == $self->index }\nmethod middle { return 2 == $self->index }\n\n\n1",
      "file" : "/var/tmp/arv_2nlZhd/Term-Caca-1.2.0/lib/Term/Caca/Event/Mouse/Button.pm",
      "package" : "Term::Caca::Event::Mouse::Button"
   }
]
