[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class Net::Topsy with Net::Topsy::Role::API {\n    use Carp qw/croak confess/;\n    use Moose;\n    use URI::Escape;\n    use JSON::Any qw/XS DWIW JSON/;\n    use Data::Dumper;\n    use LWP::UserAgent;\n    use Net::Topsy::Result;\n    our $VERSION = '0.03';\n    $VERSION = eval $VERSION;\n\n    use namespace::autoclean;\n\n    has useragent_class => ( isa => 'Str', is => 'ro', default => 'LWP::UserAgent' );\n    has useragent_args  => ( isa => 'HashRef', is => 'ro', default => sub { {} } );\n    has ua              => ( isa => 'Object', is => 'rw' );\n    has key             => ( isa => 'Str', is => 'rw', required => 0 );\n    has format          => ( isa => 'Str', is => 'rw', required => 1, default => '.json' );\n    has base_url        => ( isa => 'Str', is => 'ro', default => 'http://otter.topsy.com' );\n    has useragent       => ( isa => 'Str', is => 'ro', default => \"Net::Topsy/$VERSION (Perl)\" );\n\n    method BUILD {\n        $self->ua($self->useragent_class->new(%{$self->useragent_args}));\n        $self->ua->agent($self->useragent);\n\n        my @api_methods = keys %{$self->API->{$self->base_url}};\n\n        for my $method (@api_methods) {\n            Net::Topsy->meta->make_mutable;\n            Net::Topsy->meta->add_method( substr($method, 1) , sub {\n                my ($self, $params) = @_;\n                $params ||= {};\n                return $self->_topsy_api($params, $method);\n            });\n            Net::Topsy->meta->make_immutable;\n        }\n    }\n\n    method _topsy_api ($params, $route) {\n        die 'no route to _topsy_api!' unless $route;\n\n        $self->_validate_params($params, $route);\n        my $url = $self->_make_url($params, $route);\n        return $self->_handle_response( $self->ua->get( $url ) );\n    }\n\n    method _validate_params ($params, $route) {\n        my %topsy_api = %{$self->API};\n\n        my $api_entry = $topsy_api{$self->base_url}{$route}\n            || croak \"$route is not a topsy api entry\";\n\n        my @required = grep { $api_entry->{args}{$_} } keys %{$api_entry->{args}};\n\n        if ( my @missing = grep { !exists $params->{$_} } @required ) {\n            croak \"$route -> required params missing: @missing\";\n        }\n\n        if ( my @undefined = grep { $params->{$_} eq '' } keys %$params ) {\n            croak \"params with undefined values: @undefined\";\n        }\n\n        my %unexpected_params = map { $_ => 1 } keys %$params;\n        delete $unexpected_params{$_} for keys %{$api_entry->{args}};\n        if ( my @unexpected_params = sort keys %unexpected_params ) {\n            print \"# unexpected params: @unexpected_params\\n\" if $self->print_diags;\n        }\n\n    }\n\n    method _make_url ($params,$route) {\n        $route  = $self->base_url . $route . $self->format;\n        my $url = $route . \"?beta=\" . ($self->key || '');\n        while( my ($k,$v) = each %$params) {\n            $url .= \"&$k=\" . uri_escape($v) . \"&\" if defined $v;\n        }\n        return $url;\n    }\n\n    method _handle_response ( $response ) {\n        if ($response->is_success) {\n\n            my $perl = $self->_from_json( $response->content );\n\n            my $result = Net::Topsy::Result->new(\n                            response => $response,\n                            json     => $response->content,\n                            perl     => $perl,\n            );\n            return $result;\n        } else {\n            die $response->status_line;\n        }\n    }\n\n    method _from_json ($json) {\n        my $perl = eval { JSON::Any->from_json($json) };\n        confess $@ if $@;\n        return $perl;\n    }\n\n}\n\n\n\n1",
      "file" : "/var/tmp/arv_1zphzB/Net-Topsy-0.03/lib/Net/Topsy.pm",
      "package" : "Net::Topsy"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "class Net::Topsy::Result {\n    use MooseX::Iterator;\n    use Data::Dumper;\n    use namespace::autoclean;\n\n    has perl     => ( isa => 'HashRef',        is => 'rw', default => sub { [ ] } );\n    has json     => ( isa => 'Str',            is => 'rw', default => '' );\n    has response => ( isa => 'HTTP::Response', is => 'rw' );\n\n    has page     => ( isa => 'Int',      is => 'rw', default => 0 );\n    has window   => ( isa => 'Str',      is => 'rw', default => '' );\n    has total    => ( isa => 'Int',      is => 'rw', default => 0 );\n    has perpage  => ( isa => 'Int',      is => 'rw', default => 10);\n    has list     => ( isa => 'ArrayRef', is => 'rw', default => sub { [ ] } );\n\n    has iter     => (\n        metaclass    => 'Iterable',\n        iterate_over => 'list',\n    );\n\n    method BUILD {\n        for my $attr (qw/page window total list perpage/) {\n            $self->$attr( $self->perl->{response}{$attr} ) if exists $self->perl->{response}{$attr};\n        }\n        return $self;\n    }\n}\n\n\n1",
      "file" : "/var/tmp/arv_1zphzB/Net-Topsy-0.03/lib/Net/Topsy/Result.pm",
      "package" : "Net::Topsy::Result"
   }
]
