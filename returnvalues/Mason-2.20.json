[
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method new ($class: %params) {\n\n    my $plugin_specs = delete( $params{plugins} ) || [];\n    my $base_interp_class = delete( $params{base_interp_class} )\n      || $class->default_base_interp_class;\n\n    my @plugins = Mason::PluginManager->process_top_plugin_specs($plugin_specs);\n    my $interp_class =\n      Mason::PluginManager->apply_plugins_to_class( $base_interp_class, 'Interp', \\@plugins );\n\n    die \"cannot pass mason_root_class directly\"\n      if exists( $params{mason_root_class} );\n    return $interp_class->new(\n        mason_root_class => $class,\n        plugins          => \\@plugins,\n        %params\n    );\n}\n\nmethod default_base_interp_class ($class:) {\n    my @candidates =\n      map { join( '::', $_, 'Interp' ) } ( uniq( $class, 'Mason' ) );\n    my ($base_class) = grep { can_load($_) } @candidates\n      or die sprintf( \"cannot load %s for interp\", join( ', ', @candidates ) );\n    return $base_class;\n}\n\n1",
      "file" : "/var/tmp/arv_2bw2pl/Mason-2.20/lib/Mason.pm",
      "package" : "Mason"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method requires_plugins ($plugin_class:) {\n    return ();\n}\n\nmethod expand_to_plugins ($plugin_class:) {\n    return ( $plugin_class,\n        Mason::PluginManager->process_plugin_specs( [ $plugin_class->requires_plugins ] ) );\n}\n\nmethod get_roles_for_mason_class ($plugin_class: $name) {\n    my @roles_to_try = join( \"::\", $plugin_class, $name );\n    if ( $name eq 'Component' ) {\n        push( @roles_to_try, join( \"::\", $plugin_class, 'Filters' ) );\n    }\n    my @roles = grep { Class::MOP::is_class_loaded($_) || can_load($_) } @roles_to_try;\n    return @roles;\n}\n\n1",
      "file" : "/var/tmp/arv_2bw2pl/Mason-2.20/lib/Mason/Plugin.pm",
      "package" : "Mason::Plugin"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method BUILD ($params) {\n\n    $self->{_orig_params} = $params;\n    weaken $self->{_orig_params}->{m};\n}\n\nmethod cmeta () {\n    return $self->can('_class_cmeta') ? $self->_class_cmeta : undef;\n}\n\nmethod _build_args () {\n    my $orig_params = $self->{_orig_params};\n    return {\n        map { ( $_, $orig_params->{$_} ) }\n        grep { $_ ne 'm' } keys(%$orig_params)\n    };\n}\n\nmethod handle () {\n    $self->render(@_);\n}\n\nmethod render () {\n    $self->wrap(@_);\n}\n\nmethod wrap () {\n    inner();\n}\n\nmethod allow_path_info () {\n    return 0;\n}\n\nmethod no_wrap ($class:) {\n    $class->meta->add_method( 'render' => sub { $_[0]->main(@_) } );\n}\n\n1",
      "file" : "/var/tmp/arv_2bw2pl/Mason-2.20/lib/Mason/Component.pm",
      "package" : "Mason::Component"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method Capture ($outref) {\n    sub { $$outref = $_[0]; return '' }\n}\n\nmethod CompCall ($path, @params) {\n    Mason::DynamicFilter->new(\n        filter => sub {\n            my $m = $self->m;\n            return $m->scomp( $path, @params, yield => $_[0] );\n        }\n    );\n}\n\nmethod NoBlankLines () {\n    sub {\n        my $text = $_[0];\n        $text =~ s/^\\s*\\n//mg;\n        return $text;\n    };\n}\n\nmethod Repeat ($times) {\n    Mason::DynamicFilter->new(\n        filter => sub {\n            my $content = '';\n            for ( my $i = 0 ; $i < $times ; $i++ ) {\n                $content .= $_[0]->();\n            }\n            return $content;\n        }\n    );\n}\n\nmethod Tee ($outref) {\n    sub { $$outref = $_[0]; return $_[0] }\n}\n\nmethod Trim () {\n    sub { Mason::Util::trim( $_[0] ) }\n}\n\n1",
      "file" : "/var/tmp/arv_2bw2pl/Mason-2.20/lib/Mason/Filters/Standard.pm",
      "package" : "Mason::Filters::Standard"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method setup_dirs () {\n    $self->{temp_dir}  = join( \"/\", $self->{temp_root}, $temp_dir_count++ );\n    $self->{comp_root} = $self->{temp_dir} . \"/comps\";\n    $self->{data_dir}  = $self->{temp_dir} . \"/data\";\n    mkpath( [ $self->{comp_root}, $self->{data_dir} ], 0, 0775 );\n    $self->setup_interp(@_);\n}\n\nmethod setup_interp () {\n    $self->{interp} = $self->create_interp(@_);\n}\n\nmethod create_interp () {\n    my (%params) = @_;\n    $params{plugins} = $default_plugins if @$default_plugins;\n    my $mason_root_class = delete( $params{mason_root_class} ) || 'Mason';\n    Class::MOP::load_class($mason_root_class);\n    rmtree( $self->data_dir );\n    return $mason_root_class->new(\n        comp_root => $self->comp_root,\n        data_dir  => $self->data_dir,\n        %params,\n    );\n}\n\nmethod add_comp (%params) {\n    $self->_validate_keys( \\%params, qw(path src v verbose) );\n    my $path    = $params{path} || die \"must pass path\";\n    my $source  = $params{src}  || \" \";\n    my $verbose = $params{v}    || $params{verbose};\n    die \"'$path' is not absolute\" unless substr( $path, 0, 1 ) eq '/';\n    my $source_file = $self->comp_root . $path;\n    $self->mkpath_and_write_file( $source_file, $source );\n    if ($verbose) {\n        print STDERR \"*** $path ***\\n\";\n        my $output = $self->interp->_compile( $source_file, $path );\n        print STDERR \"$output\\n\";\n    }\n}\n\nmethod remove_comp (%params) {\n    my $path = $params{path} || die \"must pass path\";\n    my $source_file = join( \"/\", $self->comp_root, $path );\n    unlink($source_file);\n}\n\nmethod _gen_comp_path () {\n    my $caller = ( caller(2) )[3];\n    my ($caller_base) = ( $caller =~ /([^:]+)$/ );\n    my $path = \"/$caller_base\" . ( ++$gen_path_count ) . \".mc\";\n    return $path;\n}\n\nmethod test_comp (%params) {\n    my $path    = $params{path} || $self->_gen_comp_path;\n    my $source  = $params{src}  || \" \";\n    my $verbose = $params{v}    || $params{verbose};\n\n    $self->add_comp( path => $path, src => $source, verbose => $verbose );\n    delete( $params{src} );\n\n    $self->test_existing_comp( %params, path => $path );\n}\n\nmethod test_existing_comp (%params) {\n    $self->_validate_keys( \\%params, qw(args desc expect expect_data expect_error path v verbose) );\n    my $path         = $params{path} or die \"must pass path\";\n    my $caller       = ( caller(1) )[3];\n    my $desc         = $params{desc} || $path;\n    my $expect       = trim( $params{expect} );\n    my $expect_error = $params{expect_error};\n    my $expect_data  = $params{expect_data};\n    my $verbose      = $params{v} || $params{verbose};\n    my $args         = $params{args} || {};\n    ( my $request_path = $path ) =~ s/\\.m[cpi]$//;\n\n    my @run_params = ( $request_path, %$args );\n    local $current_test_object = $self;\n\n    if ( defined($expect_error) ) {\n        $desc ||= $expect_error;\n        throws_ok( sub { $self->interp->run(@run_params) }, $expect_error, $desc );\n    }\n    if ( defined($expect) ) {\n        $desc ||= $caller;\n        my $output = trim( $self->interp->run(@run_params)->output );\n        if ( ref($expect) eq 'Regexp' ) {\n            like( $output, $expect, $desc );\n        }\n        else {\n            is( $output, $expect, $desc );\n        }\n    }\n    if ( defined($expect_data) ) {\n        $desc ||= $caller;\n        cmp_deeply( $self->interp->run(@run_params)->data, $expect_data, $desc );\n    }\n}\n\nmethod run_test_in_comp (%params) {\n    my $test = delete( $params{test} ) || die \"must pass test\";\n    my $args = delete( $params{args} ) || {};\n    $params{path} ||= $self->_gen_comp_path;\n    $self->add_comp( %params, src => '% $.args->{_test}->($self);' );\n    ( my $request_path = $params{path} ) =~ s/\\.m[cpi]$//;\n    my @run_params = ( $request_path, %$args );\n    $self->interp->run( @run_params, _test => $test );\n}\n\nmethod test_parse (%params) {\n    my $caller = ( caller(1) )[3];\n    my ($caller_base) = ( $caller =~ /([^:]+)$/ );\n    my $desc = $params{desc};\n    my $source       = $params{src} || croak \"must pass src\";\n    my $expect_list  = $params{expect};\n    my $expect_error = $params{expect_error};\n    croak \"must pass either expect or expect_error\" unless $expect_list || $expect_error;\n\n    my $path = \"/parse/comp\" . $parse_count++;\n    my $file = $self->temp_dir . $path;\n    $self->mkpath_and_write_file( $file, $source );\n\n    if ($expect_error) {\n        $desc ||= $expect_error;\n        throws_ok( sub { $self->interp->_compile( $file, $path ) }, $expect_error, $desc );\n    }\n    else {\n        $desc ||= $caller;\n        my $output = $self->interp->_compile( $file, $path );\n        foreach my $expect (@$expect_list) {\n            if ( ref($expect) eq 'Regexp' ) {\n                like_string( $output, $expect, \"$desc - $expect\" );\n            }\n            else {\n                contains_string( $output, $expect, \"$desc - $expect\" );\n            }\n        }\n    }\n}\n\nmethod mkpath_and_write_file ( $source_file, $source ) {\n    unlink($source_file) if -e $source_file;\n    mkpath( dirname($source_file), 0, 0775 );\n    write_file( $source_file, $source );\n}\n\nmethod _validate_keys ( $params, @allowed_keys ) {\n    my %is_allowed = map { ( $_, 1 ) } @allowed_keys;\n    if ( my @bad_keys = grep { !$is_allowed{$_} } keys(%$params) ) {\n        croak \"bad parameters: \" . join( \", \", @bad_keys );\n    }\n}\n\n1",
      "file" : "/var/tmp/arv_2bw2pl/Mason-2.20/lib/Mason/Test/Class.pm",
      "package" : "Mason::Test::Class"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method defer ($code) {\n    my $marker = $self->interp->_construct_distinct_string();\n    push( @{ $self->{defers} }, { marker => $marker, code => $code } );\n    return $marker;\n}\n\nmethod _apply_defers_to_request_buffer () {\n    if ( my @defers = @{ $self->{defers} } ) {\n        my $request_buffer = ${ $self->_request_buffer };\n        foreach my $defer (@defers) {\n            my $subst = $defer->{marker};\n            my $repl  = $defer->{code}->();\n            $request_buffer =~ s/\\Q$subst\\E/$repl/;\n        }\n        ${ $self->_request_buffer } = $request_buffer;\n    }\n}\n\n1",
      "file" : "/var/tmp/arv_2bw2pl/Mason-2.20/lib/Mason/Plugin/Defer/Request.pm",
      "package" : "Mason::Plugin::Defer::Request"
   },
   {
      "PPI" : "PPI::Statement (but very likely crap)",
      "bad" : "method Defer () {\n    Mason::DynamicFilter->new(\n        filter => sub {\n            $self->m->defer( $_[0] );\n        }\n    );\n}\n\n1",
      "file" : "/var/tmp/arv_2bw2pl/Mason-2.20/lib/Mason/Plugin/Defer/Filters.pm",
      "package" : "Mason::Plugin::Defer::Filters"
   }
]
